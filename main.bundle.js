!function(t){var n={};function e(c){if(n[c])return n[c].exports;var B=n[c]={i:c,l:!1,exports:{}};return t[c].call(B.exports,B,B.exports,e),B.l=!0,B.exports}e.m=t,e.c=n,e.d=function(t,n,c){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:c})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var c=Object.create(null);if(e.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var B in t)e.d(c,B,function(n){return t[n]}.bind(null,B));return c},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=5)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var createjs = (this.createjs = (this.createjs || {}));\n/*!\n* CreateJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the "Software"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nthis.createjs = this.createjs||{};\n\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass\'s new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t"use strict";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class\'s name as the prefix.\n * An alias to the super class\'s constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class\'s prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn "Hello "+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, "ClassA");\n *\n * \tvar foo = new ClassB("World", "!?!");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t"use strict";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// indexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t"use strict";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink "EventDispatcher"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object\'s state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or\n\t\t * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and\n\t * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener("click", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Event (type="+this.type+")]";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n\t *\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n\t * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.\n\t * \n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n\t * \n\t * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \n\t * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to\n\t * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.\n\t * \n\t * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \n\t * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.\n\t *\n\t * <h4>Example</h4>\n\t * Add EventDispatcher capabilities to the "MyClass" class.\n\t *\n\t *      EventDispatcher.initialize(MyClass.prototype);\n\t *\n\t * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).\n\t *\n\t *      instance.addEventListener("eventName", handlerMethod);\n\t *      function handlerMethod(event) {\n\t *          console.log(event.target + " Was Clicked");\n\t *      }\n\t *\n\t * <b>Maintaining proper scope</b><br />\n\t * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}\n\t * method to subscribe to events simplifies this.\n\t *\n\t *      instance.addEventListener("click", function(event) {\n\t *          console.log(instance == this); // false, scope is ambiguous.\n\t *      });\n\t *      \n\t *      instance.on("click", function(event) {\n\t *          console.log(instance == this); // true, "on" uses dispatcher scope by default.\n\t *      });\n\t * \n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\n\t * scope.\n\t *\n\t * <b>Browser support</b>\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\n\t * requires modern browsers (IE9+).\n\t *      \n\t *\n\t * @class EventDispatcher\n\t * @constructor\n\t **/\n\tfunction EventDispatcher() {\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @protected\n\t\t * @property _listeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._listeners = null;\n\t\t\n\t\t/**\n\t\t * @protected\n\t\t * @property _captureListeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._captureListeners = null;\n\t}\n\tvar p = EventDispatcher.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t * \n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n\t * \n\t * @method initialize\n\t * @static\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n\t * prototype.\n\t **/\n\tEventDispatcher.initialize = function(target) {\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t};\n\t\n\n// public methods:\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.addEventListener("click", handleClick);\n\t *      function handleClick(event) {\n\t *         // Click happened.\n\t *      }\n\t *\n\t * @method addEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\n\t **/\n\tp.addEventListener = function(type, listener, useCapture) {\n\t\tvar listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners||{};\n\t\t}\n\t\tvar arr = listeners[type];\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\n\t\tarr = listeners[type]; // remove may have deleted the array\n\t\tif (!arr) { listeners[type] = [listener];  }\n\t\telse { arr.push(listener); }\n\t\treturn listener;\n\t};\n\t\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t * \n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t * \n\t * <h4>Example</h4>\n\t * \n\t * \t\tvar listener = myBtn.on("click", handleClick, null, false, {count:3});\n\t * \t\tfunction handleClick(evt, data) {\n\t * \t\t\tdata.count -= 1;\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n\t * \t\t\tif (data.count == 0) {\n\t * \t\t\t\talert("clicked 3 times!");\n\t * \t\t\t\tmyBtn.off("click", listener);\n\t * \t\t\t\t// alternately: evt.remove();\n\t * \t\t\t}\n\t * \t\t}\n\t * \n\t * @method on\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t **/\n\tp.on = function(type, listener, scope, once, data, useCapture) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope||listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope||this;\n\t\treturn this.addEventListener(type, function(evt) {\n\t\t\t\tlistener.call(scope, evt, data);\n\t\t\t\tonce&&evt.remove();\n\t\t\t}, useCapture);\n\t};\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.removeEventListener("click", handleClick);\n\t *\n\t * @method removeEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.removeEventListener = function(type, listener, useCapture) {\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tvar arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\n\t\t\tif (arr[i] == listener) {\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i,1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * .on method.\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \n\t * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.\n\t *\n\t * @method off\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.off = p.removeEventListener;\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Remove all listeners\n\t *      displayObject.removeAllEventListeners();\n\t *\n\t *      // Remove all click listeners\n\t *      displayObject.removeAllEventListeners("click");\n\t *\n\t * @method removeAllEventListeners\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n\t **/\n\tp.removeAllEventListeners = function(type) {\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\n\t\telse {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Use a string event\n\t *      this.dispatchEvent("complete");\n\t *\n\t *      // Use an Event instance\n\t *      var event = new createjs.Event("progress");\n\t *      this.dispatchEvent(event);\n\t *\n\t * @method dispatchEvent\n\t * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t **/\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\n\t\tif (typeof eventObj == "string") {\n\t\t\t// skip everything if there\'s no listeners and it doesn\'t bubble:\n\t\t\tvar listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\t\t\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tvar top=this, list=[top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tvar i, l=list.length;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t};\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t * @method hasEventListener\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\n\t **/\n\tp.hasEventListener = function(type) {\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t};\n\t\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent\'s parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t * \n\t * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t * @method willTrigger\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n\t **/\n\tp.willTrigger = function(type) {\n\t\tvar o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[EventDispatcher]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _dispatchEvent\n\t * @param {Object | String | Event} eventObj\n\t * @param {Object} eventPhase\n\t * @protected\n\t **/\n\tp._dispatchEvent = function(eventObj, eventPhase) {\n\t\tvar l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tvar arr = listeners[eventObj.type];\n\t\t\tif (!arr||!(l=arr.length)) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\t\t\t\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tvar o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\tcreatejs.EventDispatcher = EventDispatcher;\n}());\n\n//##############################################################################\n// Ticker.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n\t * event to be notified when a set time interval has elapsed.\n\t *\n\t * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n\t * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n\t * can not be instantiated.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener("tick", handleTick);\n\t *      function handleTick(event) {\n\t *          // Actions carried out each tick (aka frame)\n\t *          if (!event.paused) {\n\t *              // Actions carried out when the Ticker is not paused.\n\t *          }\n\t *      }\n\t *\n\t * @class Ticker\n\t * @uses EventDispatcher\n\t * @static\n\t **/\n\tfunction Ticker() {\n\t\tthrow "Ticker cannot be instantiated.";\n\t}\n\n\n// constants:\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF_SYNCHED\n\t * @static\n\t * @type {String}\n\t * @default "synched"\n\t * @readonly\n\t **/\n\tTicker.RAF_SYNCHED = "synched";\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}\n\t * event object\'s "delta" properties to make this easier.\n\t *\n\t * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF\n\t * @static\n\t * @type {String}\n\t * @default "raf"\n\t * @readonly\n\t **/\n\tTicker.RAF = "raf";\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t * @property TIMEOUT\n\t * @static\n\t * @type {String}\n\t * @default "timeout"\n\t * @readonly\n\t **/\n\tTicker.TIMEOUT = "timeout";\n\n\n// static events:\n\t/**\n\t * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n\t * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener("tick", handleTick);\n\t *      function handleTick(event) {\n\t *          console.log("Paused:", event.paused, event.delta);\n\t *      }\n\t *\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Boolean} paused Indicates whether the ticker is currently paused.\n\t * @param {Number} delta The time elapsed in ms since the last tick.\n\t * @param {Number} time The total time in ms since Ticker was initialized.\n\t * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n\t * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n\t * @since 0.6.0\n\t */\n\n\n// public static properties:\n\t/**\n\t * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will\n\t * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.\n\t * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.\n\t * @property useRAF\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.useRAF = false;\n\n\t/**\n\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n\t * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and\n\t * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.\n\t * @property timingMode\n\t * @static\n\t * @type {String}\n\t * @default Ticker.TIMEOUT\n\t **/\n\tTicker.timingMode = null;\n\n\t/**\n\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t * (ex. maxDelta=50 when running at 40fps).\n\t * \n\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t * when using both delta and other values.\n\t * \n\t * If 0, there is no maximum.\n\t * @property maxDelta\n\t * @static\n\t * @type {number}\n\t * @default 0\n\t */\n\tTicker.maxDelta = 0;\n\t\n\t/**\n\t * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n\t * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},\n\t * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more\n\t * info.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener("tick", handleTick);\n\t *      createjs.Ticker.paused = true;\n\t *      function handleTick(event) {\n\t *          console.log(event.paused,\n\t *          \tcreatejs.Ticker.getTime(false),\n\t *          \tcreatejs.Ticker.getTime(true));\n\t *      }\n\t *\n\t * @property paused\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.paused = false;\n\n\n// mix-ins:\n\t// EventDispatcher methods:\n\tTicker.removeEventListener = null;\n\tTicker.removeAllEventListeners = null;\n\tTicker.dispatchEvent = null;\n\tTicker.hasEventListener = null;\n\tTicker._listeners = null;\n\tcreatejs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n\tTicker._addEventListener = Ticker.addEventListener;\n\tTicker.addEventListener = function() {\n\t\t!Ticker._inited&&Ticker.init();\n\t\treturn Ticker._addEventListener.apply(Ticker, arguments);\n\t};\n\n\n// private static properties:\n\t/**\n\t * @property _inited\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._inited = false;\n\n\t/**\n\t * @property _startTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._startTime = 0;\n\n\t/**\n\t * @property _pausedTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTime=0;\n\n\t/**\n\t * The number of ticks that have passed\n\t * @property _ticks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._ticks = 0;\n\n\t/**\n\t * The number of ticks that have passed while Ticker has been paused\n\t * @property _pausedTicks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTicks = 0;\n\n\t/**\n\t * @property _interval\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._interval = 50;\n\n\t/**\n\t * @property _lastTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._lastTime = 0;\n\n\t/**\n\t * @property _times\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._times = null;\n\n\t/**\n\t * @property _tickTimes\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._tickTimes = null;\n\n\t/**\n\t * Stores the timeout or requestAnimationFrame id.\n\t * @property _timerId\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._timerId = null;\n\t\n\t/**\n\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t * if that property changed and a tick hasn\'t fired.\n\t * @property _raf\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._raf = true;\n\t\n\n// static getter / setters:\n\t/**\n\t * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.\n\t * @method setInterval\n\t * @static\n\t * @param {Number} interval\n\t * @deprecated\n\t **/\n\tTicker.setInterval = function(interval) {\n\t\tTicker._interval = interval;\n\t\tif (!Ticker._inited) { return; }\n\t\tTicker._setupTick();\n\t};\n\n\t/**\n\t * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.\n\t * @method getInterval\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getInterval = function() {\n\t\treturn Ticker._interval;\n\t};\n\n\t/**\n\t * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.\n\t * @method setFPS\n\t * @static\n\t * @param {Number} value\n\t * @deprecated\n\t **/\n\tTicker.setFPS = function(value) {\n\t\tTicker.setInterval(1000/value);\n\t};\n\n\t/**\n\t * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.\n\t * @method getFPS\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getFPS = function() {\n\t\treturn 1000/Ticker._interval;\n\t};\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t * @property interval\n\t * @static\n\t * @type {Number}\n\t **/\n\t \n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t * @property framerate\n\t * @static\n\t * @type {Number}\n\t **/\n\ttry {\n\t\tObject.defineProperties(Ticker, {\n\t\t\tinterval: { get: Ticker.getInterval, set: Ticker.setInterval },\n\t\t\tframerate: { get: Ticker.getFPS, set: Ticker.setFPS }\n\t\t});\n\t} catch (e) { console.log(e); }\n\n\n// public static methods:\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t * @method init\n\t * @static\n\t **/\n\tTicker.init = function() {\n\t\tif (Ticker._inited) { return; }\n\t\tTicker._inited = true;\n\t\tTicker._times = [];\n\t\tTicker._tickTimes = [];\n\t\tTicker._startTime = Ticker._getTime();\n\t\tTicker._times.push(Ticker._lastTime = 0);\n\t\tTicker.interval = Ticker._interval;\n\t};\n\t\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t * @method reset\n\t * @static\n\t **/\n\tTicker.reset = function() {\n\t\tif (Ticker._raf) {\n\t\t\tvar f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf&&f(Ticker._timerId);\n\t\t} else {\n\t\t\tclearTimeout(Ticker._timerId);\n\t\t}\n\t\tTicker.removeAllEventListeners("tick");\n\t\tTicker._timerId = Ticker._times = Ticker._tickTimes = null;\n\t\tTicker._startTime = Ticker._lastTime = Ticker._ticks = 0;\n\t\tTicker._inited = false;\n\t};\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack. \n\t * \n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between \n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that \n\t * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t * @method getMeasuredTickTime\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick\'s time, pass in 1.\n\t * @return {Number} The average time spent in a tick in milliseconds.\n\t **/\n\tTicker.getMeasuredTickTime = function(ticks) {\n\t\tvar ttl=0, times=Ticker._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));\n\t\tfor (var i=0; i<ticks; i++) { ttl += times[i]; }\n\t\treturn ttl/ticks;\n\t};\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t * @method getMeasuredFPS\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t **/\n\tTicker.getMeasuredFPS = function(ticks) {\n\t\tvar times = Ticker._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));\n\t\treturn 1000/((times[0]-times[ticks])/ticks);\n\t};\n\n\t/**\n\t * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.\n\t * @method setPaused\n\t * @static\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tTicker.setPaused = function(value) {\n\t\t// TODO: deprecated.\n\t\tTicker.paused = value;\n\t};\n\n\t/**\n\t * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.\n\t * @method getPaused\n\t * @static\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tTicker.getPaused = function() {\n\t\t// TODO: deprecated.\n\t\treturn Ticker.paused;\n\t};\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t * @method getTime\n\t * @static\n\t * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t **/\n\tTicker.getTime = function(runTime) {\n\t\treturn Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\n\t/**\n\t * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}\n\t * event object.\n\t * @method getEventTime\n\t * @static\n\t * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tTicker.getEventTime = function(runTime) {\n\t\treturn Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\t\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t * @method getTicks\n\t * @static\n\t * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value. The default value is false.\n\t * @return {Number} of ticks that have been broadcast.\n\t **/\n\tTicker.getTicks = function(pauseable) {\n\t\treturn  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n\t};\n\n\n// private static methods:\n\t/**\n\t * @method _handleSynch\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleSynch = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {\n\t\t\tTicker._tick();\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleRAF\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleRAF = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _handleTimeout\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleTimeout = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _setupTick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._setupTick = function() {\n\t\tif (Ticker._timerId != null) { return; } // avoid duplicates\n\n\t\tvar mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);\n\t\tif (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n\t\t\tvar f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tTicker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n\t\t\t\tTicker._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTicker._raf = false;\n\t\tTicker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n\t};\n\n\t/**\n\t * @method _tick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._tick = function() {\n\t\tvar paused = Ticker.paused;\n\t\tvar time = Ticker._getTime();\n\t\tvar elapsedTime = time-Ticker._lastTime;\n\t\tTicker._lastTime = time;\n\t\tTicker._ticks++;\n\t\t\n\t\tif (paused) {\n\t\t\tTicker._pausedTicks++;\n\t\t\tTicker._pausedTime += elapsedTime;\n\t\t}\n\t\t\n\t\tif (Ticker.hasEventListener("tick")) {\n\t\t\tvar event = new createjs.Event("tick");\n\t\t\tvar maxDelta = Ticker.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time-Ticker._pausedTime;\n\t\t\tTicker.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tTicker._tickTimes.unshift(Ticker._getTime()-time);\n\t\twhile (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }\n\n\t\tTicker._times.unshift(time);\n\t\twhile (Ticker._times.length > 100) { Ticker._times.pop(); }\n\t};\n\n\t/**\n\t * @method _getTime\n\t * @static\n\t * @protected\n\t **/\n\tvar now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);\n\tTicker._getTime = function() {\n\t\treturn ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;\n\t};\n\n\n\tcreatejs.Ticker = Ticker;\n}());\n\n//##############################################################################\n// UID.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)\n\t * and should not be instantiated.\n\t * @class UID\n\t * @static\n\t **/\n\tfunction UID() {\n\t\tthrow "UID cannot be instantiated";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _nextID\n\t * @type Number\n\t * @protected\n\t **/\n\tUID._nextID = 0;\n\n\n// public static methods:\n\t/**\n\t * Returns the next unique id.\n\t * @method get\n\t * @return {Number} The next unique id\n\t * @static\n\t **/\n\tUID.get = function() {\n\t\treturn UID._nextID++;\n\t};\n\n\n\tcreatejs.UID = UID;\n}());\n\n//##############################################################################\n// MouseEvent.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,\n\t * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.\n\t * @class MouseEvent\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @param {Number} stageX The normalized x position relative to the stage.\n\t * @param {Number} stageY The normalized y position relative to the stage.\n\t * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.\n\t * @param {Number} pointerID The unique id for the pointer.\n\t * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.\n\t * @param {Number} rawX The raw x position relative to the stage.\n\t * @param {Number} rawY The raw y position relative to the stage.\n\t * @param {DisplayObject} relatedTarget The secondary target for the event.\n\t * @extends Event\n\t * @constructor\n\t **/\n\tfunction MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {\n\t\tthis.Event_constructor(type, bubbles, cancelable);\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The normalized x position on the stage. This will always be within the range 0 to stage width.\n\t\t * @property stageX\n\t\t * @type Number\n\t\t*/\n\t\tthis.stageX = stageX;\n\t\n\t\t/**\n\t\t * The normalized y position on the stage. This will always be within the range 0 to stage height.\n\t\t * @property stageY\n\t\t * @type Number\n\t\t **/\n\t\tthis.stageY = stageY;\n\t\n\t\t/**\n\t\t * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawX\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawX = (rawX==null)?stageX:rawX;\n\t\n\t\t/**\n\t\t * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawY\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawY = (rawY==null)?stageY:rawY;\n\t\n\t\t/**\n\t\t * The native MouseEvent generated by the browser. The properties and API for this\n\t\t * event may differ between browsers. This property will be null if the\n\t\t * EaselJS property was not directly generated from a native MouseEvent.\n\t\t * @property nativeEvent\n\t\t * @type HtmlMouseEvent\n\t\t * @default null\n\t\t **/\n\t\tthis.nativeEvent = nativeEvent;\n\t\n\t\t/**\n\t\t * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system\n\t\t * supplied id value.\n\t\t * @property pointerID\n\t\t * @type {Number}\n\t\t */\n\t\tthis.pointerID = pointerID;\n\t\n\t\t/**\n\t\t * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.\n\t\t * For touch pointers, the first pointer in the current stack will be considered the primary pointer.\n\t\t * @property primary\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.primary = !!primary;\n\t\t\n\t\t/**\n\t\t * The secondary target for the event, if applicable. This is used for mouseout/rollout\n\t\t * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,\n\t\t * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.\n\t\t * \n\t\t * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).\n\t\t * @property relatedTarget\n\t\t * @type {DisplayObject}\n\t\t */\n\t\tthis.relatedTarget = relatedTarget;\n\t}\n\tvar p = createjs.extend(MouseEvent, createjs.Event);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\t\n// getter / setters:\n\t/**\n\t * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localX\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localX = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).x;\n\t};\n\t\n\t/**\n\t * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localY\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localY = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).y;\n\t};\n\t\n\t/**\n\t * Indicates whether the event was generated by a touch input (versus a mouse input).\n\t * @property isTouch\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tp._get_isTouch = function() {\n\t\treturn this.pointerID !== -1;\n\t};\n\t\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlocalX: { get: p._get_localX },\n\t\t\tlocalY: { get: p._get_localY },\n\t\t\tisTouch: { get: p._get_isTouch }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a clone of the MouseEvent instance.\n\t * @method clone\n\t * @return {MouseEvent} a clone of the MouseEvent instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";\n\t};\n\n\n\tcreatejs.MouseEvent = createjs.promote(MouseEvent, "Event");\n}());\n\n//##############################################################################\n// Matrix2D.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n\t *\n\t * This matrix can be visualized as:\n\t *\n\t * \t[ a  c  tx\n\t * \t  b  d  ty\n\t * \t  0  0  1  ]\n\t *\n\t * Note the locations of b and c.\n\t *\n\t * @class Matrix2D\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @constructor\n\t **/\n\tfunction Matrix2D(a, b, c, d, tx, ty) {\n\t\tthis.setValues(a,b,c,d,tx,ty);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Position (0, 0) in a 3x3 affine transformation matrix.\n\t\t * @property a\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (0, 1) in a 3x3 affine transformation matrix.\n\t\t * @property b\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 0) in a 3x3 affine transformation matrix.\n\t\t * @property c\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 1) in a 3x3 affine transformation matrix.\n\t\t * @property d\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 0) in a 3x3 affine transformation matrix.\n\t\t * @property tx\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 1) in a 3x3 affine transformation matrix.\n\t\t * @property ty\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Matrix2D.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n\t * @property DEG_TO_RAD\n\t * @static\n\t * @final\n\t * @type Number\n\t * @readonly\n\t **/\n\tMatrix2D.DEG_TO_RAD = Math.PI/180;\n\n\n// static public properties:\n\t/**\n\t * An identity matrix, representing a null transformation.\n\t * @property identity\n\t * @static\n\t * @type Matrix2D\n\t * @readonly\n\t **/\n\tMatrix2D.identity = null; // set at bottom of class definition.\n\t\n\n// public methods:\n\t/**\n\t * Sets the specified values on this instance. \n\t * @method setValues\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @return {Matrix2D} This instance. Useful for chaining method calls.\n\t*/\n\tp.setValues = function(a, b, c, d, tx, ty) {\n\t\t// don\'t forget to update docs in the constructor if these change:\n\t\tthis.a = (a == null) ? 1 : a;\n\t\tthis.b = b || 0;\n\t\tthis.c = c || 0;\n\t\tthis.d = (d == null) ? 1 : d;\n\t\tthis.tx = tx || 0;\n\t\tthis.ty = ty || 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix properties to this matrix. All parameters are required.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method append\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.append = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tif (a != 1 || b != 0 || c != 0 || d != 1) {\n\t\t\tthis.a  = a1*a+c1*b;\n\t\t\tthis.b  = b1*a+d1*b;\n\t\t\tthis.c  = a1*c+c1*d;\n\t\t\tthis.d  = b1*c+d1*d;\n\t\t}\n\t\tthis.tx = a1*tx+c1*ty+this.tx;\n\t\tthis.ty = b1*tx+d1*ty+this.ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Prepends the specified matrix properties to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * All parameters are required.\n\t * @method prepend\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prepend = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar c1 = this.c;\n\t\tvar tx1 = this.tx;\n\n\t\tthis.a  = a*a1+c*this.b;\n\t\tthis.b  = b*a1+d*this.b;\n\t\tthis.c  = a*c1+c*this.d;\n\t\tthis.d  = b*c1+d*this.d;\n\t\tthis.tx = a*tx1+c*this.ty+tx;\n\t\tthis.ty = b*tx1+d*this.ty+ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method appendMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendMatrix = function(matrix) {\n\t\treturn this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Prepends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = o.getMatrix();\n\t * \twhile (o = o.parent) {\n\t * \t\t// prepend each parent\'s transformation in turn:\n\t * \t\to.prependMatrix(o.getMatrix());\n\t * \t}\n\t * @method prependMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependMatrix = function(matrix) {\n\t\treturn this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n\t * For example, you can use this to generate a matrix representing the transformations of a display object:\n\t * \n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tmtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n\t * @method appendTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single append operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t} else {\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\t\n\t\tif (regX || regY) {\n\t\t\t// append the registration offset:\n\t\t\tthis.tx -= regX*this.a+regY*this.c; \n\t\t\tthis.ty -= regX*this.b+regY*this.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tdo  {\n\t * \t\t// prepend each parent\'s transformation in turn:\n\t * \t\tmtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t * \t} while (o = o.parent);\n\t * \t\n\t * \tNote that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}\n\t * \tvalues. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.\n\t * @method prependTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// prepend the registration offset:\n\t\t\tthis.tx -= regX; this.ty -= regY;\n\t\t}\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single prepend operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t} else {\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a clockwise rotation transformation to the matrix.\n\t * @method rotate\n\t * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.rotate = function(angle) {\n\t\tangle = angle*Matrix2D.DEG_TO_RAD;\n\t\tvar cos = Math.cos(angle);\n\t\tvar sin = Math.sin(angle);\n\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\n\t\tthis.a = a1*cos+this.c*sin;\n\t\tthis.b = b1*cos+this.d*sin;\n\t\tthis.c = -a1*sin+this.c*cos;\n\t\tthis.d = -b1*sin+this.d*cos;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a skew transformation to the matrix.\n\t * @method skew\n\t * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @param {Number} skewY The amount to skew vertically in degrees.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.skew = function(skewX, skewY) {\n\t\tskewX = skewX*Matrix2D.DEG_TO_RAD;\n\t\tskewY = skewY*Matrix2D.DEG_TO_RAD;\n\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * @method scale\n\t * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n\t * @param {Number} y The amount to scale vertically.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.scale = function(x, y) {\n\t\tthis.a *= x;\n\t\tthis.b *= x;\n\t\tthis.c *= y;\n\t\tthis.d *= y;\n\t\t//this.tx *= x;\n\t\t//this.ty *= y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * @method translate\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.translate = function(x, y) {\n\t\tthis.tx += this.a*x + this.c*y;\n\t\tthis.ty += this.b*x + this.d*y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n\t * @method identity\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.identity = function() {\n\t\tthis.a = this.d = 1;\n\t\tthis.b = this.c = this.tx = this.ty = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Inverts the matrix, causing it to perform the opposite transformation.\n\t * @method invert\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.invert = function() {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tvar tx1 = this.tx;\n\t\tvar n = a1*d1-b1*c1;\n\n\t\tthis.a = d1/n;\n\t\tthis.b = -b1/n;\n\t\tthis.c = -c1/n;\n\t\tthis.d = a1/n;\n\t\tthis.tx = (c1*this.ty-d1*tx1)/n;\n\t\tthis.ty = -(a1*this.ty-b1*tx1)/n;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns true if the matrix is an identity matrix.\n\t * @method isIdentity\n\t * @return {Boolean}\n\t **/\n\tp.isIdentity = function() {\n\t\treturn this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\n\t};\n\t\n\t/**\n\t * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n\t * @method equals\n\t * @param {Matrix2D} matrix The matrix to compare.\n\t * @return {Boolean}\n\t **/\n\tp.equals = function(matrix) {\n\t\treturn this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\n\t};\n\n\t/**\n\t * Transforms a point according to this matrix.\n\t * @method transformPoint\n\t * @param {Number} x The x component of the point to transform.\n\t * @param {Number} y The y component of the point to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n\t * @return {Point} This matrix. Useful for chaining method calls.\n\t **/\n\tp.transformPoint = function(x, y, pt) {\n\t\tpt = pt||{};\n\t\tpt.x = x*this.a+y*this.c+this.tx;\n\t\tpt.y = x*this.b+y*this.d+this.ty;\n\t\treturn pt;\n\t};\n\n\t/**\n\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n\t * results.\n\t * @method decompose\n\t * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\n\t * @return {Object} The target, or a new generic object with the transform properties applied.\n\t*/\n\tp.decompose = function(target) {\n\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n\t\tif (target == null) { target = {}; }\n\t\ttarget.x = this.tx;\n\t\ttarget.y = this.ty;\n\t\ttarget.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n\t\ttarget.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n\t\tvar skewX = Math.atan2(-this.c, this.d);\n\t\tvar skewY = Math.atan2(this.b, this.a);\n\n\t\tvar delta = Math.abs(1-skewX/skewY);\n\t\tif (delta < 0.00001) { // effectively identical, can use rotation:\n\t\t\ttarget.rotation = skewY/Matrix2D.DEG_TO_RAD;\n\t\t\tif (this.a < 0 && this.d >= 0) {\n\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\n\t\t\t}\n\t\t\ttarget.skewX = target.skewY = 0;\n\t\t} else {\n\t\t\ttarget.skewX = skewX/Matrix2D.DEG_TO_RAD;\n\t\t\ttarget.skewY = skewY/Matrix2D.DEG_TO_RAD;\n\t\t}\n\t\treturn target;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified matrix to this matrix.\n\t * @method copy\n\t * @param {Matrix2D} matrix The matrix to copy properties from.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.copy = function(matrix) {\n\t\treturn this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Returns a clone of the Matrix2D instance.\n\t * @method clone\n\t * @return {Matrix2D} a clone of the Matrix2D instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";\n\t};\n\n\t// this has to be populated after the class is defined:\n\tMatrix2D.identity = new Matrix2D();\n\n\n\tcreatejs.Matrix2D = Matrix2D;\n}());\n\n//##############################################################################\n// DisplayProps.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * Used for calculating and encapsulating display related properties.\n\t * @class DisplayProps\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.\n\t * @constructor\n\t **/\n\tfunction DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.setValues(visible, alpha, shadow, compositeOperation, matrix);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Property representing the alpha that will be applied to a display object.\n\t\t * @property alpha\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the shadow that will be applied to a display object.\n\t\t * @property shadow\n\t\t * @type Shadow\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the compositeOperation that will be applied to a display object.\n\t\t * You can find a list of valid composite operations at:\n\t\t * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>\n\t\t * @property compositeOperation\n\t\t * @type String\n\t\t **/\n\t\t\n\t\t/**\n\t\t * Property representing the value for visible that will be applied to a display object.\n\t\t * @property visible\n\t\t * @type Boolean\n\t\t **/\n\t\t\n\t\t/**\n\t\t * The transformation matrix that will be applied to a display object.\n\t\t * @property matrix\n\t\t * @type Matrix2D\n\t\t **/\n\t}\n\tvar p = DisplayProps.prototype;\n\n// initialization:\n\t/**\n\t * Reinitializes the instance with the specified values.\n\t * @method setValues\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.visible = visible == null ? true : !!visible;\n\t\tthis.alpha = alpha == null ? 1 : alpha;\n\t\tthis.shadow = shadow;\n\t\tthis.compositeOperation = compositeOperation;\n\t\tthis.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();\n\t\treturn this;\n\t};\n\n// public methods:\n\t/**\n\t * Appends the specified display properties. This is generally used to apply a child\'s properties its parent\'s.\n\t * @method append\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.append = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = shadow || this.shadow;\n\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.appendMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Prepends the specified display properties. This is generally used to apply a parent\'s properties to a child\'s.\n\t * For example, to get the combined display properties that would be applied to a child, you could use:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar props = new createjs.DisplayProps();\n\t * \tdo {\n\t * \t\t// prepend each parent\'s props in turn:\n\t * \t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());\n\t * \t} while (o = o.parent);\n\t * \t\n\t * @method prepend\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = this.shadow || shadow;\n\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.prependMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Resets this instance and its matrix to default values.\n\t * @method identity\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.identity = function() {\n\t\tthis.visible = true;\n\t\tthis.alpha = 1;\n\t\tthis.shadow = this.compositeOperation = null;\n\t\tthis.matrix.identity();\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the DisplayProps instance. Clones the associated matrix.\n\t * @method clone\n\t * @return {DisplayProps} a clone of the DisplayProps instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());\n\t};\n\n// private methods:\n\n\tcreatejs.DisplayProps = DisplayProps;\n})();\n\n//##############################################################################\n// Point.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Represents a point on a 2 dimensional x / y coordinate system.\n\t *\n\t * <h4>Example</h4>\n\t * \n\t *      var point = new createjs.Point(0, 100);\n\t * \n\t * @class Point\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @constructor\n\t **/\n\tfunction Point(x, y) {\n\t \tthis.setValues(x, y);\n\t \t\n\t \t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Point.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @return {Point} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y) {\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified point to this point.\n\t * @method copy\n\t * @param {Point} point The point to copy properties from.\n\t * @return {Point} This point. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Point instance.\n\t * @method clone\n\t * @return {Point} a clone of the Point instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Point(this.x, this.y);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Point (x="+this.x+" y="+this.y+")]";\n\t};\n\t\n\t\n\tcreatejs.Point = Point;\n}());\n\n//##############################################################################\n// Rectangle.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var rect = new createjs.Rectangle(0, 0, 100, 100);\n\t *\n\t * @class Rectangle\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @constructor\n\t **/\n\tfunction Rectangle(x, y, width, height) {\n\t\tthis.setValues(x, y, width, height);\n\t\t\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Width.\n\t\t * @property width\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Height.\n\t\t * @property height\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Rectangle.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y, width, height) {\n\t\t// don\'t forget to update docs in the constructor if these change:\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\tthis.width = width||0;\n\t\tthis.height = height||0;\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Extends the rectangle\'s bounds to include the described point or rectangle.\n\t * @method extend\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.extend = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\tif (x+width > this.x+this.width) { this.width = x+width-this.x; }\n\t\tif (y+height > this.y+this.height) { this.height = y+height-this.y; }\n\t\tif (x < this.x) { this.width += this.x-x; this.x = x; }\n\t\tif (y < this.y) { this.height += this.y-y; this.y = y; }\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Adds the specified padding to the rectangle\'s bounds.\n\t * @method pad\n\t * @param {Number} top\n\t * @param {Number} left\n\t * @param {Number} right\n\t * @param {Number} bottom\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.pad = function(top, left, bottom, right) {\n\t\tthis.x -= left;\n\t\tthis.y -= top;\n\t\tthis.width += left+right;\n\t\tthis.height += top+bottom;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified rectangle to this rectangle.\n\t * @method copy\n\t * @param {Rectangle} rectangle The rectangle to copy properties from.\n\t * @return {Rectangle} This rectangle. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(rectangle) {\n\t\treturn this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n\t};\n\t\n\t/** \n\t * Returns true if this rectangle fully encloses the described point or rectangle.\n\t * @method contains\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Boolean} True if the described point or rectangle is contained within this rectangle.\n\t*/\n\tp.contains = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\treturn (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which contains this rectangle and the specified rectangle.\n\t * @method union\n\t * @param {Rectangle} rect The rectangle to calculate a union with.\n\t * @return {Rectangle} A new rectangle describing the union.\n\t*/\n\tp.union = function(rect) {\n\t\treturn this.clone().extend(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,\n\t * or null if they do not intersect.\n\t * @method intersection\n\t * @param {Rectangle} rect The rectangle to calculate an intersection with.\n\t * @return {Rectangle} A new rectangle describing the intersection or null.\n\t*/\n\tp.intersection = function(rect) {\n\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;\n\t\tif (this.x > x1) { x1 = this.x; }\n\t\tif (this.y > y1) { y1 = this.y; }\n\t\tif (this.x + this.width < x2) { x2 = this.x + this.width; }\n\t\tif (this.y + this.height < y2) { y2 = this.y + this.height; }\n\t\treturn (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);\n\t};\n\t\n\t/** \n\t * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.\n\t * @method intersects\n\t * @param {Rectangle} rect The rectangle to compare.\n\t * @return {Boolean} True if the rectangles intersect.\n\t*/\n\tp.intersects = function(rect) {\n\t\treturn (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);\n\t};\n\t\n\t/** \n\t * Returns true if the width or height are equal or less than 0.\n\t * @method isEmpty\n\t * @return {Boolean} True if the rectangle is empty.\n\t*/\n\tp.isEmpty = function() {\n\t\treturn this.width <= 0 || this.height <= 0;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Rectangle instance.\n\t * @method clone\n\t * @return {Rectangle} a clone of the Rectangle instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";\n\t};\n\t\n\t\n\tcreatejs.Rectangle = Rectangle;\n}());\n\n//##############################################################################\n// ButtonHelper.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or\n\t * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and\n\t * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},\n\t * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.\n\t *\n\t * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent\n\t * garbage collection.\n\t * \n\t * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");\n\t *      myInstance.addEventListener("click", handleClick);\n\t *      function handleClick(event) {\n\t *          // Click Happened.\n\t *      }\n\t *\n\t * @class ButtonHelper\n\t * @param {Sprite|MovieClip} target The instance to manage.\n\t * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.\n\t * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.\n\t * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.\n\t * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing\n\t * states.\n\t * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,\n\t * then the button\'s visible states will be used instead. Note that the same instance as the "target" argument can be\n\t * used for the hitState.\n\t * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is\n\t * null, then the default state of the hitArea will be used. *\n\t * @constructor\n\t */\n\tfunction ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {\n\t\tif (!target.addEventListener) { return; }\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The target for this button helper.\n\t\t * @property target\n\t\t * @type MovieClip | Sprite\n\t\t * @readonly\n\t\t **/\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses out of the target. Defaults to "over".\n\t\t * @property overLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.overLabel = overLabel == null ? "over" : overLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses over the target. Defaults to "out".\n\t\t * @property outLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.outLabel = outLabel == null ? "out" : outLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user presses on the target. Defaults to "down".\n\t\t * @property downLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.downLabel = downLabel == null ? "down" : downLabel;\n\t\n\t\t/**\n\t\t * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.\n\t\t * @property play\n\t\t * @default false\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.play = play;\n\t\t\n\t\t\n\t//  private properties\n\t\t/**\n\t\t * @property _isPressed\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isPressed = false;\n\t\n\t\t/**\n\t\t * @property _isOver\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isOver = false;\n\t\n\t\t/**\n\t\t * @property _enabled\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._enabled = false;\n\t\t\n\t// setup:\n\t\ttarget.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.\n\t\tthis.enabled = true;\n\t\tthis.handleEvent({});\n\t\tif (hitArea) {\n\t\t\tif (hitLabel) {\n\t\t\t\thitArea.actionsEnabled = false;\n\t\t\t\thitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);\n\t\t\t}\n\t\t\ttarget.hitArea = hitArea;\n\t\t}\n\t}\n\tvar p = ButtonHelper.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.\n\t * @method setEnabled\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tp.setEnabled = function(value) { // TODO: deprecated.\n\t\tif (value == this._enabled) { return; }\n\t\tvar o = this.target;\n\t\tthis._enabled = value;\n\t\tif (value) {\n\t\t\to.cursor = "pointer";\n\t\t\to.addEventListener("rollover", this);\n\t\t\to.addEventListener("rollout", this);\n\t\t\to.addEventListener("mousedown", this);\n\t\t\to.addEventListener("pressup", this);\n\t\t\tif (o._reset) { o.__reset = o._reset; o._reset = this._reset;}\n\t\t} else {\n\t\t\to.cursor = null;\n\t\t\to.removeEventListener("rollover", this);\n\t\t\to.removeEventListener("rollout", this);\n\t\t\to.removeEventListener("mousedown", this);\n\t\t\to.removeEventListener("pressup", this);\n\t\t\tif (o.__reset) { o._reset = o.__reset; delete(o.__reset); }\n\t\t}\n\t};\n\t/**\n\t * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.\n\t * @method getEnabled\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tp.getEnabled = function() {\n\t\treturn this._enabled;\n\t};\n\n\t/**\n\t * Enables or disables the button functionality on the target.\n\t * @property enabled\n\t * @type {Boolean}\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tenabled: { get: p.getEnabled, set: p.setEnabled }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[ButtonHelper]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method handleEvent\n\t * @param {Object} evt The mouse event to handle.\n\t * @protected\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tvar label, t = this.target, type = evt.type;\n\t\tif (type == "mousedown") {\n\t\t\tthis._isPressed = true;\n\t\t\tlabel = this.downLabel;\n\t\t} else if (type == "pressup") {\n\t\t\tthis._isPressed = false;\n\t\t\tlabel = this._isOver ? this.overLabel : this.outLabel;\n\t\t} else if (type == "rollover") {\n\t\t\tthis._isOver = true;\n\t\t\tlabel = this._isPressed ? this.downLabel : this.overLabel;\n\t\t} else { // rollout and default\n\t\t\tthis._isOver = false;\n\t\t\tlabel = this._isPressed ? this.overLabel : this.outLabel;\n\t\t}\n\t\tif (this.play) {\n\t\t\tt.gotoAndPlay&&t.gotoAndPlay(label);\n\t\t} else {\n\t\t\tt.gotoAndStop&&t.gotoAndStop(label);\n\t\t}\n\t};\n\t\n\t/**\n\t * Injected into target. Preserves the paused state through a reset.\n\t * @method _reset\n\t * @protected\n\t **/\n\tp._reset = function() {\n\t\t// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.\n\t\tvar p = this.paused;\n\t\tthis.__reset();\n\t\tthis.paused = p;\n\t};\n\n\n\tcreatejs.ButtonHelper = ButtonHelper;\n}());\n\n//##############################################################################\n// Shadow.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}\n\t * via its <code>shadow</code> property.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);\n\t *\n\t * @class Shadow\n\t * @constructor\n\t * @param {String} color The color of the shadow. This can be any valid CSS color value.\n\t * @param {Number} offsetX The x offset of the shadow in pixels.\n\t * @param {Number} offsetY The y offset of the shadow in pixels.\n\t * @param {Number} blur The size of the blurring effect.\n\t **/\n\tfunction Shadow(color, offsetX, offsetY, blur) {\n\t\t\n\t\t\n\t// public properties:\n\t\t/** \n\t\t * The color of the shadow. This can be any valid CSS color value.\n\t\t * @property color\n\t\t * @type String\n\t\t * @default null\n\t\t */\n\t\tthis.color = color||"black";\n\t\n\t\t/** The x offset of the shadow.\n\t\t * @property offsetX\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetX = offsetX||0;\n\t\n\t\t/** The y offset of the shadow.\n\t\t * @property offsetY\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetY = offsetY||0;\n\t\n\t\t/** The blur of the shadow.\n\t\t * @property blur\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.blur = blur||0;\n\t}\n\tvar p = Shadow.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public properties:\n\t/**\n\t * An identity shadow object (all properties are set to 0).\n\t * @property identity\n\t * @type Shadow\n\t * @static\n\t * @final\n\t * @readonly\n\t **/\n\tShadow.identity = new Shadow("transparent", 0, 0, 0);\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Shadow]";\n\t};\n\n\t/**\n\t * Returns a clone of this Shadow instance.\n\t * @method clone\n\t * @return {Shadow} A clone of the current Shadow instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t};\n\t\n\n\tcreatejs.Shadow = Shadow;\n}());\n\n//##############################################################################\n// SpriteSheet.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually\n\t * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100\n\t * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).\n\t *\n\t * The data passed to the SpriteSheet constructor defines:\n\t * <ol>\n\t * \t<li> The source image or images to use.</li>\n\t * \t<li> The positions of individual image frames.</li>\n\t * \t<li> Sequences of frames that form named animations. Optional.</li>\n\t * \t<li> The target playback framerate. Optional.</li>\n\t * </ol>\n\t * <h3>SpriteSheet Format</h3>\n\t * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties\n\t * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.\n\t *\n\t * <h4>images</h4>\n\t * An array of source images. Images can be either an HTMlimage\n\t * instance, or a uri to an image. The former is recommended to control preloading.\n\t *\n\t * \timages: [image1, "path/to/image2.png"],\n\t *\n\t * <h4>frames</h4>\n\t * Defines the individual frames. There are two supported formats for frame data:\n\t * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,\n\t * and `count` properties.\n\t *\n\t * <ul>\n\t *  <li>`width` & `height` are required and specify the dimensions of the frames</li>\n\t *  <li>`regX` & `regY` indicate the registration point or "origin" of the frames</li>\n\t *  <li>`spacing` indicate the spacing between frames</li>\n\t *  <li>`margin` specify the margin around the image(s)</li>\n\t *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will\n\t *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned\n\t *  indexes based on their position in the source images (left to right, top to bottom).</li>\n\t * </ul>\n\t *\n\t *  \tframes: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}\n\t *\n\t * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array\n\t * with 4 required and 3 optional entries, in the order:\n\t *\n\t * <ul>\n\t *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>\n\t *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>\n\t *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>\n\t * </ul>\n\t *\n\t * \tframes: [\n\t * \t\t// x, y, width, height, imageIndex*, regX*, regY*\n\t * \t\t[64, 0, 96, 64],\n\t * \t\t[0, 0, 64, 64, 1, 32, 32]\n\t * \t\t// etc.\n\t * \t]\n\t *\n\t * <h4>animations</h4>\n\t * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an\n\t * animation of the same name. Each animation must specify the frames to play, and may\n\t * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and\n\t * the name of the `next` animation to sequence to after it completes.\n\t *\n\t * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:\n\t * <ol>\n\t * \t<li>for a single frame animation, you can simply specify the frame index\n\t *\n\t * \t\tanimations: {\n\t * \t\t\tsit: 7\n\t * \t\t}\n\t *\n\t * </li>\n\t * <li>\n\t *      for an animation of consecutive frames, you can use an array with two required, and two optional entries\n\t * \t\tin the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\t// start, end, next*, speed*\n\t * \t\t\trun: [0, 8],\n\t * \t\t\tjump: [9, 12, "run", 2]\n\t * \t\t}\n\t *\n\t *  </li>\n\t *  <li>\n\t *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame\n\t *     indexes to play in order. The object can also specify `next` and `speed` properties.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\twalk: {\n\t * \t\t\t\tframes: [1,2,3,3,2,1]\n\t * \t\t\t},\n\t * \t\t\tshoot: {\n\t * \t\t\t\tframes: [1,4,5,6],\n\t * \t\t\t\tnext: "walk",\n\t * \t\t\t\tspeed: 0.5\n\t * \t\t\t}\n\t * \t\t}\n\t *\n\t *  </li>\n\t * </ol>\n\t * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`\n\t * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in\n\t * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.\n\t *\n\t * <h4>framerate</h4>\n\t * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See\n\t * {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.\n\t *\n\t * \t\tframerate: 20\n\t *\n\t * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}\n\t * event generated by the {{#crossLink "Ticker"}}{{/crossLink}}.\n\t *\n\t * \t\tcreatejs.Ticker.on("tick", handleTick);\n\t * \t\tfunction handleTick(event) {\n\t *\t\t\tstage.update(event);\n\t *\t\t}\n\t *\n\t * <h3>Example</h3>\n\t * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three\n\t * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing frame 6-8 and\n\t * sequencing back to run.\n\t *\n\t * \t\tvar data = {\n\t * \t\t\timages: ["sprites.jpg"],\n\t * \t\t\tframes: {width:50, height:50},\n\t * \t\t\tanimations: {\n\t * \t\t\t\tstand:0,\n\t * \t\t\t\trun:[1,5],\n\t * \t\t\t\tjump:[6,8,"run"]\n\t * \t\t\t}\n\t * \t\t};\n\t * \t\tvar spriteSheet = new createjs.SpriteSheet(data);\n\t * \t\tvar animation = new createjs.Sprite(spriteSheet, "run");\n\t *\n\t * <h3>Generating SpriteSheet Images</h3>\n\t * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or\n\t * coordinates manually, however there are a number of tools that facilitate this.\n\t * <ul>\n\t *     <li>Exporting SpriteSheets or HTML5 content from Flash Pro supports the EaselJS SpriteSheet format.</li>\n\t *     <li>The popular <a href="https://www.codeandweb.com/texturepacker/easeljs" target="_blank">Texture Packer</a> has\n\t *     EaselJS support.\n\t *     <li>SWF animations in Flash can be exported to SpriteSheets using <a href="http://createjs.com/zoe" target="_blank"></a></li>\n\t * </ul>\n\t *\n\t * <h3>Cross Origin Issues</h3>\n\t * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with\n\t * using:\n\t * <ul>\n\t *     <li>a mouse</li>\n\t *     <li>methods such as {{#crossLink "Container/getObjectUnderPoint"}}{{/crossLink}}</li>\n\t *     <li>Filters (see {{#crossLink "Filter"}}{{/crossLink}})</li>\n\t *     <li>caching (see {{#crossLink "DisplayObject/cache"}}{{/crossLink}})</li>\n\t * </ul>\n\t * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or\n\t * setting the `crossOrigin` property on PreloadJS\' LoadQueue or LoadItems.\n\t *\n\t * \t\tvar image = new Image();\n\t * \t\timg.crossOrigin="Anonymous";\n\t * \t\timg.src = "http://server-with-CORS-support.com/path/to/image.jpg";\n\t *\n\t * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must\n\t * support cross-origin requests, or this will not work. For more information, check out\n\t * <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">CORS overview on MDN</a>.\n\t *\n\t * @class SpriteSheet\n\t * @constructor\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @extends EventDispatcher\n\t **/\n\tfunction SpriteSheet(data) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Indicates whether all images are finished loading.\n\t\t * @property complete\n\t\t * @type Boolean\n\t\t * @readonly\n\t\t **/\n\t\tthis.complete = true;\n\n\t\t/**\n\t\t * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class\n\t\t * {{#crossLink "Sprite/framerate:property"}}{{/crossLink}} for more information.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t **/\n\t\tthis.framerate = 0;\n\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = null;\n\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = null;\n\n\t\t/**\n\t\t * @property _images\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._images = null;\n\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Object\n\t\t **/\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @property _loadCount\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._loadCount = 0;\n\n\t\t// only used for simple frame defs:\n\t\t/**\n\t\t * @property _frameHeight\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameHeight = 0;\n\n\t\t/**\n\t\t * @property _frameWidth\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameWidth = 0;\n\n\t\t/**\n\t\t * @property _numFrames\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._numFrames = 0;\n\n\t\t/**\n\t\t * @property _regX\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regX = 0;\n\n\t\t/**\n\t\t * @property _regY\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regY = 0;\n\n\t\t/**\n\t\t * @property _spacing\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._spacing = 0;\n\n\t\t/**\n\t\t * @property _margin\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._margin = 0;\n\n\t\t// setup:\n\t\tthis._parseData(data);\n\t}\n\tvar p = createjs.extend(SpriteSheet, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// events:\n\t/**\n\t * Dispatched when all images are loaded.  Note that this only fires if the images\n\t * were not fully loaded when the sprite sheet was initialized. You should check the complete property\n\t * to prior to adding a listener. Ex.\n\t *\n\t * \tvar sheet = new createjs.SpriteSheet(data);\n\t * \tif (!sheet.complete) {\n\t * \t\t// not preloaded, listen for the complete event:\n\t * \t\tsheet.addEventListener("complete", handler);\n\t * \t}\n\t *\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}\n\t * when doing on-demand rendering.\n\t * @event getframe\n\t * @param {Number} index The frame index.\n\t * @param {Object} frame The frame object that getFrame will return.\n\t */\n\n\t/**\n\t * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that\n\t * encounters an error, and will still dispatch a {{#crossLink "SpriteSheet/complete:event"}}{{/crossLink}}\n\t * event once all images are finished processing, even if an error is encountered.\n\t * @event error\n\t * @param {String} src The source of the image that failed to load.\n\t * @since 0.8.2\n\t */\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.\n\t * @method getAnimations\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getAnimations = function() {\n\t\treturn this._animations.slice();\n\t};\n\n\t/**\n\t * Returns an array of all available animation names available on this sprite sheet as strings.\n\t * @property animations\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tanimations: { get: p.getAnimations }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns the total number of frames in the specified animation, or in the whole sprite\n\t * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and\n\t * the images have not been fully loaded.\n\t * @method getNumFrames\n\t * @param {String} animation The name of the animation to get a frame count for.\n\t * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.\n\t */\n\tp.getNumFrames = function(animation) {\n\t\tif (animation == null) {\n\t\t\treturn this._frames ? this._frames.length : this._numFrames || 0;\n\t\t} else {\n\t\t\tvar data = this._data[animation];\n\t\t\tif (data == null) { return 0; }\n\t\t\telse { return data.frames.length; }\n\t\t}\n\t};\n\n\t/**\n\t * Returns an object defining the specified animation. The returned object contains:<UL>\n\t * \t<li>frames: an array of the frame ids in the animation</li>\n\t * \t<li>speed: the playback speed for this animation</li>\n\t * \t<li>name: the name of the animation</li>\n\t * \t<li>next: the default animation to play next. If the animation loops, the name and next property will be the\n\t * \tsame.</li>\n\t * </UL>\n\t * @method getAnimation\n\t * @param {String} name The name of the animation to get.\n\t * @return {Object} a generic object with frames, speed, name, and next properties.\n\t **/\n\tp.getAnimation = function(name) {\n\t\treturn this._data[name];\n\t};\n\n\t/**\n\t * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>\n\t * \t<li>an image property holding a reference to the image object in which the frame is found</li>\n\t * \t<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that\n\t * \timage.</li>\n\t * \t<li> A regX and regY property corresponding to the regX/Y values for the frame.\n\t * </UL>\n\t * @method getFrame\n\t * @param {Number} frameIndex The index of the frame.\n\t * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.\n\t **/\n\tp.getFrame = function(frameIndex) {\n\t\tvar frame;\n\t\tif (this._frames && (frame=this._frames[frameIndex])) { return frame; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative\n\t * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:\n\t *\n\t * \t[x=-50, y=-40, width=90, height=70]\n\t *\n\t * @method getFrameBounds\n\t * @param {Number} frameIndex The index of the frame.\n\t * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t **/\n\tp.getFrameBounds = function(frameIndex, rectangle) {\n\t\tvar frame = this.getFrame(frameIndex);\n\t\treturn frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[SpriteSheet]";\n\t};\n\n\t/**\n\t * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow("SpriteSheet cannot be cloned.")\n\t};\n\n// private methods:\n\t/**\n\t * @method _parseData\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @protected\n\t **/\n\tp._parseData = function(data) {\n\t\tvar i,l,o,a;\n\t\tif (data == null) { return; }\n\n\t\tthis.framerate = data.framerate||0;\n\n\t\t// parse images:\n\t\tif (data.images && (l=data.images.length) > 0) {\n\t\t\ta = this._images = [];\n\t\t\tfor (i=0; i<l; i++) {\n\t\t\t\tvar img = data.images[i];\n\t\t\t\tif (typeof img == "string") {\n\t\t\t\t\tvar src = img;\n\t\t\t\t\timg = document.createElement("img");\n\t\t\t\t\timg.src = src;\n\t\t\t\t}\n\t\t\t\ta.push(img);\n\t\t\t\tif (!img.getContext && !img.naturalWidth) {\n\t\t\t\t\tthis._loadCount++;\n\t\t\t\t\tthis.complete = false;\n\t\t\t\t\t(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);\n\t\t\t\t\t(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// parse frames:\n\t\tif (data.frames == null) { // nothing\n\t\t} else if (Array.isArray(data.frames)) {\n\t\t\tthis._frames = [];\n\t\t\ta = data.frames;\n\t\t\tfor (i=0,l=a.length;i<l;i++) {\n\t\t\t\tvar arr = a[i];\n\t\t\t\tthis._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });\n\t\t\t}\n\t\t} else {\n\t\t\to = data.frames;\n\t\t\tthis._frameWidth = o.width;\n\t\t\tthis._frameHeight = o.height;\n\t\t\tthis._regX = o.regX||0;\n\t\t\tthis._regY = o.regY||0;\n\t\t\tthis._spacing = o.spacing||0;\n\t\t\tthis._margin = o.margin||0;\n\t\t\tthis._numFrames = o.count;\n\t\t\tif (this._loadCount == 0) { this._calculateFrames(); }\n\t\t}\n\n\t\t// parse animations:\n\t\tthis._animations = [];\n\t\tif ((o=data.animations) != null) {\n\t\t\tthis._data = {};\n\t\t\tvar name;\n\t\t\tfor (name in o) {\n\t\t\t\tvar anim = {name:name};\n\t\t\t\tvar obj = o[name];\n\t\t\t\tif (typeof obj == "number") { // single frame\n\t\t\t\t\ta = anim.frames = [obj];\n\t\t\t\t} else if (Array.isArray(obj)) { // simple\n\t\t\t\t\tif (obj.length == 1) { anim.frames = [obj[0]]; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tanim.speed = obj[3];\n\t\t\t\t\t\tanim.next = obj[2];\n\t\t\t\t\t\ta = anim.frames = [];\n\t\t\t\t\t\tfor (i=obj[0];i<=obj[1];i++) {\n\t\t\t\t\t\t\ta.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // complex\n\t\t\t\t\tanim.speed = obj.speed;\n\t\t\t\t\tanim.next = obj.next;\n\t\t\t\t\tvar frames = obj.frames;\n\t\t\t\t\ta = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);\n\t\t\t\t}\n\t\t\t\tif (anim.next === true || anim.next === undefined) { anim.next = name; } // loop\n\t\t\t\tif (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop\n\t\t\t\tif (!anim.speed) { anim.speed = 1; }\n\t\t\t\tthis._animations.push(name);\n\t\t\t\tthis._data[name] = anim;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageLoad\n\t * @protected\n\t **/\n\tp._handleImageLoad = function(src) {\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis._calculateFrames();\n\t\t\tthis.complete = true;\n\t\t\tthis.dispatchEvent("complete");\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageError\n\t * @protected\n\t */\n\tp._handleImageError = function (src) {\n\t\tvar errorEvent = new createjs.Event("error");\n\t\terrorEvent.src = src;\n\t\tthis.dispatchEvent(errorEvent);\n\n\t\t// Complete is still dispatched.\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis.dispatchEvent("complete");\n\t\t}\n\t};\n\n\t/**\n\t * @method _calculateFrames\n\t * @protected\n\t **/\n\tp._calculateFrames = function() {\n\t\tif (this._frames || this._frameWidth == 0) { return; }\n\n\t\tthis._frames = [];\n\n\t\tvar maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.\n\t\tvar frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;\n\t\tvar spacing = this._spacing, margin = this._margin;\n\t\t\n\t\timgLoop:\n\t\tfor (var i=0, imgs=this._images; i<imgs.length; i++) {\n\t\t\tvar img = imgs[i], imgW = img.width, imgH = img.height;\n\n\t\t\tvar y = margin;\n\t\t\twhile (y <= imgH-margin-frameHeight) {\n\t\t\t\tvar x = margin;\n\t\t\t\twhile (x <= imgW-margin-frameWidth) {\n\t\t\t\t\tif (frameCount >= maxFrames) { break imgLoop; }\n\t\t\t\t\tframeCount++;\n\t\t\t\t\tthis._frames.push({\n\t\t\t\t\t\t\timage: img,\n\t\t\t\t\t\t\trect: new createjs.Rectangle(x, y, frameWidth, frameHeight),\n\t\t\t\t\t\t\tregX: this._regX,\n\t\t\t\t\t\t\tregY: this._regY\n\t\t\t\t\t\t});\n\t\t\t\t\tx += frameWidth+spacing;\n\t\t\t\t}\n\t\t\t\ty += frameHeight+spacing;\n\t\t\t}\n\t\t}\n\t\tthis._numFrames = frameCount;\n\t};\n\n\n\tcreatejs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");\n}());\n\n//##############################################################################\n// Graphics.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a\n\t * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}\n\t * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the\n\t * context of an EaselJS display list.\n\t *\n\t * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or\n\t * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.\n\t * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.\n\t *\n\t *      var g = new createjs.Graphics();\n\t *      g.setStrokeStyle(1);\n\t *      g.beginStroke("#000000");\n\t *      g.beginFill("red");\n\t *      g.drawCircle(0,0,30);\n\t *\n\t * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,\n\t * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:\n\t *\n\t *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);\n\t *\n\t * Each graphics API call generates a command object (see below). The last command to be created can be accessed via\n\t * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:\n\t *\n\t *      var fillCommand = myGraphics.beginFill("red").command;\n\t *      // ... later, update the fill style/color:\n\t *      fillCommand.style = "blue";\n\t *      // or change it to a bitmap fill:\n\t *      fillCommand.bitmap(myImage);\n\t *\n\t * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you\n\t * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:\n\t *\n\t *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:\n\t *      myGraphics.append(createjs.Graphics.beginCmd);\n\t *      // we need to define the path before applying the fill:\n\t *      var circle = new createjs.Graphics.Circle(0,0,30);\n\t *      myGraphics.append(circle);\n\t *      // fill the path we just defined:\n\t *      var fill = new createjs.Graphics.Fill("red");\n\t *      myGraphics.append(fill);\n\t *\n\t * These approaches can be used together, for example to insert a custom command:\n\t *\n\t *      myGraphics.beginFill("red");\n\t *      var customCommand = new CustomSpiralCommand(etc);\n\t *      myGraphics.append(customCommand);\n\t *      myGraphics.beginFill("blue");\n\t *      myGraphics.drawCircle(0, 0, 30);\n\t *\n\t * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.\n\t *\n\t * <h4>Tiny API</h4>\n\t * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the\n\t * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS\n\t * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected\n\t * descriptions in the docs.\n\t *\n\t * <table>\n\t *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>\n\t *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>\n\t *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>\n\t *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>\n\t *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>\n\t *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>\n\t *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>\n\t *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>\n\t *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>\n\t *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>\n\t *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>\n\t *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>\n\t *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>\n\t *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>\n\t *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>\n\t *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>\n\t * </table>\n\t *\n\t * Here is the above example, using the tiny API instead.\n\t *\n\t *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);\n\t *\n\t * @class Graphics\n\t * @constructor\n\t **/\n\tfunction Graphics() {\n\n\n\t// public properties\n\t\t/**\n\t\t * Holds a reference to the last command that was created or appended. For example, you could retain a reference\n\t\t * to a Fill command in order to dynamically update the color later by using:\n\t\t *\n\t\t * \t\tvar myFill = myGraphics.beginFill("red").command;\n\t\t * \t\t// update color later:\n\t\t * \t\tmyFill.style = "yellow";\n\t\t *\n\t\t * @property command\n\t\t * @type Object\n\t\t **/\n\t\tthis.command = null;\n\n\n\t// private properties\n\t\t/**\n\t\t * @property _stroke\n\t\t * @protected\n\t\t * @type {Stroke}\n\t\t **/\n\t\tthis._stroke = null;\n\n\t\t/**\n\t\t * @property _strokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._strokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._oldStrokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _strokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._strokeDash = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._oldStrokeDash = null;\n\n\t\t/**\n\t\t * @property _strokeIgnoreScale\n\t\t * @protected\n\t\t * @type Boolean\n\t\t **/\n\t\tthis._strokeIgnoreScale = false;\n\n\t\t/**\n\t\t * @property _fill\n\t\t * @protected\n\t\t * @type {Fill}\n\t\t **/\n\t\tthis._fill = null;\n\n\t\t/**\n\t\t * @property _instructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._instructions = [];\n\n\t\t/**\n\t\t * Indicates the last instruction index that was committed.\n\t\t * @property _commitIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t **/\n\t\tthis._commitIndex = 0;\n\n\t\t/**\n\t\t * Uncommitted instructions.\n\t\t * @property _activeInstructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._activeInstructions = [];\n\n\t\t/**\n\t\t * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.\n\t\t * @property _dirty\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._dirty = false;\n\n\t\t/**\n\t\t * Index to draw from if a store operation has happened.\n\t\t * @property _storeIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._storeIndex = 0;\n\n\t// setup:\n\t\tthis.clear();\n\t}\n\tvar p = Graphics.prototype;\n\tvar G = Graphics; // shortcut\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Returns a CSS compatible color string based on the specified RGB numeric color values in the format\n\t * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,\n\t *\n\t *      createjs.Graphics.getRGB(50, 100, 150, 0.5);\n\t *      // Returns "rgba(50,100,150,0.5)"\n\t *\n\t * It also supports passing a single hex color value as the first param, and an optional alpha value as the second\n\t * param. For example,\n\t *\n\t *      createjs.Graphics.getRGB(0xFF00FF, 0.2);\n\t *      // Returns "rgba(255,0,255,0.2)"\n\t *\n\t * @method getRGB\n\t * @static\n\t * @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t * @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t * @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format\n\t * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".\n\t **/\n\tGraphics.getRGB = function(r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn "rgb("+r+","+g+","+b+")";\n\t\t} else {\n\t\t\treturn "rgba("+r+","+g+","+b+","+alpha+")";\n\t\t}\n\t};\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",\n\t * or if alpha is null then in the format "hsl(360,100,100)".\n\t *\n\t *      createjs.Graphics.getHSL(150, 100, 70);\n\t *      // Returns "hsl(150,100,70)"\n\t *\n\t * @method getHSL\n\t * @static\n\t * @param {Number} hue The hue component for the color, between 0 and 360.\n\t * @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t * @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format\n\t * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".\n\t **/\n\tGraphics.getHSL = function(hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";\n\t\t} else {\n\t\t\treturn "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";\n\t\t}\n\t};\n\n\n// static properties:\n\t/**\n\t * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid\n\t * unnecessary instantiation.\n\t * @property beginCmd\n\t * @type {Graphics.BeginPath}\n\t * @static\n\t **/\n\t // defined at the bottom of this file.\n\n\t/**\n\t * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.\n\t * @property BASE_64\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Object}\n\t **/\n\tGraphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};\n\n\t/**\n\t * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * "butt", 1 to "round", and 2 to "square".\n\t * For example, to set the line caps to "square":\n\t *\n\t *      myGraphics.ss(16, 2);\n\t *\n\t * @property STROKE_CAPS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_CAPS_MAP = ["butt", "round", "square"];\n\n\t/**\n\t * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * "miter", 1 to "round", and 2 to "bevel".\n\t * For example, to set the line joints to "bevel":\n\t *\n\t *      myGraphics.ss(16, 0, 2);\n\t *\n\t * @property STROKE_JOINTS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];\n\n\t/**\n\t * @property _ctx\n\t * @static\n\t * @protected\n\t * @type {CanvasRenderingContext2D}\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));\n\tif (canvas.getContext) {\n\t\tGraphics._ctx = canvas.getContext("2d");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.\n\t * @method getInstructions\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getInstructions = function() {\n\t\tthis._updateInstructions();\n\t\treturn this._instructions;\n\t};\n\n\t/**\n\t * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)\n\t * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.\n\t *\n\t * This property is mainly intended for introspection of the instructions (ex. for graphics export).\n\t * @property instructions\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tinstructions: { get: p.getInstructions }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true if this Graphics instance has no drawing commands.\n\t * @method isEmpty\n\t * @return {Boolean} Returns true if this Graphics instance has no drawing commands.\n\t **/\n\tp.isEmpty = function() {\n\t\treturn !(this._instructions.length || this._activeInstructions.length);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.\n\t **/\n\tp.draw = function(ctx, data) {\n\t\tthis._updateInstructions();\n\t\tvar instr = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instr.length; i<l; i++) {\n\t\t\tinstr[i].exec(ctx, data);\n\t\t}\n\t};\n\n\t/**\n\t * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and\n\t * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method drawAsPath\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t **/\n\tp.drawAsPath = function(ctx) {\n\t\tthis._updateInstructions();\n\t\tvar instr, instrs = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instrs.length; i<l; i++) {\n\t\t\t// the first command is always a beginPath command.\n\t\t\tif ((instr = instrs[i]).path !== false) { instr.exec(ctx); }\n\t\t}\n\t};\n\n\n// public methods that map directly to context 2D calls:\n\t/**\n\t * Moves the drawing point to the specified position. A tiny API method "mt" also exists.\n\t * @method moveTo\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t **/\n\tp.moveTo = function(x, y) {\n\t\treturn this.append(new G.MoveTo(x,y), true);\n\t};\n\n\t/**\n\t * Draws a line from the current drawing point to the specified position, which become the new current drawing\n\t * point. Note that you *must* call {{#crossLink "Graphics/moveTo"}}{{/crossLink}} before the first `lineTo()`.\n\t * A tiny API method "lt" also exists.\n\t *\n\t * For detailed information, read the\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">\n\t * whatwg spec</a>.\n\t * @method lineTo\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.lineTo = function(x, y) {\n\t\treturn this.append(new G.LineTo(x,y));\n\t};\n\n\t/**\n\t * Draws an arc with the specified control points and radius.  For detailed information, read the\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">\n\t * whatwg spec</a>. A tiny API method "at" also exists.\n\t * @method arcTo\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arcTo = function(x1, y1, x2, y2, radius) {\n\t\treturn this.append(new G.ArcTo(x1, y1, x2, y2, radius));\n\t};\n\n\t/**\n\t * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For\n\t * example, to draw a full circle with a radius of 20 centered at (100, 100):\n\t *\n\t *      arc(100, 100, 20, 0, Math.PI*2);\n\t *\n\t * For detailed information, read the\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.\n\t * A tiny API method "a" also exists.\n\t * @method arc\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\treturn this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));\n\t};\n\n\t/**\n\t * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n\t * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">\n\t * whatwg spec</a>. A tiny API method "qt" also exists.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.quadraticCurveTo = function(cpx, cpy, x, y) {\n\t\treturn this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));\n\t};\n\n\t/**\n\t * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,\n\t * cp2y). For detailed information, read the\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">\n\t * whatwg spec</a>. A tiny API method "bt" also exists.\n\t * @method bezierCurveTo\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\treturn this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n\t};\n\n\t/**\n\t * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t * For detailed information, read the\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">\n\t * whatwg spec</a>. A tiny API method "r" also exists.\n\t * @method rect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.rect = function(x, y, w, h) {\n\t\treturn this.append(new G.Rect(x, y, w, h));\n\t};\n\n\t/**\n\t * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t * since the fill or stroke was last set. A tiny API method "cp" also exists.\n\t * @method closePath\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.closePath = function() {\n\t\treturn this._activeInstructions.length ? this.append(new G.ClosePath()) : this;\n\t};\n\n\n// public methods that roughly map to Flash graphics APIs:\n\t/**\n\t * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need\n\t * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.\n\t * @method clear\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.clear = function() {\n\t\tthis._instructions.length = this._activeInstructions.length = this._commitIndex = 0;\n\t\tthis._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;\n\t\tthis._dirty = this._strokeIgnoreScale = false;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.\n\t * @method beginFill\n\t * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginFill = function(color) {\n\t\treturn this._setFill(color ? new G.Fill(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method "lf" also exists.\n\t * @method beginLinearGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:\n\t *\n\t *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t *\n\t * A tiny API method "rf" also exists.\n\t * @method beginRadialGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also\n\t * exists.\n\t * @method beginBitmapFill\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",\n\t * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or\n\t * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapFill = function(image, repetition, matrix) {\n\t\treturn this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.\n\t * A tiny API method "ef" also exists.\n\t * @method endFill\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endFill = function() {\n\t\treturn this.beginFill();\n\t};\n\n\t/**\n\t * Sets the stroke style. Like all drawing methods, this can be chained, so you can define\n\t * the stroke style and color in a single line of code like so:\n\t *\n\t * \tmyGraphics.setStrokeStyle(8,"round").beginStroke("#F00");\n\t *\n\t * A tiny API method "ss" also exists.\n\t * @method setStrokeStyle\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);\n\n\t\t// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:\n\t\tif (this._stroke) { this._stroke.ignoreScale = ignoreScale; }\n\t\tthis._strokeIgnoreScale = ignoreScale;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Sets or clears the stroke dash pattern.\n\t *\n\t * \tmyGraphics.setStrokeDash([20, 10], 0);\n\t *\n\t * A tiny API method `sd` also exists.\n\t * @method setStrokeDash\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear the existing stroke dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeDash = function(segments, offset) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeDash = this.command = new G.StrokeDash(segments, offset);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.\n\t * @method beginStroke\n\t * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginStroke = function(color) {\n\t\treturn this._setStroke(color ? new G.Stroke(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10).\n\t *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method "ls" also exists.\n\t * @method beginLinearGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10)\n\t *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)\n\t *          .drawRect(50, 90, 150, 110);\n\t *\n\t * A tiny API method "rs" also exists.\n\t * @method beginRadialGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,\n\t * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"\n\t * also exists.\n\t * @method beginBitmapStroke\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapStroke = function(image, repetition) {\n\t\t// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.\n\t\treturn this._setStroke(new G.Stroke().bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.\n\t * A tiny API method "es" also exists.\n\t * @method endStroke\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endStroke = function() {\n\t\treturn this.beginStroke();\n\t};\n\n\t/**\n\t * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}\n\t * method.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.curveTo = p.quadraticCurveTo;\n\n\t/**\n\t *\n\t * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}\n\t * method.\n\t * @method drawRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRect = p.rect;\n\n\t/**\n\t * Draws a rounded rectangle with all corners with the specified radius.\n\t * @method drawRoundRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRect = function(x, y, w, h, radius) {\n\t\treturn this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t};\n\n\t/**\n\t * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API\n\t * method "rc" also exists.\n\t * @method drawRoundRectComplex\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\treturn this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));\n\t};\n\n\t/**\n\t * Draws a circle with the specified radius at (x, y).\n\t *\n\t *      var g = new createjs.Graphics();\n\t *\t    g.setStrokeStyle(1);\n\t *\t    g.beginStroke(createjs.Graphics.getRGB(0,0,0));\n\t *\t    g.beginFill(createjs.Graphics.getRGB(255,0,0));\n\t *\t    g.drawCircle(0,0,3);\n\t *\n\t *\t    var s = new createjs.Shape(g);\n\t *\t\ts.x = 100;\n\t *\t\ts.y = 100;\n\t *\n\t *\t    stage.addChild(s);\n\t *\t    stage.update();\n\t *\n\t * A tiny API method "dc" also exists.\n\t * @method drawCircle\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawCircle = function(x, y, radius) {\n\t\treturn this.append(new G.Circle(x, y, radius));\n\t};\n\n\t/**\n\t * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},\n\t * except the width and height can be different. A tiny API method "de" also exists.\n\t * @method drawEllipse\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawEllipse = function(x, y, w, h) {\n\t\treturn this.append(new G.Ellipse(x, y, w, h));\n\t};\n\n\t/**\n\t * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of\n\t * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a\n\t * radius of 50:\n\t *\n\t *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);\n\t *      // Note: -90 makes the first point vertical\n\t *\n\t * A tiny API method "dp" also exists.\n\t *\n\t * @method drawPolyStar\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\treturn this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));\n\t};\n\n\t// TODO: deprecated.\n\t/**\n\t * Removed in favour of using custom command objects with {{#crossLink "Graphics/append"}}{{/crossLink}}.\n\t * @method inject\n\t * @deprecated\n\t **/\n\n\t/**\n\t * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method\n\t * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into\n\t * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.\n\t *\n\t * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert\n\t * built-in or custom graphics commands. For example:\n\t *\n\t * \t\t// attach data to our shape, so we can access it during the draw:\n\t * \t\tmyShape.color = "red";\n\t *\n\t * \t\t// append a Circle command object:\n\t * \t\tmyShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));\n\t *\n\t * \t\t// append a custom command object with an exec method that sets the fill style\n\t * \t\t// based on the shape\'s data, and then fills the circle.\n\t * \t\tmyShape.graphics.append({exec:function(ctx, shape) {\n\t * \t\t\tctx.fillStyle = shape.color;\n\t * \t\t\tctx.fill();\n\t * \t\t}});\n\t *\n\t * @method append\n\t * @param {Object} command A graphics command object exposing an "exec" method.\n\t * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.append = function(command, clean) {\n\t\tthis._activeInstructions.push(command);\n\t\tthis.command = command;\n\t\tif (!clean) { this._dirty = true; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Decodes a compact encoded path string into a series of draw instructions.\n\t * This format is not intended to be human readable, and is meant for use by authoring tools.\n\t * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw\n\t * commands.\n\t *\n\t * Each command is comprised of a single "header" character followed by a variable number of alternating x and y\n\t * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the\n\t * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4\n\t * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the\n\t * latter. Bits 5 and 6 are currently unused.\n\t *\n\t * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)\n\t * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the\n\t * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed\n\t * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the\n\t * case of move operations which are absolute, this value is a delta from the previous x or y position (as\n\t * appropriate).\n\t *\n\t * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.\n\t * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per\n\t * parameter.\n\t * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits\n\t * indicate 1500 tenths of a pixel.\n\t * <br />AA - 000000000000. Absolute y position of 0.\n\t * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.\n\t * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to\n\t * provide an absolute position of +150.0px.\n\t * <br />AAA - 000000000000000000. A y delta value of 0.\n\t *\n\t * A tiny API method "p" also exists.\n\t * @method decodePath\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.decodePath = function(str) {\n\t\tvar instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];\n\t\tvar paramCount = [2, 2, 4, 6, 0];\n\t\tvar i=0, l=str.length;\n\t\tvar params = [];\n\t\tvar x=0, y=0;\n\t\tvar base64 = Graphics.BASE_64;\n\n\t\twhile (i<l) {\n\t\t\tvar c = str.charAt(i);\n\t\t\tvar n = base64[c];\n\t\t\tvar fi = n>>3; // highest order bits 1-3 code for operation.\n\t\t\tvar f = instructions[fi];\n\t\t\t// check that we have a valid instruction & that the unused bits are empty:\n\t\t\tif (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }\n\t\t\tvar pl = paramCount[fi];\n\t\t\tif (!fi) { x=y=0; } // move operations reset the position.\n\t\t\tparams.length = 0;\n\t\t\ti++;\n\t\t\tvar charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.\n\t\t\tfor (var p=0; p<pl; p++) {\n\t\t\t\tvar num = base64[str.charAt(i)];\n\t\t\t\tvar sign = (num>>5) ? -1 : 1;\n\t\t\t\tnum = ((num&31)<<6)|(base64[str.charAt(i+1)]);\n\t\t\t\tif (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }\n\t\t\t\tnum = sign*num/10;\n\t\t\t\tif (p%2) { x = (num += x); }\n\t\t\t\telse { y = (num += y); }\n\t\t\t\tparams[p] = num;\n\t\t\t\ti += charCount;\n\t\t\t}\n\t\t\tf.apply(this,params);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stores all graphics commands so they won\'t be executed in future draws. Calling store() a second time adds to\n\t * the existing store. This also affects `drawAsPath()`.\n\t *\n\t * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so\n\t * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all\n\t * of the vector instructions for later use (ex. scaling, modifying, or exporting).\n\t *\n\t * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing\n\t * the fill or stroke.\n\t *\n\t * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of\n\t * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},\n\t * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.\n\t *\n\t * \t// set up cache:\n\t * \tmyShape.cache(0,0,500,500,scale);\n\t *\n\t * \t// when the user drags, draw a new line:\n\t * \tmyShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);\n\t * \t// then draw it into the existing cache:\n\t * \tmyShape.updateCache("source-over");\n\t * \t// store the new line, so it isn\'t redrawn next time:\n\t * \tmyShape.store();\n\t *\n\t * \t// then, when the window resizes, we can re-render at a different scale:\n\t * \t// first, unstore all our lines:\n\t * \tmyShape.unstore();\n\t * \t// then cache using the new scale:\n\t * \tmyShape.cache(0,0,500,500,newScale);\n\t * \t// finally, store the existing commands again:\n\t * \tmyShape.store();\n\t *\n\t * @method store\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.store = function() {\n\t\tthis._updateInstructions(true);\n\t\tthis._storeIndex = this._instructions.length;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}\n\t * so that they will be executed in subsequent draw calls.\n\t *\n\t * @method unstore\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.unstore = function() {\n\t\tthis._storeIndex = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.\n\t * @method clone\n\t * @return {Graphics} A clone of the current Graphics instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Graphics();\n\t\to.command = this.command;\n\t\to._stroke = this._stroke;\n\t\to._strokeStyle = this._strokeStyle;\n\t\to._strokeDash = this._strokeDash;\n\t\to._strokeIgnoreScale = this._strokeIgnoreScale;\n\t\to._fill = this._fill;\n\t\to._instructions = this._instructions.slice();\n\t\to._commitIndex = this._commitIndex;\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._dirty = this._dirty;\n\t\to._storeIndex = this._storeIndex;\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Graphics]";\n\t};\n\n\n// tiny API:\n\t/**\n\t * Shortcut to moveTo.\n\t * @method mt\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t * @protected\n\t **/\n\tp.mt = p.moveTo;\n\n\t/**\n\t * Shortcut to lineTo.\n\t * @method lt\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lt = p.lineTo;\n\n\t/**\n\t * Shortcut to arcTo.\n\t * @method at\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.at = p.arcTo;\n\n\t/**\n\t * Shortcut to bezierCurveTo.\n\t * @method bt\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bt = p.bezierCurveTo;\n\n\t/**\n\t * Shortcut to quadraticCurveTo / curveTo.\n\t * @method qt\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t * @chainable\n\t **/\n\tp.qt = p.quadraticCurveTo;\n\n\t/**\n\t * Shortcut to arc.\n\t * @method a\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @protected\n\t * @chainable\n\t **/\n\tp.a = p.arc;\n\n\t/**\n\t * Shortcut to rect.\n\t * @method r\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.r = p.rect;\n\n\t/**\n\t * Shortcut to closePath.\n\t * @method cp\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.cp = p.closePath;\n\n\t/**\n\t * Shortcut to clear.\n\t * @method c\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.c = p.clear;\n\n\t/**\n\t * Shortcut to beginFill.\n\t * @method f\n\t * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.f = p.beginFill;\n\n\t/**\n\t * Shortcut to beginLinearGradientFill.\n\t * @method lf\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lf = p.beginLinearGradientFill;\n\n\t/**\n\t * Shortcut to beginRadialGradientFill.\n\t * @method rf\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rf = p.beginRadialGradientFill;\n\n\t/**\n\t * Shortcut to beginBitmapFill.\n\t * @method bf\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",\n\t * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or\n\t * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bf = p.beginBitmapFill;\n\n\t/**\n\t * Shortcut to endFill.\n\t * @method ef\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ef = p.endFill;\n\n\t/**\n\t * Shortcut to setStrokeStyle.\n\t * @method ss\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ss = p.setStrokeStyle;\n\t\n\t/**\n\t * Shortcut to setStrokeDash.\n\t * @method sd\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear any existing dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.sd = p.setStrokeDash;\n\n\t/**\n\t * Shortcut to beginStroke.\n\t * @method s\n\t * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.s = p.beginStroke;\n\n\t/**\n\t * Shortcut to beginLinearGradientStroke.\n\t * @method ls\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ls = p.beginLinearGradientStroke;\n\n\t/**\n\t * Shortcut to beginRadialGradientStroke.\n\t * @method rs\n\t * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rs = p.beginRadialGradientStroke;\n\n\t/**\n\t * Shortcut to beginBitmapStroke.\n\t * @method bs\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bs = p.beginBitmapStroke;\n\n\t/**\n\t * Shortcut to endStroke.\n\t * @method es\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.es = p.endStroke;\n\n\t/**\n\t * Shortcut to drawRect.\n\t * @method dr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dr = p.drawRect;\n\n\t/**\n\t * Shortcut to drawRoundRect.\n\t * @method rr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rr = p.drawRoundRect;\n\n\t/**\n\t * Shortcut to drawRoundRectComplex.\n\t * @method rc\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rc = p.drawRoundRectComplex;\n\n\t/**\n\t * Shortcut to drawCircle.\n\t * @method dc\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dc = p.drawCircle;\n\n\t/**\n\t * Shortcut to drawEllipse.\n\t * @method de\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.de = p.drawEllipse;\n\n\t/**\n\t * Shortcut to drawPolyStar.\n\t * @method dp\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dp = p.drawPolyStar;\n\n\t/**\n\t * Shortcut to decodePath.\n\t * @method p\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.p = p.decodePath;\n\n\n// private methods:\n\t/**\n\t * @method _updateInstructions\n\t * @param commit\n\t * @protected\n\t **/\n\tp._updateInstructions = function(commit) {\n\t\tvar instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;\n\n\t\tif (this._dirty && active.length) {\n\t\t\tinstr.length = commitIndex; // remove old, uncommitted commands\n\t\t\tinstr.push(Graphics.beginCmd);\n\n\t\t\tvar l = active.length, ll = instr.length;\n\t\t\tinstr.length = ll+l;\n\t\t\tfor (var i=0; i<l; i++) { instr[i+ll] = active[i]; }\n\n\t\t\tif (this._fill) { instr.push(this._fill); }\n\t\t\tif (this._stroke) {\n\t\t\t\t// doesn\'t need to be re-applied if it hasn\'t changed.\n\t\t\t\tif (this._strokeDash !== this._oldStrokeDash) {\n\t\t\t\t\tthis._oldStrokeDash = this._strokeDash;\n\t\t\t\t\tinstr.push(this._strokeDash);\n\t\t\t\t}\n\t\t\t\tif (this._strokeStyle !== this._oldStrokeStyle) {\n\t\t\t\t\tthis._oldStrokeStyle = this._strokeStyle;\n\t\t\t\t\tinstr.push(this._strokeStyle);\n\t\t\t\t}\n\t\t\t\tinstr.push(this._stroke);\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tactive.length = 0;\n\t\t\tthis._commitIndex = instr.length;\n\t\t}\n\t};\n\n\t/**\n\t * @method _setFill\n\t * @param fill\n\t * @protected\n\t **/\n\tp._setFill = function(fill) {\n\t\tthis._updateInstructions(true);\n\t\tthis.command = this._fill = fill;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _setStroke\n\t * @param stroke\n\t * @protected\n\t **/\n\tp._setStroke = function(stroke) {\n\t\tthis._updateInstructions(true);\n\t\tif (this.command = this._stroke = stroke) {\n\t\t\tstroke.ignoreScale = this._strokeIgnoreScale;\n\t\t}\n\t\treturn this;\n\t};\n\n// Command Objects:\n\t/**\n\t * @namespace Graphics\n\t */\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class LineTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.LineTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class MoveTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t(G.MoveTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };\n\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class ArcTo\n\t * @constructor\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x1\n\t * @type Number\n\t */\n\t/**\n\t * @property y1\n\t * @type Number\n\t */\n\t/**\n\t * @property x2\n\t * @type Number\n\t */\n\t/**\n\t * @property y2\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ArcTo = function(x1, y1, x2, y2, radius) {\n\t\tthis.x1 = x1; this.y1 = y1;\n\t\tthis.x2 = x2; this.y2 = y2;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Arc\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle\n\t * @param {Number} endAngle\n\t * @param {Number} anticlockwise\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property startAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property endAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property anticlockwise\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.startAngle = startAngle; this.endAngle = endAngle;\n\t\tthis.anticlockwise = !!anticlockwise;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class QuadraticCurveTo\n\t * @constructor\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cpx\n\t * @type Number\n\t */\n\t/**\n\t * @property cpy\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.QuadraticCurveTo = function(cpx, cpy, x, y) {\n\t\tthis.cpx = cpx; this.cpy = cpy;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class BezierCurveTo\n\t * @constructor\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cp1x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp1y\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2y\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\tthis.cp1x = cp1x; this.cp1y = cp1y;\n\t\tthis.cp2x = cp2x; this.cp2y = cp2y;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Rect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Rect = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class ClosePath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ClosePath = function() {\n\t}).prototype.exec = function(ctx) { ctx.closePath(); };\n\n\t/**\n\t * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class BeginPath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BeginPath = function() {\n\t}).prototype.exec = function(ctx) { ctx.beginPath(); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Fill\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Matrix2D} matrix\n\t **/\n\t/**\n\t * A valid Context2D fillStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property matrix\n\t * @type Matrix2D\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Fill = function(style, matrix) {\n\t\tthis.style = style;\n\t\tthis.matrix = matrix;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.fillStyle = this.style;\n\t\tvar mtx = this.matrix;\n\t\tif (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }\n\t\tctx.fill();\n\t\tif (mtx) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t *\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.linearGradient = function(colors, ratios, x0, y0, x1, y1) {\n\t\tvar o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tvar o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.bitmap = function(image, repetition) {\n\t\tif (image.naturalWidth || image.getContext || image.readyState >= 2) {\n\t\t\tvar o = this.style = Graphics._ctx.createPattern(image, repetition || "");\n\t\t\to.props = {image: image, repetition: repetition, type: "bitmap"};\n\t\t}\n\t\treturn this;\n\t};\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Stroke\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Boolean} ignoreScale\n\t **/\n\t/**\n\t * A valid Context2D strokeStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property ignoreScale\n\t * @type Boolean\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Stroke = function(style, ignoreScale) {\n\t\tthis.style = style;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.strokeStyle = this.style;\n\t\tif (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }\n\t\tctx.stroke();\n\t\tif (this.ignoreScale) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.linearGradient = G.Fill.prototype.linearGradient;\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.radialGradient = G.Fill.prototype.radialGradient;\n\t/**\n\t * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.\n\t * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement} image\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.bitmap = G.Fill.prototype.bitmap;\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class StrokeStyle\n\t * @constructor\n\t * @param {Number} width\n\t * @param {String} [caps=butt]\n\t * @param {String} [joints=miter]\n\t * @param {Number} [miterLimit=10]\n\t * @param {Boolean} [ignoreScale=false]\n\t **/\n\t/**\n\t * @property width\n\t * @type Number\n\t */\n\t/**\n\t * One of: butt, round, square\n\t * @property caps\n\t * @type String\n\t */\n\t/**\n\t * One of: round, bevel, miter\n\t * @property joints\n\t * @type String\n\t */\n\t/**\n\t * @property miterLimit\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {\n\t\tthis.width = width;\n\t\tthis.caps = caps;\n\t\tthis.joints = joints;\n\t\tthis.miterLimit = miterLimit;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tctx.lineWidth = (this.width == null ? "1" : this.width);\n\t\tctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));\n\t\tctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));\n\t\tctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);\n\t\tctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);\n\t};\n\tp.path = false;\n\t\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class StrokeDash\n\t * @constructor\n\t * @param {Array} [segments]\n\t * @param {Number} [offset=0]\n\t **/\n\t/**\n\t * @property segments\n\t * @type Array\n\t */\n\t/**\n\t * @property offset\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.StrokeDash = function(segments, offset) {\n\t\tthis.segments = segments;\n\t\tthis.offset = offset||0;\n\t}).prototype.exec = function(ctx) {\n\t\tif (ctx.setLineDash) { // feature detection.\n\t\t\tctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.\n\t\t\tctx.lineDashOffset = this.offset||0;\n\t\t}\n\t};\n\t/**\n\t * The default value for segments (ie. no dash).\n\t * @property EMPTY_SEGMENTS\n\t * @static\n\t * @final\n\t * @readonly\n\t * @protected\n\t * @type {Array}\n\t **/\n\tG.StrokeDash.EMPTY_SEGMENTS = [];\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class RoundRect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radiusTL\n\t * @param {Number} radiusTR\n\t * @param {Number} radiusBR\n\t * @param {Number} radiusBL\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTL\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBL\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t\tthis.radiusTL = radiusTL; this.radiusTR = radiusTR;\n\t\tthis.radiusBR = radiusBR; this.radiusBL = radiusBL;\n\t}).prototype.exec = function(ctx) {\n\t\tvar max = (w<h?w:h)/2;\n\t\tvar mTL=0, mTR=0, mBR=0, mBL=0;\n\t\tvar x = this.x, y = this.y, w = this.w, h = this.h;\n\t\tvar rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;\n\n\t\tif (rTL < 0) { rTL *= (mTL=-1); }\n\t\tif (rTL > max) { rTL = max; }\n\t\tif (rTR < 0) { rTR *= (mTR=-1); }\n\t\tif (rTR > max) { rTR = max; }\n\t\tif (rBR < 0) { rBR *= (mBR=-1); }\n\t\tif (rBR > max) { rBR = max; }\n\t\tif (rBL < 0) { rBL *= (mBL=-1); }\n\t\tif (rBL > max) { rBL = max; }\n\n\t\tctx.moveTo(x+w-rTR, y);\n\t\tctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);\n\t\tctx.lineTo(x+w, y+h-rBR);\n\t\tctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);\n\t\tctx.lineTo(x+rBL, y+h);\n\t\tctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);\n\t\tctx.lineTo(x, y+rTL);\n\t\tctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);\n\t\tctx.closePath();\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Circle\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Circle = function(x, y, radius) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class Ellipse\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Ellipse = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar w = this.w, h = this.h;\n\n\t\tvar k = 0.5522848;\n\t\tvar ox = (w / 2) * k;\n\t\tvar oy = (h / 2) * k;\n\t\tvar xe = x + w;\n\t\tvar ye = y + h;\n\t\tvar xm = x + w / 2;\n\t\tvar ym = y + h / 2;\n\n\t\tctx.moveTo(x, ym);\n\t\tctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);\n\t\tctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);\n\t\tctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);\n\t\tctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.\n\t * @class PolyStar\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} sides\n\t * @param {Number} pointSize\n\t * @param {Number} angle\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property sides\n\t * @type Number\n\t */\n\t/**\n\t * @property pointSize\n\t * @type Number\n\t */\n\t/**\n\t * @property angle\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.sides = sides;\n\t\tthis.pointSize = pointSize;\n\t\tthis.angle = angle;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar radius = this.radius;\n\t\tvar angle = (this.angle||0)/180*Math.PI;\n\t\tvar sides = this.sides;\n\t\tvar ps = 1-(this.pointSize||0);\n\t\tvar a = Math.PI/sides;\n\n\t\tctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\tfor (var i=0; i<sides; i++) {\n\t\t\tangle += a;\n\t\t\tif (ps != 1) {\n\t\t\t\tctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);\n\t\t\t}\n\t\t\tangle += a;\n\t\t\tctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\t}\n\t\tctx.closePath();\n\t};\n\n\t// docced above.\n\tGraphics.beginCmd = new G.BeginPath(); // so we don\'t have to instantiate multiple instances.\n\n\n\tcreatejs.Graphics = Graphics;\n}());\n\n//##############################################################################\n// DisplayObject.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as\n\t * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.\n\t * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and\n\t * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),\n\t * caching, and mouse handlers.\n\t * @class DisplayObject\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction DisplayObject() {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t\t * @property alpha\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.alpha = 1;\n\t\n\t\t/**\n\t\t * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink "cache"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property cacheCanvas\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.cacheCanvas = null;\n\t\n\t\t/**\n\t\t * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to\n\t\t * determine if the cache has changed since a previous check.\n\t\t * @property cacheID\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cacheID = 0;\n\t\n\t\t/**\n\t\t * Unique ID for this display object. Makes display objects easier for some uses.\n\t\t * @property id\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t **/\n\t\tthis.id = createjs.UID.get();\n\t\n\t\t/**\n\t\t * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children\n\t\t * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is\n\t\t * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}\n\t\t * method from returning the child.\n\t\t *\n\t\t * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please\n\t\t * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be\n\t\t * provided in the next release of EaselJS.\n\t\t * @property mouseEnabled\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseEnabled = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.\n\t\t * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickEnabled = true;\n\t\n\t\t/**\n\t\t * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for\n\t\t * debugging.\n\t\t * @property name\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.name = null;\n\t\n\t\t/**\n\t\t * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that\n\t\t * contains this display object, or null if it has not been added\n\t\t * to one.\n\t\t * @property parent\n\t\t * @final\n\t\t * @type {Container}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.parent = null;\n\t\n\t\t/**\n\t\t * The left offset for this display object\'s registration point. For example, to make a 100x100px Bitmap rotate\n\t\t * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.\n\t\t * @property regX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regX = 0;\n\t\n\t\t/**\n\t\t * The y offset for this display object\'s registration point. For example, to make a 100x100px Bitmap rotate around\n\t\t * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.\n\t\t * @property regY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regY = 0;\n\t\n\t\t/**\n\t\t * The rotation in degrees for this display object.\n\t\t * @property rotation\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.rotation = 0;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t\t * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.\n\t\t * @property scaleX\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleX = 1;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t\t * object to half its nominal height. To vertically flip an object, set the scale to a negative number.\n\t\t * @property scaleY\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleY = 1;\n\t\n\t\t/**\n\t\t * The factor to skew this display object horizontally.\n\t\t * @property skewX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewX = 0;\n\t\n\t\t/**\n\t\t * The factor to skew this display object vertically.\n\t\t * @property skewY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewY = 0;\n\t\n\t\t/**\n\t\t * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If\n\t\t * null, this property is inherited from the parent container.\n\t\t * @property shadow\n\t\t * @type {Shadow}\n\t\t * @default null\n\t\t **/\n\t\tthis.shadow = null;\n\t\n\t\t/**\n\t\t * Indicates whether this display object should be rendered to the canvas and included when running the Stage\n\t\t * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.\n\t\t * @property visible\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.visible = true;\n\t\n\t\t/**\n\t\t * The x (horizontal) position of the display object, relative to its parent.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.x = 0;\n\t\n\t\t/** The y (vertical) position of the display object, relative to its parent.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.y = 0;\n\t\t\n\t\t/**\n\t\t * If set, defines the transformation for this display object, overriding all other transformation properties\n\t\t * (x, y, rotation, scale, skew).\n\t\t * @property transformMatrix\n\t\t * @type {Matrix2D}\n\t\t * @default null\n\t\t **/\n\t\tthis.transformMatrix = null;\n\t\t\n\t\t/**\n\t\t * The composite operation indicates how the pixels of this display object will be composited with the elements\n\t\t * behind it. If `null`, this property is inherited from the parent container. For more information, read the\n\t\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">\n\t\t * whatwg spec on compositing</a>.\n\t\t * @property compositeOperation\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.compositeOperation = null;\n\t\n\t\t/**\n\t\t * Indicates whether the display object should be drawn to a whole pixel when\n\t\t * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole\n\t\t * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).\n\t\t * @property snapToPixel\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.snapToPixel = true;\n\t\n\t\t/**\n\t\t * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}\n\t\t * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is\n\t\t * cached.\n\t\t * @property filters\n\t\t * @type {Array}\n\t\t * @default null\n\t\t **/\n\t\tthis.filters = null;\n\t\t\n\t\t/**\n\t\t * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape\'s transformation\n\t\t * will be applied relative to the display object\'s parent coordinates (as if it were a child of the parent).\n\t\t * @property mask\n\t\t * @type {Shape}\n\t\t * @default null\n\t\t */\n\t\tthis.mask = null;\n\t\t\n\t\t/**\n\t\t * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.\n\t\t * The hit area will have its transformation applied relative to this display object\'s coordinate space (as though\n\t\t * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested\n\t\t * using only its own `alpha` value regardless of the alpha value on the target display object, or the target\'s\n\t\t * ancestors (parents).\n\t\t * \n\t\t * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.\n\t\t * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.\n\t\t *\n\t\t * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\tthis.hitArea = null;\n\t\t\n\t\t/**\n\t\t * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display\n\t\t * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to\n\t\t * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.\n\t\t * @property cursor\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.cursor = null;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _cacheOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetX = 0;\n\t\n\t\t/**\n\t\t * @property _cacheOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetX = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _cacheScale\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis._cacheScale = 1;\n\t\n\t\t/**\n\t\t* @property _cacheDataURLID\n\t\t* @protected\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t*/\n\t\tthis._cacheDataURLID = 0;\n\t\t\n\t\t/**\n\t\t* @property _cacheDataURL\n\t\t* @protected\n\t\t* @type {String}\n\t\t* @default null\n\t\t*/\n\t\tthis._cacheDataURL = null;\n\t\n\t\t/**\n\t\t * @property _props\n\t\t * @protected\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t **/\n\t\tthis._props = new createjs.DisplayProps();\n\t\n\t\t/**\n\t\t * @property _rectangle\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._rectangle = new createjs.Rectangle();\n\t\n\t\t/**\n\t\t * @property _bounds\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._bounds = null;\n\t}\n\tvar p = createjs.extend(DisplayObject, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n// static properties:\n\t/**\n\t * Listing of mouse event names. Used in _hasMouseEventListener.\n\t * @property _MOUSE_EVENTS\n\t * @protected\n\t * @static\n\t * @type {Array}\n\t **/\n\tDisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];\n\n\t/**\n\t * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}\n\t * with cross domain content.\n\t * @property suppressCrossDomainErrors\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject.suppressCrossDomainErrors = false;\n\t\n\t/**\n\t * @property _snapToPixelEnabled\n\t * @protected\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.\n\n\t/**\n\t * @property _hitTestCanvas\n\t * @type {HTMLCanvasElement | Object}\n\t * @static\n\t * @protected\n\t **/\n\t/**\n\t * @property _hitTestContext\n\t * @type {CanvasRenderingContext2D}\n\t * @static\n\t * @protected\n\t **/\n\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.\n\tif (canvas.getContext) {\n\t\tDisplayObject._hitTestCanvas = canvas;\n\t\tDisplayObject._hitTestContext = canvas.getContext("2d");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\t/**\n\t * @property _nextCacheID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t **/\n\tDisplayObject._nextCacheID = 1;\n\n\n// events:\n\t/**\n\t * Dispatched when the user presses their left mouse button over the display object. See the \n\t * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mousedown\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user presses their left mouse button and then releases it while over the display object.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event click\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user double clicks their left mouse button over this display object.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event dblclick\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user\'s mouse enters this display object. This event must be enabled using \n\t * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseover\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user\'s mouse leaves this display object. This event must be enabled using \n\t * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseout\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on\n\t * myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse enters shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse enters shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollover\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}\n\t * on myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse leaves shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse leaves shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollout\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove\n\t * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be\n\t * useful for dragging and similar operations.\n\t * @event pressmove\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event\n\t * will be generated on that object when that mouse press is released. This can be useful for dragging and similar\n\t * operations.\n\t * @event pressup\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is added to a parent container.\n\t * @event added\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is removed from its parent container.\n\t * @event removed\n\t */\n\t \n\t/**\n\t * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the\n\t * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on\n\t * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their\n\t * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being\n\t * dispatched on their parent.\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For\n\t *      example if you called stage.update("hello"), then the params would be ["hello"].\n\t * @since 0.6.0\n\t */\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.\n\t * @method getStage\n\t * @return {Stage}\n\t * @deprecated\n\t **/\n\tp.getStage = function() {\n\t\t// uses dynamic access to avoid circular dependencies;\n\t\tvar o = this, _Stage = createjs["Stage"];\n\t\twhile (o.parent) { o = o.parent; }\n\t\tif (o instanceof _Stage) { return o; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.\n\t * @property stage\n\t * @type {Stage}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tstage: { get: p.getStage }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns <code>true</code> if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (ignoreCache || !cacheCanvas) { return false; }\n\t\tvar scale = this._cacheScale;\n\t\tctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Applies this display object\'s transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow\n\t * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.\n\t * @method updateContext\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.\n\t **/\n\tp.updateContext = function(ctx) {\n\t\tvar o=this, mask=o.mask, mtx= o._props.matrix;\n\t\t\n\t\tif (mask && mask.graphics && !mask.graphics.isEmpty()) {\n\t\t\tmask.getMatrix(mtx);\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t\t\n\t\t\tmask.graphics.drawAsPath(ctx);\n\t\t\tctx.clip();\n\t\t\t\n\t\t\tmtx.invert();\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t}\n\t\t\n\t\tthis.getMatrix(mtx);\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\tif (DisplayObject._snapToPixelEnabled && o.snapToPixel) {\n\t\t\ttx = tx + (tx < 0 ? -0.5 : 0.5) | 0;\n\t\t\tty = ty + (ty < 0 ? -0.5 : 0.5) | 0;\n\t\t}\n\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);\n\t\tctx.globalAlpha *= o.alpha;\n\t\tif (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }\n\t\tif (o.shadow) { this._applyShadow(ctx, o.shadow); }\n\t};\n\n\t/**\n\t * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content\n\t * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),\n\t * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The\n\t * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must\n\t * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify\n\t * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached\n\t * using this display object\'s coordinates.\n\t *\n\t * <h4>Example</h4>\n\t * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:\n\t *\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);\n\t *      myShape.cache(-25, -25, 50, 50);\n\t *\n\t * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink "Filter"}}{{/crossLink}}\n\t * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.\n\t * \n\t * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)\n\t * will add padding to the canvas dimensions.\n\t *\n\t * @method cache\n\t * @param {Number} x The x coordinate origin for the cache region.\n\t * @param {Number} y The y coordinate origin for the cache region.\n\t * @param {Number} width The width of the cache region.\n\t * @param {Number} height The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n\t * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n\t * \tcached elements with greater fidelity. Default is 1.\n\t **/\n\tp.cache = function(x, y, width, height, scale) {\n\t\t// draw to canvas.\n\t\tscale = scale||1;\n\t\tif (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }\n\t\tthis._cacheWidth = width;\n\t\tthis._cacheHeight = height;\n\t\tthis._cacheOffsetX = x;\n\t\tthis._cacheOffsetY = y;\n\t\tthis._cacheScale = scale;\n\t\tthis.updateCache();\n\t};\n\n\t/**\n\t * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t * will be drawn over the existing cache using the specified compositeOperation.\n\t *\n\t * <h4>Example</h4>\n\t * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line\n\t * will be drawn on top of the old one.\n\t *\n\t *      // Not shown: Creating the shape, and caching it.\n\t *      shapeInstance.clear();\n\t *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);\n\t *      shapeInstance.updateCache();\n\t *\n\t * @method updateCache\n\t * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.\n\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">\n\t * whatwg spec on compositing</a>.\n\t **/\n\tp.updateCache = function(compositeOperation) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (!cacheCanvas) { throw "cache() must be called before updateCache()"; }\n\t\tvar scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;\n\t\tvar w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext("2d");\n\t\t\n\t\tvar fBounds = this._getFilterBounds();\n\t\toffX += (this._filterOffsetX = fBounds.x);\n\t\toffY += (this._filterOffsetY = fBounds.y);\n\t\t\n\t\tw = Math.ceil(w*scale) + fBounds.width;\n\t\th = Math.ceil(h*scale) + fBounds.height;\n\t\tif (w != cacheCanvas.width || h != cacheCanvas.height) {\n\t\t\t// TODO: it would be nice to preserve the content if there is a compositeOperation.\n\t\t\tcacheCanvas.width = w;\n\t\t\tcacheCanvas.height = h;\n\t\t} else if (!compositeOperation) {\n\t\t\tctx.clearRect(0, 0, w+1, h+1);\n\t\t}\n\t\t\n\t\tctx.save();\n\t\tctx.globalCompositeOperation = compositeOperation;\n\t\tctx.setTransform(scale, 0, 0, scale, -offX, -offY);\n\t\tthis.draw(ctx, true);\n\t\t// TODO: filters and cache scale don\'t play well together at present.\n\t\tthis._applyFilters();\n\t\tctx.restore();\n\t\tthis.cacheID = DisplayObject._nextCacheID++;\n\t};\n\n\t/**\n\t * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.\n\t * @method uncache\n\t **/\n\tp.uncache = function() {\n\t\tthis._cacheDataURL = this.cacheCanvas = null;\n\t\tthis.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;\n\t\tthis._cacheScale = 1;\n\t};\n\t\n\t/**\n\t * Returns a data URL for the cache, or null if this display object is not cached.\n\t * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.\n\t * @method getCacheDataURL\n\t * @return {String} The image data url for the cache.\n\t **/\n\tp.getCacheDataURL = function() {\n\t\tif (!this.cacheCanvas) { return null; }\n\t\tif (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }\n\t\treturn this._cacheDataURL;\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of the display object\n\t * to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t * over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed coordinates on the stage.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.localToGlobal(100, 100);\n\t *      // Results in x=400, y=300\n\t *\n\t * @method localToGlobal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position in the source display object to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates\n\t * on the stage.\n\t **/\n\tp.localToGlobal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the global (stage) coordinate space to the\n\t * coordinate space of the display object. For example, this could be used to determine\n\t * the current mouse position within the display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed position in the display object\'s coordinate space.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.globalToLocal(100, 100);\n\t *      // Results in x=-200, y=-100\n\t *\n\t * @method globalToLocal\n\t * @param {Number} x The x position on the stage to transform.\n\t * @param {Number} y The y position on the stage to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed position in the\n\t * display object\'s coordinate space.\n\t **/\n\tp.globalToLocal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of this display object to the coordinate\n\t * space of the target display object. Returns a Point instance with x and y properties correlating to the\n\t * transformed position in the target\'s coordinate space. Effectively the same as using the following code with\n\t * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.\n\t *\n\t *      var pt = this.localToGlobal(x, y);\n\t *      pt = target.globalToLocal(pt.x, pt.y);\n\t *\n\t * @method localToLocal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position on the source display object to transform.\n\t * @param {DisplayObject} target The target display object to which the coordinates will be transformed.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position\n\t * in the target\'s coordinate space.\n\t **/\n\tp.localToLocal = function(x, y, target, pt) {\n\t\tpt = this.localToGlobal(x, y, pt);\n\t\treturn target.globalToLocal(pt.x, pt.y, pt);\n\t};\n\n\t/**\n\t * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.\n\t * Omitted parameters will have the default value set.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.setTransform(100, 100, 2, 2);\n\t *\n\t * @method setTransform\n\t * @param {Number} [x=0] The horizontal translation (x position) in pixels\n\t * @param {Number} [y=0] The vertical translation (y position) in pixels\n\t * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1\n\t * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1\n\t * @param {Number} [rotation=0] The rotation, in degrees\n\t * @param {Number} [skewX=0] The horizontal skew factor\n\t * @param {Number} [skewY=0] The vertical skew factor\n\t * @param {Number} [regX=0] The horizontal registration point in pixels\n\t * @param {Number} [regY=0] The vertical registration point in pixels\n\t * @return {DisplayObject} Returns this instance. Useful for chaining commands.\n\t * @chainable\n\t*/\n\tp.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.scaleX = scaleX == null ? 1 : scaleX;\n\t\tthis.scaleY = scaleY == null ? 1 : scaleY;\n\t\tthis.rotation = rotation || 0;\n\t\tthis.skewX = skewX || 0;\n\t\tthis.skewY = skewY || 0;\n\t\tthis.regX = regX || 0;\n\t\tthis.regY = regY || 0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a matrix based on this object\'s current transform.\n\t * @method getMatrix\n\t * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new\n\t * Matrix object is returned.\n\t * @return {Matrix2D} A matrix representing this display object\'s transform.\n\t **/\n\tp.getMatrix = function(matrix) {\n\t\tvar o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();\n\t\treturn o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t};\n\t\n\t/**\n\t * Generates a Matrix2D object representing the combined transform of the display object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can\n\t * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}\n\t * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.\n\t * @method getConcatenatedMatrix\n\t * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new Matrix2D object is returned.\n\t * @return {Matrix2D} The combined matrix.\n\t **/\n\tp.getConcatenatedMatrix = function(matrix) {\n\t\tvar o = this, mtx = this.getMatrix(matrix);\n\t\twhile (o = o.parent) {\n\t\t\tmtx.prependMatrix(o.getMatrix(o._props.matrix));\n\t\t}\n\t\treturn mtx;\n\t};\n\t\n\t/**\n\t * Generates a DisplayProps object representing the combined display properties of the  object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).\n\t * @method getConcatenatedDisplayProps\n\t * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new DisplayProps object is returned.\n\t * @return {DisplayProps} The combined display properties.\n\t **/\n\tp.getConcatenatedDisplayProps = function(props) {\n\t\tprops = props ? props.identity() : new createjs.DisplayProps();\n\t\tvar o = this, mtx = o.getMatrix(props.matrix); \n\t\tdo {\n\t\t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n\t\t\t\n\t\t\t// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.\n\t\t\t// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.\n\t\t\tif (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }\n\t\t} while (o = o.parent);\n\t\treturn props;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified point in <em>local</em> coordinates (ie. draws a pixel\n\t * with alpha > 0 at the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation\n\t * of the display object.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar myShape = new createjs.Shape();\n\t * \t\tmyShape.graphics.beginFill("red").drawRect(100, 100, 20, 50);\n\t *\n\t * \t\tconsole.log(myShape.hitTest(10,10); // false\n\t * \t\tconsole.log(myShape.hitTest(110, 25); // true\n\t *\n\t * Note that to use Stage coordinates (such as {{#crossLink "Stage/mouseX:property"}}{{/crossLink}}), they must\n\t * first be converted to local coordinates:\n\t *\n\t *      stage.addEventListener("stagemousedown", handleMouseDown);\n\t *      function handleMouseDown(event) {\n\t *      \tvar p = myShape.globalToLocal(stage.mouseX, stage.mouseY);\n\t *          var hit = myShape.hitTest(p.x, p.y);\n\t *      }\n\t *\n\t * Shape-to-shape collision is not currently supported by EaselJS.\n\t *\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object\'s local coordinates.\n\t * @param {Number} y The y position to check in the display object\'s local coordinates.\n\t * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified\n\t * local Point.\n\t*/\n\tp.hitTest = function(x, y) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\n\t\tvar hit = this._testHit(ctx);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\treturn hit;\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);\n\t *      var shape = stage.addChild(new createjs.Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.\n\t * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object\'s bounds in its local coordinate system (ie. with no transformation).\n\t * Objects that have been cached will return the bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * <table>\n\t * \t<tr><td><b>All</b></td><td>\n\t * \t\tAll display objects support setting bounds manually using setBounds(). Likewise, display objects that\n\t * \t\thave been cached using cache() will return the bounds of their cache. Manual and cache bounds will override\n\t * \t\tthe automatic calculations listed below.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Bitmap</b></td><td>\n\t * \t\tReturns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).\n\t * \t</td></tr>\n\t * \t<tr><td><b>Sprite</b></td><td>\n\t * \t\tReturns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified\n\t * \t\tin the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}\n\t * \t</td></tr>\n\t * \t<tr><td><b>Container</b></td><td>\n\t * \t\tReturns the aggregate (combined) bounds of all children that return a non-null value from getBounds().\n\t * \t</td></tr>\n\t * \t<tr><td><b>Shape</b></td><td>\n\t * \t\tDoes not currently support automatic bounds calculations. Use setBounds() to manually define bounds.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Text</b></td><td>\n\t * \t\tReturns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are\n\t * \t\tnot, especially when using textBaseline values other than "top".\n\t * \t</td></tr>\n\t * \t<tr><td><b>BitmapText</b></td><td>\n\t * \t\tReturns approximate bounds. Values will be more accurate if spritesheet frame registration points are close\n\t * \t\tto (x=0,y=0).\n\t * \t</td></tr>\n\t* </table>\n\t * \n\t * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and\n\t * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the\n\t * bounds explicitly:\n\t * \n\t * \tvar bounds = obj.getBounds();\n\t * \tobj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\t * \t// getBounds will now use the set values, instead of recalculating\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * \tvar myBounds = obj.getBounds().clone();\n\t * \t// OR:\n\t * \tmyRect.copy(obj.getBounds());\n\t * \n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this\n\t * object.\n\t **/\n\tp.getBounds = function() {\n\t\tif (this._bounds) { return this._rectangle.copy(this._bounds); }\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (cacheCanvas) {\n\t\t\tvar scale = this._cacheScale;\n\t\t\treturn this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object\'s bounds in its parent\'s coordinate system (ie. with transformations applied).\n\t * Objects that have been cached will return the transformed bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * Container instances calculate aggregate bounds for all children that return bounds via getBounds.\n\t * @method getTransformedBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t **/\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\t\n\t/**\n\t * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &\n\t * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always\n\t * override calculated bounds.\n\t * \n\t * The bounds should be specified in the object\'s local (untransformed) coordinates. For example, a Shape instance\n\t * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).\n\t * @method setBounds\n\t * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.\n\t * @param {Number} y The y origin of the bounds.\n\t * @param {Number} width The width of the bounds.\n\t * @param {Number} height The height of the bounds.\n\t **/\n\tp.setBounds = function(x, y, width, height) {\n\t\tif (x == null) { this._bounds = x; }\n\t\tthis._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);\n\t};\n\n\t/**\n\t * Returns a clone of this DisplayObject. Some properties that are specific to this instance\'s current context are\n\t * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements\n\t * are copied by reference (masks, individual filter instances, hit area)\n\t * @method clone\n\t * @return {DisplayObject} A clone of the current DisplayObject instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new DisplayObject());\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[DisplayObject (name="+  this.name +")]";\n\t};\n\n\n// private methods:\n\t// separated so it can be used more easily in subclasses:\n\t/**\n\t * @method _cloneProps\n\t * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t * instance copied into.\n\t * @return {DisplayObject} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\to.alpha = this.alpha;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.tickEnabled = this.tickEnabled;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.compositeOperation = this.compositeOperation;\n\t\to.snapToPixel = this.snapToPixel;\n\t\to.filters = this.filters==null?null:this.filters.slice(0);\n\t\to.mask = this.mask;\n\t\to.hitArea = this.hitArea;\n\t\to.cursor = this.cursor;\n\t\to._bounds = this._bounds;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _applyShadow\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Shadow} shadow\n\t **/\n\tp._applyShadow = function(ctx, shadow) {\n\t\tshadow = shadow || Shadow.identity;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t};\n\t\n\t\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\t// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.\n\t\tvar ls = this._listeners;\n\t\tif (ls && ls["tick"]) {\n\t\t\t// reset & reuse the event object to avoid construction / GC costs:\n\t\t\tevtObj.target = null;\n\t\t\tevtObj.propagationStopped = evtObj.immediatePropagationStopped = false;\n\t\t\tthis.dispatchEvent(evtObj);\n\t\t}\n\t};\n\n\t/**\n\t * @method _testHit\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {Boolean}\n\t **/\n\tp._testHit = function(ctx) {\n\t\ttry {\n\t\t\tvar hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";\n\t\t\t}\n\t\t}\n\t\treturn hit;\n\t};\n\n\t/**\n\t * @method _applyFilters\n\t * @protected\n\t **/\n\tp._applyFilters = function() {\n\t\tif (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }\n\t\tvar l = this.filters.length;\n\t\tvar ctx = this.cacheCanvas.getContext("2d");\n\t\tvar w = this.cacheCanvas.width;\n\t\tvar h = this.cacheCanvas.height;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tthis.filters[i].applyFilter(ctx, 0, 0, w, h);\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _getFilterBounds\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getFilterBounds = function(rect) {\n\t\tvar l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);\n\t\tif (!filters || !(l=filters.length)) { return bounds; }\n\t\t\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar f = this.filters[i];\n\t\t\tf.getBounds&&f.getBounds(bounds);\n\t\t}\n\t\treturn bounds;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object\'s transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform){\n\t\treturn this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n\t};\n\t\n\t/**\n\t * @method _transformBounds\n\t * @param {Rectangle} bounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._transformBounds = function(bounds, matrix, ignoreTransform) {\n\t\tif (!bounds) { return bounds; }\n\t\tvar x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\t\n\t\tif (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar x_a = width*mtx.a, x_b = width*mtx.b;\n\t\tvar y_c = height*mtx.c, y_d = height*mtx.d;\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\t\n\t\tvar minX = tx, maxX = tx, minY = ty, maxY = ty;\n\n\t\tif ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\t\n\t\tif ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\t\n\t\treturn bounds.setValues(minX, minY, maxX-minX, maxY-minY);\n\t};\n\t\n\t/**\n\t * Indicates whether the display object has any mouse event listeners or a cursor.\n\t * @method _isMouseOpaque\n\t * @return {Boolean}\n\t * @protected\n\t **/\n\tp._hasMouseEventListener = function() {\n\t\tvar evts = DisplayObject._MOUSE_EVENTS;\n\t\tfor (var i= 0, l=evts.length; i<l; i++) {\n\t\t\tif (this.hasEventListener(evts[i])) { return true; }\n\t\t}\n\t\treturn !!this.cursor;\n\t};\n\n\tcreatejs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");\n}());\n\n//##############################################################################\n// Container.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\t\n\n// constructor:\n/**\n * A Container is a nestable display list that allows you to work with compound display elements. For  example you could\n * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and\n * transform them as a group, while still being able to move the individual parts relative to each other. Children of\n * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent\n * Container.\n *\n * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>\n * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.\n * Containers have some overhead, so you generally shouldn\'t create a Container to hold a single child.\n *\n * <h4>Example</h4>\n *\n *      var container = new createjs.Container();\n *      container.addChild(bitmapInstance, shapeInstance);\n *      container.x = 100;\n *\n * @class Container\n * @extends DisplayObject\n * @constructor\n **/\n\tfunction Container() {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The array of children in the display list. You should usually use the child management methods such as\n\t\t * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},\n\t\t * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is\n\t\t * included for advanced uses.\n\t\t * @property children\n\t\t * @type Array\n\t\t * @default null\n\t\t **/\n\t\tthis.children = [];\n\t\t\n\t\t/**\n\t\t * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.\n\t\t * If false, the children will be aggregated under the container - for example, a click on a child shape would\n\t\t * trigger a click event on the container.\n\t\t * @property mouseChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseChildren = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.\n\t\t * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickChildren = true;\n\t}\n\tvar p = createjs.extend(Container, createjs.DisplayObject);\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.\n\t * @method getNumChildren\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tp.getNumChildren = function() {\n\t\treturn this.children.length;\n\t};\n\n\t/**\n\t * Returns the number of children in the container.\n\t * @property numChildren\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnumChildren: { get: p.getNumChildren }\n\t\t});\n\t} catch (e) {}\n\t\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Container; // TODO: deprecated.\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.children.length;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\t// this ensures we don\'t have issues with display list changes that occur during a draw:\n\t\tvar list = this.children.slice();\n\t\tfor (var i=0,l=list.length; i<l; i++) {\n\t\t\tvar child = list[i];\n\t\t\tif (!child.isVisible()) { continue; }\n\t\t\t\n\t\t\t// draw the child:\n\t\t\tctx.save();\n\t\t\tchild.updateContext(ctx);\n\t\t\tchild.draw(ctx);\n\t\t\tctx.restore();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Adds a child to the top of the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance);\n\t *\n\t * You can also add multiple children at once:\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance, shapeInstance, textInstance);\n\t *\n\t * @method addChild\n\t * @param {DisplayObject} child The display object to add.\n\t * @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChild = function(child) {\n\t\tif (child == null) { return child; }\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addChild(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n\t\tchild.dispatchEvent("added");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and\n\t * setting its parent to this Container.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      addChildAt(child1, index);\n\t *\n\t * You can also add multiple children, such as:\n\t *\n\t *      addChildAt(child1, child2, ..., index);\n\t *\n\t * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,\n\t * you could use:\n\t *\n\t *      container.addChildAt(myShape, container.getChildIndex(otherShape));\n\t *\n\t * This would also bump otherShape\'s index up by one. Fails silently if the index is out of range.\n\t *\n\t * @method addChildAt\n\t * @param {DisplayObject} child The display object to add.\n\t * @param {Number} index The index to add the child at.\n\t * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChildAt = function(child, index) {\n\t\tvar l = arguments.length;\n\t\tvar indx = arguments[l-1]; // can\'t use the same name as the index param or it replaces arguments[1]\n\t\tif (indx < 0 || indx > this.children.length) { return arguments[l-2]; }\n\t\tif (l > 2) {\n\t\t\tfor (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }\n\t\t\treturn arguments[l-2];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.splice(index, 0, child);\n\t\tchild.dispatchEvent("added");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is\n\t * already known.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChild(child);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      removeChild(child1, child2, ...);\n\t *\n\t * Returns true if the child (or children) was removed, or false if it was not in the display list.\n\t * @method removeChild\n\t * @param {DisplayObject} child The child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t **/\n\tp.removeChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this.removeChildAt(createjs.indexOf(this.children, child));\n\t};\n\n\t/**\n\t * Removes the child at the specified index from the display list, and sets its parent to null.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChildAt(2);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      container.removeChild(2, 7, ...)\n\t *\n\t * Returns true if the child (or children) was removed, or false if any index was out of range.\n\t * @method removeChildAt\n\t * @param {Number} index The index of the child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n\t **/\n\tp.removeChildAt = function(index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar a = [];\n\t\t\tfor (var i=0; i<l; i++) { a[i] = arguments[i]; }\n\t\t\ta.sort(function(a, b) { return b-a; });\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }\n\t\t\treturn good;\n\t\t}\n\t\tif (index < 0 || index > this.children.length-1) { return false; }\n\t\tvar child = this.children[index];\n\t\tif (child) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\tchild.dispatchEvent("removed");\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all children from the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tcontainer.removeAllChildren();\n\t *\n\t * @method removeAllChildren\n\t **/\n\tp.removeAllChildren = function() {\n\t\tvar kids = this.children;\n\t\twhile (kids.length) { this.removeChildAt(0); }\n\t};\n\n\t/**\n\t * Returns the child at the specified index.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.getChildAt(2);\n\t *\n\t * @method getChildAt\n\t * @param {Number} index The index of the child to return.\n\t * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.\n\t **/\n\tp.getChildAt = function(index) {\n\t\treturn this.children[index];\n\t};\n\t\n\t/**\n\t * Returns the child with the specified name.\n\t * @method getChildByName\n\t * @param {String} name The name of the child to return.\n\t * @return {DisplayObject} The child with the specified name.\n\t **/\n\tp.getChildByName = function(name) {\n\t\tvar kids = this.children;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif(kids[i].name == name) { return kids[i]; }\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Performs an array sort operation on the child list.\n\t *\n\t * <h4>Example: Display children with a higher y in front.</h4>\n\t * \n\t *      var sortFunction = function(obj1, obj2, options) {\n\t *          if (obj1.y > obj2.y) { return 1; }\n\t *          if (obj1.y < obj2.y) { return -1; }\n\t *          return 0;\n\t *      }\n\t *      container.sortChildren(sortFunction);\n\t *\n\t * @method sortChildren\n\t * @param {Function} sortFunction the function to use to sort the child list. See JavaScript\'s <code>Array.sort</code>\n\t * documentation for details.\n\t **/\n\tp.sortChildren = function(sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t};\n\n\t/**\n\t * Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var index = container.getChildIndex(child);\n\t *\n\t * @method getChildIndex\n\t * @param {DisplayObject} child The child to return the index of.\n\t * @return {Number} The index of the specified child. -1 if the child is not found.\n\t **/\n\tp.getChildIndex = function(child) {\n\t\treturn createjs.indexOf(this.children, child);\n\t};\n\t\n\t/**\n\t * Swaps the children at the specified indexes. Fails silently if either index is out of range.\n\t * @method swapChildrenAt\n\t * @param {Number} index1\n\t * @param {Number} index2\n\t **/\n\tp.swapChildrenAt = function(index1, index2) {\n\t\tvar kids = this.children;\n\t\tvar o1 = kids[index1];\n\t\tvar o2 = kids[index2];\n\t\tif (!o1 || !o2) { return; }\n\t\tkids[index1] = o2;\n\t\tkids[index2] = o1;\n\t};\n\t\n\t/**\n\t * Swaps the specified children\'s depth in the display list. Fails silently if either child is not a child of this\n\t * Container.\n\t * @method swapChildren\n\t * @param {DisplayObject} child1\n\t * @param {DisplayObject} child2\n\t **/\n\tp.swapChildren = function(child1, child2) {\n\t\tvar kids = this.children;\n\t\tvar index1,index2;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif (kids[i] == child1) { index1 = i; }\n\t\t\tif (kids[i] == child2) { index2 = i; }\n\t\t\tif (index1 != null && index2 != null) { break; }\n\t\t}\n\t\tif (i==l) { return; } // TODO: throw error?\n\t\tkids[index1] = child2;\n\t\tkids[index2] = child1;\n\t};\n\t\n\t/**\n\t * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.\n\t * @param {DisplayObject} child\n\t * @param {Number} index  \n\t * @method setChildIndex\n\t **/\n\tp.setChildIndex = function(child, index) {\n\t\tvar kids = this.children, l=kids.length;\n\t\tif (child.parent != this || index < 0 || index >= l) { return; }\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tif (kids[i] == child) { break; }\n\t\t}\n\t\tif (i==l || i == index) { return; }\n\t\tkids.splice(i,1);\n\t\tkids.splice(index,0,child);\n\t};\n\n\t/**\n\t * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)\n\t * of this container.\n\t * @method contains\n\t * @param {DisplayObject} child The DisplayObject to be checked.\n\t * @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t **/\n\tp.contains = function(child) {\n\t\twhile (child) {\n\t\t\tif (child == this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the\n\t * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all\n\t * transform properties including regX/Y.\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object\'s local coordinates.\n\t * @param {Number} y The y position to check in the display object\'s local coordinates.\n\t * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified\n\t * coordinates.\n\t **/\n\tp.hitTest = function(x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn (this.getObjectUnderPoint(x, y) != null);\n\t};\n\n\t/**\n\t * Returns an array of all display objects under the specified coordinates that are in this container\'s display\n\t * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}\n\t * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.\n\t * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.\n\t * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),\n\t * and only if the mouse\'s position has changed.\n\t * \n\t * <ul>\n\t *     <li>By default (mode=0) this method evaluates all display objects.</li>\n\t *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}\n\t * \t\tand {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>\n\t * \t   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event\n\t * \t   \tlisteners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects\n\t * \t   \tthat would normally intercept mouse interaction will be included. This can significantly improve performance\n\t * \t   \tin some cases by reducing the number of display objects that need to be tested.</li>\n\t * </li>\n\t * \n\t * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.\n\t * @method getObjectsUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {Array} An Array of DisplayObjects under the specified coordinates.\n\t **/\n\tp.getObjectsUnderPoint = function(x, y, mode) {\n\t\tvar arr = [];\n\t\tvar pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display\n\t * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive\n\t * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.\n\t * @method getObjectUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {DisplayObject} The top-most display object under the specified coordinates.\n\t **/\n\tp.getObjectUnderPoint = function(x, y, mode) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\treturn this._getBounds(null, true);\n\t};\n\t\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\n\t/**\n\t * Returns a clone of this Container. Some properties that are specific to this instance\'s current context are\n\t * reverted to their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the\n\t * properties of the container will be cloned, but the new instance will not have any children.\n\t * @return {Container} A clone of the current Container instance.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar o = this._cloneProps(new Container());\n\t\tif (recursive) { this._cloneChildren(o); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Container (name="+  this.name +")]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (this.tickChildren) {\n\t\t\tfor (var i=this.children.length-1; i>=0; i--) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.tickEnabled && child._tick) { child._tick(evtObj); }\n\t\t\t}\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * Recursively clones all children of this container, and adds them to the target container.\n\t * @method cloneChildren\n\t * @protected\n\t * @param {Container} o The target container.\n\t **/\n\tp._cloneChildren = function(o) {\n\t\tif (o.children.length) { o.removeAllChildren(); }\n\t\tvar arr = o.children;\n\t\tfor (var i=0, l=this.children.length; i<l; i++) {\n\t\t\tvar clone = this.children[i].clone(true);\n\t\t\tclone.parent = o;\n\t\t\tarr.push(clone);\n\t\t}\n\t};\n\n\t/**\n\t * @method _getObjectsUnderPoint\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Array} arr\n\t * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.\n\t * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.\n\t * @param {Number} currentDepth Indicates the current depth of the search.\n\t * @return {DisplayObject}\n\t * @protected\n\t **/\n\tp._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {\n\t\tcurrentDepth = currentDepth || 0;\n\t\tif (!currentDepth && !this._testMask(this, x, y)) { return null; }\n\t\tvar mtx, ctx = createjs.DisplayObject._hitTestContext;\n\t\tactiveListener = activeListener || (mouse&&this._hasMouseEventListener());\n\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tvar children = this.children, l = children.length;\n\t\tfor (var i=l-1; i>=0; i--) {\n\t\t\tvar child = children[i];\n\t\t\tvar hitArea = child.hitArea;\n\t\t\tif (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }\n\t\t\tif (!hitArea && !this._testMask(child, x, y)) { continue; }\n\t\t\t\n\t\t\t// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:\n\t\t\tif (!hitArea && child instanceof Container) {\n\t\t\t\tvar result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);\n\t\t\t\tif (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }\n\t\t\t} else {\n\t\t\t\tif (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }\n\t\t\t\t\n\t\t\t\t// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It\'s kind of a mixed bag. When we\'re only hunting for DOs with event listeners, it may not make sense.\n\t\t\t\tvar props = child.getConcatenatedDisplayProps(child._props);\n\t\t\t\tmtx = props.matrix;\n\t\t\t\t\n\t\t\t\tif (hitArea) {\n\t\t\t\t\tmtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));\n\t\t\t\t\tprops.alpha = hitArea.alpha;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.globalAlpha = props.alpha;\n\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\t(hitArea||child).draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\t\tif (arr) { arr.push(child); }\n\t\t\t\telse { return (mouse && !this.mouseChildren) ? this : child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * @method _testMask\n\t * @param {DisplayObject} target\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Boolean} Indicates whether the x/y is within the masked region.\n\t * @protected\n\t **/\n\tp._testMask = function(target, x, y) {\n\t\tvar mask = target.mask;\n\t\tif (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }\n\t\t\n\t\tvar mtx = this._props.matrix, parent = target.parent;\n\t\tmtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n\t\tmtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n\t\t\n\t\tvar ctx = createjs.DisplayObject._hitTestContext;\n\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\n\t\t// draw the mask as a solid fill:\n\t\tmask.graphics.drawAsPath(ctx);\n\t\tctx.fillStyle = "#000";\n\t\tctx.fill();\n\t\t\n\t\tif (!this._testHit(ctx)) { return false; }\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object\'s transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\t\n\t\tvar mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar l = this.children.length, rect=null;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar child = this.children[i];\n\t\t\tif (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }\n\t\t\tif (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }\n\t\t\telse { rect = bounds.clone(); }\n\t\t}\n\t\treturn rect;\n\t};\n\n\n\tcreatejs.Container = createjs.promote(Container, "DisplayObject");\n}());\n\n//##############################################################################\n// Stage.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}\n\t * method is called, it will render its display list to its target canvas.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child\n\t * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage("canvasElementId");\n\t *      var image = new createjs.Bitmap("imagePath.png");\n\t *      stage.addChild(image);\n\t *      createjs.Ticker.addEventListener("tick", handleTick);\n\t *      function handleTick(event) {\n\t *          image.x += 10;\n\t *          stage.update();\n\t *      }\n\t *\n\t * @class Stage\n\t * @extends Container\n\t * @constructor\n\t * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id\n\t * of a canvas object in the current document.\n\t **/\n\tfunction Stage(canvas) {\n\t\tthis.Container_constructor();\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>\n\t\t * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for\n\t\t * example).\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var stage = new createjs.Stage("canvasId");\n\t\t *      stage.autoClear = false;\n\t\t *\n\t\t * @property autoClear\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.autoClear = true;\n\t\n\t\t/**\n\t\t * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t\t * first stage that will be ticked (or they will clear each other\'s render).\n\t\t *\n\t\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t\t * new canvas or mouse events will not work as expected. For example:\n\t\t *\n\t\t *      myStage.enableDOMEvents(false);\n\t\t *      myStage.canvas = anotherCanvas;\n\t\t *      myStage.enableDOMEvents(true);\n\t\t *\n\t\t * @property canvas\n\t\t * @type HTMLCanvasElement | Object\n\t\t **/\n\t\tthis.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;\n\t\n\t\t/**\n\t\t * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseX\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseX = 0;\n\t\n\t\t/**\n\t\t * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseY\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseY = 0;\n\t\n\t\t/**\n\t\t * Specifies the area of the stage to affect when calling update. This can be use to selectively\n\t\t * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.\n\t\t * @property drawRect\n\t\t * @type {Rectangle}\n\t\t */\n\t\tthis.drawRect = null;\n\t\n\t\t/**\n\t\t * Indicates whether display objects should be rendered on whole pixels. You can set the\n\t\t * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of\n\t\t * display objects to false to enable/disable this behaviour on a per instance basis.\n\t\t * @property snapToPixelEnabled\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.snapToPixelEnabled = false;\n\t\n\t\t/**\n\t\t * Indicates whether the mouse is currently within the bounds of the canvas.\n\t\t * @property mouseInBounds\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseInBounds = false;\n\t\n\t\t/**\n\t\t * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.\n\t\t * @property tickOnUpdate\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickOnUpdate = true;\n\t\n\t\t/**\n\t\t * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See\n\t\t * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}\n\t\t * x/y/rawX/rawY.\n\t\t * @property mouseMoveOutside\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseMoveOutside = false;\n\t\t\n\t\t\n\t\t/**\n\t\t * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.\n\t\t * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.\n\t\t * @property preventSelection\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.preventSelection = true;\n\t\n\t\t/**\n\t\t * The hitArea property is not supported for Stage.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\t \n\t\t \n\t// private properties:\n\t\t/**\n\t\t * Holds objects with data for each active pointer id. Each object has the following properties:\n\t\t * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)\n\t\t * @property _pointerData\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerData = {};\n\t\n\t\t/**\n\t\t * Number of active pointers.\n\t\t * @property _pointerCount\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerCount = 0;\n\t\n\t\t/**\n\t\t * The ID of the primary pointer.\n\t\t * @property _primaryPointerID\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._primaryPointerID = null;\n\t\n\t\t/**\n\t\t * @property _mouseOverIntervalID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._mouseOverIntervalID = null;\n\t\t\n\t\t/**\n\t\t * @property _nextStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._nextStage = null;\n\t\t\n\t\t/**\n\t\t * @property _prevStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._prevStage = null;\n\t\t\n\t\t\n\t// initialize:\n\t\tthis.enableDOMEvents(true);\n\t}\n\tvar p = createjs.extend(Stage, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// events:\n\t/**\n\t * Dispatched when the user moves the mouse over the canvas.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemousemove\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event stagemousedown\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).\n\t * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.\n\t * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemouseup\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseleave\n\t * @since 0.7.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseenter\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the tick event is propagated through the display list.\n\t * You can call preventDefault on the event object to cancel propagating the tick event.\n\t * @event tickstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if\n\t * tickOnUpdate is false. Precedes the "drawstart" event.\n\t * @event tickend\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.\n\t * You can call preventDefault on the event object to cancel the draw.\n\t * @event drawstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.\n\t * @event drawend\n\t * @since 0.7.0\n\t */\n\n\t \n// getter / setters:\n\t/**\n\t * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.\n\t * This can be useful in cases where you have multiple layered canvases and want user interactions\n\t * events to pass through. For example, this would relay mouse events from topStage to bottomStage:\n\t *\n\t *      topStage.nextStage = bottomStage;\n\t *\n\t * To disable relaying, set nextStage to null.\n\t * \n\t * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings\n\t * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.\n\t * Considerations when using roll over in relay targets:<OL>\n\t * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>\n\t * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>\n\t * <LI> All relay targets will share the frequency value of the top-most stage</LI>\n\t * </OL>\n\t * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing\n\t * 30 as it\'s desired frequency):\n\t * \ttopStage.nextStage = targetStage;\n\t * \ttopStage.enableMouseOver(10);\n\t * \ttargetStage.enableMouseOver(30);\n\t * \n\t * If the target stage\'s canvas is completely covered by this stage\'s canvas, you may also want to disable its\n\t * DOM events using:\n\t * \n\t *\ttargetStage.enableDOMEvents(false);\n\t * \n\t * @property nextStage\n\t * @type {Stage}\n\t **/\n\tp._get_nextStage = function() {\n\t\treturn this._nextStage;\n\t};\n\tp._set_nextStage = function(value) {\n\t\tif (this._nextStage) { this._nextStage._prevStage = null; }\n\t\tif (value) { value._prevStage = this; }\n\t\tthis._nextStage = value;\n\t};\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnextStage: { get: p._get_nextStage, set: p._set_nextStage }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}\n\t * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,\n\t * and then render the display list to the canvas.\n\t *\n\t * @method update\n\t * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.\n\t **/\n\tp.update = function(props) {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.tickOnUpdate) { this.tick(props); }\n\t\tif (this.dispatchEvent("drawstart", false, true) === false) { return; }\n\t\tcreatejs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tvar r = this.drawRect, ctx = this.canvas.getContext("2d");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tif (this.autoClear) {\n\t\t\tif (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }\n\t\t\telse { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }\n\t\t}\n\t\tctx.save();\n\t\tif (this.drawRect) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(r.x, r.y, r.width, r.height);\n\t\t\tctx.clip();\n\t\t}\n\t\tthis.updateContext(ctx);\n\t\tthis.draw(ctx, false);\n\t\tctx.restore();\n\t\tthis.dispatchEvent("drawend");\n\t};\n\t\n\t/**\n\t * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}\n\t * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.\n\t *\n\t * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is\n\t * propagated to listeners.\n\t *\n\t * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that\n\t * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be\n\t * passed as the `props` parameter to `tick()`. For example:\n\t *\n\t * \tTicker.on("tick", handleTick);\n\t * \tfunction handleTick(evtObj) {\n\t * \t\t// clone the event object from Ticker, and add some custom data to it:\n\t * \t\tvar evt = evtObj.clone().set({greeting:"hello", name:"world"});\n\t * \t\t\n\t * \t\t// pass it to stage.update():\n\t * \t\tmyStage.update(evt); // subsequently calls tick() with the same param\n\t * \t}\n\t * \t\n\t * \t// ...\n\t * \tmyDisplayObject.on("tick", handleDisplayObjectTick);\n\t * \tfunction handleDisplayObjectTick(evt) {\n\t * \t\tconsole.log(evt.delta); // the delta property from the Ticker tick event object\n\t * \t\tconsole.log(evt.greeting, evt.name); // custom data: "hello world"\n\t * \t}\n\t * \n\t * @method tick\n\t * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.\n\t **/\n\tp.tick = function(props) {\n\t\tif (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }\n\t\tvar evtObj = new createjs.Event("tick");\n\t\tif (props) {\n\t\t\tfor (var n in props) {\n\t\t\t\tif (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }\n\t\t\t}\n\t\t}\n\t\tthis._tick(evtObj);\n\t\tthis.dispatchEvent("tickend");\n\t};\n\n\t/**\n\t * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}\n\t * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}\n\t * directly, using:\n\t *\n\t *      Ticker.addEventListener("tick", myStage");\n\t *\n\t * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to\n\t * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.\n\t * @property handleEvent\n\t * @type Function\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tif (evt.type == "tick") { this.update(evt); }\n\t};\n\n\t/**\n\t * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.\n\t * @method clear\n\t **/\n\tp.clear = function() {\n\t\tif (!this.canvas) { return; }\n\t\tvar ctx = this.canvas.getContext("2d");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);\n\t};\n\n\t/**\n\t * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can\n\t * be specified as the src value of an image element.\n\t * @method toDataURL\n\t * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color\n\t * value is allowed. The default value is a transparent background.\n\t * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type\n\t * is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t * @return {String} a Base64 encoded image.\n\t **/\n\tp.toDataURL = function(backgroundColor, mimeType) {\n\t\tvar data, ctx = this.canvas.getContext(\'2d\'), w = this.canvas.width, h = this.canvas.height;\n\n\t\tif (backgroundColor) {\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\t\t\tctx.globalCompositeOperation = "destination-over";\n\t\t\t\n\t\t\tctx.fillStyle = backgroundColor;\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\tvar dataURL = this.canvas.toDataURL(mimeType||"image/png");\n\n\t\tif(backgroundColor) {\n\t\t\tctx.putImageData(data, 0, 0);\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t};\n\n\t/**\n\t * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}\n\t * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}\n\t * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage\'s display list. These events can\n\t * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled\n\t * independently of mouse move events via the optional `frequency` parameter.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var stage = new createjs.Stage("canvasId");\n\t *      stage.enableMouseOver(10); // 10 updates per second\n\t *\n\t * @method enableMouseOver\n\t * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast\n\t * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less\n\t * responsive, but uses less CPU.\n\t **/\n\tp.enableMouseOver = function(frequency) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t\tif (frequency == 0) {\n\t\t\t\tthis._testMouseOver(true);\n\t\t\t}\n\t\t}\n\t\tif (frequency == null) { frequency = 20; }\n\t\telse if (frequency <= 0) { return; }\n\t\tvar o = this;\n\t\tthis._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));\n\t};\n\n\t/**\n\t * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good\n\t * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive\n\t * events from the page.\n\t *\n\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t * new canvas or mouse events will not work as expected. For example:\n\t *\n\t *      myStage.enableDOMEvents(false);\n\t *      myStage.canvas = anotherCanvas;\n\t *      myStage.enableDOMEvents(true);\n\t *\n\t * @method enableDOMEvents\n\t * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.\n\t **/\n\tp.enableDOMEvents = function(enable) {\n\t\tif (enable == null) { enable = true; }\n\t\tvar n, o, ls = this._eventListeners;\n\t\tif (!enable && ls) {\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.removeEventListener(n, o.f, false);\n\t\t\t}\n\t\t\tthis._eventListeners = null;\n\t\t} else if (enable && !ls && this.canvas) {\n\t\t\tvar t = window.addEventListener ? window : document;\n\t\t\tvar _this = this;\n\t\t\tls = this._eventListeners = {};\n\t\t\tls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };\n\t\t\tls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };\n\t\t\tls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };\n\t\t\tls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };\n\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.addEventListener(n, o.f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stage instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow("Stage cannot be cloned.");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Stage (name="+  this.name +")]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _getElementRect\n\t * @protected\n\t * @param {HTMLElement} e\n\t **/\n\tp._getElementRect = function(e) {\n\t\tvar bounds;\n\t\ttry { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9\n\t\tcatch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }\n\n\t\tvar offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);\n\t\tvar offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);\n\n\t\tvar styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.\n\t\tvar padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);\n\t\tvar padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);\n\t\tvar padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);\n\t\tvar padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);\n\n\t\t// note: in some browsers bounds properties are read only.\n\t\treturn {\n\t\t\tleft: bounds.left+offX+padL,\n\t\t\tright: bounds.right+offX-padR,\n\t\t\ttop: bounds.top+offY+padT,\n\t\t\tbottom: bounds.bottom+offY-padB\n\t\t}\n\t};\n\n\t/**\n\t * @method _getPointerData\n\t * @protected\n\t * @param {Number} id\n\t **/\n\tp._getPointerData = function(id) {\n\t\tvar data = this._pointerData[id];\n\t\tif (!data) { data = this._pointerData[id] = {x:0,y:0}; }\n\t\treturn data;\n\t};\n\n\t/**\n\t * @method _handleMouseMove\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseMove = function(e) {\n\t\tif(!e){ e = window.event; }\n\t\tthis._handlePointerMove(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerMove\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerMove = function(id, e, pageX, pageY, owner) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\tif (!this.canvas) { return; }\n\t\tvar nextStage=this._nextStage, o=this._getPointerData(id);\n\n\t\tvar inBounds = o.inBounds;\n\t\tthis._updatePointerPosition(id, e, pageX, pageY);\n\t\tif (inBounds || o.inBounds || this.mouseMoveOutside) {\n\t\t\tif (id === -1 && o.inBounds == !inBounds) {\n\t\t\t\tthis._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);\n\t\t\t}\n\t\t\t\n\t\t\tthis._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);\n\t\t\tthis._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);\n\t};\n\n\t/**\n\t * @method _updatePointerPosition\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t **/\n\tp._updatePointerPosition = function(id, e, pageX, pageY) {\n\t\tvar rect = this._getElementRect(this.canvas);\n\t\tpageX -= rect.left;\n\t\tpageY -= rect.top;\n\n\t\tvar w = this.canvas.width;\n\t\tvar h = this.canvas.height;\n\t\tpageX /= (rect.right-rect.left)/w;\n\t\tpageY /= (rect.bottom-rect.top)/h;\n\t\tvar o = this._getPointerData(id);\n\t\tif (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {\n\t\t\to.x = pageX;\n\t\t\to.y = pageY;\n\t\t} else if (this.mouseMoveOutside) {\n\t\t\to.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);\n\t\t\to.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);\n\t\t}\n\n\t\to.posEvtObj = e;\n\t\to.rawX = pageX;\n\t\to.rawY = pageY;\n\n\t\tif (id === this._primaryPointerID || id === -1) {\n\t\t\tthis.mouseX = o.x;\n\t\t\tthis.mouseY = o.y;\n\t\t\tthis.mouseInBounds = o.inBounds;\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleMouseUp\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseUp = function(e) {\n\t\tthis._handlePointerUp(-1, e, false);\n\t};\n\n\t/**\n\t * @method _handlePointerUp\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Boolean} clear\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerUp = function(id, e, clear, owner) {\n\t\tvar nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar target=null, oTarget = o.target;\n\t\tif (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\t\t\n\t\tif (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }\n\t\t\n\t\tif (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }\n\t\tthis._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);\n\t\t\n\t\tif (clear) {\n\t\t\tif (id==this._primaryPointerID) { this._primaryPointerID = null; }\n\t\t\tdelete(this._pointerData[id]);\n\t\t} else { o.target = null; }\n\t\t\n\t\tnextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);\n\t};\n\n\t/**\n\t * @method _handleMouseDown\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseDown = function(e) {\n\t\tthis._handlePointerDown(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerDown\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerDown = function(id, e, pageX, pageY, owner) {\n\t\tif (this.preventSelection) { e.preventDefault(); }\n\t\tif (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.\n\t\t\n\t\tif (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }\n\t\tvar target = null, nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }\n\t\tthis._dispatchMouseEvent(target, "mousedown", true, id, o, e);\n\t\t\n\t\tnextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);\n\t};\n\n\t/**\n\t * @method _testMouseOver\n\t * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t * @param {Stage} eventTarget The stage that the cursor is actively over.\n\t * @protected\n\t **/\n\tp._testMouseOver = function(clear, owner, eventTarget) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar nextStage = this._nextStage;\n\t\tif (!this._mouseOverIntervalID) {\n\t\t\t// not enabled for mouseover, but should still relay the event.\n\t\t\tnextStage&&nextStage._testMouseOver(clear, owner, eventTarget);\n\t\t\treturn;\n\t\t}\n\t\tvar o = this._getPointerData(-1);\n\t\t// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.\n\t\tif (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }\n\t\t\n\t\tvar e = o.posEvtObj;\n\t\tvar isEventTarget = eventTarget || e&&(e.target == this.canvas);\n\t\tvar target=null, common = -1, cursor="", t, i, l;\n\t\t\n\t\tif (!owner && (clear || this.mouseInBounds && isEventTarget)) {\n\t\t\ttarget = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\n\t\tvar oldList = this._mouseOverTarget||[];\n\t\tvar oldTarget = oldList[oldList.length-1];\n\t\tvar list = this._mouseOverTarget = [];\n\n\t\t// generate ancestor list and check for cursor:\n\t\tt = target;\n\t\twhile (t) {\n\t\t\tlist.unshift(t);\n\t\t\tif (!cursor) { cursor = t.cursor; }\n\t\t\tt = t.parent;\n\t\t}\n\t\tthis.canvas.style.cursor = cursor;\n\t\tif (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }\n\n\t\t// find common ancestor:\n\t\tfor (i=0,l=list.length; i<l; i++) {\n\t\t\tif (list[i] != oldList[i]) { break; }\n\t\t\tcommon = i;\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=oldList.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=list.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);\n\t};\n\n\t/**\n\t * @method _handleDoubleClick\n\t * @protected\n\t * @param {MouseEvent} e\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handleDoubleClick = function(e, owner) {\n\t\tvar target=null, nextStage=this._nextStage, o=this._getPointerData(-1);\n\t\tif (!owner) {\n\t\t\ttarget = this._getObjectsUnderPoint(o.x, o.y, null, true);\n\t\t\tthis._dispatchMouseEvent(target, "dblclick", true, -1, o, e);\n\t\t}\n\t\tnextStage&&nextStage._handleDoubleClick(e, owner || target && this);\n\t};\n\n\t/**\n\t * @method _dispatchMouseEvent\n\t * @protected\n\t * @param {DisplayObject} target\n\t * @param {String} type\n\t * @param {Boolean} bubbles\n\t * @param {Number} pointerId\n\t * @param {Object} o\n\t * @param {MouseEvent} [nativeEvent]\n\t * @param {DisplayObject} [relatedTarget]\n\t **/\n\tp._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {\n\t\t// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.\n\t\tif (!target || (!bubbles && !target.hasEventListener(type))) { return; }\n\t\t/*\n\t\t// TODO: account for stage transformations?\n\t\tthis._mtx = this.getConcatenatedMatrix(this._mtx).invert();\n\t\tvar pt = this._mtx.transformPoint(o.x, o.y);\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);\n\t\t*/\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);\n\t\ttarget.dispatchEvent(evt);\n\t};\n\n\n\tcreatejs.Stage = createjs.promote(Stage, "Container");\n}());\n\n//##############################################################################\n// Bitmap.js\n//##############################################################################\n\n(function() {\n\t\n\t/**\n\t * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing\n\t * HTML element, or a string.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var bitmap = new createjs.Bitmap("imagePath.jpg");\n\t *\n\t * <strong>Notes:</strong>\n\t * <ol>\n\t *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it\n\t *      will be displayed.</li>\n\t *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,\n\t *     the Bitmap can be cached.</li>\n\t *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This\n\t *     happens in all browsers except recent Firefox builds.</li>\n\t *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using\n\t *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting\n\t *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>\n\t * </ol>\n\t *\n\t * @class Bitmap\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to\n\t * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.\n\t * If it is a URI, a new Image object will be constructed and assigned to the .image property.\n\t **/\n\tfunction Bitmap(imageOrUri) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially\n\t\t * mobile browsers) support drawing video to a canvas.\n\t\t * @property image\n\t\t * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement\n\t\t **/\n\t\tif (typeof imageOrUri == "string") {\n\t\t\tthis.image = document.createElement("img");\n\t\t\tthis.image.src = imageOrUri;\n\t\t} else {\n\t\t\tthis.image = imageOrUri;\n\t\t}\n\t\n\t\t/**\n\t\t * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.\n\t\t * Note that video sources must have a width / height set to work correctly with `sourceRect`.\n\t\t * @property sourceRect\n\t\t * @type Rectangle\n\t\t * @default null\n\t\t */\n\t\tthis.sourceRect = null;\n\t}\n\tvar p = createjs.extend(Bitmap, createjs.DisplayObject);\n\t\n\t\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Bitmap; // TODO: deprecated.\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar image = this.image;\n\t\tvar hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }\n\t\tvar img = this.image, rect = this.sourceRect;\n\t\tif (rect) {\n\t\t\t// some browsers choke on out of bound values, so we\'ll fix them:\n\t\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;\n\t\t\tif (x1 < 0) { x -= x1; x1 = 0; }\n\t\t\tif (x2 > w) { x2 = w; }\n\t\t\tif (y1 < 0) { y -= y1; y1 = 0; }\n\t\t\tif (y2 > h) { y2 = h; }\n\t\t\tctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);\n\t\t} else {\n\t\t\tctx.drawImage(img, 0, 0);\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}\n\t * method.\n\t * @method cache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}\n\t * method.\n\t * @method updateCache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}\n\t * method.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tvar image = this.image, o = this.sourceRect || image;\n\t\tvar hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Bitmap instance.\n\t * @method clone\n\t * @return {Bitmap} a clone of the Bitmap instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Bitmap(this.image);\n\t\tif (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }\n\t\tthis._cloneProps(o);\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Bitmap (name="+  this.name +")]";\n\t};\n\n\t\n\tcreatejs.Bitmap = createjs.promote(Bitmap, "DisplayObject");\n}());\n\n//##############################################################################\n// Sprite.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of\n\t * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100\n\t * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,\n\t * play frames as an animation, and even sequence animations together.\n\t *\n\t * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var instance = new createjs.Sprite(spriteSheet);\n\t *      instance.gotoAndStop("frameName");\n\t *\n\t * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,\n\t * only the first defined frame defined in the sprite sheet will be displayed.\n\t *\n\t * @class Sprite\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame\n\t * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.\n\t * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.\n\t **/\n\tfunction Sprite(spriteSheet, frameOrAnimation) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}\n\t\t * definitions, this will advance non-sequentially. This will always be an integer value.\n\t\t * @property currentFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * Returns the name of the currently playing animation.\n\t\t * @property currentAnimation\n\t\t * @type {String}\n\t\t * @final\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentAnimation = null;\n\t\n\t\t/**\n\t\t * Prevents the animation from advancing each tick automatically. For example, you could create a sprite\n\t\t * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis.paused = true;\n\t\n\t\t/**\n\t\t * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame\n\t\t * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.\n\t\t * @property spriteSheet\n\t\t * @type {SpriteSheet}\n\t\t * @readonly\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * Specifies the current frame index within the currently playing animation. When playing normally, this will increase\n\t\t * from 0 to n-1, where n is the number of frames in the current animation.\n\t\t *\n\t\t * This could be a non-integer value if\n\t\t * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation\'s speed is\n\t\t * not an integer.\n\t\t * @property currentAnimationFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.currentAnimationFrame = 0;\n\t\n\t\t/**\n\t\t * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related\n\t\t * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being\n\t\t * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.framerate = 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * Current animation object.\n\t\t * @property _animation\n\t\t * @protected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t **/\n\t\tthis._animation = null;\n\t\n\t\t/**\n\t\t * Current frame index.\n\t\t * @property _currentFrame\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis._currentFrame = null;\n\t\t\n\t\t/**\n\t\t * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame\n\t\t * @property _skipAdvance\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._skipAdvance = false;\n\t\t\n\t\t\n\t\tif (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }\n\t}\n\tvar p = createjs.extend(Sprite, createjs.DisplayObject);\n\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.\n\n\n// events:\n\t/**\n\t * Dispatched when an animation reaches its ends.\n\t * @event animationend\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} name The name of the animation that just ended.\n\t * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,\n\t * or calling gotoAndPlay() or gotoAndStop().\n\t * @event change\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t */\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.spriteSheet.complete;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._normalizeFrame();\n\t\tvar o = this.spriteSheet.getFrame(this._currentFrame|0);\n\t\tif (!o) { return false; }\n\t\tvar rect = o.rect;\n\t\tif (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }\n\t\treturn true;\n\t};\n\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method cache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method updateCache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}\n\t * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain\n\t * unchanged.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\n\t/**\n\t * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}\n\t * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}\n\t * will resume playback.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\n\t/**\n\t * Sets paused to false and plays the specified animation name, named frame, or frame number.\n\t * @method gotoAndPlay\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and begin playing.\n\t **/\n\tp.gotoAndPlay = function(frameOrAnimation) {\n\t\tthis.paused = false;\n\t\tthis._skipAdvance = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Sets paused to true and seeks to the specified animation name, named frame, or frame number.\n\t * @method gotoAndStop\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and stop.\n\t **/\n\tp.gotoAndStop = function(frameOrAnimation) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite\n\t * or its SpriteSheet.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\tvar fps = this.framerate || this.spriteSheet.framerate;\n\t\tvar t = (fps && time != null) ? time/(1000/fps) : 1;\n\t\tthis._normalizeFrame(t);\n\t};\n\t\n\t/**\n\t * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to\n\t * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a\n\t * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.\n\t *\n\t * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.\n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully\n\t * loaded.\n\t **/\n\tp.getBounds = function() {\n\t\t// TODO: should this normalizeFrame?\n\t\treturn this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);\n\t};\n\n\t/**\n\t * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned\n\t * instances.\n\t * @method clone\n\t * @return {Sprite} a clone of the Sprite instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Sprite(this.spriteSheet));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Sprite (name="+  this.name +")]";\n\t};\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Sprite} o\n\t * @return {Sprite} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentAnimation = this.currentAnimation;\n\t\to.paused = this.paused;\n\t\to.currentAnimationFrame = this.currentAnimationFrame;\n\t\to.framerate = this.framerate;\n\t\t\n\t\to._animation = this._animation;\n\t\to._currentFrame = this._currentFrame;\n\t\to._skipAdvance = this._skipAdvance;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}\n\t * ticks.\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t * @method _tick\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (!this.paused) {\n\t\t\tif (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }\n\t\t\tthis._skipAdvance = false;\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\n\n\t/**\n\t * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.\n\t * @protected\n\t * @method _normalizeFrame\n\t **/\n\tp._normalizeFrame = function(frameDelta) {\n\t\tframeDelta = frameDelta || 0;\n\t\tvar animation = this._animation;\n\t\tvar paused = this.paused;\n\t\tvar frame = this._currentFrame;\n\t\tvar l;\n\t\t\n\t\tif (animation) {\n\t\t\tvar speed = animation.speed || 1;\n\t\t\tvar animFrame = this.currentAnimationFrame;\n\t\t\tl = animation.frames.length;\n\t\t\tif (animFrame + frameDelta * speed >= l) {\n\t\t\t\tvar next = animation.next;\n\t\t\t\tif (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {\n\t\t\t\t\t// something changed in the event stack, so we shouldn\'t make any more changes here.\n\t\t\t\t\treturn;\n\t\t\t\t} else if (next) {\n\t\t\t\t\t// sequence. Automatically calls _normalizeFrame again with the remaining frames.\n\t\t\t\t\treturn this._goto(next, frameDelta - (l - animFrame) / speed);\n\t\t\t\t} else {\n\t\t\t\t\t// end.\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tanimFrame = animation.frames.length - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanimFrame += frameDelta * speed;\n\t\t\t}\n\t\t\tthis.currentAnimationFrame = animFrame;\n\t\t\tthis._currentFrame = animation.frames[animFrame | 0]\n\t\t} else {\n\t\t\tframe = (this._currentFrame += frameDelta);\n\t\t\tl = this.spriteSheet.getNumFrames();\n\t\t\tif (frame >= l && l > 0) {\n\t\t\t\tif (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {\n\t\t\t\t\t// looped.\n\t\t\t\t\tif ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tframe = this._currentFrame | 0;\n\t\tif (this.currentFrame != frame) {\n\t\t\tthis.currentFrame = frame;\n\t\t\tthis.dispatchEvent("change");\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},\n\t * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)\n\t * @property _dispatchAnimationEnd\n\t * @private\n\t * @type {Function}\n\t **/\n\tp._dispatchAnimationEnd = function(animation, frame, paused, next, end) {\n\t\tvar name = animation ? animation.name : null;\n\t\tif (this.hasEventListener("animationend")) {\n\t\t\tvar evt = new createjs.Event("animationend");\n\t\t\tevt.name = name;\n\t\t\tevt.next = next;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t\t// did the animation get changed in the event stack?:\n\t\tvar changed = (this._animation != animation || this._currentFrame != frame);\n\t\t// if the animation hasn\'t changed, but the sprite was paused, then we want to stick to the last frame:\n\t\tif (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }\n\t\treturn changed;\n\t};\n\n\t/**\n\t * Moves the playhead to the specified frame number or animation.\n\t * @method _goto\n\t * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.\n\t * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.\n\t * @protected\n\t **/\n\tp._goto = function(frameOrAnimation, frame) {\n\t\tthis.currentAnimationFrame = 0;\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tvar data = this.spriteSheet.getAnimation(frameOrAnimation);\n\t\t\tif (data) {\n\t\t\t\tthis._animation = data;\n\t\t\t\tthis.currentAnimation = frameOrAnimation;\n\t\t\t\tthis._normalizeFrame(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentAnimation = this._animation = null;\n\t\t\tthis._currentFrame = frameOrAnimation;\n\t\t\tthis._normalizeFrame();\n\t\t}\n\t};\n\n\n\tcreatejs.Sprite = createjs.promote(Sprite, "DisplayObject");\n}());\n\n//##############################################################################\n// Shape.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}\n\t * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape\n\t * instances to display the same vector graphics with different positions or transforms.\n\t *\n\t * If the vector art will not\n\t * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the\n\t * rendering cost.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);\n\t *      var shape = new createjs.Shape(graphics);\n\t *\n\t *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);\n\t *\n\t * @class Shape\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.\n\t **/\n\tfunction Shape(graphics) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The graphics instance to display.\n\t\t * @property graphics\n\t\t * @type Graphics\n\t\t **/\n\t\tthis.graphics = graphics ? graphics : new createjs.Graphics();\n\t}\n\tvar p = createjs.extend(Shape, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if\n\t * the draw was handled (useful for overriding functionality).\n\t *\n\t * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx, this);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns a clone of this Shape. Some properties that are specific to this instance\'s current context are reverted to\n\t * their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} recursive If true, this Shape\'s {{#crossLink "Graphics"}}{{/crossLink}} instance will also be\n\t * cloned. If false, the Graphics instance will be shared with the new Shape.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;\n\t\treturn  this._cloneProps(new Shape(g));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Shape (name="+  this.name +")]";\n\t};\n\n\n\tcreatejs.Shape = createjs.promote(Shape, "DisplayObject");\n}());\n\n//##############################################################################\n// Text.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the\n\t * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML\n\t * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}\n\t * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.\n\t *\n\t * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use\n\t * multiple font styles, you will need to create multiple text instances, and position them manually.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");\n\t *      text.x = 100;\n\t *      text.textBaseline = "alphabetic";\n\t *\n\t * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser\n\t * before it can be displayed.\n\t *\n\t * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all\n\t * browsers will render Text exactly the same.\n\t * @class Text\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {String} [text] The text to display.\n\t * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold\n\t * 36px Arial").\n\t * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.\n\t * "#F00", "red", or "#FF0000").\n\t **/\n\tfunction Text(text, font, color) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t **/\n\t\tthis.text = text;\n\t\n\t\t/**\n\t\t * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").\n\t\t * @property font\n\t\t * @type String\n\t\t **/\n\t\tthis.font = font;\n\t\n\t\t/**\n\t\t * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".\n\t\t * It will also accept valid canvas fillStyle values.\n\t\t * @property color\n\t\t * @type String\n\t\t **/\n\t\tthis.color = color;\n\t\n\t\t/**\n\t\t * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed\n\t\t * information view the\n\t\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">\n\t\t * whatwg spec</a>. Default is "left".\n\t\t * @property textAlign\n\t\t * @type String\n\t\t **/\n\t\tthis.textAlign = "left";\n\t\n\t\t/**\n\t\t * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or\n\t\t * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">\n\t\t * whatwg spec</a>. Default is "top".\n\t\t * @property textBaseline\n\t\t * @type String\n\t\t*/\n\t\tthis.textBaseline = "top";\n\t\n\t\t/**\n\t\t * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or\n\t\t * shrunk to make it fit in this width. For detailed information view the\n\t\t * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">\n\t\t * whatwg spec</a>.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t*/\n\t\tthis.maxWidth = null;\n\t\n\t\t/**\n\t\t * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.\n\t\t * @property outline\n\t\t * @type Number\n\t\t **/\n\t\tthis.outline = 0;\n\t\n\t\t/**\n\t\t * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,\n\t\t * the value of getMeasuredLineHeight is used.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,\n\t\t * the text will not be wrapped.\n\t\t * @property lineWidth\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineWidth = null;\n\t}\n\tvar p = createjs.extend(Text, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// static properties:\n\t/**\n\t * @property _workingContext\n\t * @type CanvasRenderingContext2D\n\t * @private\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));\n\tif (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }\n\t\n\t\n// constants:\n\t/**\n\t * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};\n\t\n\t/**\n\t * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.text != null && this.text !== "");\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\n\t\tvar col = this.color || "#000";\n\t\tif (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }\n\t\telse { ctx.fillStyle = col; }\n\t\t\n\t\tthis._drawText(this._prepContext(ctx));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.\n\t * @method getMeasuredWidth\n\t * @return {Number} The measured, untransformed width of the text.\n\t **/\n\tp.getMeasuredWidth = function() {\n\t\treturn this._getMeasuredWidth(this.text);\n\t};\n\n\t/**\n\t * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured\n\t * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.\n\t * @method getMeasuredLineHeight\n\t * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is\n\t * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.\n\t **/\n\tp.getMeasuredLineHeight = function() {\n\t\treturn this._getMeasuredWidth("M")*1.2;\n\t};\n\n\t/**\n\t * Returns the approximate height of multi-line text by multiplying the number of lines against either the\n\t * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that\n\t * this operation requires the text flowing logic to run, which has an associated CPU cost.\n\t * @method getMeasuredHeight\n\t * @return {Number} The approximate height of the untransformed multi-line text.\n\t **/\n\tp.getMeasuredHeight = function() {\n\t\treturn this._drawText(null,{}).height;\n\t};\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tif (this.text == null || this.text === "") { return null; }\n\t\tvar o = this._drawText(null, {});\n\t\tvar w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;\n\t\tvar x = w * Text.H_OFFSETS[this.textAlign||"left"];\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\tvar y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];\n\t\treturn this._rectangle.setValues(x, y, w, o.height);\n\t};\n\t\n\t/**\n\t * Returns an object with width, height, and lines properties. The width and height are the visual width and height\n\t * of the drawn text. The lines property contains an array of strings, one for\n\t * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing\n\t * whitespace removed.\n\t * @method getMetrics\n\t * @return {Object} An object with width, height, and lines properties.\n\t **/\n\tp.getMetrics = function() {\n\t\tvar o = {lines:[]};\n\t\to.lineHeight = this.lineHeight || this.getMeasuredLineHeight();\n\t\to.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];\n\t\treturn this._drawText(null, o, o.lines);\n\t};\n\n\t/**\n\t * Returns a clone of the Text instance.\n\t * @method clone\n\t * @return {Text} a clone of the Text instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Text(this.text, this.font, this.color));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Text} o\n\t * @protected\n\t * @return {Text} o\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.textAlign = this.textAlign;\n\t\to.textBaseline = this.textBaseline;\n\t\to.maxWidth = this.maxWidth;\n\t\to.outline = this.outline;\n\t\to.lineHeight = this.lineHeight;\n\t\to.lineWidth = this.lineWidth;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _getWorkingContext\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {CanvasRenderingContext2D}\n\t * @protected\n\t **/\n\tp._prepContext = function(ctx) {\n\t\tctx.font = this.font||"10px sans-serif";\n\t\tctx.textAlign = this.textAlign||"left";\n\t\tctx.textBaseline = this.textBaseline||"top";\n\t\treturn ctx;\n\t};\n\n\t/**\n\t * Draws multiline text.\n\t * @method _drawText\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Object} o\n\t * @param {Array} lines\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._drawText = function(ctx, o, lines) {\n\t\tvar paint = !!ctx;\n\t\tif (!paint) {\n\t\t\tctx = Text._workingContext;\n\t\t\tctx.save();\n\t\t\tthis._prepContext(ctx);\n\t\t}\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\t\n\t\tvar maxW = 0, count = 0;\n\t\tvar hardLines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n\t\tfor (var i=0, l=hardLines.length; i<l; i++) {\n\t\t\tvar str = hardLines[i];\n\t\t\tvar w = null;\n\t\t\t\n\t\t\tif (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {\n\t\t\t\t// text wrapping:\n\t\t\t\tvar words = str.split(/(\\s)/);\n\t\t\t\tstr = words[0];\n\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\n\t\t\t\tfor (var j=1, jl=words.length; j<jl; j+=2) {\n\t\t\t\t\t// Line needs to wrap:\n\t\t\t\t\tvar wordW = ctx.measureText(words[j] + words[j+1]).width;\n\t\t\t\t\tif (w + wordW > this.lineWidth) {\n\t\t\t\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\t\t\t\tif (lines) { lines.push(str); }\n\t\t\t\t\t\tif (w > maxW) { maxW = w; }\n\t\t\t\t\t\tstr = words[j+1];\n\t\t\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr += words[j] + words[j+1];\n\t\t\t\t\t\tw += wordW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\tif (lines) { lines.push(str); }\n\t\t\tif (o && w == null) { w = ctx.measureText(str).width; }\n\t\t\tif (w > maxW) { maxW = w; }\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (o) {\n\t\t\to.width = maxW;\n\t\t\to.height = count*lineHeight;\n\t\t}\n\t\tif (!paint) { ctx.restore(); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _drawTextLine\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {String} text\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tp._drawTextLine = function(ctx, text, y) {\n\t\t// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:\n\t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }\n\t\telse { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }\n\t};\n\t\n\t\n\t/**\n\t * @method _getMeasuredWidth\n\t * @param {String} text\n\t * @protected\n\t **/\n\tp._getMeasuredWidth = function(text) {\n\t\tvar ctx = Text._workingContext;\n\t\tctx.save();\n\t\tvar w = this._prepContext(ctx).measureText(text).width;\n\t\tctx.restore();\n\t\treturn w;\n\t};\n\n\n\tcreatejs.Text = createjs.promote(Text, "DisplayObject");\n}());\n\n//##############################################################################\n// BitmapText.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported\n\t * using new line characters, but automatic wrapping is not supported. See the \n\t * {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}\n\t * property for more information on defining glyphs.\n\t * \n\t * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.\n\t * As such, methods like addChild and removeChild are disabled.\n\t * @class BitmapText\n\t * @extends DisplayObject\n\t * @param {String} [text=""] The text to display.\n\t * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.\n\t * @constructor\n\t **/\n\tfunction BitmapText(text, spriteSheet) {\n\t\tthis.Container_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t * @default ""\n\t\t **/\n\t\tthis.text = text||"";\n\t\t\n\t\t/**\n\t\t * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character\n\t\t * should have a single frame animation defined in the sprite sheet named the same as\n\t\t * corresponding character. For example, the following animation definition:\n\t\t *\n\t\t * \t\t"A": {frames: [0]}\n\t\t *\n\t\t * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form\n\t\t * is also acceptable:\n\t\t * \n\t\t * \t\t"A": 0\n\t\t *\n\t\t * Note that if a character in the text is not found in the sprite sheet, it will also\n\t\t * try to use the alternate case (upper or lower).\n\t\t *\n\t\t * See SpriteSheet for more information on defining sprite sheet data.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t * @default null\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * The height of each line of text. If 0, then it will use a line height calculated\n\t\t * by checking for the height of the "1", "T", or "L" character (in that order). If\n\t\t * those characters are not defined, it will use the height of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * This spacing (in pixels) will be added after each character in the output.\n\t\t * @property letterSpacing\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.letterSpacing = 0;\n\t\n\t\t/**\n\t\t * If a space character is not defined in the sprite sheet, then empty pixels equal to\n\t\t * spaceWidth will be inserted instead. If 0, then it will use a value calculated\n\t\t * by checking for the width of the "1", "l", "E", or "A" character (in that order). If\n\t\t * those characters are not defined, it will use the width of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property spaceWidth\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.spaceWidth = 0;\n\t\t\n\t\t\n\t// private properties:\n\t \t/**\n\t\t * @property _oldProps\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};\n\t}\n\tvar p = createjs.extend(BitmapText, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// static properties:\n\t/**\n\t * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains\n\t * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be\n\t * retained, slightly increasing memory use, but reducing instantiation.\n\t * @property maxPoolSize\n\t * @type Number\n\t * @static\n\t * @default 100\n\t **/\n\tBitmapText.maxPoolSize = 100;\n\t\n\t/**\n\t * Sprite object pool.\n\t * @type {Array}\n\t * @static\n\t * @private\n\t */\n\tBitmapText._spritePool = [];\n\n\t\n// public methods:\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return; }\n\t\tthis._updateText();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.getBounds = function() {\n\t\tthis._updateText();\n\t\treturn this.Container_getBounds();\n\t};\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);\n\t};\n\t\n\tp.clone = function() {\n\t\treturn this._cloneProps(new BitmapText(this.text, this.spriteSheet));\n\t};\n\t\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeAllChildren\n\t **/\n\tp.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};\n\n\n// private methods:\n \t/**\n\t * @method _cloneProps\n\t * @param {BitmapText} o\n\t * @return {BitmapText} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.Container__cloneProps(o);\n\t\to.lineHeight = this.lineHeight;\n\t\to.letterSpacing = this.letterSpacing;\n\t\to.spaceWidth = this.spaceWidth;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * @method _getFrameIndex\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getFrameIndex = function(character, spriteSheet) {\n\t\tvar c, o = spriteSheet.getAnimation(character);\n\t\tif (!o) {\n\t\t\t(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);\n\t\t\tif (c) { o = spriteSheet.getAnimation(c); }\n\t\t}\n\t\treturn o && o.frames[0];\n\t};\n\t\n\t/**\n\t * @method _getFrame\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._getFrame = function(character, spriteSheet) {\n\t\tvar index = this._getFrameIndex(character, spriteSheet);\n\t\treturn index == null ? index : spriteSheet.getFrame(index);\n\t};\n\t\n\t/**\n\t * @method _getLineHeight\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getLineHeight = function(ss) {\n\t\tvar frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.height : 1;\n\t};\n\t/**\n\t * @method _getSpaceWidth\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getSpaceWidth = function(ss) {\n\t\tvar frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.width : 1;\n\t};\n\t\n\t/**\n\t * @method _drawText\n\t * @protected\n\t **/\n\tp._updateText = function() {\n\t\tvar x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;\n\t\tvar pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;\n\t\t\n\t\tfor (var n in o) {\n\t\t\tif (o[n] != this[n]) {\n\t\t\t\to[n] = this[n];\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\t\tif (!change) { return; }\n\t\t\n\t\tvar hasSpace = !!this._getFrame(" ", ss);\n\t\tif (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }\n\t\tif (!lineH) { lineH = this._getLineHeight(ss); }\n\t\t\n\t\tfor(var i=0, l=this.text.length; i<l; i++) {\n\t\t\tvar character = this.text.charAt(i);\n\t\t\tif (character == " " && !hasSpace) {\n\t\t\t\tx += spaceW;\n\t\t\t\tcontinue;\n\t\t\t} else if (character=="\\n" || character=="\\r") {\n\t\t\t\tif (character=="\\r" && this.text.charAt(i+1) == "\\n") { i++; } // crlf\n\t\t\t\tx = 0;\n\t\t\t\ty += lineH;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar index = this._getFrameIndex(character, ss);\n\t\t\tif (index == null) { continue; }\n\t\t\t\n\t\t\tif (childIndex < numKids) {\n\t\t\t\tsprite = kids[childIndex];\n\t\t\t} else {\n\t\t\t\tkids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());\n\t\t\t\tsprite.parent = this;\n\t\t\t\tnumKids++;\n\t\t\t}\n\t\t\tsprite.spriteSheet = ss;\n\t\t\tsprite.gotoAndStop(index);\n\t\t\tsprite.x = x;\n\t\t\tsprite.y = y;\n\t\t\tchildIndex++;\n\t\t\t\n\t\t\tx += sprite.getBounds().width + this.letterSpacing;\n\t\t}\n\t\twhile (numKids > childIndex) {\n\t\t\t // faster than removeChild.\n\t\t\tpool.push(sprite = kids.pop());\n\t\t\tsprite.parent = null;\n\t\t\tnumKids--;\n\t\t}\n\t\tif (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }\n\t};\n\n\n\tcreatejs.BitmapText = createjs.promote(BitmapText, "Container");\n}());\n\n//##############################################################################\n// MovieClip.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink "Container"}}{{/crossLink}}. It allows\n\t * you to create objects which encapsulate timeline animations, state changes, and synched actions. Due to the\n\t * complexities inherent in correctly setting up a MovieClip, it is largely intended for tool output and is not included\n\t * in the main EaselJS library.\n\t *\n\t * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have\n\t * been made to support time-based timelines in the future.\n\t *\n\t * <h4>Example</h4>\n\t * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in\n\t * the animation using {{#crossLink "MovieClip/gotoAndPlay"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage("canvas");\n\t *      createjs.Ticker.addEventListener("tick", stage);\n\t *\n\t *      var mc = new createjs.MovieClip(null, 0, true, {start:20});\n\t *      stage.addChild(mc);\n\t *\n\t *      var child1 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill("#999999")\n\t *              .drawCircle(30,30,30));\n\t *      var child2 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill("#5a9cfb")\n\t *              .drawCircle(30,30,30));\n\t *\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child1)\n\t *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child2)\n\t *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));\n\t *\n\t *      mc.gotoAndPlay("start");\n\t *\n\t * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set\n\t * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the\n\t * <code>tween.set()</code> method to affect properties will likely not provide the desired result.\n\t *\n\t * @class MovieClip\n\t * @main MovieClip\n\t * @extends Container\n\t * @constructor\n\t * @param {String} [mode=independent] Initial value for the mode property. One of {{#crossLink "MovieClip/INDEPENDENT:property"}}{{/crossLink}},\n\t * {{#crossLink "MovieClip/SINGLE_FRAME:property"}}{{/crossLink}}, or {{#crossLink "MovieClip/SYNCHED:property"}}{{/crossLink}}.\n\t * The default is {{#crossLink "MovieClip/INDEPENDENT:property"}}{{/crossLink}}.\n\t * @param {Number} [startPosition=0] Initial value for the {{#crossLink "MovieClip/startPosition:property"}}{{/crossLink}}\n\t * property.\n\t * @param {Boolean} [loop=true] Initial value for the {{#crossLink "MovieClip/loop:property"}}{{/crossLink}}\n\t * property. The default is `true`.\n\t * @param {Object} [labels=null] A hash of labels to pass to the {{#crossLink "MovieClip/timeline:property"}}{{/crossLink}}\n\t * instance associated with this MovieClip. Labels only need to be passed if they need to be used.\n\t **/\n\tfunction MovieClip(mode, startPosition, loop, labels) {\n\t\tthis.Container_constructor();\n\t\t!MovieClip.inited&&MovieClip.init(); // static init\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n\t\t * See each constant for a description of the behaviour.\n\t\t * @property mode\n\t\t * @type String\n\t\t * @default null\n\t\t **/\n\t\tthis.mode = mode||MovieClip.INDEPENDENT;\n\t\n\t\t/**\n\t\t * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n\t\t * @property startPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.startPosition = startPosition || 0;\n\t\n\t\t/**\n\t\t * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.loop = loop;\n\t\n\t\t/**\n\t\t * The current frame of the movieclip.\n\t\t * @property currentFrame\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip\n\t\t * instance is initialized. Animations are created by adding <a href="http://tweenjs.com">TweenJS</a> Tween\n\t\t * instances to the timeline.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);\n\t\t *      var mc = new createjs.MovieClip();\n\t\t *      mc.timeline.addTween(tween);\n\t\t *\n\t\t * Elements can be added and removed from the timeline by toggling an "_off" property\n\t\t * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to\n\t\t * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for\n\t\t * frame 1. You can use the "visible" property to achieve the same effect.\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({_off:false})\n\t\t *          .wait(1).to({_off:true})\n\t\t *          .wait(1).to({_off:false});\n\t\t *\n\t\t * @property timeline\n\t\t * @type Timeline\n\t\t * @default null\n\t\t */\n\t\tthis.timeline = new createjs.Timeline(null, labels, {paused:true, position:startPosition, useTicks:true});\n\t\n\t\t/**\n\t\t * If true, the MovieClip\'s position will not advance when ticked.\n\t\t * @property paused\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\t\n\t\t/**\n\t\t * If true, actions in this MovieClip\'s tweens will be run when the playhead advances.\n\t\t * @property actionsEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.actionsEnabled = true;\n\t\n\t\t/**\n\t\t * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n\t\t * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n\t\t * <br><br>\n\t\t * For example, if you had a character animation with a "body" child MovieClip instance\n\t\t * with different costumes on each frame, you could set body.autoReset = false, so that\n\t\t * you can manually change the frame it is on, without worrying that it will be reset\n\t\t * automatically.\n\t\t * @property autoReset\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\t\t\n\t\t/**\n\t\t * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.\n\t\t * @property frameBounds\n\t\t * @type Array\n\t\t * @default null\n\t\t */\n\t\tthis.frameBounds = this.frameBounds||null; // TODO: Deprecated. This is for backwards support of FlashCC\n\t\t\n\t\t/**\n\t\t * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n\t\t * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being\n\t\t * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis.framerate = null;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _synchOffset\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._synchOffset = 0;\n\t\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @private\n\t\t */\n\t\tthis._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\t\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The time remaining from the previous tick, only applicable when .framerate is set.\n\t\t * @property _t\n\t\t * @type Number\n\t\t * @private\n\t\t */\n\t\tthis._t = 0;\n\t\n\t\t/**\n\t\t * List of display objects that are actively being managed by the MovieClip.\n\t\t * @property _managed\n\t\t * @type Object\n\t\t * @private\n\t\t */\n\t\tthis._managed = {};\n\t}\n\tvar p = createjs.extend(MovieClip, createjs.Container);\n\n\n// constants:\n\t/**\n\t * The MovieClip will advance independently of its parent, even if its parent is paused.\n\t * This is the default mode.\n\t * @property INDEPENDENT\n\t * @static\n\t * @type String\n\t * @default "independent"\n\t * @readonly\n\t **/\n\tMovieClip.INDEPENDENT = "independent";\n\n\t/**\n\t * The MovieClip will only display a single frame (as determined by the startPosition property).\n\t * @property SINGLE_FRAME\n\t * @static\n\t * @type String\n\t * @default "single"\n\t * @readonly\n\t **/\n\tMovieClip.SINGLE_FRAME = "single";\n\n\t/**\n\t * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n\t * the parent MovieClip.\n\t * @property SYNCHED\n\t * @static\n\t * @type String\n\t * @default "synched"\n\t * @readonly\n\t **/\n\tMovieClip.SYNCHED = "synched";\n\t\n\t\n// static properties:\n\tMovieClip.inited = false;\n\t\n\t\n// static methods:\n\tMovieClip.init = function() {\n\t\tif (MovieClip.inited) { return; }\n\t\t// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.\n\t\tMovieClipPlugin.install();\n\t\tMovieClip.inited = true;\n\t};\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink "MovieClip/labels:property"}}{{/crossLink}} property instead.\n\t * @method getLabels\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getLabels = function() {\n\t\treturn this.timeline.getLabels();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink "MovieClip/currentLabel:property"}}{{/crossLink}} property instead.\n\t * @method getCurrentLabel\n\t * @return {String}\n\t * @deprecated\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tthis._updateTimeline();\n\t\treturn this.timeline.getCurrentLabel();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink "MovieClip/duration:property"}}{{/crossLink}} property instead.\n\t * @method getDuration\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp.getDuration = function() {\n\t\treturn this.timeline.duration;\n\t};\n\n\t/**\n\t * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n\t * Shortcut to TweenJS: Timeline.getLabels();\n\t * @property labels\n\t * @type {Array}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the name of the label on or immediately before the current frame. See TweenJS: Timeline.getCurrentLabel()\n\t * for more information.\n\t * @property currentLabel\n\t * @type {String}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks. Identical to {{#crossLink "MovieClip/duration:property"}}{{/crossLink}}\n\t * and provided for Flash API compatibility.\n\t * @property totalFrames\n\t * @type {Number}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks.\n\t * @property duration\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlabels: { get: p.getLabels },\n\t\t\tcurrentLabel: { get: p.getCurrentLabel },\n\t\t\ttotalFrames: { get: p.getDuration },\n\t\t\tduration: { get: p.getDuration }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of FlashCC\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\t// children are placed in draw, so we can\'t determine if we have content.\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// draw to cache first:\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._updateTimeline();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Sets paused to false.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * Sets paused to true.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to false.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to true.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The animation or frame name to go to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\t// TODO: should we worry at all about clips who change their own modes via frame scripts?\n\t\tvar independent = MovieClip.INDEPENDENT;\n\t\tif (this.mode != independent) { return; }\n\t\t\n\t\tvar o=this, fps = o.framerate;\n\t\twhile ((o = o.parent) && fps == null) {\n\t\t\tif (o.mode == independent) { fps = o._framerate; }\n\t\t}\n\t\tthis._framerate = fps;\n\t\t\n\t\tvar t = (fps != null && fps != -1 && time != null) ? time/(1000/fps) + this._t : 1;\n\t\tvar frames = t|0;\n\t\tthis._t = t-frames; // leftover time\n\t\t\n\t\twhile (!this.paused && frames--) {\n\t\t\tthis._prevPosition = (this._prevPos < 0) ? 0 : this._prevPosition+1;\n\t\t\tthis._updateTimeline();\n\t\t}\n\t};\n\t\n\t/**\n\t * MovieClip instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\t// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.\n\t\tthrow("MovieClip cannot be cloned.")\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[MovieClip (name="+  this.name +")]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tthis.advance(evtObj&&evtObj.delta);\n\t\tthis.Container__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _goto\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.timeline.resolve(positionOrLabel);\n\t\tif (pos == null) { return; }\n\t\t// prevent _updateTimeline from overwriting the new position because of a reset:\n\t\tif (this._prevPos == -1) { this._prevPos = NaN; }\n\t\tthis._prevPosition = pos;\n\t\tthis._t = 0;\n\t\tthis._updateTimeline();\n\t};\n\t\n\t/**\n\t * @method _reset\n\t * @private\n\t **/\n\tp._reset = function() {\n\t\tthis._prevPos = -1;\n\t\tthis._t = this.currentFrame = 0;\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * @method _updateTimeline\n\t * @protected\n\t **/\n\tp._updateTimeline = function() {\n\t\tvar tl = this.timeline;\n\t\tvar synched = this.mode != MovieClip.INDEPENDENT;\n\t\ttl.loop = (this.loop==null) ? true : this.loop;\n\t\t\n\t\tvar pos = synched ? this.startPosition + (this.mode==MovieClip.SINGLE_FRAME?0:this._synchOffset) : (this._prevPos < 0 ? 0 : this._prevPosition);\n\t\tvar mode = synched || !this.actionsEnabled ? createjs.Tween.NONE : null;\n\t\t\n\t\t// pre-assign currentFrame so it is available to frame scripts:\n\t\tthis.currentFrame = tl._calcPosition(pos);\n\t\t\n\t\t// update timeline position, ignoring actions if this is a graphic.\n\t\ttl.setPosition(pos, mode);\n\n\t\tthis._prevPosition = tl._prevPosition;\n\t\tif (this._prevPos == tl._prevPos) { return; }\n\t\tthis.currentFrame = this._prevPos = tl._prevPos;\n\n\t\tfor (var n in this._managed) { this._managed[n] = 1; }\n\n\t\tvar tweens = tl._tweens;\n\t\tfor (var i=0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\tvar target = tween._target;\n\t\t\tif (target == this || tween.passive) { continue; } // TODO: this assumes actions tween has this as the target. Valid?\n\t\t\tvar offset = tween._stepPosition;\n\n\t\t\tif (target instanceof createjs.DisplayObject) {\n\t\t\t\t// motion tween.\n\t\t\t\tthis._addManagedChild(target, offset);\n\t\t\t} else {\n\t\t\t\t// state tween.\n\t\t\t\tthis._setState(target.state, offset);\n\t\t\t}\n\t\t}\n\n\t\tvar kids = this.children;\n\t\tfor (i=kids.length-1; i>=0; i--) {\n\t\t\tvar id = kids[i].id;\n\t\t\tif (this._managed[id] == 1) {\n\t\t\t\tthis.removeChildAt(i);\n\t\t\t\tdelete(this._managed[id]);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _setState\n\t * @param {Array} state\n\t * @param {Number} offset\n\t * @protected\n\t **/\n\tp._setState = function(state, offset) {\n\t\tif (!state) { return; }\n\t\tfor (var i=state.length-1;i>=0;i--) {\n\t\t\tvar o = state[i];\n\t\t\tvar target = o.t;\n\t\t\tvar props = o.p;\n\t\t\tfor (var n in props) { target[n] = props[n]; }\n\t\t\tthis._addManagedChild(target, offset);\n\t\t}\n\t};\n\n\t/**\n\t * Adds a child to the timeline, and sets it up as a managed child.\n\t * @method _addManagedChild\n\t * @param {MovieClip} child The child MovieClip to manage\n\t * @param {Number} offset\n\t * @private\n\t **/\n\tp._addManagedChild = function(child, offset) {\n\t\tif (child._off) { return; }\n\t\tthis.addChildAt(child,0);\n\n\t\tif (child instanceof MovieClip) {\n\t\t\tchild._synchOffset = offset;\n\t\t\t// TODO: this does not precisely match Flash. Flash loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.\n\t\t\tif (child.mode == MovieClip.INDEPENDENT && child.autoReset && !this._managed[child.id]) { child._reset(); }\n\t\t}\n\t\tthis._managed[child.id] = 2;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (!bounds) {\n\t\t\tthis._updateTimeline();\n\t\t\tif (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }\n\t\t}\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\treturn this.Container__getBounds(matrix, ignoreTransform);\n\t};\n\n\n\tcreatejs.MovieClip = createjs.promote(MovieClip, "Container");\n\n\n\n// MovieClipPlugin for TweenJS:\n\t/**\n\t * This plugin works with <a href="http://tweenjs.com" target="_blank">TweenJS</a> to prevent the startPosition\n\t * property from tweening.\n\t * @private\n\t * @class MovieClipPlugin\n\t * @constructor\n\t **/\n\tfunction MovieClipPlugin() {\n\t\tthrow("MovieClipPlugin cannot be instantiated.")\n\t}\n\t\n\t/**\n\t * @method priority\n\t * @private\n\t **/\n\tMovieClipPlugin.priority = 100; // very high priority, should run first\n\n\t/**\n\t * @method install\n\t * @private\n\t **/\n\tMovieClipPlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MovieClipPlugin, ["startPosition"]);\n\t};\n\t\n\t/**\n\t * @method init\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String|Number|Boolean} value\n\t * @private\n\t **/\n\tMovieClipPlugin.init = function(tween, prop, value) {\n\t\treturn value;\n\t};\n\t\n\t/**\n\t * @method step\n\t * @private\n\t **/\n\tMovieClipPlugin.step = function() {\n\t\t// unused.\n\t};\n\n\t/**\n\t * @method tween\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String | Number | Boolean} value\n\t * @param {Array} startValues\n\t * @param {Array} endValues\n\t * @param {Number} ratio\n\t * @param {Object} wait\n\t * @param {Object} end\n\t * @return {*}\n\t */\n\tMovieClipPlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tif (!(tween.target instanceof MovieClip)) { return value; }\n\t\treturn (ratio == 1 ? endValues[prop] : startValues[prop]);\n\t};\n\n}());\n\n//##############################################################################\n// SpriteSheetUtils.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\t\n\t\n// constructor:\n\t/**\n\t * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.\n\t * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For\n\t * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across\n\t * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.\n\t * @class SpriteSheetUtils\n\t * @static\n\t **/\n\tfunction SpriteSheetUtils() {\n\t\tthrow "SpriteSheetUtils cannot be instantiated";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _workingCanvas\n\t * @static\n\t * @type HTMLCanvasElement | Object\n\t * @protected\n\t*/\n\t/**\n\t * @property _workingContext\n\t * @static\n\t * @type CanvasRenderingContext2D\n\t * @protected\n\t*/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));\n\tif (canvas.getContext) {\n\t\tSpriteSheetUtils._workingCanvas = canvas;\n\t\tSpriteSheetUtils._workingContext = canvas.getContext("2d");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// public static methods:\n\t/**\n\t * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>\n\t * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,\n\t * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names\n\t * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.\n\t * <br/><br/>\n\t * For example:<br/>\n\t * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);\n\t * The above would add frames that are flipped horizontally AND frames that are flipped vertically.\n\t * <br/><br/>\n\t * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some\n\t * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,\n\t * which is why addFlippedFrames is available.\n\t * @method addFlippedFrames\n\t * @static\n\t * @param {SpriteSheet} spriteSheet\n\t * @param {Boolean} horizontal If true, horizontally flipped frames will be added.\n\t * @param {Boolean} vertical If true, vertically flipped frames will be added.\n\t * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.\n\t * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.\n\t **/\n\tSpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {\n\t\tif (!horizontal && !vertical && !both) { return; }\n\n\t\tvar count = 0;\n\t\tif (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }\n\t\tif (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }\n\t\tif (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }\n\t};\n\n\t/**\n\t * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is\n\t * to use a spritesheet frame as the source for a bitmap fill.\n\t *\n\t * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}\n\t * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this\n\t * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}\n\t * property of {{#crossLink "Bitmap"}}{{/crossLink}}.\n\t *\n\t * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.\n\t * @method extractFrame\n\t * @static\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.\n\t * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation\n\t * name is specified, only the first frame of the animation will be extracted.\n\t * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.\n\t*/\n\tSpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tframeOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];\n\t\t}\n\t\tvar data = spriteSheet.getFrame(frameOrAnimation);\n\t\tif (!data) { return null; }\n\t\tvar r = data.rect;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tcanvas.width = r.width;\n\t\tcanvas.height = r.height;\n\t\tSpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);\n\t\tvar img = document.createElement("img");\n\t\timg.src = canvas.toDataURL("image/png");\n\t\treturn img;\n\t};\n\n\t/**\n\t * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed\n\t * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of\n\t * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings\n\t * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).\n\t * @method mergeAlpha\n\t * @static\n\t * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.\n\t * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.\n\t * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.\n\t * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.\n\t * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.\n\t*/\n\tSpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {\n\t\tif (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }\n\t\tcanvas.width = Math.max(alphaImage.width, rgbImage.width);\n\t\tcanvas.height = Math.max(alphaImage.height, rgbImage.height);\n\t\tvar ctx = canvas.getContext("2d");\n\t\tctx.save();\n\t\tctx.drawImage(rgbImage,0,0);\n\t\tctx.globalCompositeOperation = "destination-in";\n\t\tctx.drawImage(alphaImage,0,0);\n\t\tctx.restore();\n\t\treturn canvas;\n\t};\n\n\n// private static methods:\n\tSpriteSheetUtils._flip = function(spriteSheet, count, h, v) {\n\t\tvar imgs = spriteSheet._images;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tvar ctx = SpriteSheetUtils._workingContext;\n\t\tvar il = imgs.length/count;\n\t\tfor (var i=0;i<il;i++) {\n\t\t\tvar src = imgs[i];\n\t\t\tsrc.__tmp = i; // a bit hacky, but faster than doing indexOf below.\n\t\t\tctx.setTransform(1,0,0,1,0,0);\n\t\t\tctx.clearRect(0,0,canvas.width+1,canvas.height+1);\n\t\t\tcanvas.width = src.width;\n\t\t\tcanvas.height = src.height;\n\t\t\tctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);\n\t\t\tctx.drawImage(src,0,0);\n\t\t\tvar img = document.createElement("img");\n\t\t\timg.src = canvas.toDataURL("image/png");\n\t\t\t// work around a strange bug in Safari:\n\t\t\timg.width = src.width;\n\t\t\timg.height = src.height;\n\t\t\timgs.push(img);\n\t\t}\n\n\t\tvar frames = spriteSheet._frames;\n\t\tvar fl = frames.length/count;\n\t\tfor (i=0;i<fl;i++) {\n\t\t\tsrc = frames[i];\n\t\t\tvar rect = src.rect.clone();\n\t\t\timg = imgs[src.image.__tmp+il*count];\n\n\t\t\tvar frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};\n\t\t\tif (h) {\n\t\t\t\trect.x = img.width-rect.x-rect.width; // update rect\n\t\t\t\tframe.regX = rect.width-src.regX; // update registration point\n\t\t\t}\n\t\t\tif (v) {\n\t\t\t\trect.y = img.height-rect.y-rect.height;  // update rect\n\t\t\t\tframe.regY = rect.height-src.regY; // update registration point\n\t\t\t}\n\t\t\tframes.push(frame);\n\t\t}\n\n\t\tvar sfx = "_"+(h?"h":"")+(v?"v":"");\n\t\tvar names = spriteSheet._animations;\n\t\tvar data = spriteSheet._data;\n\t\tvar al = names.length/count;\n\t\tfor (i=0;i<al;i++) {\n\t\t\tvar name = names[i];\n\t\t\tsrc = data[name];\n\t\t\tvar anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};\n\t\t\tif (src.next) { anim.next += sfx; }\n\t\t\tframes = src.frames;\n\t\t\tfor (var j=0,l=frames.length;j<l;j++) {\n\t\t\t\tanim.frames.push(frames[j]+fl*count);\n\t\t\t}\n\t\t\tdata[anim.name] = anim;\n\t\t\tnames.push(anim.name);\n\t\t}\n\t};\n\n\n\tcreatejs.SpriteSheetUtils = SpriteSheetUtils;\n}());\n\n//##############################################################################\n// SpriteSheetBuilder.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * The SpriteSheetBuilder allows you to generate {{#crossLink "SpriteSheet"}}{{/crossLink}} instances at run time\n\t * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and\n\t * render them at run time as SpriteSheets for better performance.\n\t *\n\t * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated\n\t * without locking the UI.\n\t *\n\t * Note that the "images" used in the generated SpriteSheet are actually canvas elements, and that they will be\n\t * sized to the nearest power of 2 up to the value of {{#crossLink "SpriteSheetBuilder/maxWidth:property"}}{{/crossLink}}\n\t * or {{#crossLink "SpriteSheetBuilder/maxHeight:property"}}{{/crossLink}}.\n\t * @class SpriteSheetBuilder\n\t * @param {Number} [framerate=0] The {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} of\n\t * {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are created.\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction SpriteSheetBuilder(framerate) {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t * @default 2048\n\t\t*/\n\t\tthis.maxWidth = 2048;\n\t\n\t\t/**\n\t\t * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxHeight\n\t\t * @type Number\n\t\t * @default 2048\n\t\t **/\n\t\tthis.maxHeight = 2048;\n\t\n\t\t/**\n\t\t * The SpriteSheet that was generated. This will be null before a build is completed successfully.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t **/\n\t\tthis.spriteSheet = null;\n\t\n\t\t/**\n\t\t * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified\n\t\t * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored\n\t\t * to the a specific device resolution (ex. tablet vs mobile).\n\t\t * @property scale\n\t\t * @type Number\n\t\t * @default 1\n\t\t **/\n\t\tthis.scale = 1;\n\t\n\t\t/**\n\t\t* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.\n\t\t* @property padding\n\t\t* @type Number\n\t\t* @default 1\n\t\t**/\n\t\tthis.padding = 1;\n\t\n\t\t/**\n\t\t * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be\n\t\t * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,\n\t\t * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).\n\t\t * Defaults to 0.3.\n\t\t * @property timeSlice\n\t\t * @type Number\n\t\t * @default 0.3\n\t\t **/\n\t\tthis.timeSlice = 0.3;\n\t\n\t\t/**\n\t\t * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not\n\t\t * been initiated.\n\t\t * @property progress\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.progress = -1;\n\n\t\t/**\n\t\t * A {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} value that will be passed to new {{#crossLink "SpriteSheet"}}{{/crossLink}} instances that are\n\t\t * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink "Ticker"}}{{/crossLink}}\n\t\t * framerate.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = framerate || 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = [];\n\t\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = {};\n\t\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._data = null;\n\t\n\t\t/**\n\t\t * @property _nextFrameIndex\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._nextFrameIndex = 0;\n\t\n\t\t/**\n\t\t * @property _index\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._index = 0;\n\t\n\t\t/**\n\t\t * @property _timerID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._timerID = null;\n\t\n\t\t/**\n\t\t * @property _scale\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._scale = 1;\n\t}\n\tvar p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\tSpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";\n\tSpriteSheetBuilder.ERR_RUNNING = "a build is already running";\n\n// events:\n\t/**\n\t * Dispatched when a build completes.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when an asynchronous build has progress.\n\t * @event progress\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Number} progress The current progress value (0-1).\n\t * @since 0.6.0\n\t */\n\n\n// public methods:\n\t/**\n\t * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you\n\t * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have\n\t * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple\n\t * times, but manipulate it or its children to change it to generate different frames.\n\t *\n\t * Note that the source\'s transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply\n\t * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}\n\t * and pass in the Container as the source.\n\t * @method addFrame\n\t * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the\n\t * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or\n\t * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.\n\t * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.\n\t **/\n\tp.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect) { return null; }\n\t\tscale = scale||1;\n\t\treturn this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;\n\t};\n\n\t/**\n\t * Adds an animation that will be included in the created {{#crossLink "SpriteSheet"}}{{/crossLink}}.\n\t * @method addAnimation\n\t * @param {String} name The name for the animation.\n\t * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation\n\t * that played frame indexes 3, 6, and 5 in that order.\n\t * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can\n\t * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.\n\t * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would\n\t * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had\n\t * the opposite effect.\n\t **/\n\tp.addAnimation = function(name, frames, next, speed) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._animations[name] = {frames:frames, next:next, speed:speed};\n\t};\n\n\t/**\n\t * This will take a {{#crossLink "MovieClip"}}{{/crossLink}} instance, and add its frames and labels to this\n\t * builder. Labels will be added as an animation running from the label index to the next label. For example, if\n\t * there is a label named "foo" at frame 0 and a label named "bar" at frame 10, in a MovieClip with 15 frames, it\n\t * will add an animation named "foo" that runs from frame index 0 to 9, and an animation named "bar" that runs from\n\t * frame index 10 to 14.\n\t *\n\t * Note that this will iterate through the full MovieClip with {{#crossLink "MovieClip/actionsEnabled:property"}}{{/crossLink}}\n\t * set to `false`, ending on the last frame.\n\t * @method addMovieClip\n\t * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to\n\t * draw to the frame. If not specified, it will look for a {{#crossLink "DisplayObject/getBounds"}}{{/crossLink}}\n\t * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not\n\t * found, the MovieClip will be skipped.\n\t * @param {Number} [scale=1] The scale to draw the movie clip at.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called\n\t * with three parameters: the source, setupData, and the frame index.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four\n\t * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)\n\t * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.\n\t **/\n\tp.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rects = source.frameBounds;\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect && !rects) { return; }\n\n\t\tvar i, l, baseFrameIndex = this._frames.length;\n\t\tvar duration = source.timeline.duration;\n\t\tfor (i=0; i<duration; i++) {\n\t\t\tvar r = (rects&&rects[i]) ? rects[i] : rect;\n\t\t\tthis.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});\n\t\t}\n\t\tvar labels = source.timeline._labels;\n\t\tvar lbls = [];\n\t\tfor (var n in labels) {\n\t\t\tlbls.push({index:labels[n], label:n});\n\t\t}\n\t\tif (lbls.length) {\n\t\t\tlbls.sort(function(a,b){ return a.index-b.index; });\n\t\t\tfor (i=0,l=lbls.length; i<l; i++) {\n\t\t\t\tvar label = lbls[i].label;\n\t\t\t\tvar start = baseFrameIndex+lbls[i].index;\n\t\t\t\tvar end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);\n\t\t\t\tvar frames = [];\n\t\t\t\tfor (var j=start; j<end; j++) { frames.push(j); }\n\t\t\t\tif (labelFunction) {\n\t\t\t\t\tlabel = labelFunction(label, source, start, end);\n\t\t\t\t\tif (!label) { continue; }\n\t\t\t\t}\n\t\t\t\tthis.addAnimation(label, frames, true); // for now, this loops all animations.\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames.\n\t * @method build\n\t * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error\n\t * occurred.\n\t **/\n\tp.build = function() {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._startBuild();\n\t\twhile (this._drawNext()) {}\n\t\tthis._endBuild();\n\t\treturn this.spriteSheet;\n\t};\n\n\t/**\n\t * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will\n\t * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the\n\t * specified callback.\n\t * @method buildAsync\n\t * @param {Number} [timeSlice] Sets the timeSlice property on this instance.\n\t **/\n\tp.buildAsync = function(timeSlice) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis.timeSlice = timeSlice;\n\t\tthis._startBuild();\n\t\tvar _this = this;\n\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);\n\t};\n\n\t/**\n\t * Stops the current asynchronous build.\n\t * @method stopAsync\n\t **/\n\tp.stopAsync = function() {\n\t\tclearTimeout(this._timerID);\n\t\tthis._data = null;\n\t};\n\n\t/**\n\t * SpriteSheetBuilder instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow("SpriteSheetBuilder cannot be cloned.");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[SpriteSheetBuilder]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _startBuild\n\t * @protected\n\t **/\n\tp._startBuild = function() {\n\t\tvar pad = this.padding||0;\n\t\tthis.progress = 0;\n\t\tthis.spriteSheet = null;\n\t\tthis._index = 0;\n\t\tthis._scale = this.scale;\n\t\tvar dataFrames = [];\n\t\tthis._data = {\n\t\t\timages: [],\n\t\t\tframes: dataFrames,\n\t\t\tframerate: this.framerate,\n\t\t\tanimations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?\n\t\t};\n\n\t\tvar frames = this._frames.slice();\n\t\tframes.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });\n\n\t\tif (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\tvar y=0, x=0;\n\t\tvar img = 0;\n\t\twhile (frames.length) {\n\t\t\tvar o = this._fillRow(frames, y, img, dataFrames, pad);\n\t\t\tif (o.w > x) { x = o.w; }\n\t\t\ty += o.h;\n\t\t\tif (!o.h || !frames.length) {\n\t\t\t\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");\n\t\t\t\tcanvas.width = this._getSize(x,this.maxWidth);\n\t\t\t\tcanvas.height = this._getSize(y,this.maxHeight);\n\t\t\t\tthis._data.images[img] = canvas;\n\t\t\t\tif (!o.h) {\n\t\t\t\t\tx=y=0;\n\t\t\t\t\timg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _setupMovieClipFrame\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._setupMovieClipFrame = function(source, data) {\n\t\tvar ae = source.actionsEnabled;\n\t\tsource.actionsEnabled = false;\n\t\tsource.gotoAndStop(data.i);\n\t\tsource.actionsEnabled = ae;\n\t\tdata.f&&data.f(source, data.d, data.i);\n\t};\n\n\t/**\n\t * @method _getSize\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._getSize = function(size,max) {\n\t\tvar pow = 4;\n\t\twhile (Math.pow(2,++pow) < size){}\n\t\treturn Math.min(max,Math.pow(2,pow));\n\t};\n\n\t/**\n\t * @method _fillRow\n\t * @param {Array} frames\n\t * @param {Number} y\n\t * @param {HTMLImageElement} img\n\t * @param {Object} dataFrames\n\t * @param {Number} pad\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._fillRow = function(frames, y, img, dataFrames, pad) {\n\t\tvar w = this.maxWidth;\n\t\tvar maxH = this.maxHeight;\n\t\ty += pad;\n\t\tvar h = maxH-y;\n\t\tvar x = pad;\n\t\tvar height = 0;\n\t\tfor (var i=frames.length-1; i>=0; i--) {\n\t\t\tvar frame = frames[i];\n\t\t\tvar sc = this._scale*frame.scale;\n\t\t\tvar rect = frame.sourceRect;\n\t\t\tvar source = frame.source;\n\t\t\tvar rx = Math.floor(sc*rect.x-pad);\n\t\t\tvar ry = Math.floor(sc*rect.y-pad);\n\t\t\tvar rh = Math.ceil(sc*rect.height+pad*2);\n\t\t\tvar rw = Math.ceil(sc*rect.width+pad*2);\n\t\t\tif (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\t\tif (rh > h || x+rw > w) { continue; }\n\t\t\tframe.img = img;\n\t\t\tframe.rect = new createjs.Rectangle(x,y,rw,rh);\n\t\t\theight = height || rh;\n\t\t\tframes.splice(i,1);\n\t\t\tdataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];\n\t\t\tx += rw;\n\t\t}\n\t\treturn {w:x, h:height};\n\t};\n\n\t/**\n\t * @method _endBuild\n\t * @protected\n\t **/\n\tp._endBuild = function() {\n\t\tthis.spriteSheet = new createjs.SpriteSheet(this._data);\n\t\tthis._data = null;\n\t\tthis.progress = 1;\n\t\tthis.dispatchEvent("complete");\n\t};\n\n\t/**\n\t * @method _run\n\t * @protected\n\t **/\n\tp._run = function() {\n\t\tvar ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;\n\t\tvar t = (new Date()).getTime()+ts;\n\t\tvar complete = false;\n\t\twhile (t > (new Date()).getTime()) {\n\t\t\tif (!this._drawNext()) { complete = true; break; }\n\t\t}\n\t\tif (complete) {\n\t\t\tthis._endBuild();\n\t\t} else {\n\t\t\tvar _this = this;\n\t\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-ts);\n\t\t}\n\t\tvar p = this.progress = this._index/this._frames.length;\n\t\tif (this.hasEventListener("progress")) {\n\t\t\tvar evt = new createjs.Event("progress");\n\t\t\tevt.progress = p;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t};\n\n\t/**\n\t * @method _drawNext\n\t * @protected\n\t * @return Boolean Returns false if this is the last draw.\n\t **/\n\tp._drawNext = function() {\n\t\tvar frame = this._frames[this._index];\n\t\tvar sc = frame.scale*this._scale;\n\t\tvar rect = frame.rect;\n\t\tvar sourceRect = frame.sourceRect;\n\t\tvar canvas = this._data.images[frame.img];\n\t\tvar ctx = canvas.getContext("2d");\n\t\tframe.funct&&frame.funct(frame.source, frame.data);\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(rect.x, rect.y, rect.width, rect.height);\n\t\tctx.clip();\n\t\tctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));\n\t\tctx.scale(sc,sc);\n\t\tframe.source.draw(ctx); // display object will draw itself.\n\t\tctx.restore();\n\t\treturn (++this._index) < this._frames.length;\n\t};\n\n\n\tcreatejs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");\n}());\n\n//##############################################################################\n// DOMElement.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>\n\t *\n\t * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed\n\t * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is\n\t * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be\n\t * drawn in front of or behind the canvas).\n\t *\n\t * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that\n\t * the DOM Object be added to a div that also contains the canvas so that they share the same position\n\t * on the page.\n\t *\n\t * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements\n\t * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML\n\t * content.\n\t *\n\t * <h4>Mouse Interaction</h4>\n\t *\n\t * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse\n\t * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to\n\t * the htmlElement (note, this does not support EventDispatcher)\n\t *\n\t *      var domElement = new createjs.DOMElement(htmlElement);\n\t *      domElement.htmlElement.onclick = function() {\n\t *          console.log("clicked");\n\t *      }\n\t *\n\t * @class DOMElement\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.\n\t */\n\tfunction DOMElement(htmlElement) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\tif (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }\n\t\tthis.mouseEnabled = false;\n\t\t\n\t\tvar style = htmlElement.style;\n\t\tstyle.position = "absolute";\n\t\tstyle.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The DOM object to manage.\n\t\t * @property htmlElement\n\t\t * @type HTMLElement\n\t\t */\n\t\tthis.htmlElement = htmlElement;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _oldMtx\n\t\t * @type Matrix2D\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = null;\n\t}\n\tvar p = createjs.extend(DOMElement, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t */\n\tp.isVisible = function() {\n\t\treturn this.htmlElement != null;\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t */\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// this relies on the _tick method because draw isn\'t called if the parent is not visible.\n\t\t// the actual update happens in _handleDrawEnd\n\t\treturn true;\n\t};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method cache\n\t */\n\tp.cache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method uncache\n\t */\n\tp.uncache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method updateCache\n\t */\n\tp.updateCache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method hitTest\n\t */\n\tp.hitTest = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToGlobal\n\t */\n\tp.localToGlobal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method globalToLocal\n\t */\n\tp.globalToLocal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToLocal\n\t */\n\tp.localToLocal = function() {};\n\n\t/**\n\t * DOMElement cannot be cloned. Throws an error.\n\t * @method clone\n\t */\n\tp.clone = function() {\n\t\tthrow("DOMElement cannot be cloned.")\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn "[DOMElement (name="+  this.name +")]";\n\t};\n\n\t/**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n\t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event click\n\t */\n\n     /**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event dblClick\n\t */\n\n     /**\n      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t  * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t  * @event mousedown\n\t  */\n\n     /**\n      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.\n      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.\n      * @event mouseover\n\t  */\n\n     /**\n      * Not applicable to DOMElement.\n\t  * @event tick\n\t  */\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t */\n\tp._tick = function(evtObj) {\n\t\tvar stage = this.getStage();\n\t\tstage&&stage.on("drawend", this._handleDrawEnd, this, true);\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _handleDrawEnd\n\t * @param {Event} evt\n\t * @protected\n\t */\n\tp._handleDrawEnd = function(evt) {\n\t\tvar o = this.htmlElement;\n\t\tif (!o) { return; }\n\t\tvar style = o.style;\n\t\t\n\t\tvar props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;\n\t\t\n\t\tvar visibility = props.visible ? "visible" : "hidden";\n\t\tif (visibility != style.visibility) { style.visibility = visibility; }\n\t\tif (!props.visible) { return; }\n\t\t\n\t\tvar oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;\n\t\tvar n = 10000; // precision\n\t\t\n\t\tif (!oldMtx || !oldMtx.equals(mtx)) {\n\t\t\tvar str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);\n\t\t\tstyle.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";\n\t\t\tstyle.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";\n\t\t\tif (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }\n\t\t\toldProps.matrix.copy(mtx);\n\t\t}\n\t\t\n\t\tif (oldProps.alpha != props.alpha) {\n\t\t\tstyle.opacity = ""+(props.alpha*n|0)/n;\n\t\t\toldProps.alpha = props.alpha;\n\t\t}\n\t};\n\n\n\tcreatejs.DOMElement = createjs.promote(DOMElement, "DisplayObject");\n}());\n\n//##############################################################################\n// Filter.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using\n\t * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use\n\t * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myInstance.filters = [\n\t *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),\n\t *          new createjs.BlurFilter(5, 5, 10)\n\t *      ];\n\t *      myInstance.cache(0,0, 100, 100);\n\t *\n\t * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the\n\t * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}\n\t * will cause an object to feather outwards, resulting in a margin around the shape.\n\t *\n\t * <h4>EaselJS Filters</h4>\n\t * EaselJS comes with a number of pre-built filters:\n\t * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image\'s alpha channel to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>\n\t *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>\n\t *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>\n\t * </ul>\n\t *\n\t * @class Filter\n\t * @constructor\n\t **/\n\tfunction Filter() {}\n\tvar p = Filter.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/**\n\t * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.\n\t * @method getBounds\n\t * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.\n\t * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.\n\t **/\n\tp.getBounds = function(rect) {\n\t\treturn rect;\n\t};\n\n\t/**\n\t * Applies the filter to the specified context.\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\t// this is the default behaviour because most filters access pixel data. It is overridden when not needed.\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\t\ttry {\n\t\t\tvar imageData = ctx.getImageData(x, y, width, height);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._applyFilter(imageData)) {\n\t\t\ttargetCtx.putImageData(imageData, targetX, targetY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[Filter]";\n\t};\n\n\t/**\n\t * Returns a clone of this Filter instance.\n\t * @method clone\n\t * @return {Filter} A clone of the current Filter instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Filter();\n\t};\n\t\n// private methods:\n\t/**\n\t * @method _applyFilter\n\t * @param {ImageData} imageData Target ImageData instance.\n\t * @return {Boolean}\n\t **/\n\tp._applyFilter = function(imageData) { return true; };\n\n\n\tcreatejs.Filter = Filter;\n}());\n\n//##############################################################################\n// BlurFilter.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\n\t * set higher than 1.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}\n\t * method to account for the spread that the blur causes.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);\n\t *\n\t *      var blurFilter = new createjs.BlurFilter(5, 5, 1);\n\t *      shape.filters = [blurFilter];\n\t *      var bounds = blurFilter.getBounds();\n\t *\n\t *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.\n\t * @class BlurFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {Number} [blurX=0] The horizontal blur radius in pixels.\n\t * @param {Number} [blurY=0] The vertical blur radius in pixels.\n\t * @param {Number} [quality=1] The number of blur iterations.\n\t **/\n\tfunction BlurFilter( blurX, blurY, quality) {\n\t\tif ( isNaN(blurX) || blurX < 0 ) blurX = 0;\n\t\tif ( isNaN(blurY) || blurY < 0 ) blurY = 0;\n\t\tif ( isNaN(quality) || quality < 1  ) quality = 1;\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Horizontal blur radius in pixels\n\t\t * @property blurX\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurX = blurX | 0;\n\n\t\t/**\n\t\t * Vertical blur radius in pixels\n\t\t * @property blurY\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurY = blurY | 0;\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @property quality\n\t\t * @default 1\n\t\t * @type Number\n\t\t **/\n\t\tthis.quality = quality | 0;\n\t}\n\tvar p = createjs.extend(BlurFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// constants:\n\t/**\n\t * Array of multiply values for blur calculations.\n\t * @property MUL_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];\n\n\t/**\n\t * Array of shift values for blur calculations.\n\t * @property SHG_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];\n\n// public methods:\n\t/** docced in super class **/\n\tp.getBounds = function (rect) {\n\t\tvar x = this.blurX|0, y = this.blurY| 0;\n\t\tif (x <= 0 && y <= 0) { return rect; }\n\t\tvar q = Math.pow(this.quality, 0.2);\n\t\treturn (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new BlurFilter(this.blurX, this.blurY, this.quality);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn "[BlurFilter]";\n\t};\n\n\n// private methods:\n\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\n\t\tvar radiusX = this.blurX >> 1;\n\t\tif (isNaN(radiusX) || radiusX < 0) return false;\n\t\tvar radiusY = this.blurY >> 1;\n\t\tif (isNaN(radiusY) || radiusY < 0) return false;\n\t\tif (radiusX == 0 && radiusY == 0) return false;\n\n\t\tvar iterations = this.quality;\n\t\tif (isNaN(iterations) || iterations < 1) iterations = 1;\n\t\titerations |= 0;\n\t\tif (iterations > 3) iterations = 3;\n\t\tif (iterations < 1) iterations = 1;\n\n\t\tvar px = imageData.data;\n\t\tvar x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;\n\n\t\tvar divx = (radiusX + radiusX + 1) | 0;\n\t\tvar divy = (radiusY + radiusY + 1) | 0;\n\t\tvar w = imageData.width | 0;\n\t\tvar h = imageData.height | 0;\n\n\t\tvar w1 = (w - 1) | 0;\n\t\tvar h1 = (h - 1) | 0;\n\t\tvar rxp1 = (radiusX + 1) | 0;\n\t\tvar ryp1 = (radiusY + 1) | 0;\n\n\t\tvar ssx = {r:0,b:0,g:0,a:0};\n\t\tvar sx = ssx;\n\t\tfor ( i = 1; i < divx; i++ )\n\t\t{\n\t\t\tsx = sx.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsx.n = ssx;\n\n\t\tvar ssy = {r:0,b:0,g:0,a:0};\n\t\tvar sy = ssy;\n\t\tfor ( i = 1; i < divy; i++ )\n\t\t{\n\t\t\tsy = sy.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsy.n = ssy;\n\n\t\tvar si = null;\n\n\n\t\tvar mtx = BlurFilter.MUL_TABLE[radiusX] | 0;\n\t\tvar stx = BlurFilter.SHG_TABLE[radiusX] | 0;\n\t\tvar mty = BlurFilter.MUL_TABLE[radiusY] | 0;\n\t\tvar sty = BlurFilter.SHG_TABLE[radiusY] | 0;\n\n\t\twhile (iterations-- > 0) {\n\n\t\t\tyw = yi = 0;\n\t\t\tvar ms = mtx;\n\t\t\tvar ss = stx;\n\t\t\tfor (y = h; --y > -1;) {\n\t\t\t\tr = rxp1 * (pr = px[(yi) | 0]);\n\t\t\t\tg = rxp1 * (pg = px[(yi + 1) | 0]);\n\t\t\t\tb = rxp1 * (pb = px[(yi + 2) | 0]);\n\t\t\t\ta = rxp1 * (pa = px[(yi + 3) | 0]);\n\n\t\t\t\tsx = ssx;\n\n\t\t\t\tfor( i = rxp1; --i > -1; )\n\t\t\t\t{\n\t\t\t\t\tsx.r = pr;\n\t\t\t\t\tsx.g = pg;\n\t\t\t\t\tsx.b = pb;\n\t\t\t\t\tsx.a = pa;\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tfor( i = 1; i < rxp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tp = (yi + ((w1 < i ? w1 : i) << 2)) | 0;\n\t\t\t\t\tr += ( sx.r = px[p]);\n\t\t\t\t\tg += ( sx.g = px[p+1]);\n\t\t\t\t\tb += ( sx.b = px[p+2]);\n\t\t\t\t\ta += ( sx.a = px[p+3]);\n\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tsi = ssx;\n\t\t\t\tfor ( x = 0; x < w; x++ )\n\t\t\t\t{\n\t\t\t\t\tpx[yi++] = (r * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (g * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (b * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (a * ms) >>> ss;\n\n\t\t\t\t\tp = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);\n\n\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\tsi = si.n;\n\n\t\t\t\t}\n\t\t\t\tyw += w;\n\t\t\t}\n\n\t\t\tms = mty;\n\t\t\tss = sty;\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tyi = (x << 2) | 0;\n\n\t\t\t\tr = (ryp1 * (pr = px[yi])) | 0;\n\t\t\t\tg = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;\n\t\t\t\tb = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;\n\t\t\t\ta = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;\n\n\t\t\t\tsy = ssy;\n\t\t\t\tfor( i = 0; i < ryp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tsy.r = pr;\n\t\t\t\t\tsy.g = pg;\n\t\t\t\t\tsy.b = pb;\n\t\t\t\t\tsy.a = pa;\n\t\t\t\t\tsy = sy.n;\n\t\t\t\t}\n\n\t\t\t\typ = w;\n\n\t\t\t\tfor( i = 1; i <= radiusY; i++ )\n\t\t\t\t{\n\t\t\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\t\t\tr += ( sy.r = px[yi]);\n\t\t\t\t\tg += ( sy.g = px[yi+1]);\n\t\t\t\t\tb += ( sy.b = px[yi+2]);\n\t\t\t\t\ta += ( sy.a = px[yi+3]);\n\n\t\t\t\t\tsy = sy.n;\n\n\t\t\t\t\tif( i < h1 )\n\t\t\t\t\t{\n\t\t\t\t\t\typ += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tyi = x;\n\t\t\t\tsi = ssy;\n\t\t\t\tif ( iterations > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss ) * pa;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t};\n\n\tcreatejs.BlurFilter = createjs.promote(BlurFilter, "Filter");\n}());\n\n//##############################################################################\n// AlphaMapFilter.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\t\n\t\n// constructor:\n\t/**\n\t * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will\n\t * be copied from the red channel of the map, and the RGB channels will be copied from the target.\n\t *\n\t * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much\n\t * better performance.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.\n\t *\n\t *       var box = new createjs.Shape();\n\t *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)\n\t *       box.graphics.drawRect(0, 0, 100, 100);\n\t *       box.cache(0, 0, 100, 100);\n\t *\n\t *       var bmp = new createjs.Bitmap("path/to/image.jpg");\n\t *       bmp.filters = [\n\t *           new createjs.AlphaMapFilter(box.cacheCanvas)\n\t *       ];\n\t *       bmp.cache(0, 0, 100, 100);\n\t *       stage.addChild(bmp);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMapFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the\n\t * result. This should be exactly the same dimensions as the target.\n\t **/\n\tfunction AlphaMapFilter(alphaMap) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same\n\t\t * dimensions as the target.\n\t\t * @property alphaMap\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.alphaMap = alphaMap;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _alphaMap\n\t\t * @protected\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis._alphaMap = null;\n\t\t\n\t\t/**\n\t\t * @property _mapData\n\t\t * @protected\n\t\t * @type Uint8ClampedArray\n\t\t **/\n\t\tthis._mapData = null;\n\t}\n\tvar p = createjs.extend(AlphaMapFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\tvar o = new AlphaMapFilter(this.alphaMap);\n\t\to._alphaMap = this._alphaMap;\n\t\to._mapData = this._mapData;\n\t\treturn o;\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn "[AlphaMapFilter]";\n\t};\n\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\t\tif (!this.alphaMap) { return true; }\n\t\tif (!this._prepAlphaMap()) { return false; }\n\t\t\n\t\t// TODO: update to support scenarios where the target has different dimensions.\n\t\tvar data = imageData.data;\n\t\tvar map = this._mapData;\n\t\tfor(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t * @method _prepAlphaMap\n\t * @protected\n\t **/\n\tp._prepAlphaMap = function () {\n\t\tif (!this.alphaMap) { return false; }\n\t\tif (this.alphaMap == this._alphaMap && this._mapData) { return true; }\n\n\t\tthis._mapData = null;\n\t\tvar map = this._alphaMap = this.alphaMap;\n\t\tvar canvas = map;\n\t\tvar ctx;\n\t\tif (map instanceof HTMLCanvasElement) {\n\t\t\tctx = canvas.getContext("2d");\n\t\t} else {\n\t\t\tcanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");\n\t\t\tcanvas.width = map.width;\n\t\t\tcanvas.height = map.height;\n\t\t\tctx = canvas.getContext("2d");\n\t\t\tctx.drawImage(map, 0, 0);\n\t\t}\n\n\t\ttry {\n\t\t\tvar imgData = ctx.getImageData(0, 0, map.width, map.height);\n\t\t} catch (e) {\n\t\t\t//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis._mapData = imgData.data;\n\t\treturn true;\n\t};\n\n\n\tcreatejs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");\n}());\n\n//##############################################################################\n// AlphaMaskFilter.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will\n\t * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to\n\t * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32\n\t * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.\n\t *\n\t * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.\n\t *\n\t *      var box = new createjs.Shape();\n\t *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)\n\t *      box.graphics.drawRect(0, 0, 100, 100);\n\t *      box.cache(0, 0, 100, 100);\n\t *\n\t *      var bmp = new createjs.Bitmap("path/to/image.jpg");\n\t *      bmp.filters = [\n\t *          new createjs.AlphaMaskFilter(box.cacheCanvas)\n\t *      ];\n\t *      bmp.cache(0, 0, 100, 100);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMaskFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} mask\n\t **/\n\tfunction AlphaMaskFilter(mask) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The image (or canvas) to use as the mask.\n\t\t * @property mask\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.mask = mask;\n\t}\n\tvar p = createjs.extend(AlphaMaskFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/**\n\t * Applies the filter to the specified context.\n\t *\n\t * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters\n\t * correctly.</strong>\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\tif (!this.mask) { return true; }\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\n\t\ttargetCtx.save();\n\t\tif (ctx != targetCtx) {\n\t\t\t// TODO: support targetCtx and targetX/Y\n\t\t\t// clearRect, then draw the ctx in?\n\t\t\treturn false;\n\t\t}\n\n\t\ttargetCtx.globalCompositeOperation = "destination-in";\n\t\ttargetCtx.drawImage(this.mask, targetX, targetY);\n\t\ttargetCtx.restore();\n\t\treturn true;\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\treturn new AlphaMaskFilter(this.mask);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn "[AlphaMaskFilter]";\n\t};\n\n\n\tcreatejs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");\n}());\n\n//##############################################################################\n// ColorFilter.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Applies a color transform to DisplayObjects.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels\n\t * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);\n\t *\n\t *      shape.filters = [\n\t *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)\n\t *      ];\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorFilter\n\t * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.\n\t * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.\n\t * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.\n\t * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.\n\t * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range\n\t * between -255 and 255.\n\t * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @constructor\n\t * @extends Filter\n\t **/\n\tfunction ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Red channel multiplier.\n\t\t * @property redMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.redMultiplier = redMultiplier != null ? redMultiplier : 1;\n\t\n\t\t/**\n\t\t * Green channel multiplier.\n\t\t * @property greenMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;\n\t\n\t\t/**\n\t\t * Blue channel multiplier.\n\t\t * @property blueMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;\n\t\n\t\t/**\n\t\t * Alpha channel multiplier.\n\t\t * @property alphaMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;\n\t\n\t\t/**\n\t\t * Red channel offset (added to value).\n\t\t * @property redOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.redOffset = redOffset || 0;\n\t\n\t\t/**\n\t\t * Green channel offset (added to value).\n\t\t * @property greenOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenOffset = greenOffset || 0;\n\t\n\t\t/**\n\t\t * Blue channel offset (added to value).\n\t\t * @property blueOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueOffset = blueOffset || 0;\n\t\n\t\t/**\n\t\t * Alpha channel offset (added to value).\n\t\t * @property alphaOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaOffset = alphaOffset || 0;\n\t}\n\tvar p = createjs.extend(ColorFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn "[ColorFilter]";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);\n\t};\n\t\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) {\n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tdata[i] = data[i]*this.redMultiplier+this.redOffset;\n\t\t\tdata[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;\n\t\t\tdata[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;\n\t\t\tdata[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorFilter = createjs.promote(ColorFilter, "Filter");\n}());\n\n//##############################################################################\n// ColorMatrix.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.\n\t * Most methods return the instance to facilitate chained calls.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myColorMatrix.adjustHue(20).adjustBrightness(50);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}\n\t * for an example of how to use ColorMatrix to change a DisplayObject\'s color.\n\t * @class ColorMatrix\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @constructor\n\t **/\n\tfunction ColorMatrix(brightness, contrast, saturation, hue) {\n\t\tthis.setColor(brightness, contrast, saturation, hue);\n\t}\n\tvar p = ColorMatrix.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Array of delta values for contrast calculations.\n\t * @property DELTA_INDEX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.DELTA_INDEX = [\n\t\t0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,\n\t\t0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,\n\t\t0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,\n\t\t0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,\n\t\t0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,\n\t\t1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,\n\t\t1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,\n\t\t2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,\n\t\t4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,\n\t\t7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,\n\t\t10.0\n\t];\n\n\t/**\n\t * Identity matrix values.\n\t * @property IDENTITY_MATRIX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.IDENTITY_MATRIX = [\n\t\t1,0,0,0,0,\n\t\t0,1,0,0,0,\n\t\t0,0,1,0,0,\n\t\t0,0,0,1,0,\n\t\t0,0,0,0,1\n\t];\n\n\t/**\n\t * The constant length of a color matrix.\n\t * @property LENGTH\n\t * @type Number\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;\n\n\n// public methods:\n\t/**\n\t * Resets the instance with the specified values.\n\t * @method setColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.setColor = function(brightness,contrast,saturation,hue) {\n\t\treturn this.reset().adjustColor(brightness,contrast,saturation,hue);\n\t};\n\n\t/**\n\t * Resets the matrix to identity values.\n\t * @method reset\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.reset = function() {\n\t\treturn this.copy(ColorMatrix.IDENTITY_MATRIX);\n\t};\n\n\t/**\n\t * Shortcut method to adjust brightness, contrast, saturation and hue.\n\t * Equivalent to calling adjustHue(hue), adjustContrast(contrast),\n\t * adjustBrightness(brightness), adjustSaturation(saturation), in that order.\n\t * @method adjustColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustColor = function(brightness,contrast,saturation,hue) {\n\t\tthis.adjustHue(hue);\n\t\tthis.adjustContrast(contrast);\n\t\tthis.adjustBrightness(brightness);\n\t\treturn this.adjustSaturation(saturation);\n\t};\n\n\t/**\n\t * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.\n\t * Positive values will make the image brighter, negative values will make it darker.\n\t * @method adjustBrightness\n\t * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustBrightness = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,255);\n\t\tthis._multiplyMatrix([\n\t\t\t1,0,0,0,value,\n\t\t\t0,1,0,0,value,\n\t\t\t0,0,1,0,value,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the contrast of pixel color.\n\t * Positive values will increase contrast, negative values will decrease contrast.\n\t * @method adjustContrast\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustContrast = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x;\n\t\tif (value<0) {\n\t\t\tx = 127+value/100*127;\n\t\t} else {\n\t\t\tx = value%1;\n\t\t\tif (x == 0) {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[value];\n\t\t\t} else {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.\n\t\t\t}\n\t\t\tx = x*127+127;\n\t\t}\n\t\tthis._multiplyMatrix([\n\t\t\tx/127,0,0,0,0.5*(127-x),\n\t\t\t0,x/127,0,0,0.5*(127-x),\n\t\t\t0,0,x/127,0,0.5*(127-x),\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the color saturation of the pixel.\n\t * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).\n\t * @method adjustSaturation\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustSaturation = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x = 1+((value > 0) ? 3*value/100 : value/100);\n\t\tvar lumR = 0.3086;\n\t\tvar lumG = 0.6094;\n\t\tvar lumB = 0.0820;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Adjusts the hue of the pixel color.\n\t * @method adjustHue\n\t * @param {Number} value A value between -180 & 180.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustHue = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,180)/180*Math.PI;\n\t\tvar cosVal = Math.cos(value);\n\t\tvar sinVal = Math.sin(value);\n\t\tvar lumR = 0.213;\n\t\tvar lumG = 0.715;\n\t\tvar lumB = 0.072;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Concatenates (multiplies) the specified matrix with this one.\n\t * @method concat\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.concat = function(matrix) {\n\t\tmatrix = this._fixMatrix(matrix);\n\t\tif (matrix.length != ColorMatrix.LENGTH) { return this; }\n\t\tthis._multiplyMatrix(matrix);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this ColorMatrix.\n\t * @method clone\n\t * @return {ColorMatrix} A clone of this ColorMatrix.\n\t **/\n\tp.clone = function() {\n\t\treturn (new ColorMatrix()).copy(this);\n\t};\n\n\t/**\n\t * Return a length 25 (5x5) array instance containing this matrix\'s values.\n\t * @method toArray\n\t * @return {Array} An array holding this matrix\'s values.\n\t **/\n\tp.toArray = function() {\n\t\tvar arr = [];\n\t\tfor (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {\n\t\t\tarr[i] = this[i];\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Copy the specified matrix\'s values to this matrix.\n\t * @method copy\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.copy = function(matrix) {\n\t\tvar l = ColorMatrix.LENGTH;\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tthis[i] = matrix[i];\n\t\t}\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn "[ColorMatrix]";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _multiplyMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._multiplyMatrix = function(matrix) {\n\t\tvar i, j, k, col = [];\n\n\t\tfor (i=0;i<5;i++) {\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tcol[j] = this[j+i*5];\n\t\t\t}\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tvar val=0;\n\t\t\t\tfor (k=0;k<5;k++) {\n\t\t\t\t\tval += matrix[j+k*5]*col[k];\n\t\t\t\t}\n\t\t\t\tthis[j+i*5] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.\n\t * @method _cleanValue\n\t * @param {Number} value The raw number\n\t * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.\n\t * @protected\n\t **/\n\tp._cleanValue = function(value, limit) {\n\t\treturn Math.min(limit,Math.max(-limit,value));\n\t};\n\n\t/**\n\t * Makes sure matrixes are 5x5 (25 long).\n\t * @method _fixMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._fixMatrix = function(matrix) {\n\t\tif (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }\n\t\tif (matrix.length < ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));\n\t\t} else if (matrix.length > ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,ColorMatrix.LENGTH);\n\t\t}\n\t\treturn matrix;\n\t};\n\n\n\tcreatejs.ColorMatrix = ColorMatrix;\n}());\n\n//##############################################################################\n// ColorMatrixFilter.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n\t * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the\n\t * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,\n\t * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);\n\t *\n\t *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);\n\t *      shape.filters = [\n\t *          new createjs.ColorMatrixFilter(matrix)\n\t *      ];\n\t *\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorMatrixFilter\n\t * @constructor\n\t * @extends Filter\n\t * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}\n\t * class.\n\t **/\n\tfunction ColorMatrixFilter(matrix) {\n\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}\n\t\t * @property matrix\n\t\t * @type Array | ColorMatrix\n\t\t **/\n\t\tthis.matrix = matrix;\n\t}\n\tvar p = createjs.extend(ColorMatrixFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn "[ColorMatrixFilter]";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorMatrixFilter(this.matrix);\n\t};\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) { \n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tvar r,g,b,a;\n\t\tvar mtx = this.matrix;\n\t\tvar m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];\n\t\tvar m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];\n\t\tvar m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];\n\t\tvar m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];\n\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tr = data[i];\n\t\t\tg = data[i+1];\n\t\t\tb = data[i+2];\n\t\t\ta = data[i+3];\n\t\t\tdata[i] = r*m0+g*m1+b*m2+a*m3+m4; // red\n\t\t\tdata[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green\n\t\t\tdata[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue\n\t\t\tdata[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");\n}());\n\n//##############################################################################\n// Touch.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\n// constructor:\n\t/**\n * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and\n * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.\n *\n * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have\n * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.\n *\n * <h4>Example</h4>\n *\n *      var stage = new createjs.Stage("canvasId");\n *      createjs.Touch.enable(stage);\n *\n * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:\n *\n *      createjs.Touch.disable(stage);\n *\n * @class Touch\n * @static\n **/\n\tfunction Touch() {\n\t\tthrow "Touch cannot be instantiated";\n\t}\n\n\n// public static methods:\n\t/**\n\t * Returns `true` if touch is supported in the current browser.\n\t * @method isSupported\n\t * @return {Boolean} Indicates whether touch is supported in the current browser.\n\t * @static\n\t **/\n\tTouch.isSupported = function() {\n\t\treturn\t!!((\'ontouchstart\' in window) // iOS & Android\n\t\t\t|| (window.navigator[\'msPointerEnabled\'] && window.navigator[\'msMaxTouchPoints\'] > 0) // IE10\n\t\t\t|| (window.navigator[\'pointerEnabled\'] && window.navigator[\'maxTouchPoints\'] > 0)); // IE11+\n\t};\n\n\t/**\n\t * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS\n\t * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and\n\t * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for\n\t * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}\n\t * for more information.\n\t * @method enable\n\t * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.\n\t * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.\n\t * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be\n\t * allowed when the user is interacting with the target canvas.\n\t * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.\n\t * @static\n\t **/\n\tTouch.enable = function(stage, singleTouch, allowDefault) {\n\t\tif (!stage || !stage.canvas || !Touch.isSupported()) { return false; }\n\t\tif (stage.__touch) { return true; }\n\n\t\t// inject required properties on stage:\n\t\tstage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};\n\n\t\t// note that in the future we may need to disable the standard mouse event model before adding\n\t\t// these to prevent duplicate calls. It doesn\'t seem to be an issue with iOS devices though.\n\t\tif (\'ontouchstart\' in window) { Touch._IOS_enable(stage); }\n\t\telse if (window.navigator[\'msPointerEnabled\'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all listeners that were set up when calling `Touch.enable()` on a stage.\n\t * @method disable\n\t * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.\n\t * @static\n\t **/\n\tTouch.disable = function(stage) {\n\t\tif (!stage) { return; }\n\t\tif (\'ontouchstart\' in window) { Touch._IOS_disable(stage); }\n\t\telse if (window.navigator[\'msPointerEnabled\'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }\n\t\t\n\t\tdelete stage.__touch;\n\t};\n\n\n// Private static methods:\n\t/**\n\t * @method _IOS_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };\n\t\tcanvas.addEventListener("touchstart", f, false);\n\t\tcanvas.addEventListener("touchmove", f, false);\n\t\tcanvas.addEventListener("touchend", f, false);\n\t\tcanvas.addEventListener("touchcancel", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_disable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tif (!canvas) { return; }\n\t\tvar f = stage.__touch.f;\n\t\tcanvas.removeEventListener("touchstart", f, false);\n\t\tcanvas.removeEventListener("touchmove", f, false);\n\t\tcanvas.removeEventListener("touchend", f, false);\n\t\tcanvas.removeEventListener("touchcancel", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IOS_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }\n\t\tvar touches = e.changedTouches;\n\t\tvar type = e.type;\n\t\tfor (var i= 0,l=touches.length; i<l; i++) {\n\t\t\tvar touch = touches[i];\n\t\t\tvar id = touch.identifier;\n\t\t\tif (touch.target != stage.canvas) { continue; }\n\n\t\t\tif (type == "touchstart") {\n\t\t\t\tthis._handleStart(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == "touchmove") {\n\t\t\t\tthis._handleMove(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == "touchend" || type == "touchcancel") {\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };\n\n\t\tif (window.navigator["pointerEnabled"] === undefined) {\n\t\t\tcanvas.addEventListener("MSPointerDown", f, false);\n\t\t\twindow.addEventListener("MSPointerMove", f, false);\n\t\t\twindow.addEventListener("MSPointerUp", f, false);\n\t\t\twindow.addEventListener("MSPointerCancel", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }\n\t\t} else {\n\t\t\tcanvas.addEventListener("pointerdown", f, false);\n\t\t\twindow.addEventListener("pointermove", f, false);\n\t\t\twindow.addEventListener("pointerup", f, false);\n\t\t\twindow.addEventListener("pointercancel", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }\n\n\t\t}\n\t\tstage.__touch.activeIDs = {};\n\t};\n\n\t/**\n\t * @method _IE_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_disable = function(stage) {\n\t\tvar f = stage.__touch.f;\n\n\t\tif (window.navigator["pointerEnabled"] === undefined) {\n\t\t\twindow.removeEventListener("MSPointerMove", f, false);\n\t\t\twindow.removeEventListener("MSPointerUp", f, false);\n\t\t\twindow.removeEventListener("MSPointerCancel", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener("MSPointerDown", f, false);\n\t\t\t}\n\t\t} else {\n\t\t\twindow.removeEventListener("pointermove", f, false);\n\t\t\twindow.removeEventListener("pointerup", f, false);\n\t\t\twindow.removeEventListener("pointercancel", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener("pointerdown", f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle.\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IE_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }\n\t\tvar type = e.type;\n\t\tvar id = e.pointerId;\n\t\tvar ids = stage.__touch.activeIDs;\n\n\t\tif (type == "MSPointerDown" || type == "pointerdown") {\n\t\t\tif (e.srcElement != stage.canvas) { return; }\n\t\t\tids[id] = true;\n\t\t\tthis._handleStart(stage, id, e, e.pageX, e.pageY);\n\t\t} else if (ids[id]) { // it\'s an id we\'re watching\n\t\t\tif (type == "MSPointerMove" || type == "pointermove") {\n\t\t\t\tthis._handleMove(stage, id, e, e.pageX, e.pageY);\n\t\t\t} else if (type == "MSPointerUp" || type == "MSPointerCancel"\n\t\t\t\t\t|| type == "pointerup" || type == "pointercancel") {\n\t\t\t\tdelete(ids[id]);\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleStart\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleStart = function(stage, id, e, x, y) {\n\t\tvar props = stage.__touch;\n\t\tif (!props.multitouch && props.count) { return; }\n\t\tvar ids = props.pointers;\n\t\tif (ids[id]) { return; }\n\t\tids[id] = true;\n\t\tprops.count++;\n\t\tstage._handlePointerDown(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleMove\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleMove = function(stage, id, e, x, y) {\n\t\tif (!stage.__touch.pointers[id]) { return; }\n\t\tstage._handlePointerMove(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleEnd\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @protected\n\t **/\n\tTouch._handleEnd = function(stage, id, e) {\n\t\t// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).\n\t\tvar props = stage.__touch;\n\t\tvar ids = props.pointers;\n\t\tif (!ids[id]) { return; }\n\t\tprops.count--;\n\t\tstage._handlePointerUp(id, e, true);\n\t\tdelete(ids[id]);\n\t};\n\n\n\tcreatejs.Touch = Touch;\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class EaselJS\n\t **/\n\tvar s = createjs.EaselJS = createjs.EaselJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/"0.8.2"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:34 GMT"; // injected by build process\n\n})();\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * @class PreloadJS\n\t **/\n\tvar s = createjs.PreloadJS = createjs.PreloadJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type {String}\n\t * @static\n\t **/\n\ts.version = /*=version*/"0.6.2"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type {String}\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:31 GMT"; // injected by build process\n\n})();\n\n//##############################################################################\n// proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n\t * @class ErrorEvent\n\t * @param {String} [title] The error title\n\t * @param {String} [message] The error description\n\t * @param {Object} [data] Additional error data\n\t * @constructor\n\t */\n\tfunction ErrorEvent(title, message, data) {\n\t\tthis.Event_constructor("error");\n\n\t\t/**\n\t\t * The short error title, which indicates the type of error that occurred.\n\t\t * @property title\n\t\t * @type String\n\t\t */\n\t\tthis.title = title;\n\n\t\t/**\n\t\t * The verbose error message, containing details about the error.\n\t\t * @property message\n\t\t * @type String\n\t\t */\n\t\tthis.message = message;\n\n\t\t/**\n\t\t * Additional data attached to an error.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\n\n\tp.clone = function() {\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\n\t};\n\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, "Event");\n\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\n(function (scope) {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.\n\t * @class ProgressEvent\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\n\t * a percentage (between 0 and 1), it can be omitted.\n\t * @todo Consider having this event be a "fileprogress" event as well\n\t * @constructor\n\t */\n\tfunction ProgressEvent(loaded, total) {\n\t\tthis.Event_constructor("progress");\n\n\t\t/**\n\t\t * The amount that has been loaded (out of a total amount)\n\t\t * @property loaded\n\t\t * @type {Number}\n\t\t */\n\t\tthis.loaded = loaded;\n\n\t\t/**\n\t\t * The total "size" of the load.\n\t\t * @property total\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.total = (total == null) ? 1 : total;\n\n\t\t/**\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\n\t};\n\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\n\n\t/**\n\t * Returns a clone of the ProgressEvent instance.\n\t * @method clone\n\t * @return {ProgressEvent} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\n\t};\n\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, "Event");\n\n}(window));\n\n//##############################################################################\n// json3.js\n//##############################################################################\n\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader =  true && __webpack_require__(4);\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    "function": true,\n    "object": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;\n\n  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root["Object"]());\n    exports || (exports = root["Object"]());\n\n    // Native constructor aliases.\n    var Number = context["Number"] || root["Number"],\n        String = context["String"] || root["String"],\n        Object = context["Object"] || root["Object"],\n        Date = context["Date"] || root["Date"],\n        SyntaxError = context["SyntaxError"] || root["SyntaxError"],\n        TypeError = context["TypeError"] || root["TypeError"],\n        Math = context["Math"] || root["Math"],\n        nativeJSON = context["JSON"] || root["JSON"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == "object" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == "bug-string-char-index") {\n        // IE <= 7 doesn\'t support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = "a"[0] != "a";\n      } else if (name == "json") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has("json-stringify") && has("json-parse");\n      } else {\n        var value, serialized = \'{"a":[1,true,false,null,"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t"]}\';\n        // Test `JSON.stringify`.\n        if (name == "json-stringify") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === "0" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === "0" &&\n                stringify(new String()) == \'""\' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === "1" &&\n                stringify([value]) == "[1]" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of\n                // `"[null]"`.\n                stringify([undef]) == "[null]" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == "null" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == "[null,null,null]" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ "a": [value, true, false, null, "\\x00\\b\\n\\f\\r\\t"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === "1" &&\n                stringify([1, 2], null, 1) == "[\\n 1,\\n 2\\n]" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == \'"-271821-04-20T00:00:00.000Z"\' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == \'"+275760-09-13T00:00:00.000Z"\' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == \'"-000001-01-01T00:00:00.000Z"\' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == \'"1969-12-31T23:59:59.999Z"\';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == "json-parse") {\n          var parse = exports.parse;\n          if (typeof parse == "function") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse("0") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse(\'"\\t"\');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse("01") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse("1.") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has("json")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = "[object Function]",\n          dateClass = "[object Date]",\n          numberClass = "[object Number]",\n          stringClass = "[object String]",\n          arrayClass = "[object Array]",\n          booleanClass = "[object Boolean]";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has("bug-string-char-index");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            "toString": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn\'t implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object\'s prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment\'s `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = "constructor"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has("json-stringify")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: "\\\\\\\\",\n          34: \'\\\\"\',\n          8: "\\\\b",\n          12: "\\\\f",\n          10: "\\\\n",\n          13: "\\\\r",\n          9: "\\\\t"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = "000000";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = "\\\\u00";\n        var quote = function (value) {\n          var result = \'"\', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + \'"\';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == "object" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, "toJSON")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle\'s `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  "." + toPaddedString(3, milliseconds) + "Z";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return "null";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return "" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `"null"`.\n            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote("" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == "object") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? "null" : element);\n              }\n              result = results.length ? (whitespace ? "[\\n" + indentation + results.join(",\\n" + indentation) + "\\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + ":"}\n                  // be the concatenation of `member` and the `space` character."\n                  // The "`space` character" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);\n                }\n              });\n              result = results.length ? (whitespace ? "{\\n" + indentation + results.join(",\\n" + indentation) + "\\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`""`) only if they are used directly within an object member list\n          // (e.g., `!("" in { "": 1})`).\n          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has("json-parse")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: "\\\\",\n          34: \'"\',\n          47: "/",\n          98: "\\b",\n          116: "\\t",\n          110: "\\n",\n          102: "\\f",\n          114: "\\r"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `"$"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = "@", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode("0x" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == "true") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == "false") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == "null") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return "$";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == "$") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == "string") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == "[") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == "]") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == ",") {\n                    value = lex();\n                    if (value == "]") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == ",") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == "{") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == "}") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == ",") {\n                    value = lex();\n                    if (value == "}") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == "object" && value) {\n            // `forEach` can\'t be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = "" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != "$") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;\n        };\n      }\n    }\n\n    exports["runInContext"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root["JSON3"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root["JSON3"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      "noConflict": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root["JSON3"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      "parse": JSON3.parse,\n      "stringify": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return JSON3;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//##############################################################################\n// DomUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few utilities for interacting with the dom.\n\t * @class DomUtils\n\t */\n\tvar s = {};\n\n\ts.appendToHead = function (el) {\n\t\ts.getHead().appendChild(el)\n\t}\n\n\ts.getHead = function () {\n\t\treturn document.head || document.getElementsByTagName("head")[0];\n\t}\n\n\ts.getBody = function () {\n\t\treturn document.body || document.getElementsByTagName("body")[0];\n\t}\n\n\tcreatejs.DomUtils = s;\n\n}());\n\n//##############################################################################\n// DataUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few data utilities for formatting different data types.\n\t * @class DataUtils\n\t */\n\tvar s = {};\n\n\t// static methods\n\t/**\n\t * Parse XML using the DOM. This is required when preloading XML or SVG.\n\t * @method parseXML\n\t * @param {String} text The raw text or XML that is loaded by XHR.\n\t * @param {String} type The mime type of the XML. Use "text/xml" for XML, and  "image/svg+xml" for SVG parsing.\n\t * @return {XML} An XML document\n\t * @static\n\t */\n\ts.parseXML = function (text, type) {\n\t\tvar xml = null;\n\t\t// CocoonJS does not support XML parsing with either method.\n\n\t\t// Most browsers will use DOMParser\n\t\t// IE fails on certain SVG files, so we have a fallback below.\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txml = parser.parseFromString(text, type);\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// Fallback for IE support.\n\t\tif (!xml) {\n\t\t\ttry {\n\t\t\t\txml = new ActiveXObject("Microsoft.XMLDOM");\n\t\t\t\txml.async = false;\n\t\t\t\txml.loadXML(text);\n\t\t\t} catch (e) {\n\t\t\t\txml = null;\n\t\t\t}\n\t\t}\n\n\t\treturn xml;\n\t};\n\n\t/**\n\t * Parse a string into an Object.\n\t * @method parseJSON\n\t * @param {String} value The loaded JSON string\n\t * @returns {Object} A JavaScript object.\n\t */\n\ts.parseJSON = function (value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {\n\t\t\t// TODO; Handle this with a custom error?\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tcreatejs.DataUtils = s;\n\n}());\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n\t * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n\t * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}\n\t * @class LoadItem\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\tfunction LoadItem() {\n\t\t/**\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n\t\t * string (recommended), or an HTML tag.\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = null;\n\n\t\t/**\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\n\t\t * @property type\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.type = null;\n\n\t\t/**\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n\t\t * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.\n\t\t * @property id\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.id = null;\n\n\t\t/**\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n\t\t * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n\t\t * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.\n\t\t * @property maintainOrder\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.maintainOrder = false;\n\n\t\t/**\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n\t\t * @property callback\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.callback = null;\n\n\t\t/**\n\t\t * An arbitrary data object, which is included with the loaded object.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or\n\t\t * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as\n\t\t * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.\n\t\t * @property method\n\t\t * @type {String}\n\t\t * @default get\n\t\t */\n\t\tthis.method = createjs.LoadItem.GET;\n\n\t\t/**\n\t\t * An object hash of name/value pairs to send to the server.\n\t\t * @property values\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.values = null;\n\n\t\t/**\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n\t\t * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the\n\t\t * default headers by including them in your headers object.\n\t\t * @property headers\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.headers = null;\n\n\t\t/**\n\t\t * Enable credentials for XHR requests.\n\t\t * @property withCredentials\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.withCredentials = false;\n\n\t\t/**\n\t\t * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text\n\t\t * based files (json, xml, text, css, js).\n\t\t * @property mimeType\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.mimeType = null;\n\n\t\t/**\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n\t\t * @property crossOrigin\n\t\t * @type {boolean}\n\t\t * @default Anonymous\n\t\t */\n\t\tthis.crossOrigin = null;\n\n\t\t/**\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t\t * @property loadTimeout\n\t\t * @type {Number}\n\t\t * @default 8000 (8 seconds)\n\t\t */\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t};\n\n\tvar p = LoadItem.prototype = {};\n\tvar s = LoadItem;\n\n\t/**\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t * @property LOAD_TIMEOUT_DEFAULT\n\t * @type {number}\n\t * @static\n\t */\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\n\n\t/**\n\t * Create a LoadItem.\n\t * <ul>\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>\n\t *     <li>LoadItem instances are returned as-is</li>\n\t *     <li>Objects are returned with any needed properties added</li>\n\t * </ul>\n\t * @method create\n\t * @param {LoadItem|String|Object} value The load item value\n\t * @returns {LoadItem|Object}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (typeof value == "string") {\n\t\t\tvar item = new LoadItem();\n\t\t\titem.src = value;\n\t\t\treturn item;\n\t\t} else if (value instanceof s) {\n\t\t\treturn value;\n\t\t} else if (value instanceof Object && value.src) {\n\t\t\tif (value.loadTimeout == null) {\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t\t\t}\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error("Type not recognized.");\n\t\t}\n\t};\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tcreatejs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class RequestUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * The Regular Expression used to test file URLS for an absolute path.\n\t * @property ABSOLUTE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n\t/**\n\t * The Regular Expression used to test file URLS for a relative path.\n\t * @property RELATIVE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\n\n\t/**\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n\t * removed.\n\t * @property EXTENSION_PATT\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n\t/**\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n\t * <ul>\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n\t *     `//networkPath`)</li>\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n\t *     the file path is expected to follow the format `name.ext`.</li>\n\t * </ul>\n\t * @method parseURI\n\t * @param {String} path\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional \'extension`\n\t * property, which is the lowercase extension.\n\t * @static\n\t */\n\ts.parseURI = function (path) {\n\t\tvar info = {absolute: false, relative: false};\n\t\tif (path == null) { return info; }\n\n\t\t// Drop the query string\n\t\tvar queryIndex = path.indexOf("?");\n\t\tif (queryIndex > -1) {\n\t\t\tpath = path.substr(0, queryIndex);\n\t\t}\n\n\t\t// Absolute\n\t\tvar match;\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\n\t\t\tinfo.absolute = true;\n\n\t\t\t// Relative\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\n\t\t\tinfo.relative = true;\n\t\t}\n\n\t\t// Extension\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\n\t\t\tinfo.extension = match[1].toLowerCase();\n\t\t}\n\t\treturn info;\n\t};\n\n\t/**\n\t * Formats an object into a query string for either a POST or GET request.\n\t * @method formatQueryString\n\t * @param {Object} data The data to convert to a query string.\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\n\t * @static\n\t */\n\ts.formatQueryString = function (data, query) {\n\t\tif (data == null) {\n\t\t\tthrow new Error(\'You must specify data.\');\n\t\t}\n\t\tvar params = [];\n\t\tfor (var n in data) {\n\t\t\tparams.push(n + \'=\' + escape(data[n]));\n\t\t}\n\t\tif (query) {\n\t\t\tparams = params.concat(query);\n\t\t}\n\t\treturn params.join(\'&\');\n\t};\n\n\t/**\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n\t * @method buildPath\n\t * @param {String} src The source path to add values to.\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n\t * path will be preserved.\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\n\t * @static\n\t */\n\ts.buildPath = function (src, data) {\n\t\tif (data == null) {\n\t\t\treturn src;\n\t\t}\n\n\t\tvar query = [];\n\t\tvar idx = src.indexOf(\'?\');\n\n\t\tif (idx != -1) {\n\t\t\tvar q = src.slice(idx + 1);\n\t\t\tquery = query.concat(q.split(\'&\'));\n\t\t}\n\n\t\tif (idx != -1) {\n\t\t\treturn src.slice(0, idx) + \'?\' + this.formatQueryString(data, query);\n\t\t} else {\n\t\t\treturn src + \'?\' + this.formatQueryString(data, query);\n\t\t}\n\t};\n\n\t/**\n\t * @method isCrossDomain\n\t * @param {LoadItem|Object} item A load item with a `src` property.\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\n\t * @static\n\t */\n\ts.isCrossDomain = function (item) {\n\t\tvar target = document.createElement("a");\n\t\ttarget.href = item.src;\n\n\t\tvar host = document.createElement("a");\n\t\thost.href = location.href;\n\n\t\tvar crossdomain = (target.hostname != "") &&\n\t\t\t\t\t\t  (target.port != host.port ||\n\t\t\t\t\t\t   target.protocol != host.protocol ||\n\t\t\t\t\t\t   target.hostname != host.hostname);\n\t\treturn crossdomain;\n\t};\n\n\t/**\n\t * @method isLocal\n\t * @param {LoadItem|Object} item A load item with a `src` property\n\t * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as\n\t * well.\n\t * @static\n\t */\n\ts.isLocal = function (item) {\n\t\tvar target = document.createElement("a");\n\t\ttarget.href = item.src;\n\t\treturn target.hostname == "" && target.protocol == "file:";\n\t};\n\n\t/**\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n\t * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n\t * {{#crossLink "AbstractLoader"}}{{/crossLink}}.\n\t * @method isBinary\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is binary.\n\t * @static\n\t */\n\ts.isBinary = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.IMAGE:\n\t\t\tcase createjs.AbstractLoader.BINARY:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLImageElement\n\t * @method isImageTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isImageTag = function(item) {\n\t\treturn item instanceof HTMLImageElement;\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLAudioElement\n\t * @method isAudioTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isAudioTag = function(item) {\n\t\tif (window.HTMLAudioElement) {\n\t\t\treturn item instanceof HTMLAudioElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLVideoElement\n\t * @method isVideoTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isVideoTag = function(item) {\n\t\tif (window.HTMLVideoElement) {\n\t\t\treturn item instanceof HTMLVideoElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n\t * @method isText\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is text.\n\t * @static\n\t */\n\ts.isText = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.TEXT:\n\t\t\tcase createjs.AbstractLoader.JSON:\n\t\t\tcase createjs.AbstractLoader.MANIFEST:\n\t\t\tcase createjs.AbstractLoader.XML:\n\t\t\tcase createjs.AbstractLoader.CSS:\n\t\t\tcase createjs.AbstractLoader.SVG:\n\t\t\tcase createjs.AbstractLoader.JAVASCRIPT:\n\t\t\tcase createjs.AbstractLoader.SPRITESHEET:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n\t * if it is an unusual extension.\n\t * @method getTypeByExtension\n\t * @param {String} extension The file extension to use to determine the load type.\n\t * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\n\t * the type can not be determined by the extension.\n\t * @static\n\t */\n\ts.getTypeByExtension = function (extension) {\n\t\tif (extension == null) {\n\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\n\t\tswitch (extension.toLowerCase()) {\n\t\t\tcase "jpeg":\n\t\t\tcase "jpg":\n\t\t\tcase "gif":\n\t\t\tcase "png":\n\t\t\tcase "webp":\n\t\t\tcase "bmp":\n\t\t\t\treturn createjs.AbstractLoader.IMAGE;\n\t\t\tcase "ogg":\n\t\t\tcase "mp3":\n\t\t\tcase "webm":\n\t\t\t\treturn createjs.AbstractLoader.SOUND;\n\t\t\tcase "mp4":\n\t\t\tcase "webm":\n\t\t\tcase "ts":\n\t\t\t\treturn createjs.AbstractLoader.VIDEO;\n\t\t\tcase "json":\n\t\t\t\treturn createjs.AbstractLoader.JSON;\n\t\t\tcase "xml":\n\t\t\t\treturn createjs.AbstractLoader.XML;\n\t\t\tcase "css":\n\t\t\t\treturn createjs.AbstractLoader.CSS;\n\t\t\tcase "js":\n\t\t\t\treturn createjs.AbstractLoader.JAVASCRIPT;\n\t\t\tcase \'svg\':\n\t\t\t\treturn createjs.AbstractLoader.SVG;\n\t\t\tdefault:\n\t\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\t};\n\n\tcreatejs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n// constructor\n\t/**\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n\t * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.\n\t * @class AbstractLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n\t * other, so this is a suggested directive.\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n\t * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.\n\t * @extends EventDispatcher\n\t */\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\n\t\tthis.EventDispatcher_constructor();\n\n\t\t// public properties\n\t\t/**\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.\n\t\t * @property loaded\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loaded = false;\n\n\t\t/**\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n\t\t * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}\n\t\t * instead.\n\t\t * @property canceled\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.canceled = false;\n\n\t\t/**\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *     var queue = new createjs.LoadQueue();\n\t\t *     queue.loadFile("largeImage.png");\n\t\t *     queue.on("progress", function() {\n\t\t *         console.log("Progress:", queue.progress, event.progress);\n\t\t *     });\n\t\t *\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = 0;\n\n\t\t/**\n\t\t * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of\n\t\t * supported types.\n\t\t * @property type\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n\t\t * can be overridden to provide custom formatting.\n\t\t *\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\n\t\t * called in the current scope, as well as the success and error callbacks.\n\t\t *\n\t\t * <h4>Example asynchronous resultFormatter</h4>\n\t\t *\n\t\t * \tfunction _formatResult(loader) {\n\t\t * \t\treturn function(success, error) {\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\n\t\t * \t\t\tsuccess(result);\n\t\t * \t\t}\n\t\t * \t}\n\t\t * @property resultFormatter\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.resultFormatter = null;\n\n\t\t// protected properties\n\t\t/**\n\t\t * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},\n\t\t * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.\n\t\t * @property _item\n\t\t * @type {LoadItem|Object}\n\t\t * @private\n\t\t */\n\t\tif (loadItem) {\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\n\t\t} else {\n\t\t\tthis._item = null;\n\t\t}\n\n\t\t/**\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n\t\t * @property _preferXHR\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._preferXHR = preferXHR;\n\n\t\t/**\n\t\t * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For\n\t\t * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.\n\t\t * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.\n\t\t * @property _result\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._result = null;\n\n\t\t/**\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}\n\t\t * method, and passing `true`.\n\t\t * @property _rawResult\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._rawResult = null;\n\n\t\t/**\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and\n\t\t * {{#crossLink "ManifestLoader"}}{{/crossLink}}.\n\t\t * @property _loadItems\n\t\t * @type {null}\n\t\t * @protected\n\t\t */\n\t\tthis._loadedItems = null;\n\n\t\t/**\n\t\t * The attribute the items loaded using tags use for the source.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @private\n\t\t */\n\t\tthis._tagSrcAttribute = null;\n\n\t\t/**\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n\t\t * @property _tag\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._tag = null;\n\t};\n\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n\tvar s = AbstractLoader;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Defines a POST request, use for a method value when loading data.\n\t * @property POST\n\t * @type {string}\n\t * @default post\n\t * @static\n\t */\n\ts.POST = "POST";\n\n\t/**\n\t * Defines a GET request, use for a method value when loading data.\n\t * @property GET\n\t * @type {string}\n\t * @default get\n\t * @static\n\t */\n\ts.GET = "GET";\n\n\t/**\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.BINARY = "binary";\n\n\t/**\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n\t * &lt;style&gt; tag when loaded with tags.\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.CSS = "css";\n\n\t/**\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.IMAGE = "image";\n\n\t/**\n\t * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a\n\t * &lt;script&gt; tag.\n\t *\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n\t * only tag-loaded scripts are injected.\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JAVASCRIPT = "javascript";\n\n\t/**\n\t * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n\t * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON\n\t * must contain a matching wrapper function.\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSON = "json";\n\n\t/**\n\t * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}\n\t * property is set to.\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSONP = "jsonp";\n\n\t/**\n\t * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded\n\t * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an\n\t * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}\n\t * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,\n\t * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.MANIFEST = "manifest";\n\n\t/**\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n\t * &lt;audio&gt; tag.\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SOUND = "sound";\n\n\t/**\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n\t * &lt;video&gt; tag.\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.VIDEO = "video";\n\n\t/**\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n\t * @property SPRITESHEET\n\t * @type {String}\n\t * @default spritesheet\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SPRITESHEET = "spritesheet";\n\n\t/**\n\t * The preload type for SVG files.\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SVG = "svg";\n\n\t/**\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n\t * loaded as raw text.\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.TEXT = "text";\n\n\t/**\n\t * The preload type for xml files. XML is loaded into an XML document.\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.XML = "xml";\n\n// Events\n\t/**\n\t * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n\t * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.\n\t * @event progress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.\n\t * @event loadstart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.1\n\t */\n\n\t/**\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n\t * just a regular {{#crossLink "Event"}}{{/crossLink}}.\n\t * @event error\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n\t * This enables loaders to maintain internal queues, and surface file load errors.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The even type ("fileerror")\n\t * @param {LoadItem|object} The item that encountered the error\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n\t * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s\n\t * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a\n\t * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type ("fileload")\n\t * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n\t * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n\t * @event initialize\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type ("initialize")\n\t * @param {AbstractLoader} loader The loader that has been initialized.\n\t */\n\n\n\t/**\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n\t * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or\n\t * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will\n\t * be a {{#crossLink "LoadItem"}}{{/crossLink}}.\n\t * @method getItem\n\t * @return {Object} The manifest item that this loader is responsible for loading.\n\t * @since 0.6.0\n\t */\n\tp.getItem = function () {\n\t\treturn this._item;\n\t};\n\n\t/**\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}\n\t * event is dispatched.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n\t * data (if it exists).\n\t * @return {Object}\n\t * @since 0.6.0\n\t */\n\tp.getResult = function (raw) {\n\t\treturn raw ? this._rawResult : this._result;\n\t};\n\n\t/**\n\t * Return the `tag` this object creates or uses for loading.\n\t * @method getTag\n\t * @return {Object} The tag instance\n\t * @since 0.6.0\n\t */\n\tp.getTag = function () {\n\t\treturn this._tag;\n\t};\n\n\t/**\n\t * Set the `tag` this item uses for loading.\n\t * @method setTag\n\t * @param {Object} tag The tag instance\n\t * @since 0.6.0\n\t */\n\tp.setTag = function(tag) {\n\t  this._tag = tag;\n\t};\n\n\t/**\n\t * Begin loading the item. This method is required when using a loader by itself.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.on("complete", handleComplete);\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n\t *      queue.load();\n\t *\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis._createRequest();\n\n\t\tthis._request.on("complete", this, this);\n\t\tthis._request.on("progress", this, this);\n\t\tthis._request.on("loadStart", this, this);\n\t\tthis._request.on("abort", this, this);\n\t\tthis._request.on("timeout", this, this);\n\t\tthis._request.on("error", this, this);\n\n\t\tvar evt = new createjs.Event("initialize");\n\t\tevt.loader = this._request;\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._request.load();\n\t};\n\n\t/**\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n\t * the background), but events will not longer be dispatched.\n\t * @method cancel\n\t */\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis.destroy();\n\t};\n\n\t/**\n\t * Clean up the loader.\n\t * @method destroy\n\t */\n\tp.destroy = function() {\n\t\tif (this._request) {\n\t\t\tthis._request.removeAllEventListeners();\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tthis._request = null;\n\n\t\tthis._item = null;\n\t\tthis._rawResult = null;\n\t\tthis._result = null;\n\n\t\tthis._loadItems = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}\n\t * to expose items it loads internally.\n\t * @method getLoadedItems\n\t * @return {Array} A list of the items loaded by the loader.\n\t * @since 0.6.0\n\t */\n\tp.getLoadedItems = function () {\n\t\treturn this._loadedItems;\n\t};\n\n\n\t// Private methods\n\t/**\n\t * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or\n\t * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.\n\t * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},\n\t * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.\n\t * @method _createRequest\n\t * @protected\n\t */\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n\t/**\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n\t * by loaders that require tag loading.\n\t * @method _createTag\n\t * @param {String} src The tag source\n\t * @return {HTMLElement} The tag that was created\n\t * @protected\n\t */\n\tp._createTag = function(src) { return null; };\n\n\t/**\n\t * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendLoadStart\n\t * @protected\n\t */\n\tp._sendLoadStart = function () {\n\t\tif (this._isCanceled()) { return; }\n\t\tthis.dispatchEvent("loadstart");\n\t};\n\n\t/**\n\t * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.\n\t * @method _sendProgress\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n\t * and <code>total</code> properties.\n\t * @protected\n\t */\n\tp._sendProgress = function (value) {\n\t\tif (this._isCanceled()) { return; }\n\t\tvar event = null;\n\t\tif (typeof(value) == "number") {\n\t\t\tthis.progress = value;\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\n\t\t} else {\n\t\t\tevent = value;\n\t\t\tthis.progress = value.loaded / value.total;\n\t\t\tevent.progress = this.progress;\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t}\n\t\tthis.hasEventListener("progress") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event\n\t * @method _sendComplete\n\t * @protected\n\t */\n\tp._sendComplete = function () {\n\t\tif (this._isCanceled()) { return; }\n\n\t\tthis.loaded = true;\n\n\t\tvar event = new createjs.Event("complete");\n\t\tevent.rawResult = this._rawResult;\n\n\t\tif (this._result != null) {\n\t\t\tevent.result = this._result;\n\t\t}\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendError\n\t * @param {ErrorEvent} event The event object containing specific error properties.\n\t * @protected\n\t */\n\tp._sendError = function (event) {\n\t\tif (this._isCanceled() || !this.hasEventListener("error")) { return; }\n\t\tif (event == null) {\n\t\t\tevent = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error\n\t\t}\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n\t * do not cause issues after the queue has been cleaned up.\n\t * @method _isCanceled\n\t * @return {Boolean} If the loader has been canceled.\n\t * @protected\n\t */\n\tp._isCanceled = function () {\n\t\tif (window.createjs == null || this.canceled) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n\t * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.\n\t * @property resultFormatter\n\t * @type Function\n\t * @return {Object} The formatted result\n\t * @since 0.6.0\n\t */\n\tp.resultFormatter = null;\n\n\t/**\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n\t * this method can be overridden for custom behaviours.\n\t * @method handleEvent\n\t * @param {Event} event The event that the internal request dispatches.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase "complete":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\n\t\t\t\tif (result instanceof Function) {\n\t\t\t\t\tresult.call(this,\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._result =  result || this._rawResult;\n\t\t\t\t\tthis._sendComplete();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase "progress":\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\tbreak;\n\t\t\tcase "error":\n\t\t\t\tthis._sendError(event);\n\t\t\t\tbreak;\n\t\t\tcase "loadstart":\n\t\t\t\tthis._sendLoadStart();\n\t\t\t\tbreak;\n\t\t\tcase "abort":\n\t\t\tcase "timeout":\n\t\t\t\tif (!this._isCanceled()) {\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent("PRELOAD_" + event.type.toUpperCase() + "_ERROR"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * The "success" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} result The formatted result\n\t * @private\n\t */\n\tp._resultFormatSuccess = function (result) {\n\t\tthis._result = result;\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The "error" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} error The error event\n\t * @private\n\t */\n\tp._resultFormatFailed = function (event) {\n\t\tthis._sendError(event);\n\t};\n\n\t/**\n\t * @method buildPath\n\t * @protected\n\t * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}\n\t * instead.\n\t */\n\tp.buildPath = function (src, data) {\n\t\treturn createjs.RequestUtils.buildPath(src, data);\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function () {\n\t\treturn "[PreloadJS AbstractLoader]";\n\t};\n\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n\t * handle HTML media elements, such as Video and Audio.\n\t * @class AbstractMediaLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @param {String} type The type of media to load. Usually "video" or "audio".\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = "src";\n\n        this.on("initialize", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n\t// static properties\n\t// public methods\n\tp.load = function () {\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n\t\tif (!this._tag) {\n\t\t\tthis._tag = this._createTag(this._item.src);\n\t\t}\n\n\t\tthis._tag.preload = "auto";\n\t\tthis._tag.load();\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Creates a new tag for loading if it doesn\'t exist yet.\n\t * @method _createTag\n\t * @private\n\t */\n\tp._createTag = function () {};\n\n\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n    // protected methods\n    /**\n     * Before the item loads, set its mimeType and responseType.\n     * @property _updateXHR\n     * @param {Event} event\n     * @private\n     */\n    p._updateXHR = function (event) {\n        // Only exists for XHR\n        if (event.loader.setResponseType) {\n            event.loader.setResponseType("blob");\n        }\n    };\n\n\t/**\n\t * The result formatter for media files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\n\t\tthis._tag.onstalled = null;\n\t\tif (this._preferXHR) {\n            var URL = window.URL || window.webkitURL;\n            var result = loader.getResult(true);\n\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\n\t\t}\n\t\treturn loader.getTag();\n\t};\n\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},\n\t * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n\t * hood to get data.\n\t * @class AbstractRequest\n\t * @param {LoadItem} item\n\t * @constructor\n\t */\n\tvar AbstractRequest = function (item) {\n\t\tthis._item = item;\n\t};\n\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n\t// public methods\n\t/**\n\t * Begin a load.\n\t * @method load\n\t */\n\tp.load =  function() {};\n\n\t/**\n\t * Clean up a request.\n\t * @method destroy\n\t */\n\tp.destroy = function() {};\n\n\t/**\n\t * Cancel an in-progress request.\n\t * @method cancel\n\t */\n\tp.cancel = function() {};\n\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n\t * @class TagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\n\t */\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\t/**\n\t\t * The HTML tag instance that is used to load.\n\t\t * @property _tag\n\t\t * @type {HTMLElement}\n\t\t * @protected\n\t\t */\n\t\tthis._tag = tag;\n\n\t\t/**\n\t\t * The tag attribute that specifies the source, such as "src", "href", etc.\n\t\t * @property _tagSrcAttribute\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis._tagSrcAttribute = srcAttribute;\n\n\t\t/**\n\t\t * A method closure used for handling the tag load event.\n\t\t * @property _loadedHandler\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n\t\t/**\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n\t\t * @property _addedToDOM\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._addedToDOM = false;\n\n\t\t/**\n\t\t * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\n\t\t *\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._startTagVisibility = null;\n\t};\n\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n\t// public methods\n\tp.load = function () {\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\n\n\t\tvar evt = new createjs.Event("initialize");\n\t\tevt.loader = this._tag;\n\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._hideTag();\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\n\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\n\t\tif (this._tag.parentNode == null) {\n\t\t\twindow.document.body.appendChild(this._tag);\n\t\t\tthis._addedToDOM = true;\n\t\t}\n\t};\n\n\tp.destroy = function() {\n\t\tthis._clean();\n\t\tthis._tag = null;\n\n\t\tthis.AbstractRequest_destroy();\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n\t * and LINK tags), but other cases may exist.\n\t * @method _handleReadyStateChange\n\t * @private\n\t */\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == "loaded" || tag.readyState == "complete") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Handle any error events from the tag.\n\t * @method _handleError\n\t * @protected\n\t */\n\tp._handleError = function() {\n\t\tthis._clean();\n\t\tthis.dispatchEvent("error");\n\t};\n\n\t/**\n\t * Handle the tag\'s onload callback.\n\t * @method _handleTagComplete\n\t * @private\n\t */\n\tp._handleTagComplete = function () {\n\t\tthis._rawResult = this._tag;\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n\t\tthis._clean();\n\t\tthis._showTag();\n\n\t\tthis.dispatchEvent("complete");\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specified in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.Event("timeout"));\n\t};\n\n\t/**\n\t * Remove event listeners, but don\'t destroy the request object\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function() {\n\t\tthis._tag.onload = null;\n\t\tthis._tag.onreadystatechange = null;\n\t\tthis._tag.onerror = null;\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\n\t\t}\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tp._hideTag = function() {\n\t\tthis._startTagVisibility = this._tag.style.visibility;\n\t\tthis._tag.style.visibility = "hidden";\n\t};\n\n\tp._showTag = function() {\n\t\tthis._tag.style.visibility = this._startTagVisibility;\n\t};\n\n\t/**\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n\t * that is already in a load, but not complete.\n\t * @method _handleStalled\n\t * @private\n\t */\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\tcreatejs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.\n\t * @class MediaTagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.\n\t * @constructor\n\t */\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\tthis._tag = tag;\n\t\tthis._tagSrcAttribute = srcAttribute;\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\t};\n\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n\tvar s = MediaTagRequest;\n\n\t// public methods\n\tp.load = function () {\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\n\t\tthis._stalledCallback = sc;\n\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleProgress = pc;\n\n\t\tthis._tag.addEventListener("stalled", sc);\n\t\tthis._tag.addEventListener("progress", pc);\n\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\n\t\t// The tag doesn\'t keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n\t\tthis._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn\'t work in Chrome, so we use an event.\n\n\t\tthis.TagRequest_load();\n\t};\n\n\t// private methods\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == "loaded" || tag.readyState == "complete") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\t/**\n\t * An XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no "total", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t// protected methods\n\tp._clean = function () {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);\n\t\tthis._tag.removeEventListener("stalled", this._stalledCallback);\n\t\tthis._tag.removeEventListener("progress", this._progressCallback);\n\n\t\tthis.TagRequest__clean();\n\t};\n\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n// constructor\n\t/**\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n\t * cross-domain loading.\n\t * @class XHRRequest\n\t * @constructor\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n\t * for an overview of supported file properties.\n\t * @extends AbstractLoader\n\t */\n\tfunction XHRRequest (item) {\n\t\tthis.AbstractRequest_constructor(item);\n\n\t\t// protected properties\n\t\t/**\n\t\t * A reference to the XHR request used to load the content.\n\t\t * @property _request\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n\t\t * @private\n\t\t */\n\t\tthis._request = null;\n\n\t\t/**\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n\t\t * typically IE9).\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._loadTimeout = null;\n\n\t\t/**\n\t\t * The browser\'s XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n\t\t * the version, so we use capabilities to make a best guess.\n\t\t * @property _xhrLevel\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._xhrLevel = 1;\n\n\t\t/**\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n\t\t * null until the file is loaded.\n\t\t * @property _response\n\t\t * @type {mixed}\n\t\t * @private\n\t\t */\n\t\tthis._response = null;\n\n\t\t/**\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n\t\t * want to access the raw content as it was loaded.\n\t\t * @property _rawResponse\n\t\t * @type {String|Object}\n\t\t * @private\n\t\t */\n\t\tthis._rawResponse = null;\n\n\t\tthis._canceled = false;\n\n\t\t// Setup our event handlers now.\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n\t\tif (!this._createXHR(item)) {\n\t\t\t//TODO: Throw error?\n\t\t}\n\t};\n\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n\t/**\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n\t * @property ACTIVEX_VERSIONS\n\t * @type {Array}\n\t * @since 0.4.2\n\t * @private\n\t */\n\tXHRRequest.ACTIVEX_VERSIONS = [\n\t\t"Msxml2.XMLHTTP.6.0",\n\t\t"Msxml2.XMLHTTP.5.0",\n\t\t"Msxml2.XMLHTTP.4.0",\n\t\t"MSXML2.XMLHTTP.3.0",\n\t\t"MSXML2.XMLHTTP",\n\t\t"Microsoft.XMLHTTP"\n\t];\n\n// Public methods\n\t/**\n\t * Look up the loaded result.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n\t *      HTML head.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>An binary arraybuffer loaded by XHR</li>\n\t * </ul>\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (raw) {\n\t\tif (raw && this._rawResponse) {\n\t\t\treturn this._rawResponse;\n\t\t}\n\t\treturn this._response;\n\t};\n\n\t// Overrides abstract method in AbstractRequest\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis._clean();\n\t\tthis._request.abort();\n\t};\n\n\t// Overrides abstract method in AbstractLoader\n\tp.load = function () {\n\t\tif (this._request == null) {\n\t\t\tthis._handleError();\n\t\t\treturn;\n\t\t}\n\n\t\t//Events\n\t\tif (this._request.addEventListener != null) {\n\t\t\tthis._request.addEventListener("loadstart", this._handleLoadStartProxy, false);\n\t\t\tthis._request.addEventListener("progress", this._handleProgressProxy, false);\n\t\t\tthis._request.addEventListener("abort", this._handleAbortProxy, false);\n\t\t\tthis._request.addEventListener("error", this._handleErrorProxy, false);\n\t\t\tthis._request.addEventListener("timeout", this._handleTimeoutProxy, false);\n\n\t\t\t// Note: We don\'t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.addEventListener("load", this._handleLoadProxy, false);\n\t\t\tthis._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);\n\t\t} else {\n\t\t\t// IE9 support\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\n\t\t\tthis._request.onabort = this._handleAbortProxy;\n\t\t\tthis._request.onerror = this._handleErrorProxy;\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\n\n\t\t\t// Note: We don\'t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.onload = this._handleLoadProxy;\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\n\t\t}\n\n\t\t// Set up a timeout if we don\'t have XHR2\n\t\tif (this._xhrLevel == 1) {\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\t\t}\n\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n\t\ttry {\n\t\t\tif (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\n\t\t\t\tthis._request.send();\n\t\t\t} else if (this._item.method == createjs.AbstractLoader.POST) {\n\t\t\t\tthis._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));\n\t\t}\n\t};\n\n\tp.setResponseType = function (type) {\n\t\t// Some old browsers doesn\'t support blob, so we convert arraybuffer to blob after response is downloaded\n\t\tif (type === \'blob\') {\n\t\t\ttype = window.URL ? \'blob\' : \'arraybuffer\';\n\t\t\tthis._responseType = type;\n\t\t}\n\t\tthis._request.responseType = type;\n\t};\n\n\t/**\n\t * Get all the response headers from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n\t * pair.\n\t * @method getAllResponseHeaders\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getAllResponseHeaders = function () {\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\n\t\t\treturn this._request.getAllResponseHeaders();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Get a specific response header from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\n\t * @method getResponseHeader\n\t * @param {String} header The header name to retrieve.\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getResponseHeader = function (header) {\n\t\tif (this._request.getResponseHeader instanceof Function) {\n\t\t\treturn this._request.getResponseHeader(header);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n// protected methods\n\t/**\n\t * The XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no "total", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t/**\n\t * The XHR request has reported a load start.\n\t * @method _handleLoadStart\n\t * @param {Object} event The XHR loadStart event.\n\t * @private\n\t */\n\tp._handleLoadStart = function (event) {\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis.dispatchEvent("loadstart");\n\t};\n\n\t/**\n\t * The XHR request has reported an abort event.\n\t * @method handleAbort\n\t * @param {Object} event The XHR abort event.\n\t * @private\n\t */\n\tp._handleAbort = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));\n\t};\n\n\t/**\n\t * The XHR request has reported an error event.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\n\t};\n\n\t/**\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\n\t * @method _handleReadyStateChange\n\t * @param {Object} event The XHR readyStateChange event.\n\t * @private\n\t */\n\tp._handleReadyStateChange = function (event) {\n\t\tif (this._request.readyState == 4) {\n\t\t\tthis._handleLoad();\n\t\t}\n\t};\n\n\t/**\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n\t * @method _handleLoad\n\t * @param {Object} event The XHR load event.\n\t * @private\n\t */\n\tp._handleLoad = function (event) {\n\t\tif (this.loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis.loaded = true;\n\n\t\tvar error = this._checkError();\n\t\tif (error) {\n\t\t\tthis._handleError(error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._response = this._getResponse();\n\t\t// Convert arraybuffer back to blob\n\t\tif (this._responseType === \'arraybuffer\') {\n\t\t\ttry {\n\t\t\t\tthis._response = new Blob([this._response]);\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t\t\t\tif (e.name === \'TypeError\' && window.BlobBuilder) {\n\t\t\t\t\tvar builder = new BlobBuilder();\n\t\t\t\t\tbuilder.append(this._response);\n\t\t\t\t\tthis._response = builder.getBlob();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.Event("complete"));\n\t};\n\n\t/**\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n\t * callback.\n\t * @method _handleTimeout\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n\t * @private\n\t */\n\tp._handleTimeout = function (event) {\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));\n\t};\n\n// Protected\n\t/**\n\t * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\n\t * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\n\t * @method _checkError\n\t * @return {int} If the request status returns an error code.\n\t * @private\n\t */\n\tp._checkError = function () {\n\t\t//LM: Probably need additional handlers here, maybe 501\n\t\tvar status = parseInt(this._request.status);\n\n\t\tswitch (status) {\n\t\t\tcase 404:   // Not Found\n\t\t\tcase 0:     // Not Loaded\n\t\t\t\treturn new Error(status);\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n\t * @method _getResponse\n\t * @private\n\t */\n\tp._getResponse = function () {\n\t\tif (this._response != null) {\n\t\t\treturn this._response;\n\t\t}\n\n\t\tif (this._request.response != null) {\n\t\t\treturn this._request.response;\n\t\t}\n\n\t\t// Android 2.2 uses .responseText\n\t\ttry {\n\t\t\tif (this._request.responseText != null) {\n\t\t\t\treturn this._request.responseText;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n\t\ttry {\n\t\t\tif (this._request.responseXML != null) {\n\t\t\t\treturn this._request.responseXML;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n\t *      <li>XMLHttpRequest are created when available.</li>\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n\t *      <li>Text requests override the mime type if possible</li>\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n\t *      <li>Binary loads set the response type to "arraybuffer"</li></ol>\n\t * @method _createXHR\n\t * @param {Object} item The requested item that is being loaded.\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\n\t * @private\n\t */\n\tp._createXHR = function (item) {\n\t\t// Check for cross-domain loads. We can\'t fully support them, but we can try.\n\t\tvar crossdomain = createjs.RequestUtils.isCrossDomain(item);\n\t\tvar headers = {};\n\n\t\t// Create the request. Fallback to whatever support we have.\n\t\tvar req = null;\n\t\tif (window.XMLHttpRequest) {\n\t\t\treq = new XMLHttpRequest();\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n\t\t\t\treq = new XDomainRequest();\n\t\t\t}\n\t\t} else { // Old IE versions use a different approach\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\n\t\t\t\ttry {\n\t\t\t\t\treq = new ActiveXObject(axVersion);\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (req == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Default to utf-8 for Text requests.\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\n\t\t\titem.mimeType = "text/plain; charset=utf-8";\n\t\t}\n\n\t\t// IE9 doesn\'t support overrideMimeType(), so we need to check for it.\n\t\tif (item.mimeType && req.overrideMimeType) {\n\t\t\treq.overrideMimeType(item.mimeType);\n\t\t}\n\n\t\t// Determine the XHR level\n\t\tthis._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;\n\n\t\tvar src = null;\n\t\tif (item.method == createjs.AbstractLoader.GET) {\n\t\t\tsrc = createjs.RequestUtils.buildPath(item.src, item.values);\n\t\t} else {\n\t\t\tsrc = item.src;\n\t\t}\n\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n\t\treq.open(item.method || createjs.AbstractLoader.GET, src, true);\n\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n\t\t\theaders["Origin"] = location.origin;\n\t\t}\n\n\t\t// To send data we need to set the Content-type header)\n\t\tif (item.values && item.method == createjs.AbstractLoader.POST) {\n\t\t\theaders["Content-Type"] = "application/x-www-form-urlencoded";\n\t\t}\n\n\t\tif (!crossdomain && !headers["X-Requested-With"]) {\n\t\t\theaders["X-Requested-With"] = "XMLHttpRequest";\n\t\t}\n\n\t\tif (item.headers) {\n\t\t\tfor (var n in item.headers) {\n\t\t\t\theaders[n] = item.headers[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (n in headers) {\n\t\t\treq.setRequestHeader(n, headers[n])\n\t\t}\n\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n\t\t\treq.withCredentials = item.withCredentials;\n\t\t}\n\n\t\tthis._request = req;\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * A request has completed (or failed or canceled), and needs to be disposed.\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function () {\n\t\tclearTimeout(this._loadTimeout);\n\n\t\tif (this._request.removeEventListener != null) {\n\t\t\tthis._request.removeEventListener("loadstart", this._handleLoadStartProxy);\n\t\t\tthis._request.removeEventListener("progress", this._handleProgressProxy);\n\t\t\tthis._request.removeEventListener("abort", this._handleAbortProxy);\n\t\t\tthis._request.removeEventListener("error", this._handleErrorProxy);\n\t\t\tthis._request.removeEventListener("timeout", this._handleTimeoutProxy);\n\t\t\tthis._request.removeEventListener("load", this._handleLoadProxy);\n\t\t\tthis._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);\n\t\t} else {\n\t\t\tthis._request.onloadstart = null;\n\t\t\tthis._request.onprogress = null;\n\t\t\tthis._request.onabort = null;\n\t\t\tthis._request.onerror = null;\n\t\t\tthis._request.ontimeout = null;\n\t\t\tthis._request.onload = null;\n\t\t\tthis._request.onreadystatechange = null;\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn "[PreloadJS XHRRequest]";\n\t};\n\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");\n\n}());\n\n//##############################################################################\n// LoadQueue.js\n//##############################################################################\n\n/*\n TODO: WINDOWS ISSUES\n * No error for HTML audio in IE 678\n * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR\n * No script complete handler in IE 67 TAGS (XHR is fine)\n * No XML/JSON in IE6 TAGS\n * Need to hide loading SVG in Opera TAGS\n * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)\n * SVG no load or failure in Opera XHR\n * Reported issues with IE7/8\n */\n\n(function () {\n\t"use strict";\n\n// constructor\n\t/**\n\t * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either\n\t * a single file, or queue of files.\n\t *\n\t * <b>Creating a Queue</b><br />\n\t * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR\n\t * argument to false.\n\t *\n\t *      var queue = new createjs.LoadQueue(true);\n\t *\n\t * <b>Listening for Events</b><br />\n\t * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}\n\t * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>\n\t *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all\n\t *     files</li>\n\t *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with\n\t *     any file.</li>\n\t *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has\n\t *     changed.</li>\n\t *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>\n\t *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note\n\t *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>\n\t * </ul>\n\t *\n\t *      queue.on("fileload", handleFileLoad, this);\n\t *      queue.on("complete", handleComplete, this);\n\t *\n\t * <b>Adding files and manifests</b><br />\n\t * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a\n\t * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are\n\t * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you\n\t * like.\n\t *\n\t *      queue.loadFile("filePath/file.jpg");\n\t *      queue.loadFile({id:"image", src:"filePath/file.jpg"});\n\t *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);\n\t *\n\t *      // Use an external manifest\n\t *      queue.loadManifest("path/to/manifest.json");\n\t *      queue.loadManifest({src:"manifest.json", type:"manifest"});\n\t *\n\t * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not\n\t * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin\n\t * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a\n\t * `loadNow` argument of `true`.\n\t *\n\t *      queue.load();\n\t *\n\t * <b>File Types</b><br />\n\t * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS\n\t * should handle the majority of standard file and url formats, and works with common file extensions. If you have\n\t * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a\n\t * <code>type</code> property with any manifest item.\n\t *\n\t *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.AbstractLoader.SOUND});\n\t *\n\t *      // Note that PreloadJS will not read a file extension from the query string\n\t *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.AbstractLoader.IMAGE});\n\t *\n\t * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:\n\t * <ul>\n\t *     <li>{{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>\n\t *     <li>{{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}: CSS files</li>\n\t *     <li>{{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}: Common image formats</li>\n\t *     <li>{{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>\n\t *     <li>{{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}: JSON data</li>\n\t *     <li>{{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>\n\t *     <li>{{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see\n\t *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>\n\t *     <li>{{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}: Audio file formats</li>\n\t *     <li>{{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definitions. This\n\t *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>\n\t *     <li>{{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}: SVG files</li>\n\t *     <li>{{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>\n     *     <li>{{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}: Video objects</li>\n\t *     <li>{{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}: XML data</li>\n\t * </ul>\n\t *\n\t * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better\n\t * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but\n\t * are deprecated.</em>\n\t *\n\t * <b>Handling Results</b><br />\n\t * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is\n\t * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a\n\t * formatted object that can be used immediately, including:\n\t * <ul>\n\t *     <li>Binary: The binary loaded result</li>\n\t *     <li>CSS: A &lt;link /&gt; tag</li>\n\t *     <li>Image: An &lt;img /&gt; tag</li>\n\t *     <li>JavaScript: A &lt;script /&gt; tag</li>\n\t *     <li>JSON/JSONP: A formatted JavaScript Object</li>\n\t *     <li>Manifest: A JavaScript object.\n\t *     <li>Sound: An &lt;audio /&gt; tag</a>\n\t *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.\n\t *     <li>SVG: An &lt;object /&gt; tag</li>\n\t *     <li>Text: Raw text</li>\n     *     <li>Video: A Video DOM node</li>\n\t *     <li>XML: An XML DOM node</li>\n\t * </ul>\n\t *\n\t *      function handleFileLoad(event) {\n\t *          var item = event.item; // A reference to the item that was passed in to the LoadQueue\n\t *          var type = item.type;\n\t *\n\t *          // Add any images to the page body.\n\t *          if (type == createjs.LoadQueue.IMAGE) {\n\t *              document.body.appendChild(event.result);\n\t *          }\n\t *      }\n\t *\n\t * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up\n\t * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the\n\t * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>\n\t * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.\n\t *\n\t *      var image = queue.getResult("image");\n\t *      document.body.appendChild(image);\n\t *\n\t * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}\n\t * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd\n\t * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,\n\t * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.\n\t *\n\t *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.\n\t *\n\t * <b>Plugins</b><br />\n\t * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,\n\t * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,\n\t * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.\n\t *\n\t *      queue.installPlugin(createjs.Sound);\n\t *\n\t * <h4>Known Browser Issues</h4>\n\t * <ul>\n\t *     <li>Browsers without audio support can not load audio files.</li>\n\t *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>\n\t *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other\n\t *     than Chrome will continue to download in the background.</li>\n\t *     <li>When loading scripts using tags, they are automatically added to the document.</li>\n\t *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>\n\t *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require\n\t *     XHR to work.</li>\n\t *     <li>Content loaded via tags will not show progress, and will continue to download in the background when\n\t *     canceled, although no events will be dispatched.</li>\n\t * </ul>\n\t *\n\t * @class LoadQueue\n\t * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP\n\t * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR\n\t * when necessary.\n\t * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue\n\t * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`\n\t * will not receive a base path.\n\t * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To\n\t * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any\n\t * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin\n\t * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>\n\t *\n\t * @constructor\n\t * @extends AbstractLoader\n\t */\n\tfunction LoadQueue (preferXHR, basePath, crossOrigin) {\n\t\tthis.AbstractLoader_constructor();\n\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._plugins = [];\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _typeCallbacks\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._typeCallbacks = {};\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _extensionCallbacks\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._extensionCallbacks = {};\n\n\t\t/**\n\t\t * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and\n\t\t * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.\n\t\t * @property next\n\t\t * @type {LoadQueue}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head\n\t\t * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas\n\t\t * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order\n\t\t * specified.\n\t\t *\n\t\t * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}\n\t\t * property on the load item, or by ensuring that only one connection can be open at a time using\n\t\t * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property\n\t\t * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the\n\t\t * `maintainScriptOrder` to `false` during a load will not change items already in a queue.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var queue = new createjs.LoadQueue();\n\t\t *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once\n\t\t *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order\n\t\t *      queue.loadManifest([\n\t\t *          "script1.js",\n\t\t *          "script2.js",\n\t\t *          "image.png", // Load any time\n\t\t *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js\n\t\t *          "image3.png",\n\t\t *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)\n\t\t *      ]);\n\t\t *\n\t\t * @property maintainScriptOrder\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.maintainScriptOrder = true;\n\n\t\t/**\n\t\t * Determines if the LoadQueue will stop processing the current queue when an error is encountered.\n\t\t * @property stopOnError\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopOnError = false;\n\n\t\t/**\n\t\t * The number of maximum open connections that a loadQueue tries to maintain. Please see\n\t\t * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.\n\t\t * @property _maxConnections\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._maxConnections = 1;\n\n\t\t/**\n\t\t * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the\n\t\t * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can\n\t\t * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is\n\t\t * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the\n\t\t * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of\n\t\t * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.\n\t\t *\n\t\t * Loaders can be removed from PreloadJS by simply not including them.\n\t\t *\n\t\t * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list\n\t\t * so that they are checked first.\n\t\t * @property _availableLoaders\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._availableLoaders = [\n\t\t\tcreatejs.ImageLoader,\n\t\t\tcreatejs.JavaScriptLoader,\n\t\t\tcreatejs.CSSLoader,\n\t\t\tcreatejs.JSONLoader,\n\t\t\tcreatejs.JSONPLoader,\n\t\t\tcreatejs.SoundLoader,\n\t\t\tcreatejs.ManifestLoader,\n\t\t\tcreatejs.SpriteSheetLoader,\n\t\t\tcreatejs.XMLLoader,\n\t\t\tcreatejs.SVGLoader,\n\t\t\tcreatejs.BinaryLoader,\n\t\t\tcreatejs.VideoLoader,\n\t\t\tcreatejs.TextLoader\n\t\t];\n\n\t\t/**\n\t\t * The number of built in loaders, so they can\'t be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.\n\t\t\t\t * @property _defaultLoaderLength\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._defaultLoaderLength = this._availableLoaders.length;\n\n\t\tthis.init(preferXHR, basePath, crossOrigin);\n\t}\n\n\tvar p = createjs.extend(LoadQueue, createjs.AbstractLoader);\n\tvar s = LoadQueue;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t/**\n\t * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.\n\t * @method init\n\t * @param preferXHR\n\t * @param basePath\n\t * @param crossOrigin\n\t * @private\n\t */\n\tp.init = function (preferXHR, basePath, crossOrigin) {\n\n\t\t// public properties\n\t\t/**\n\t\t * @property useXHR\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t * @deprecated Use preferXHR instead.\n\t\t */\n\t\tthis.useXHR = true;\n\n\t\t/**\n\t\t * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR\n\t\t * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,\n\t\t * and plain text can not be loaded with tags, so it will default the the correct type instead of using the\n\t\t * user-defined type.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis.preferXHR = true; //TODO: Get/Set\n\t\tthis._preferXHR = true;\n\t\tthis.setPreferXHR(preferXHR);\n\n\t\t// protected properties\n\t\t/**\n\t\t * Whether the queue is currently paused or not.\n\t\t * @property _paused\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * A path that will be prepended on to the item\'s {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The\n\t\t * `_basePath` property will only be used if an item\'s source is relative, and does not include a protocol such\n\t\t * as `http://`, or a relative path such as `../`.\n\t\t * @property _basePath\n\t\t * @type {String}\n\t\t * @private\n\t\t * @since 0.3.1\n\t\t */\n\t\tthis._basePath = basePath;\n\n\t\t/**\n\t\t * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded\n\t\t * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by\n\t\t * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,\n\t\t * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""\n\t\t * and "Anonymous".\n\t\t * @property _crossOrigin\n\t\t * @type {String}\n\t\t * @default ""\n\t\t * @private\n\t\t * @since 0.4.1\n\t\t */\n\t\tthis._crossOrigin = crossOrigin;\n\n\t\t/**\n\t\t * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first\n\t\t * file is requested.\n\t\t * @property _loadStartWasDispatched\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @private\n\t\t */\n\t\tthis._loadStartWasDispatched = false;\n\n\t\t/**\n\t\t * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when\n\t\t * using a script tag to do preloading.\n\t\t * @property _currentlyLoadingScript\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._currentlyLoadingScript = null;\n\n\t\t/**\n\t\t * An array containing the currently downloading files.\n\t\t * @property _currentLoads\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._currentLoads = [];\n\n\t\t/**\n\t\t * An array containing the queued items that have not yet started downloading.\n\t\t * @property _loadQueue\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueue = [];\n\n\t\t/**\n\t\t * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.\n\t\t * @property _loadQueueBackup\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueueBackup = [];\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}\n\t\t * id.\n\t\t * @property _loadItemsById\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsById = {};\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}\n\t\t * source.\n\t\t * @property _loadItemsBySrc\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsBySrc = {};\n\n\t\t/**\n\t\t * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.\n\t\t * @property _loadedResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedResults = {};\n\n\t\t/**\n\t\t * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.\n\t\t * @property _loadedRawResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedRawResults = {};\n\n\t\t/**\n\t\t * The number of items that have been requested. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded. This does not include items inside of loaders such as the\n\t\t * {{#crossLink "ManifestLoader"}}{{/crossLink}}.\n\t\t * @property _numItems\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItems = 0;\n\n\t\t/**\n\t\t * The number of items that have completed loaded. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded.\n\t\t * @property _numItemsLoaded\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItemsLoaded = 0;\n\n\t\t/**\n\t\t * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right\n\t\t * order.\n\t\t * @property _scriptOrder\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._scriptOrder = [];\n\n\t\t/**\n\t\t * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are\n\t\t * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>\n\t\t * once they are complete and have been dispatched.\n\t\t * @property _loadedScripts\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadedScripts = [];\n\n\t\t/**\n\t\t * The last progress amount. This is used to suppress duplicate progress events.\n\t\t * @property _lastProgress\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._lastProgress = NaN;\n\n\t};\n\n// static properties\n\t/**\n\t * The time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}\n\t * event is dispatched if the timeout is reached before any data is received.\n\t * @property loadTimeout\n\t * @type {Number}\n\t * @default 8000\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated In favour of {{#crossLink "LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.\n\t */\n\ts.loadTimeout = 8000;\n\n\t/**\n\t * The time in milliseconds to assume a load has failed.\n\t * @property LOAD_TIMEOUT\n\t * @type {Number}\n\t * @default 0\n\t * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.\n\t */\n\ts.LOAD_TIMEOUT = 0;\n\n// Preload Types\n\t/**\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}} instead.\n\t */\n\ts.BINARY = createjs.AbstractLoader.BINARY;\n\n\t/**\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.\n\t */\n\ts.CSS = createjs.AbstractLoader.CSS;\n\n\t/**\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.\n\t */\n\ts.IMAGE = createjs.AbstractLoader.IMAGE;\n\n\t/**\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.\n\t */\n\ts.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;\n\n\t/**\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}} instead.\n\t */\n\ts.JSON = createjs.AbstractLoader.JSON;\n\n\t/**\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}} instead.\n\t */\n\ts.JSONP = createjs.AbstractLoader.JSONP;\n\n\t/**\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}} instead.\n\t */\n\ts.MANIFEST = createjs.AbstractLoader.MANIFEST;\n\n\t/**\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.\n\t */\n\ts.SOUND = createjs.AbstractLoader.SOUND;\n\n\t/**\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.\n\t */\n\ts.VIDEO = createjs.AbstractLoader.VIDEO;\n\n\t/**\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}} instead.\n\t */\n\ts.SVG = createjs.AbstractLoader.SVG;\n\n\t/**\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}} instead.\n\t */\n\ts.TEXT = createjs.AbstractLoader.TEXT;\n\n\t/**\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}} instead.\n\t */\n\ts.XML = createjs.AbstractLoader.XML;\n\n\t/**\n\t * @property POST\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} instead.\n\t */\n\ts.POST = createjs.AbstractLoader.POST;\n\n\t/**\n\t * @property GET\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} instead.\n\t */\n\ts.GET = createjs.AbstractLoader.GET;\n\n// events\n\t/**\n\t * This event is fired when an individual file has loaded, and been processed.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n\t * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file\'s progress changes.\n\t * @event fileprogress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This event is fired when an individual file starts to load.\n\t * @event filestart\n\t * @param {Object} The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n\t * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a property.\n\t */\n\n\t/**\n\t * Although it extends {{#crossLink "AbstractLoader"}}{{/crossLink}}, the `initialize` event is never fired from\n\t * a LoadQueue instance.\n\t * @event initialize\n\t * @private\n\t */\n\n// public methods\n\t/**\n\t * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.\n\t * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added\n\t * once, and will be prepended to the list of available loaders.\n\t * @method registerLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to add.\n\t * @since 0.6.0\n\t */\n\tp.registerLoader = function (loader) {\n\t\tif (!loader || !loader.canLoadItem) {\n\t\t\tthrow new Error("loader is of an incorrect type.");\n\t\t} else if (this._availableLoaders.indexOf(loader) != -1) {\n\t\t\tthrow new Error("loader already exists."); //LM: Maybe just silently fail here\n\t\t}\n\n\t\tthis._availableLoaders.unshift(loader);\n\t};\n\n\t/**\n\t * Remove a custom loader added using {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be\n\t * unregistered, the default loaders will always be available.\n\t * @method unregisterLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to remove\n\t */\n\tp.unregisterLoader = function (loader) {\n\t\tvar idx = this._availableLoaders.indexOf(loader);\n\t\tif (idx != -1 && idx < this._defaultLoaderLength - 1) {\n\t\t\tthis._availableLoaders.splice(idx, 1);\n\t\t}\n\t};\n\n\t/**\n\t * @method setUseXHR\n\t * @param {Boolean} value The new useXHR value to set.\n\t * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if\n\t * the provided value argument was true.\n\t * @since 0.3.0\n\t * @deprecated use the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property, or the\n\t * {{#crossLink "LoadQueue/setUseXHR"}}{{/crossLink}} method instead.\n\t */\n\tp.setUseXHR = function (value) {\n\t\treturn this.setPreferXHR(value);\n\t};\n\n\t/**\n\t * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may\n\t * fail, or be ignored depending on the browser\'s capabilities and the load type.\n\t * @method setPreferXHR\n\t * @param {Boolean} value\n\t * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.\n\t * @since 0.6.0\n\t */\n\tp.setPreferXHR = function (value) {\n\t\t// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.\n\t\t//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.\n\t\tthis.preferXHR = (value != false && window.XMLHttpRequest != null);\n\t\treturn this.preferXHR;\n\t};\n\n\t/**\n\t * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded\n\t * content, and allows the queue to be used again.\n\t * @method removeAll\n\t * @since 0.3.0\n\t */\n\tp.removeAll = function () {\n\t\tthis.remove();\n\t};\n\n\t/**\n\t * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.\n\t * This also removes internal references to loaded item(s).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      queue.loadManifest([\n\t *          {src:"test.png", id:"png"},\n\t *          {src:"test.jpg", id:"jpg"},\n\t *          {src:"test.mp3", id:"mp3"}\n\t *      ]);\n\t *      queue.remove("png"); // Single item by ID\n\t *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.\n\t *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.\n\t *\n\t * @method remove\n\t * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of\n\t * items, or multiple items as arguments.\n\t * @since 0.3.0\n\t */\n\tp.remove = function (idsOrUrls) {\n\t\tvar args = null;\n\n\t\tif (idsOrUrls && !Array.isArray(idsOrUrls)) {\n\t\t\targs = [idsOrUrls];\n\t\t} else if (idsOrUrls) {\n\t\t\targs = idsOrUrls;\n\t\t} else if (arguments.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar itemsWereRemoved = false;\n\n\t\t// Destroy everything\n\t\tif (!args) {\n\t\t\tthis.close();\n\t\t\tfor (var n in this._loadItemsById) {\n\t\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t\t}\n\t\t\tthis.init(this.preferXHR, this._basePath);\n\n\t\t\t// Remove specific items\n\t\t} else {\n\t\t\twhile (args.length) {\n\t\t\t\tvar item = args.pop();\n\t\t\t\tvar r = this.getResult(item);\n\n\t\t\t\t//Remove from the main load Queue\n\t\t\t\tfor (i = this._loadQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueue[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueue.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove from the backup queue\n\t\t\t\tfor (i = this._loadQueueBackup.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueueBackup[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueueBackup.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (r) {\n\t\t\t\t\tthis._disposeItem(this.getItem(item));\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = this._currentLoads.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar loadItem = this._currentLoads[i].getItem();\n\t\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\t\tthis._currentLoads.splice(i, 1)[0].cancel();\n\t\t\t\t\t\t\titemsWereRemoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was called during a load, try to load the next item.\n\t\t\tif (itemsWereRemoved) {\n\t\t\t\tthis._loadNext();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stops all open loads, destroys any loaded items, and resets the queue, so all items can\n\t * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the\n\t * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or\n\t * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.\n\t * @method reset\n\t * @since 0.3.0\n\t */\n\tp.reset = function () {\n\t\tthis.close();\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t}\n\n\t\t//Reset the queue to its start state\n\t\tvar a = [];\n\t\tfor (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {\n\t\t\ta.push(this._loadQueueBackup[i].getItem());\n\t\t}\n\n\t\tthis.loadManifest(a, false);\n\t};\n\n\t/**\n\t * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).\n\t * Currently, only one plugin can exist per type/extension.\n\t *\n\t * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information\n\t * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the\n\t * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.\n\t *\n\t * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned\n\t * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its\n\t * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when\n\t * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these\n\t * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}\n\t * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.\n\t *\n\t * @method installPlugin\n\t * @param {Function} plugin The plugin class to install.\n\t */\n\tp.installPlugin = function (plugin) {\n\t\tif (plugin == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin.getPreloadHandlers != null) {\n\t\t\tthis._plugins.push(plugin);\n\t\t\tvar map = plugin.getPreloadHandlers();\n\t\t\tmap.scope = plugin;\n\n\t\t\tif (map.types != null) {\n\t\t\t\tfor (var i = 0, l = map.types.length; i < l; i++) {\n\t\t\t\t\tthis._typeCallbacks[map.types[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map.extensions != null) {\n\t\t\t\tfor (i = 0, l = map.extensions.length; i < l; i++) {\n\t\t\t\t\tthis._extensionCallbacks[map.extensions[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum\n\t * number of open connections, so any additional connections may remain in a pending state until the browser\n\t * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}\n\t * is `true`, only one script is loaded at a time due to browser limitations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.setMaxConnections(10); // Allow 10 concurrent loads\n\t *\n\t * @method setMaxConnections\n\t * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue\n\t * is open at any time.\n\t */\n\tp.setMaxConnections = function (value) {\n\t\tthis._maxConnections = value;\n\t\tif (!this._paused && this._loadQueue.length > 0) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}\n\t * method.\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.\n\t * @method loadFile\n\t * @param {LoadItem|Object|String} file The file object or path to load. A file can be either\n\t * <ul>\n\t *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadFile = function (file, loadNow, basePath) {\n\t\tif (file == null) {\n\t\t\tvar event = new createjs.ErrorEvent("PRELOAD_NO_FILE");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\t\tthis._addItem(file, null, basePath);\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.\n\t * The files in the manifest are requested in the same order, but may complete in a different order if the max\n\t * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load\n\t * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is\n\t * default).\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.\n\t * @method loadManifest\n\t * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of\n\t * manifests:\n\t * <ol>\n\t *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,\n\t *     which defines the list of files to load, and can optionally contain a "path" property, which will be\n\t *     prepended to each file in the list.</li>\n\t *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP\n\t *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,\n\t *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>\n\t *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can\n\t *     optionally contain a "path" property, which will be prepended to each file in the list.</li>\n\t *     <li>An Array of files to load.</li>\n\t * </ol>\n\t *\n\t * Each "file" in a manifest can be either:\n\t * <ul>\n\t *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t *\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadManifest = function (manifest, loadNow, basePath) {\n\t\tvar fileList = null;\n\t\tvar path = null;\n\n\t\t// Array-based list of items\n\t\tif (Array.isArray(manifest)) {\n\t\t\tif (manifest.length == 0) {\n\t\t\t\tvar event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");\n\t\t\t\tthis._sendError(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfileList = manifest;\n\n\t\t\t// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.\n\t\t} else if (typeof(manifest) === "string") {\n\t\t\tfileList = [\n\t\t\t\t{\n\t\t\t\t\tsrc: manifest,\n\t\t\t\t\ttype: s.MANIFEST\n\t\t\t\t}\n\t\t\t];\n\n\t\t} else if (typeof(manifest) == "object") {\n\n\t\t\t// An object that defines a manifest path\n\t\t\tif (manifest.src !== undefined) {\n\t\t\t\tif (manifest.type == null) {\n\t\t\t\t\tmanifest.type = s.MANIFEST;\n\t\t\t\t} else if (manifest.type != s.MANIFEST) {\n\t\t\t\t\tvar event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");\n\t\t\t\t\tthis._sendError(event);\n\t\t\t\t}\n\t\t\t\tfileList = [manifest];\n\n\t\t\t\t// An object that defines a manifest\n\t\t\t} else if (manifest.manifest !== undefined) {\n\t\t\t\tfileList = manifest.manifest;\n\t\t\t\tpath = manifest.path;\n\t\t\t}\n\n\t\t\t// Unsupported. This will throw an error.\n\t\t} else {\n\t\t\tvar event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, l = fileList.length; i < l; i++) {\n\t\t\tthis._addItem(fileList[i], path, basePath);\n\t\t}\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\n\t};\n\n\t/**\n\t * Start a LoadQueue that was created, but not automatically started.\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis.setPaused(false);\n\t};\n\n\t/**\n\t * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was\n\t * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getItem\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}\n\t * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}\n\t * event as the `item` parameter.\n\t */\n\tp.getItem = function (value) {\n\t\treturn this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t};\n\n\t/**\n\t * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"\n\t * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getResult\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML\n\t *      DOM.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>A binary arraybuffer loaded by XHR</li>\n\t *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play\n\t *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method\n\t *      which can not be used to play audio back.</li>\n\t * </ul>\n\t * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the \'item`\n\t * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (value, rawResult) {\n\t\tvar item = this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar id = item.id;\n\t\tif (rawResult && this._loadedRawResults[id]) {\n\t\t\treturn this._loadedRawResults[id];\n\t\t}\n\t\treturn this._loadedResults[id];\n\t};\n\n\t/**\n\t * Generate an list of items loaded by this queue.\n\t * @method getItems\n\t * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress\n\t * and failed load items will also be included.\n\t * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},\n\t * result, and rawResult.\n\t * @since 0.6.0\n\t */\n\tp.getItems = function (loaded) {\n\t\tvar arr = [];\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tvar item = this._loadItemsById[n];\n\t\t\tvar result = this.getResult(n);\n\t\t\tif (loaded === true && result == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr.push({\n\t\t\t\titem: item,\n\t\t\t\tresult: result,\n\t\t\t\trawResult: this.getResult(n, true)\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not\n\t * be processed when active loads complete. LoadQueues are not paused by default.\n\t *\n\t * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or\n\t * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`\n\t * argument is `false`.\n\t * @method setPaused\n\t * @param {Boolean} value Whether the queue should be paused or not.\n\t */\n\tp.setPaused = function (value) {\n\t\tthis._paused = value;\n\t\tif (!this._paused) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from\n\t * starting to download. Note that currently any active loads will remain open, and events may be processed.\n\t *\n\t * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.\n\t * @method close\n\t */\n\tp.close = function () {\n\t\twhile (this._currentLoads.length) {\n\t\t\tthis._currentLoads.pop().cancel();\n\t\t}\n\t\tthis._scriptOrder.length = 0;\n\t\tthis._loadedScripts.length = 0;\n\t\tthis.loadStartWasDispatched = false;\n\t\tthis._itemCount = 0;\n\t\tthis._lastProgress = NaN;\n\t};\n\n// protected methods\n\t/**\n\t * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to\n\t * load the content. The load queue is populated with the loader instance that handles preloading, and not the load\n\t * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}\n\t * method.\n\t * @method _addItem\n\t * @param {String|Object} value The item to add to the queue.\n\t * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is\n\t * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was\n\t * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.\n\t * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}\n\t * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged\n\t * version.\n\t * @private\n\t */\n\tp._addItem = function (value, path, basePath) {\n\t\tvar item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.\n\t\tif (item == null) {\n\t\t\treturn;\n\t\t} // Sometimes plugins or types should be skipped.\n\t\tvar loader = this._createLoader(item);\n\t\tif (loader != null) {\n\t\t\tif ("plugins" in loader) {\n\t\t\t\tloader.plugins = this._plugins;\n\t\t\t}\n\t\t\titem._loader = loader;\n\t\t\tthis._loadQueue.push(loader);\n\t\t\tthis._loadQueueBackup.push(loader);\n\n\t\t\tthis._numItems++;\n\t\t\tthis._updateProgress();\n\n\t\t\t// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.\n\t\t\tif ((this.maintainScriptOrder\n\t\t\t\t\t&& item.type == createjs.LoadQueue.JAVASCRIPT\n\t\t\t\t\t\t//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way\n\t\t\t\t\t)\n\t\t\t\t\t|| item.maintainOrder === true) {\n\t\t\t\tthis._scriptOrder.push(item);\n\t\t\t\tthis._loadedScripts.push(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of\n\t * item is determined by browser support, requirements based on the file type, and developer settings. For example,\n\t * XHR is only used for file types that support it in new browsers.\n\t *\n\t * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may\n\t * alter the load item.\n\t * @method _createLoadItem\n\t * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.\n\t * @param {String} [path] A path to prepend to the item\'s source. Sources beginning with http:// or similar will\n\t * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}\n\t * when it is added.\n\t * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to\n\t * the path argument.\n\t * @return {Object} The loader instance that will be used.\n\t * @private\n\t */\n\tp._createLoadItem = function (value, path, basePath) {\n\t\tvar item = createjs.LoadItem.create(value);\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar bp = ""; // Store the generated basePath\n\t\tvar useBasePath = basePath || this._basePath;\n\n\t\tif (item.src instanceof Object) {\n\t\t\tif (!item.type) {\n\t\t\t\treturn null;\n\t\t\t} // the the src is an object, type is required to pass off to plugin\n\t\t\tif (path) {\n\t\t\t\tbp = path;\n\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t// Also append basePath\n\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t}\n\t\t\t} else if (useBasePath != null) {\n\t\t\t\tbp = useBasePath;\n\t\t\t}\n\t\t} else {\n\t\t\t// Determine Extension, etc.\n\t\t\tvar match = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t\tif (item.type == null) {\n\t\t\t\titem.type = createjs.RequestUtils.getTypeByExtension(item.ext);\n\t\t\t}\n\n\t\t\t// Inject path & basePath\n\t\t\tvar autoId = item.src;\n\t\t\tif (!match.absolute && !match.relative) {\n\t\t\t\tif (path) {\n\t\t\t\t\tbp = path;\n\t\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t\tautoId = path + autoId;\n\t\t\t\t\t// Also append basePath\n\t\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t\t}\n\t\t\t\t} else if (useBasePath != null) {\n\t\t\t\t\tbp = useBasePath;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.src = bp + item.src;\n\t\t}\n\t\titem.path = bp;\n\n\t\t// If there\'s no id, set one now.\n\t\tif (item.id === undefined || item.id === null || item.id === "") {\n\t\t\titem.id = autoId;\n\t\t}\n\n\t\t// Give plugins a chance to modify the loadItem:\n\t\tvar customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];\n\t\tif (customHandler) {\n\t\t\t// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)\n\t\t\tvar result = customHandler.callback.call(customHandler.scope, item, this);\n\n\t\t\t// The plugin will handle the load, or has canceled it. Ignore it.\n\t\t\tif (result === false) {\n\t\t\t\treturn null;\n\n\t\t\t\t// Load as normal:\n\t\t\t} else if (result === true) {\n\t\t\t\t// Do Nothing\n\n\t\t\t\t// Result is a loader class:\n\t\t\t} else if (result != null) {\n\t\t\t\titem._loader = result;\n\t\t\t}\n\n\t\t\t// Update the extension in case the type changed:\n\t\t\tmatch = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension != null) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t}\n\n\t\t// Store the item for lookup. This also helps clean-up later.\n\t\tthis._loadItemsById[item.id] = item;\n\t\tthis._loadItemsBySrc[item.src] = item;\n\n\t\tif (item.crossOrigin == null) {\n\t\t\titem.crossOrigin = this._crossOrigin;\n\t\t}\n\n\t\treturn item;\n\t};\n\n\t/**\n\t * Create a loader for a load item.\n\t * @method _createLoader\n\t * @param {Object} item A formatted load item that can be used to generate a loader.\n\t * @return {AbstractLoader} A loader that can be used to load content.\n\t * @private\n\t */\n\tp._createLoader = function (item) {\n\t\tif (item._loader != null) { // A plugin already specified a loader\n\t\t\treturn item._loader;\n\t\t}\n\n\t\t// Initially, try and use the provided/supported XHR mode:\n\t\tvar preferXHR = this.preferXHR;\n\n\t\tfor (var i = 0; i < this._availableLoaders.length; i++) {\n\t\t\tvar loader = this._availableLoaders[i];\n\t\t\tif (loader && loader.canLoadItem(item)) {\n\t\t\t\treturn new loader(item, preferXHR);\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Log error (requires createjs.log)\n\t\treturn null;\n\t};\n\n\t/**\n\t * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event\n\t * is processed. The queue will "fill up" any empty slots, up to the max connection specified using\n\t * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded\n\t * using tags, which have to be loaded one at a time to maintain load order.\n\t * @method _loadNext\n\t * @private\n\t */\n\tp._loadNext = function () {\n\t\tif (this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only dispatch loadstart event when the first file is loaded.\n\t\tif (!this._loadStartWasDispatched) {\n\t\t\tthis._sendLoadStart();\n\t\t\tthis._loadStartWasDispatched = true;\n\t\t}\n\n\t\t// The queue has completed.\n\t\tif (this._numItems == this._numItemsLoaded) {\n\t\t\tthis.loaded = true;\n\t\t\tthis._sendComplete();\n\n\t\t\t// Load the next queue, if it has been defined.\n\t\t\tif (this.next && this.next.load) {\n\t\t\t\tthis.next.load();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t// Must iterate forwards to load in the right order.\n\t\tfor (var i = 0; i < this._loadQueue.length; i++) {\n\t\t\tif (this._currentLoads.length >= this._maxConnections) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar loader = this._loadQueue[i];\n\n\t\t\t// Determine if we should be only loading one tag-script at a time:\n\t\t\t// Note: maintainOrder items don\'t do anything here because we can hold onto their loaded value\n\t\t\tif (!this._canStartLoad(loader)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._loadQueue.splice(i, 1);\n\t\t\ti--;\n\t\t\tthis._loadItem(loader);\n\t\t}\n\t};\n\n\t/**\n\t * Begin loading an item. Event listeners are not added to the loaders until the load starts.\n\t * @method _loadItem\n\t * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.\n\t * @private\n\t */\n\tp._loadItem = function (loader) {\n\t\tloader.on("fileload", this._handleFileLoad, this);\n\t\tloader.on("progress", this._handleProgress, this);\n\t\tloader.on("complete", this._handleFileComplete, this);\n\t\tloader.on("error", this._handleError, this);\n\t\tloader.on("fileerror", this._handleFileError, this);\n\t\tthis._currentLoads.push(loader);\n\t\tthis._sendFileStart(loader.getItem());\n\t\tloader.load();\n\t};\n\n\t/**\n\t * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}\n\t * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}\n\t * events.\n\t * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.\n\t * @private\n\t * @since 0.6.0\n\t */\n\tp._handleFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error from an internal file load operation. This enables\n\t * loaders like M\n\t * @param event\n\t * @private\n\t */\n\tp._handleFileError = function (event) {\n\t\tvar newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);\n\t\tthis._sendError(newEvent);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}\n\t * is set to `true`.\n\t * @method _handleError\n\t * @param {ErrorEvent} event The error event, containing relevant error information.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._numItemsLoaded++;\n\n\t\tthis._finishOrderedItem(loader, true);\n\t\tthis._updateProgress();\n\n\t\tvar newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());\n\t\t// TODO: Propagate actual error message.\n\n\t\tthis._sendError(newEvent);\n\n\t\tif (!this.stopOnError) {\n\t\t\tthis._removeLoadItem(loader);\n\t\t\tthis._cleanLoadItem(loader);\n\t\t\tthis._loadNext();\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and\n\t * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,\n\t * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.\n\t * @method _handleFileComplete\n\t * @param {Event} event The event object from the loader.\n\t * @private\n\t */\n\tp._handleFileComplete = function (event) {\n\t\tvar loader = event.target;\n\t\tvar item = loader.getItem();\n\n\t\tvar result = loader.getResult();\n\t\tthis._loadedResults[item.id] = result;\n\t\tvar rawResult = loader.getResult(true);\n\t\tif (rawResult != null && rawResult !== result) {\n\t\t\tthis._loadedRawResults[item.id] = rawResult;\n\t\t}\n\n\t\tthis._saveLoadedItems(loader);\n\n\t\t// Remove the load item\n\t\tthis._removeLoadItem(loader);\n\n\t\tif (!this._finishOrderedItem(loader)) {\n\t\t\t// The item was NOT managed, so process it now\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t}\n\n\t\t// Clean up the load item\n\t\tthis._cleanLoadItem(loader);\n\t};\n\n\t/**\n\t * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).\n\t * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the\n\t * LoadQueue\'s look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}\n\t * methods.\n\t * @method _saveLoadedItems\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._saveLoadedItems = function (loader) {\n\t\t// TODO: Not sure how to handle this. Would be nice to expose the items.\n\t\t// Loaders may load sub-items. This adds them to this queue\n\t\tvar list = loader.getLoadedItems();\n\t\tif (list === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i].item;\n\n\t\t\t// Store item lookups\n\t\t\tthis._loadItemsBySrc[item.src] = item;\n\t\t\tthis._loadItemsById[item.id] = item;\n\n\t\t\t// Store loaded content\n\t\t\tthis._loadedResults[item.id] = list[i].result;\n\t\t\tthis._loadedRawResults[item.id] = list[i].rawResult;\n\t\t}\n\t};\n\n\t/**\n\t * Flag an item as finished. If the item\'s order is being managed, then ensure that it is allowed to finish, and if\n\t * so, trigger prior items to trigger as well.\n\t * @method _finishOrderedItem\n\t * @param {AbstractLoader} loader\n\t * @param {Boolean} loadFailed\n\t * @return {Boolean} If the item\'s order is being managed. This allows the caller to take an alternate\n\t * behaviour if it is.\n\t * @private\n\t */\n\tp._finishOrderedItem = function (loader, loadFailed) {\n\t\tvar item = loader.getItem();\n\n\t\tif ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)\n\t\t\t\t|| item.maintainOrder) {\n\n\t\t\t//TODO: Evaluate removal of the _currentlyLoadingScript\n\t\t\tif (loader instanceof createjs.JavaScriptLoader) {\n\t\t\t\tthis._currentlyLoadingScript = false;\n\t\t\t}\n\n\t\t\tvar index = createjs.indexOf(this._scriptOrder, item);\n\t\t\tif (index == -1) {\n\t\t\t\treturn false;\n\t\t\t} // This loader no longer exists\n\t\t\tthis._loadedScripts[index] = (loadFailed === true) ? true : item;\n\n\t\t\tthis._checkScriptLoadOrder();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the\n\t * order they were added, but with a "null" value. When they are completed, the value is set to the load item,\n\t * and then when they are processed and dispatched, the value is set to `true`. This method simply\n\t * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are\n\t * dispatched.\n\t * @method _checkScriptLoadOrder\n\t * @private\n\t */\n\tp._checkScriptLoadOrder = function () {\n\t\tvar l = this._loadedScripts.length;\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tvar item = this._loadedScripts[i];\n\t\t\tif (item === null) {\n\t\t\t\tbreak;\n\t\t\t} // This is still loading. Do not process further.\n\t\t\tif (item === true) {\n\t\t\t\tcontinue;\n\t\t\t} // This has completed, and been processed. Move on.\n\n\t\t\tvar loadItem = this._loadedResults[item.id];\n\t\t\tif (item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\t\t// Append script tags to the head automatically.\n\t\t\t\tcreatejs.DomUtils.appendToHead(loadItem);\n\t\t\t}\n\n\t\t\tvar loader = item._loader;\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t\tthis._loadedScripts[i] = true;\n\t\t}\n\t};\n\n\t/**\n\t * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts\n\t * the next item.\n\t * @method _processFinishedLoad\n\t * @param {LoadItem|Object} item\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._processFinishedLoad = function (item, loader) {\n\t\tthis._numItemsLoaded++;\n\n\t\t// Since LoadQueue needs maintain order, we can\'t append scripts in the loader.\n\t\t// So we do it here instead. Or in _checkScriptLoadOrder();\n\t\tif (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\tvar tag = loader.getTag();\n\t\t\tcreatejs.DomUtils.appendToHead(tag);\n\t\t}\n\n\t\tthis._updateProgress();\n\t\tthis._sendFileComplete(item, loader);\n\t\tthis._loadNext();\n\t};\n\n\t/**\n\t * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to\n\t * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>\n\t * the script can even be started, since it exist in the DOM while loading.\n\t * @method _canStartLoad\n\t * @param {AbstractLoader} loader The loader for the item\n\t * @return {Boolean} Whether the item can start a load or not.\n\t * @private\n\t */\n\tp._canStartLoad = function (loader) {\n\t\tif (!this.maintainScriptOrder || loader.preferXHR) {\n\t\t\treturn true;\n\t\t}\n\t\tvar item = loader.getItem();\n\t\tif (item.type != createjs.LoadQueue.JAVASCRIPT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._currentlyLoadingScript) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar index = this._scriptOrder.indexOf(item);\n\t\tvar i = 0;\n\t\twhile (i < index) {\n\t\t\tvar checkItem = this._loadedScripts[i];\n\t\t\tif (checkItem == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._currentlyLoadingScript = true;\n\t\treturn true;\n\t};\n\n\t/**\n\t * A load item is completed or was canceled, and needs to be removed from the LoadQueue.\n\t * @method _removeLoadItem\n\t * @param {AbstractLoader} loader A loader instance to remove.\n\t * @private\n\t */\n\tp._removeLoadItem = function (loader) {\n\t\tvar l = this._currentLoads.length;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (this._currentLoads[i] == loader) {\n\t\t\t\tthis._currentLoads.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove unneeded references from a loader.\n\t *\n\t * @param loader\n\t * @private\n\t */\n\tp._cleanLoadItem = function(loader) {\n\t\tvar item = loader.getItem();\n\t\tif (item) {\n\t\t\tdelete item._loader;\n\t\t}\n\t}\n\n\t/**\n\t * An item has dispatched progress. Propagate that progress, and update the LoadQueue\'s overall progress.\n\t * @method _handleProgress\n\t * @param {ProgressEvent} event The progress event from the item.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._sendFileProgress(loader.getItem(), loader.progress);\n\t\tthis._updateProgress();\n\t};\n\n\t/**\n\t * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an\n\t * item dispatches progress or completes. Note that since we don\'t always know the actual filesize of items before\n\t * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append\n\t * loaded progress on top of the already-loaded items.\n\t *\n\t * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:\n\t * <ul>\n\t *      <li>5/10 of the items in the queue (50%)</li>\n\t *      <li>plus 20% of item 6\'s slot (2%)</li>\n\t *      <li>equals 52%</li>\n\t * </ul>\n\t * @method _updateProgress\n\t * @private\n\t */\n\tp._updateProgress = function () {\n\t\tvar loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress\n\t\tvar remaining = this._numItems - this._numItemsLoaded;\n\t\tif (remaining > 0) {\n\t\t\tvar chunk = 0;\n\t\t\tfor (var i = 0, l = this._currentLoads.length; i < l; i++) {\n\t\t\t\tchunk += this._currentLoads[i].progress;\n\t\t\t}\n\t\t\tloaded += (chunk / remaining) * (remaining / this._numItems);\n\t\t}\n\n\t\tif (this._lastProgress != loaded) {\n\t\t\tthis._sendProgress(loaded);\n\t\t\tthis._lastProgress = loaded;\n\t\t}\n\t};\n\n\t/**\n\t * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal\n\t * hashes.\n\t * @method _disposeItem\n\t * @param {LoadItem|Object} item The item that was passed in for preloading.\n\t * @private\n\t */\n\tp._disposeItem = function (item) {\n\t\tdelete this._loadedResults[item.id];\n\t\tdelete this._loadedRawResults[item.id];\n\t\tdelete this._loadItemsById[item.id];\n\t\tdelete this._loadItemsBySrc[item.src];\n\t};\n\n\t/**\n\t * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendFileProgress\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @param {Number} progress The amount the item has been loaded (between 0 and 1).\n\t * @protected\n\t */\n\tp._sendFileProgress = function (item, progress) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.hasEventListener("fileprogress")) {\n\t\t\treturn;\n\t\t}\n\n\t\t//LM: Rework ProgressEvent to support this?\n\t\tvar event = new createjs.Event("fileprogress");\n\t\tevent.progress = progress;\n\t\tevent.loaded = progress;\n\t\tevent.total = 1;\n\t\tevent.item = item;\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for\n\t * details on the event payload.\n\t * @method _sendFileComplete\n\t * @param {LoadItemObject} item The item that is being loaded.\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._sendFileComplete = function (item, loader) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar event = new createjs.Event("fileload");\n\t\tevent.loader = loader;\n\t\tevent.item = item;\n\t\tevent.result = this._loadedResults[item.id];\n\t\tevent.rawResult = this._loadedRawResults[item.id];\n\n\t\t// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.\n\t\tif (item.completeHandler) {\n\t\t\titem.completeHandler(event);\n\t\t}\n\n\t\tthis.hasEventListener("fileload") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see\n\t * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.\n\t * @method _sendFileStart\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @protected\n\t */\n\tp._sendFileStart = function (item) {\n\t\tvar event = new createjs.Event("filestart");\n\t\tevent.item = item;\n\t\tthis.hasEventListener("filestart") && this.dispatchEvent(event);\n\t};\n\n\tp.toString = function () {\n\t\treturn "[PreloadJS LoadQueue]";\n\t};\n\n\tcreatejs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");\n}());\n\n//##############################################################################\n// TextLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for Text files.\n\t * @class TextLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction TextLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);\n\t};\n\n\tvar p = createjs.extend(TextLoader, createjs.AbstractLoader);\n\tvar s = TextLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}},\n\t * but is also the default loader if a file type can not be determined.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.TEXT;\n\t};\n\n\tcreatejs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// BinaryLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.\n\t * @class BinaryLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction BinaryLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);\n\t\tthis.on("initialize", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(BinaryLoader, createjs.AbstractLoader);\n\tvar s = BinaryLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.BINARY;\n\t};\n\n\t// private methods\n\t/**\n\t * Before the item loads, set the response type to "arraybuffer"\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.setResponseType("arraybuffer");\n\t};\n\n\tcreatejs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// CSSLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class CSSLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction CSSLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = "href";\n\n\t\tif (preferXHR) {\n\t\t\tthis._tag = document.createElement("style");\n\t\t} else {\n\t\t\tthis._tag = document.createElement("link");\n\t\t}\n\n\t\tthis._tag.rel = "stylesheet";\n\t\tthis._tag.type = "text/css";\n\t};\n\n\tvar p = createjs.extend(CSSLoader, createjs.AbstractLoader);\n\tvar s = CSSLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.CSS;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for CSS files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tif (this._preferXHR) {\n\t\t\tvar tag = loader.getTag();\n\n\t\t\tif (tag.styleSheet) { // IE\n\t\t\t\ttag.styleSheet.cssText = loader.getResult(true);\n\t\t\t} else {\n\t\t\t\tvar textNode = document.createTextNode(loader.getResult(true));\n\t\t\t\ttag.appendChild(textNode);\n\t\t\t}\n\t\t} else {\n\t\t\ttag = this._tag;\n\t\t}\n\n\t\tcreatejs.DomUtils.appendToHead(tag);\n\n\t\treturn tag;\n\t};\n\n\tcreatejs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// ImageLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for image files.\n\t * @class ImageLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ImageLoader (loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = "src";\n\n\t\t// Check if the preload item is already a tag.\n\t\tif (createjs.RequestUtils.isImageTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem.src;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {\n\t\t\tthis._tag = loadItem.tag;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis._tag = document.createElement("img");\n\t\t}\n\n\t\tthis.on("initialize", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(ImageLoader, createjs.AbstractLoader);\n\tvar s = ImageLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.IMAGE;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tif (this._tag.src != "" && this._tag.complete) {\n\t\t\tthis._sendComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar crossOrigin = this._item.crossOrigin;\n\t\tif (crossOrigin == true) { crossOrigin = "Anonymous"; }\n\t\tif (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {\n\t\t\tthis._tag.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Before the item loads, set its mimeType and responseType.\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.mimeType = \'text/plain; charset=x-user-defined-binary\';\n\n\t\t// Only exists for XHR\n\t\tif (event.loader.setResponseType) {\n\t\t\tevent.loader.setResponseType("blob");\n\t\t}\n\t};\n\n\t/**\n\t * The result formatter for Image files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLImageElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn this._formatImage;\n\t};\n\n\t/**\n\t * The asynchronous image formatter function. This is required because images have\n\t * a short delay before they are ready.\n\t * @method _formatImage\n\t * @param {Function} successCallback The method to call when the result has finished formatting\n\t * @param {Function} errorCallback The method to call if an error occurs during formatting\n\t * @private\n\t */\n\tp._formatImage = function (successCallback, errorCallback) {\n\t\tvar tag = this._tag;\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tif (!this._preferXHR) {\n\t\t\t//document.body.removeChild(tag);\n\t\t} else if (URL) {\n\t\t\tvar objURL = URL.createObjectURL(this.getResult(true));\n\t\t\ttag.src = objURL;\n\n\t\t\ttag.addEventListener("load", this._cleanUpURL, false);\n\t\t\ttag.addEventListener("error", this._cleanUpURL, false);\n\t\t} else {\n\t\t\ttag.src = this._item.src;\n\t\t}\n\n\t\tif (tag.complete) {\n\t\t\tsuccessCallback(tag);\n\t\t} else {\n            tag.onload = createjs.proxy(function() {\n                successCallback(this._tag);\n            }, this);\n\n            tag.onerror = createjs.proxy(function() {\n                errorCallback(_this._tag);\n            }, this);\n\t\t}\n\t};\n\n\t/**\n\t * Clean up the ObjectURL, the tag is done with it. Note that this function is run\n\t * as an event listener without a proxy/closure, as it doesn\'t require it - so do not\n\t * include any functionality that requires scope without changing it.\n\t * @method _cleanUpURL\n\t * @param event\n\t * @private\n\t */\n\tp._cleanUpURL = function (event) {\n\t\tvar URL = window.URL || window.webkitURL;\n\t\tURL.revokeObjectURL(event.target.src);\n\t};\n\n\tcreatejs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// JavaScriptLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for JavaScript files.\n\t * @class JavaScriptLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JavaScriptLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = "src";\n\t\tthis.setTag(document.createElement("script"));\n\t};\n\n\tvar p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);\n\tvar s = JavaScriptLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JAVASCRIPT;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JavaScript files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar tag = loader.getTag();\n\t\tif (this._preferXHR) {\n\t\t\ttag.text = loader.getResult(true);\n\t\t}\n\t\treturn tag;\n\t};\n\n\tcreatejs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// JSONLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}\n\t * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to\n\t * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.\n\t * @class JSONLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(JSONLoader, createjs.AbstractLoader);\n\tvar s = JSONLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSON;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JSON files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar json = null;\n\t\ttry {\n\t\t\tjson = createjs.DataUtils.parseJSON(loader.getResult(true));\n\t\t} catch (e) {\n\t\t\tvar event = new createjs.ErrorEvent("JSON_FORMAT", null, e);\n\t\t\tthis._sendError(event);\n\t\t\treturn e;\n\t\t}\n\n\t\treturn json;\n\t};\n\n\tcreatejs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// JSONPLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON\n\t * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,\n\t * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use\n\t * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.\n\t *\n\t * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.\n\t * JSONP files are loaded as JavaScript, and the "callback" is executed once they are loaded. The callback in the\n\t * JSONP must match the callback passed to the loadItem.\n\t *\n\t * <h4>Example JSONP</h4>\n\t *\n\t * \t\tcallbackName({\n\t * \t\t\t"name": "value",\n\t *\t \t\t"num": 3,\n\t *\t\t\t"obj": { "bool":true }\n\t * \t\t});\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar loadItem = {id:"json", type:"jsonp", src:"http://server.com/text.json", callback:"callbackName"}\n\t * \t\tvar queue = new createjs.LoadQueue();\n\t * \t\tqueue.on("complete", handleComplete);\n\t * \t\tqueue.loadItem(loadItem);\n\t *\n\t * \t\tfunction handleComplete(event) }\n\t * \t\t\tvar json = queue.getResult("json");\n\t * \t\t\tconsole.log(json.obj.bool); // true\n\t * \t\t}\n\t *\n\t * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded\n\t * in order, either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1),\n\t * or set {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.\n\t *\n\t * @class JSONPLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONPLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);\n\t\tthis.setTag(document.createElement("script"));\n\t\tthis.getTag().type = "text/javascript";\n\t};\n\n\tvar p = createjs.extend(JSONPLoader, createjs.AbstractLoader);\n\tvar s = JSONPLoader;\n\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSONP;\n\t};\n\n\t// public methods\n\tp.cancel = function () {\n\t\tthis.AbstractLoader_cancel();\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * Loads the JSONp file.  Because of the unique loading needs of JSONp\n\t * we don\'t use the AbstractLoader.load() method.\n\t *\n\t * @method load\n\t *\n\t */\n\tp.load = function () {\n\t\tif (this._item.callback == null) {\n\t\t\tthrow new Error(\'callback is required for loading JSONP requests.\');\n\t\t}\n\n\t\t// TODO: Look into creating our own iFrame to handle the load\n\t\t// In the first attempt, FF did not get the result\n\t\t//   result instanceof Object did not work either\n\t\t//   so we would need to clone the result.\n\t\tif (window[this._item.callback] != null) {\n\t\t\tthrow new Error(\n\t\t\t\t"JSONP callback \'" +\n\t\t\t\tthis._item.callback +\n\t\t\t\t"\' already exists on window. You need to specify a different callback or re-name the current one.");\n\t\t}\n\n\t\twindow[this._item.callback] = createjs.proxy(this._handleLoad, this);\n\t\twindow.document.body.appendChild(this._tag);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\t// Load the tag\n\t\tthis._tag.src = this._item.src;\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the JSONP callback, which is a public method defined on `window`.\n\t * @method _handleLoad\n\t * @param {Object} data The formatted JSON data.\n\t * @private\n\t */\n\tp._handleLoad = function (data) {\n\t\tthis._result = this._rawResult = data;\n\t\tthis._sendComplete();\n\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specfied in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._dispose();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent("timeout"));\n\t};\n\n\t/**\n\t * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.\n\t * @method _dispose\n\t * @private\n\t */\n\tp._dispose = function () {\n\t\twindow.document.body.removeChild(this._tag);\n\t\tdelete window[this._item.callback];\n\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tcreatejs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// ManifestLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\n\t * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the\n\t * {{#crossLink "LoadItem"}}{{/crossLink}}.\n\t *\n\t * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\n\t * example shows a sample manifest definition, as well as how to to include a sub-manifest.\n\t *\n\t * \t\t{\n\t * \t\t\t"path": "assets/",\n\t *\t \t    "manifest": [\n\t *\t\t\t\t"image.png",\n\t *\t\t\t\t{"src": "image2.png", "id":"image2"},\n\t *\t\t\t\t{"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}\n\t *\t \t    ]\n\t *\t \t}\n\t *\n\t * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},\n\t * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\t *\n\t * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are\n\t * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}\n\t * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}.\n\t * @class ManifestLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ManifestLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t};\n\n\tvar p = createjs.extend(ManifestLoader, createjs.AbstractLoader);\n\tvar s = ManifestLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property MANIFEST_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.MANIFEST_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.MANIFEST;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase "complete":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.MANIFEST_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase "progress":\n\t\t\t\tevent.loaded *= s.MANIFEST_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t/**\n\t * Create and load the manifest items once the actual manifest has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.manifest) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue();\n\t\t\tqueue.on("fileload", this._handleManifestFileLoad, this);\n\t\t\tqueue.on("progress", this._handleManifestProgress, this);\n\t\t\tqueue.on("complete", this._handleManifestComplete, this, true);\n\t\t\tqueue.on("error", this._handleManifestError, this, true);\n\t\t\tfor(var i = 0, l = this.plugins.length; i < l; i++) {\t// conserve order of plugins\n\t\t\t\tqueue.installPlugin(this.plugins[i]);\n\t\t\t}\n\t\t\tqueue.loadManifest(json);\n\t\t} else {\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}\n\t * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The manifest has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * The manifest has reported an error with one of the files.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event("fileerror");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n\t * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n\t * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.\n\t * @class SoundLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction SoundLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\n\n\t\t// protected properties\n\t\tif (createjs.RequestUtils.isAudioTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\n\t\t\tthis._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n\tvar s = SoundLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SOUND;\n\t};\n\n\t// protected methods\n\tp._createTag = function (src) {\n\t\tvar tag = document.createElement("audio");\n\t\ttag.autoplay = false;\n\t\ttag.preload = "none";\n\n\t\t//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\n\t\ttag.src = src;\n\t\treturn tag;\n\t};\n\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");\n\n}());\n\n//##############################################################################\n// VideoLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for video files.\n\t * @class VideoLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction VideoLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);\n\n\t\tif (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {\n\t\t\tthis.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);\n\n\t\t\t// We can\'t use XHR for a tag that\'s passed in.\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis.setTag(this._createTag());\n\t\t}\n\t};\n\n\tvar p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);\n\tvar s = VideoLoader;\n\n\t/**\n\t * Create a new video tag\n\t *\n\t * @returns {HTMLElement}\n\t * @private\n\t */\n\tp._createTag = function () {\n\t\treturn document.createElement("video");\n\t};\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.VIDEO;\n\t};\n\n\tcreatejs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");\n\n}());\n\n//##############################################################################\n// SpriteSheetLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader\n\t * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}\n\t * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}\n\t * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>\n\t * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property\n\t * to {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}.\n\t *\n\t * The {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/crossOrigin:property"}}{{/crossLink}} as well\n\t * as the {{#crossLink "LoadQueue\'s"}}{{/crossLink}} `basePath` argument and {{#crossLink "LoadQueue/_preferXHR"}}{{/crossLink}}\n\t * property supplied to the {{#crossLink "LoadQueue"}}{{/crossLink}} are passed on to the sub-manifest that loads\n\t * the SpriteSheet images.\n\t *\n\t * Note that the SpriteSheet JSON does not respect the {{#crossLink "LoadQueue/_preferXHR:property"}}{{/crossLink}}\n\t * property, which should instead be determined by the presence of a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}\n\t * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on\n\t * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.\n\t * @class SpriteSheetLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SpriteSheetLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);\n\n\t\t// protected properties\n\t\t/**\n\t\t * An internal queue which loads the SpriteSheet\'s images.\n\t\t * @method _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}\n\n\tvar p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);\n\tvar s = SpriteSheetLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property SPRITESHEET_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.SPRITESHEET_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SPRITESHEET;\n\t};\n\n\t// public methods\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy;\n\t\tthis._manifestQueue.close();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase "complete":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.SPRITESHEET_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase "progress":\n\t\t\t\tevent.loaded *= s.SPRITESHEET_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\t/**\n\t * Create and load the images once the SpriteSheet JSON has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.images) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);\n\t\t\tqueue.on("complete", this._handleManifestComplete, this, true);\n\t\t\tqueue.on("fileload", this._handleManifestFileLoad, this);\n\t\t\tqueue.on("progress", this._handleManifestProgress, this);\n\t\t\tqueue.on("error", this._handleManifestError, this, true);\n\t\t\tqueue.loadManifest(json.images);\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tvar image = event.result;\n\t\tif (image != null) {\n\t\t\tvar images = this.getResult().images;\n\t\t\tvar pos = images.indexOf(event.item.src);\n\t\t\timages[pos] = image;\n\t\t}\n\t};\n\n\t/**\n\t * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}\n\t * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._result = new createjs.SpriteSheet(this._result);\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * An image has reported an error.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event("fileerror");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// SVGLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for SVG files.\n\t * @class SVGLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SVGLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = "data";\n\n\t\tif (preferXHR) {\n\t\t\tthis.setTag(document.createElement("svg"));\n\t\t} else {\n\t\t\tthis.setTag(document.createElement("object"));\n\t\t\tthis.getTag().type = "image/svg+xml";\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SVGLoader, createjs.AbstractLoader);\n\tvar s = SVGLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SVG;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for SVG files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {Object}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\t// mime should be image/svg+xml, but Opera requires text/xml\n\t\tvar xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");\n\t\tvar tag = loader.getTag();\n\n\t\tif (!this._preferXHR && document.body.contains(tag)) {\n\t\t\tdocument.body.removeChild(tag);\n\t\t}\n\n\t\tif (xml.documentElement != null) {\n\t\t\ttag.appendChild(xml.documentElement);\n\t\t\ttag.style.visibility = "visible";\n\t\t\treturn tag;\n\t\t} else { // For browsers that don\'t support SVG, just give them the XML. (IE 9-8)\n\t\t\treturn xml;\n\t\t}\n\t};\n\n\tcreatejs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// XMLLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class XMLLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction XMLLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(XMLLoader, createjs.AbstractLoader);\n\tvar s = XMLLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.XML;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for XML files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {XMLDocument}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");\n\t};\n\n\tcreatejs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * The SoundJS class has been renamed {{#crossLink "Sound"}}{{/crossLink}}.  Please see {{#crossLink "Sound"}}{{/crossLink}}\n\t * for information on using sound.\n\t * @class SoundJS\n\t **/\n\tvar s = createjs.SoundJS = createjs.SoundJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/"0.6.2"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:31 GMT"; // injected by build process\n\n})();\n\n//##############################################################################\n// IndexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t"use strict";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// BrowserDetect.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n(function() {\n\t"use strict";\n\n\t/**\n\t * An object that determines the current browser, version, operating system, and other environment\n\t * variables via user agent string.\n\t *\n\t * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      if (createjs.BrowserDetect.isIOS) { // do stuff }\n\t *\n\t * @property BrowserDetect\n\t * @type {Object}\n\t * @param {Boolean} isFirefox True if our browser is Firefox.\n\t * @param {Boolean} isOpera True if our browser is opera.\n\t * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\n\t * completely different browser with different abilities.\n\t * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\n\t * @param {Boolean} isAndroid True if our browser is Android.\n\t * @param {Boolean} isBlackberry True if our browser is Blackberry.\n\t * @constructor\n\t * @static\n\t */\n\tfunction BrowserDetect() {\n\t\tthrow "BrowserDetect cannot be instantiated";\n\t};\n\n\tvar agent = BrowserDetect.agent = window.navigator.userAgent;\n\tBrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);\n\tBrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);\n\tBrowserDetect.isOpera = (window.opera != null);\n\tBrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\n\tBrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);\n\n\tcreatejs.BrowserDetect = BrowserDetect;\n\n}());\n\n//##############################################################################\n// AudioSprite.js\n//##############################################################################\n\n//  NOTE this is "Class" is purely to document audioSprite Setup and usage.\n\n\n/**\n * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called\n * out here for quick reference.</strong>\n *\n * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.\n * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a\n * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent\n * accidentally playing bits of the neighbouring clips.\n *\n * <strong>Benefits of Audio Sprites:</strong>\n * <ul>\n *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\n *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different\n *     sounds that could be loaded at once.</li>\n *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\n * where the network round trip for each file can add significant latency.</li>\n * </ul>\n *\n * <strong>Drawbacks of Audio Sprites</strong>\n * <ul>\n *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop\n * \t\tsmoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid\n * \t\tit.</li>\n *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers\n *     (Chrome!), HTML audio will only load enough to play through at the current download speed â€“ so we rely on the\n *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific\n *     sounds, the audio may not yet have downloaded fully.</li>\n *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\n * \t\tconcurrently playing instances, you can only play 2 of the sounds at the same time.</li>\n * </ul>\n *\n * <h4>Example</h4>\n *\n *\t\tcreatejs.Sound.initializeDefaultPlugins();\n *\t\tvar assetsPath = "./assets/";\n *\t\tvar sounds = [{\n *\t\t\tsrc:"MyAudioSprite.ogg", data: {\n *\t\t\t\taudioSprite: [\n *\t\t\t\t\t{id:"sound1", startTime:0, duration:500},\n *\t\t\t\t\t{id:"sound2", startTime:1000, duration:400},\n *\t\t\t\t\t{id:"sound3", startTime:1700, duration: 1000}\n *\t\t\t\t]}\n *\t\t\t}\n *\t\t];\n *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\n *\t\tcreatejs.Sound.on("fileload", loadSound);\n *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n *\t\t// after load is complete\n *\t\tcreatejs.Sound.play("sound2");\n *\n * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\n *\n * \t\tcreatejs.Sound.play("MyAudioSprite", {startTime: 1000, duration: 400});\n *\n * The excellent CreateJS community has created a tool to create audio sprites, available at\n * <a href="https://github.com/tonistiigi/audiosprite" target="_blank">https://github.com/tonistiigi/audiosprite</a>,\n * as well as a <a href="http://jsfiddle.net/bharat_battu/g8fFP/12/" target="_blank">jsfiddle</a> to convert the output\n * to SoundJS format.\n *\n * @class AudioSprite\n * @since 0.6.0\n */\n\n//##############################################################################\n// PlayPropsConfig.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\t/**\n\t * A class to store the optional play properties passed in {{#crossLink "Sound/play"}}{{/crossLink}} and\n\t * {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} calls.\n\t *\n\t * Optional Play Properties Include:\n\t * <ul>\n\t * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.</li>\n\t * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>\n\t * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>\n\t * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.</li>\n\t * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.</li>\n\t * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>\n\t * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>\n\t * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>\n\t * </ul>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tvar ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})\n\t * \tcreatejs.Sound.play("mySound", ppc);\n\t * \tmySoundInstance.play(ppc);\n\t *\n\t * @class PlayPropsConfig\n\t * @constructor\n\t * @since 0.6.1\n\t */\n\t// TODO think of a better name for this class\n\tvar PlayPropsConfig = function () {\n// Public Properties\n\t\t/**\n\t\t * How to interrupt any currently playing instances of audio with the same source,\n\t\t * if the maximum number of instances of the sound are already playing. Values are defined as\n\t\t * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by\n\t\t * {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\n\t\t * @property interrupt\n\t\t * @type {string}\n\t\t * @default null\n\t\t */\n\t\tthis.interrupt = null;\n\n\t\t/**\n\t\t * The amount of time to delay the start of audio playback, in milliseconds.\n\t\t * @property delay\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis.delay = null;\n\n\t\t/**\n\t\t * The offset from the start of the audio to begin playback, in milliseconds.\n\t\t * @property offset\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.offset = null;\n\n\t\t/**\n\t\t * How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t\t * loops), and -1 can be used for infinite playback.\n\t\t * @property loop\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.loop = null;\n\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t\t * against the individual volume.\n\t\t * @property volume\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.volume = null;\n\n\t\t/**\n\t\t * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t\t * @property pan\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.pan = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t\t * @property startTime\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.startTime = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t\t * @property duration\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.duration = null;\n\t};\n\tvar p = PlayPropsConfig.prototype = {};\n\tvar s = PlayPropsConfig;\n\n\n// Static Methods\n\t/**\n\t * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.\n\t *\n\t * @method create\n\t * @param {PlayPropsConfig|Object} value The play properties\n\t * @returns {PlayPropsConfig}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (value instanceof s || value instanceof Object) {\n\t\t\tvar ppc = new createjs.PlayPropsConfig();\n\t\t\tppc.set(value);\n\t\t\treturn ppc;\n\t\t} else {\n\t\t\tthrow new Error("Type not recognized.");\n\t\t}\n\t};\n\n// Public Methods\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.\n\t * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tp.toString = function() {\n\t\treturn "[PlayPropsConfig]";\n\t};\n\n\tcreatejs.PlayPropsConfig = s;\n\n}());\n\n//##############################################################################\n// Sound.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\n\t * All Sound APIs on this class are static.\n\t *\n\t * <b>Registering and Preloading</b><br />\n\t * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink "Sound/registerSound"}}{{/crossLink}},\n\t * or register multiple sounds using {{#crossLink "Sound/registerSounds"}}{{/crossLink}}. If you don\'t register a\n\t * sound prior to attempting to play it using {{#crossLink "Sound/play"}}{{/crossLink}} or create it using {{#crossLink "Sound/createInstance"}}{{/crossLink}},\n\t * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\n\t * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>, registration is handled for you when the sound is\n\t * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\n\t * PreloadJS so they are ready when you want to use them.\n\t *\n\t * <b>Playback</b><br />\n\t * To play a sound once it\'s been registered and preloaded, use the {{#crossLink "Sound/play"}}{{/crossLink}} method.\n\t * This method returns a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} which can be paused, resumed, muted, etc.\n\t * Please see the {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} documentation for more on the instance control APIs.\n\t *\n\t * <b>Plugins</b><br />\n\t * By default, the {{#crossLink "WebAudioPlugin"}}{{/crossLink}} or the {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}\n\t * are used (when available), although developers can change plugin priority or add new plugins (such as the\n\t * provided {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}). Please see the {{#crossLink "Sound"}}{{/crossLink}} API\n\t * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\n\t * {{#crossLink "Sound/installPlugins"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\n\t *      createjs.Sound.on("fileload", this.loadHandler, this);\n\t *      createjs.Sound.registerSound("path/to/mySound.ogg", "sound");\n\t *      function loadHandler(event) {\n     *          // This is fired for each sound that is registered.\n     *          var instance = createjs.Sound.play("sound");  // play using id.  Could also use full source path or event.src.\n     *          instance.on("complete", this.handleComplete, this);\n     *          instance.volume = 0.5;\n\t *      }\n\t *\n\t * The maximum number of concurrently playing instances of the same sound can be specified in the "data" argument\n\t * of {{#crossLink "Sound/registerSound"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\n\t * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\n\t * default limit of 100.\n\t *\n\t *      createjs.Sound.registerSound("sound.mp3", "soundId", 4);\n\t *\n\t * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\n\t * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\n\t * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use\n\t * the {{#crossLink "Sound/fileload:event"}}{{/crossLink}} event to determine when a sound has finished internally\n\t * preloading. It is recommended that all audio is preloaded before it is played.\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *\t\tqueue.installPlugin(createjs.Sound);\n\t *\n\t * <b>Audio Sprites</b><br />\n\t * SoundJS has added support for {{#crossLink "AudioSprite"}}{{/crossLink}}, available as of version 0.6.0.\n\t * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\n\t * grouped into a single file.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar assetsPath = "./assets/";\n\t *\t\tvar sounds = [{\n\t *\t\t\tsrc:"MyAudioSprite.ogg", data: {\n\t *\t\t\t\taudioSprite: [\n\t *\t\t\t\t\t{id:"sound1", startTime:0, duration:500},\n\t *\t\t\t\t\t{id:"sound2", startTime:1000, duration:400},\n\t *\t\t\t\t\t{id:"sound3", startTime:1700, duration: 1000}\n\t *\t\t\t\t]}\n \t *\t\t\t}\n\t *\t\t];\n\t *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\n\t *\t\tcreatejs.Sound.on("fileload", loadSound);\n\t *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n\t *\t\t// after load is complete\n\t *\t\tcreatejs.Sound.play("sound2");\n\t *\n\t * <b>Mobile Playback</b><br />\n\t * Devices running iOS require the WebAudio context to be "unlocked" by playing at least one sound inside of a user-\n\t * initiated event (such as touch/click). Earlier versions of SoundJS included a "MobileSafe" sample, but this is no\n\t * longer necessary as of SoundJS 0.6.2.\n\t * <ul>\n\t *     <li>\n\t *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink "WebAudioPlugin/playEmptySound"}}{{/crossLink}}\n\t *         method in the call stack of a user input event to manually unlock the audio context.\n\t *     </li>\n\t *     <li>\n\t *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level "mousedown"\n\t *         and "touchend" event, and unlock WebAudio. This will continue to check these events until the WebAudio\n\t *         context becomes "unlocked" (changes from "suspended" to "running")\n\t *     </li>\n\t *     <li>\n\t *         Both the "mousedown" and "touchend" events can be used to unlock audio in iOS9+, the "touchstart" event\n\t *         will work in iOS8 and below. The "touchend" event will only work in iOS9 when the gesture is interpreted\n\t *         as a "click", so if the user long-presses the button, it will no longer work.\n\t *     </li>\n\t *     <li>\n\t *         When using the <a href="http://www.createjs.com/docs/easeljs/classes/Touch.html">EaselJS Touch class</a>,\n\t *         the "mousedown" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure\n\t *         only touch events fire. To get around this, you can either rely on "touchend", or:\n\t *         <ol>\n\t *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>\n\t *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>\n\t *         </ol>\n\t *         These settings may change how your application behaves, and are not recommended.\n\t *     </li>\n\t * </ul>\n\t *\n\t * <b>Loading Alternate Paths and Extension-less Files</b><br />\n\t * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for\n\t * the `src` property, which is a hash using the format `{extension:"path", extension2:"path2"}`. These labels are\n\t * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in\n\t * different folders, or on CDNs, which often has completely different filenames for each file.\n\t *\n\t * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading\n\t * and loading with PreloadJS.\n\t *\n\t * <em>Note: an id is required for playback.</em>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar sounds = {path:"./audioPath/",\n\t * \t\t\t\tmanifest: [\n\t *\t\t\t\t{id: "cool", src: {mp3:"mp3/awesome.mp3", ogg:"noExtensionOggFile"}}\n\t *\t\t]};\n\t *\n\t *\t\tcreatejs.Sound.alternateExtensions = ["mp3"];\n\t *\t\tcreatejs.Sound.addEventListener("fileload", handleLoad);\n\t *\t\tcreatejs.Sound.registerSounds(sounds);\n\t *\n\t * <h3>Known Browser and OS issues</h3>\n\t * <b>IE 9 HTML Audio limitations</b><br />\n\t * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n\t * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n\t * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We\'ve found default\n\t * encoding with 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe\n\t * estimate.</li></ul>\n\t *\n\t * <b>Firefox 25 Web Audio limitations</b>\n\t * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n\t * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>. </br>\n\t * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if\n\t * possible.</li></ul>\n\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 Web Audio limitations</b><br />\n\t * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on\n\t * Mobile Playback above.</li>\n\t * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio\n\t * at a different sampleRate.</li>\n\t * </ul>\n\t *\n\t * <b>Android HTML Audio limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\n\t * a delay.</li></ul>\n\t *\n\t * <b>Web Audio and PreloadJS</b><br />\n\t * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.\n\t * This means that tag loading can not be used to avoid cross domain issues.</li><ul>\n\t *\n\t * @class Sound\n\t * @static\n\t * @uses EventDispatcher\n\t */\n\tfunction Sound() {\n\t\tthrow "Sound cannot be instantiated";\n\t}\n\n\tvar s = Sound;\n\n\n// Static Properties\n\t/**\n\t * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_ANY\n\t * @type {String}\n\t * @default any\n\t * @static\n\t */\n\ts.INTERRUPT_ANY = "any";\n\n\t/**\n\t * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\n\t * least distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_EARLY\n\t * @type {String}\n\t * @default early\n\t * @static\n\t */\n\ts.INTERRUPT_EARLY = "early";\n\n\t/**\n\t * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\n\t * distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_LATE\n\t * @type {String}\n\t * @default late\n\t * @static\n\t */\n\ts.INTERRUPT_LATE = "late";\n\n\t/**\n\t * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_NONE\n\t * @type {String}\n\t * @default none\n\t * @static\n\t */\n\ts.INTERRUPT_NONE = "none";\n\n\t/**\n\t * Defines the playState of an instance that is still initializing.\n\t * @property PLAY_INITED\n\t * @type {String}\n\t * @default playInited\n\t * @static\n\t */\n\ts.PLAY_INITED = "playInited";\n\n\t/**\n\t * Defines the playState of an instance that is currently playing or paused.\n\t * @property PLAY_SUCCEEDED\n\t * @type {String}\n\t * @default playSucceeded\n\t * @static\n\t */\n\ts.PLAY_SUCCEEDED = "playSucceeded";\n\n\t/**\n\t * Defines the playState of an instance that was interrupted by another instance.\n\t * @property PLAY_INTERRUPTED\n\t * @type {String}\n\t * @default playInterrupted\n\t * @static\n\t */\n\ts.PLAY_INTERRUPTED = "playInterrupted";\n\n\t/**\n\t * Defines the playState of an instance that completed playback.\n\t * @property PLAY_FINISHED\n\t * @type {String}\n\t * @default playFinished\n\t * @static\n\t */\n\ts.PLAY_FINISHED = "playFinished";\n\n\t/**\n\t * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\n\t * when the interrupt mode was "INTERRUPT_NONE", the playback stalled, or the sound could not be found.\n\t * @property PLAY_FAILED\n\t * @type {String}\n\t * @default playFailed\n\t * @static\n\t */\n\ts.PLAY_FAILED = "playFailed";\n\n\t/**\n\t * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\n\t * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\n\t * support additional media types.\n\t *\n\t * NOTE this does not currently work for {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\n\t *\n\t * More details on file formats can be found at <a href="http://en.wikipedia.org/wiki/Audio_file_format" target="_blank">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\n\t * A very detailed list of file formats can be found at <a href="http://www.fileinfo.com/filetypes/audio" target="_blank">http://www.fileinfo.com/filetypes/audio</a>.\n\t * @property SUPPORTED_EXTENSIONS\n\t * @type {Array[String]}\n\t * @default ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"]\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"];\n\n\t/**\n\t * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\n\t * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\n\t * plugins determine more accurately if an extension is supported.\n\t *\n \t * A useful list of extensions for each format can be found at <a href="http://html5doctor.com/html5-audio-the-state-of-play/" target="_blank">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\n\t * @property EXTENSION_MAP\n\t * @type {Object}\n\t * @since 0.4.0\n\t * @default {m4a:"mp4"}\n\t * @static\n\t */\n\ts.EXTENSION_MAP = {\n\t\tm4a:"mp4"\n\t};\n\n\t/**\n\t * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\n\t * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\n\t * @property FILE_PATTERN\n\t * @type {RegExp}\n\t * @static\n\t * @protected\n\t */\n\ts.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\n\n\n// Class Public properties\n\t/**\n\t * Determines the default behavior for interrupting other currently playing instances with the same source, if the\n\t * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink "Sound/INTERRUPT_NONE:property"}}{{/crossLink}}\n\t * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink "Sound/play"}}{{/crossLink}}\n\t * is called without passing a value for interrupt.\n\t * @property defaultInterruptBehavior\n\t * @type {String}\n\t * @default Sound.INTERRUPT_NONE, or "none"\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\n\n\t/**\n\t * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\n\t * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\n\t * extensions array is ["mp3", "m4a", "wav"] it will check mp3 support, then m4a, then wav. The audio files need\n\t * to exist in the same location, as only the extension is altered.\n\t *\n\t * Note that regardless of which file is loaded, you can call {{#crossLink "Sound/createInstance"}}{{/crossLink}}\n\t * and {{#crossLink "Sound/play"}}{{/crossLink}} using the same id or full source path passed for loading.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\tvar sounds = [\n\t *\t\t{src:"myPath/mySound.ogg", id:"example"},\n\t *\t];\n\t *\tcreatejs.Sound.alternateExtensions = ["mp3"]; // now if ogg is not supported, SoundJS will try asset0.mp3\n\t *\tcreatejs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\n\t *\tcreatejs.Sound.registerSounds(sounds, assetPath);\n\t *\t// ...\n\t *\tcreatejs.Sound.play("myPath/mySound.ogg"); // works regardless of what extension is supported.  Note calling with ID is a better approach\n\t *\n\t * @property alternateExtensions\n\t * @type {Array}\n\t * @since 0.5.2\n\t * @static\n\t */\n\ts.alternateExtensions = [];\n\n\t/**\n\t * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\n\t * Sound attempts to apply the default plugins: {{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by\n\t * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n\t * @property activePlugin\n\t * @type {Object}\n\t * @static\n\t */\n    s.activePlugin = null;\n\n\n// class getter / setter properties\n\t/**\n\t * Set the master volume of Sound. The master volume is multiplied against each sound\'s individual volume.  For\n\t * example, if master volume is 0.5 and a sound\'s volume is 0.5, the resulting volume is 0.25. To set individual\n\t * sound volume, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.volume = 0.5;\n\t *\n\t *\n\t * @property volume\n\t * @type {Number}\n\t * @default 1\n\t * @since 0.6.1\n\t */\n\ts._masterVolume = 1;\n\tObject.defineProperty(s, "volume", {\n\t\tget: function () {return this._masterVolume;},\n\t\tset: function (value) {\n\t\t\t\tif (Number(value) == null) {return false;}\n\t\t\t\tvalue = Math.max(0, Math.min(1, value));\n\t\t\t\ts._masterVolume = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t});\n\n\t/**\n\t * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\n\t * separately and when set will override, but not change the mute property of individual instances. To mute an individual\n\t * instance, use AbstractSoundInstance {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.muted = true;\n\t *\n\t *\n\t * @property muted\n\t * @type {Boolean}\n\t * @default false\n\t * @since 0.6.1\n\t */\n\ts._masterMute = false;\n\t// OJR references to the methods were not working, so the code had to be duplicated here\n\tObject.defineProperty(s, "muted", {\n\t\tget: function () {return this._masterMute;},\n\t\tset: function (value) {\n\t\t\t\tif (value == null) {return false;}\n\n\t\t\t\tthis._masterMute = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t});\n\n\t/**\n\t * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\n\t * or if the plugin supports a specific feature. Capabilities include:\n\t * <ul>\n\t *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\n\t *     <li><b>volume;</b> If the plugin can control audio volume.</li>\n\t *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\n\t *     if there is no known limit.</li>\n\t * <br />An entry for each file type in {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}:\n\t *     <li><b>mp3:</b> If MP3 audio is supported.</li>\n\t *     <li><b>ogg:</b> If OGG audio is supported.</li>\n\t *     <li><b>wav:</b> If WAV audio is supported.</li>\n\t *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\n\t *     <li><b>m4a:</b> If M4A audio is supported.</li>\n\t *     <li><b>mp4:</b> If MP4 audio is supported.</li>\n\t *     <li><b>aiff:</b> If aiff audio is supported.</li>\n\t *     <li><b>wma:</b> If wma audio is supported.</li>\n\t *     <li><b>mid:</b> If mid audio is supported.</li>\n\t * </ul>\n\t *\n\t * You can get a specific capability of the active plugin using standard object notation\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var mp3 = createjs.Sound.capabilities.mp3;\n\t *\n\t * Note this property is read only.\n\t *\n\t * @property capabilities\n\t * @type {Object}\n\t * @static\n\t * @readOnly\n\t * @since 0.6.1\n\t */\n\tObject.defineProperty(s, "capabilities", {\n\t\tget: function () {\n\t\t\t\t\tif (s.activePlugin == null) {return null;}\n\t\t\t\t\treturn s.activePlugin._capabilities;\n\t\t\t\t},\n\t\tset: function (value) { return false;}\n\t});\n\n\n// Class Private properties\n\t/**\n\t * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\n\t * plugins ({{#crossLink "WebAudioPlugin"}}{{/crossLink}}, followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}).\n\t * If plugins have been registered, but none are applicable, then sound playback will fail.\n\t * @property _pluginsRegistered\n\t * @type {Boolean}\n\t * @default false\n\t * @static\n\t * @protected\n\t */\n\ts._pluginsRegistered = false;\n\n\t/**\n\t * Used internally to assign unique IDs to each AbstractSoundInstance.\n\t * @property _lastID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t */\n\ts._lastID = 0;\n\n\t/**\n\t * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\n\t * all instances when using static APIs like {{#crossLink "Sound/stop"}}{{/crossLink}} and {{#crossLink "Sound/setVolume"}}{{/crossLink}}.\n\t * When an instance has finished playback, it gets removed via the {{#crossLink "Sound/finishedPlaying"}}{{/crossLink}}\n\t * method. If the user replays an instance, it gets added back in via the {{#crossLink "Sound/_beginPlaying"}}{{/crossLink}}\n\t * method.\n\t * @property _instances\n\t * @type {Array}\n\t * @protected\n\t * @static\n\t */\n\ts._instances = [];\n\n\t/**\n\t * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\n\t * @property _idHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._idHash = {};\n\n\t/**\n\t * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\n\t * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\n\t * and data.\n\t * @property _preloadHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._preloadHash = {};\n\n\t/**\n\t * An object hash storing {{#crossLink "PlayPropsConfig"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in\n\t * {{#crossLink "Sound/registerSound"}}{{/crossLink}} and {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n\t * @property _defaultPlayPropsHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t * @since 0.6.1\n\t */\n\ts._defaultPlayPropsHash = {};\n\n\n// EventDispatcher methods:\n\ts.addEventListener = null;\n\ts.removeEventListener = null;\n\ts.removeAllEventListeners = null;\n\ts.dispatchEvent = null;\n\ts.hasEventListener = null;\n\ts._listeners = null;\n\n\tcreatejs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\n\n\n// Events\n\t/**\n\t * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.4.1\n\t */\n\n\t/**\n\t * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.6.0\n\t */\n\n\n// Class Public Methods\n\t/**\n\t * Get the preload rules to allow Sound to be used as a plugin by <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\n\t * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\n\t * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\n\t * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\n\t * @method getPreloadHandlers\n\t * @return {Object} An object containing:\n\t * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\n\t *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\n\t *      <li>types: A list of file types that are supported by Sound (currently supports "sound").</li>\n\t *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink "Sound/SUPPORTED_EXTENSIONS:property"}}{{/crossLink}}).</li></ul>\n\t * @static\n\t * @protected\n\t */\n\ts.getPreloadHandlers = function () {\n\t\treturn {\n\t\t\tcallback:createjs.proxy(s.initLoad, s),\n\t\t\ttypes:["sound"],\n\t\t\textensions:s.SUPPORTED_EXTENSIONS\n\t\t};\n\t};\n\n\t/**\n\t * Used to dispatch fileload events from internal loading.\n\t * @method _handleLoadComplete\n\t * @param event A loader event.\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._handleLoadComplete = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = true;\n\n\t\t\tif (!s.hasEventListener("fileload")) { continue; }\n\n\t\t\tvar event = new createjs.Event("fileload");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used to dispatch error events from internal preloading.\n\t * @param event\n\t * @protected\n\t * @since 0.6.0\n\t * @static\n\t */\n\ts._handleLoadError = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = false;\n\n\t\t\tif (!s.hasEventListener("fileerror")) { continue; }\n\n\t\t\tvar event = new createjs.Event("fileerror");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used by {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} to register a Sound plugin.\n\t *\n\t * @method _registerPlugin\n\t * @param {Object} plugin The plugin class to install.\n\t * @return {Boolean} Whether the plugin was successfully initialized.\n\t * @static\n\t * @private\n\t */\n\ts._registerPlugin = function (plugin) {\n\t\t// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\n\t\tif (plugin.isSupported()) {\n\t\t\ts.activePlugin = new plugin();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\n\t * @method registerPlugins\n\t * @param {Array} plugins An array of plugins classes to install.\n\t * @return {Boolean} Whether a plugin was successfully initialized.\n\t * @static\n\t */\n\ts.registerPlugins = function (plugins) {\n\t\ts._pluginsRegistered = true;\n\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\n\t\t\tif (s._registerPlugin(plugins[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Initialize the default plugins. This method is automatically called when any audio is played or registered before\n\t * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\n\t * default plugins are {{#crossLink "WebAudioPlugin"}}{{/crossLink}} followed by {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tif (!createjs.initializeDefaultPlugins()) { return; }\n\t *\n\t * @method initializeDefaultPlugins\n\t * @returns {Boolean} True if a plugin was initialized, false otherwise.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.initializeDefaultPlugins = function () {\n\t\tif (s.activePlugin != null) {return true;}\n\t\tif (s._pluginsRegistered) {return false;}\n\t\tif (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Determines if Sound has been initialized, and a plugin has been activated.\n\t *\n\t * <h4>Example</h4>\n\t * This example sets up a Flash fallback, but only if there is no plugin specified yet.\n\t *\n\t * \tif (!createjs.Sound.isReady()) {\n\t *\t\tcreatejs.FlashAudioPlugin.swfPath = "../src/soundjs/flashaudio/";\n\t * \t\tcreatejs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\t}\n\t *\n\t * @method isReady\n\t * @return {Boolean} If Sound has initialized a plugin.\n\t * @static\n\t */\n\ts.isReady = function () {\n\t\treturn (s.activePlugin != null);\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapabilities\n\t * @return {Object} An object containing the capabilities of the active plugin.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getCapabilities = function () {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/capabilities:property"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapability\n\t * @param {String} key The capability to retrieve\n\t * @return {Number|Boolean} The value of the capability.\n\t * @static\n\t * @see getCapabilities\n\t * @deprecated\n\t */\n\ts.getCapability = function (key) {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities[key];\n\t};\n\n\t/**\n\t * Process manifest items from <a href="http://preloadjs.com" target="_blank">PreloadJS</a>. This method is intended\n\t * for usage by a plugin, and not for direct interaction.\n\t * @method initLoad\n\t * @param {Object} src The object to load.\n\t * @return {Object|AbstractLoader} An instance of AbstractLoader.\n\t * @protected\n\t * @static\n\t */\n\ts.initLoad = function (loadItem) {\n\t\treturn s._registerSound(loadItem);\n\t};\n\n\t/**\n\t * Internal method for loading sounds.  This should not be called directly.\n\t *\n\t * @method _registerSound\n\t * @param {Object} src The object to load, containing src property and optionally containing id and data.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @private\n\t * @since 0.6.0\n\t */\n\n\ts._registerSound = function (loadItem) {\n\t\tif (!s.initializeDefaultPlugins()) {return false;}\n\n\t\tvar details;\n\t\tif (loadItem.src instanceof Object) {\n\t\t\tdetails = s._parseSrc(loadItem.src);\n\t\t\tdetails.src = loadItem.path + details.src;\n\t\t} else {\n\t\t\tdetails = s._parsePath(loadItem.src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tloadItem.src = details.src;\n\t\tloadItem.type = "sound";\n\n\t\tvar data = loadItem.data;\n\t\tvar numChannels = null;\n\t\tif (data != null) {\n\t\t\tif (!isNaN(data.channels)) {\n\t\t\t\tnumChannels = parseInt(data.channels);\n\t\t\t} else if (!isNaN(data)) {\n\t\t\t\tnumChannels = parseInt(data);\n\t\t\t}\n\n\t\t\tif(data.audioSprite) {\n\t\t\t\tvar sp;\n\t\t\t\tfor(var i = data.audioSprite.length; i--; ) {\n\t\t\t\t\tsp = data.audioSprite[i];\n\t\t\t\t\ts._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\n\n\t\t\t\t\tif (sp.defaultPlayProps) {\n\t\t\t\t\t\ts._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\n\t\tvar loader = s.activePlugin.register(loadItem);\n\n\t\tSoundChannel.create(loadItem.src, numChannels);\n\n\t\t// return the number of instances to the user.  This will also be returned in the load event.\n\t\tif (data == null || !isNaN(data)) {\n\t\t\tloadItem.data = numChannels || SoundChannel.maxPerChannel();\n\t\t} else {\n\t\t\tloadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\n\t\t}\n\n\t\tif (loader.type) {loadItem.type = loader.type;}\n\n\t\tif (loadItem.defaultPlayProps) {\n\t\t\ts._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);\n\t\t}\n\t\treturn loader;\n\t};\n\n\t/**\n\t * Register an audio file for loading and future playback in Sound. This is automatically called when using\n\t * <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.  It is recommended to register all sounds that\n\t * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\n\t *      createjs.Sound.on("fileload", handleLoad); // add an event listener for when load is completed\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.ogg", "myID", 3);\n\t *      createjs.Sound.registerSound({ogg:"path1/mySound.ogg", mp3:"path2/mySoundNoExtension"}, "myID", 3);\n\t *\n\t *\n\t * @method registerSound\n\t * @param {String | Object} src The source or an Object with a "src" property or an Object with multiple extension labeled src properties.\n\t * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.\n\t * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\n\t * channels for an audio instance, however a "channels" property can be appended to the data object if it is used\n\t * for other information. The audio channels will set a default based on plugin if no value is found.\n\t * Sound also uses the data property to hold an {{#crossLink "AudioSprite"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>\n\t *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\n\t *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\n\t *   duration is the amount of time to play the clip for, in milliseconds.<br/>\n\t * This allows Sound to support audio sprites that are played back by id.\n\t * @param {string} basePath Set a path that will be prepended to src for loading.\n\t * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.\n\t * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for options.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.registerSound = function (src, id, data, basePath, defaultPlayProps) {\n\t\tvar loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};\n\t\tif (src instanceof Object && src.src) {\n\t\t\tbasePath = id;\n\t\t\tloadItem = src;\n\t\t}\n\t\tloadItem = createjs.LoadItem.create(loadItem);\n\t\tloadItem.path = basePath;\n\n\t\tif (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}\n\n\t\tvar loader = s._registerSound(loadItem);\n\t\tif(!loader) {return false;}\n\n\t\tif (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\n\t\ts._preloadHash[loadItem.src].push(loadItem);\n\t\tif (s._preloadHash[loadItem.src].length == 1) {\n\t\t\t// OJR note this will disallow reloading a sound if loading fails or the source changes\n\t\t\tloader.on("complete", createjs.proxy(this._handleLoadComplete, this));\n\t\t\tloader.on("error", createjs.proxy(this._handleLoadError, this));\n\t\t\ts.activePlugin.preload(loader);\n\t\t} else {\n\t\t\tif (s._preloadHash[loadItem.src][0] == true) {return true;}\n\t\t}\n\n\t\treturn loadItem;\n\t};\n\n\t/**\n\t * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\n\t * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\n\t * when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar assetPath = "./myAudioPath/";\n\t *      var sounds = [\n\t *          {src:"asset0.ogg", id:"example"},\n\t *          {src:"asset1.ogg", id:"1", data:6},\n\t *          {src:"asset2.mp3", id:"works"}\n\t *          {src:{mp3:"path1/asset3.mp3", ogg:"path2/asset3NoExtension}, id:"better"}\n\t *      ];\n\t *      createjs.Sound.alternateExtensions = ["mp3"];\t// if the passed extension is not supported, try this extension\n\t *      createjs.Sound.on("fileload", handleLoad); // call handleLoad when each sound loads\n\t *      createjs.Sound.registerSounds(sounds, assetPath);\n\t *\n\t * @method registerSounds\n\t * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n\t * {{#crossLink "Sound/registerSound"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n\t * with "id" and "data" being optional.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.\n\t * Note id is required if src is an object with extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n\t * audio that was loaded with a basePath by src, the basePath must be included.\n\t * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n\t * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n\t * Also, it will return true for any values when the source is already loaded.\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.registerSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t\t// TODO document this feature\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove a sound that has been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this sound before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.removeSound("myID");\n\t *      createjs.Sound.removeSound("myAudioBasePath/mySound.ogg");\n\t *      createjs.Sound.removeSound("myPath/myOtherSound.mp3", "myBasePath/");\n\t *      createjs.Sound.removeSound({mp3:"musicNoExtension", ogg:"music.ogg"}, "myBasePath/");\n\t *\n\t * @method removeSound\n\t * @param {String | Object} src The src or ID of the audio, or an Object with a "src" property, or an Object with multiple extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Boolean} True if sound is successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSound = function(src, basePath) {\n\t\tif (s.activePlugin == null) {return false;}\n\n\t\tif (src instanceof Object && src.src) {src = src.src;}\n\n\t\tvar details;\n\t\tif (src instanceof Object) {\n\t\t\tdetails = s._parseSrc(src);\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t\tdetails = s._parsePath(src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tsrc = details.src;\n\t\tif (basePath != null) {src = basePath + src;}\n\n\t\tfor(var prop in s._idHash){\n\t\t\tif(s._idHash[prop].src == src) {\n\t\t\t\tdelete(s._idHash[prop]);\n\t\t\t}\n\t\t}\n\n\t\t// clear from SoundChannel, which also stops and deletes all instances\n\t\tSoundChannel.removeSrc(src);\n\n\t\tdelete(s._preloadHash[src]);\n\n\t\ts.activePlugin.removeSound(src);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an array of audio files that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this audio before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tassetPath = "./myPath/";\n\t *      var sounds = [\n\t *          {src:"asset0.ogg", id:"example"},\n\t *          {src:"asset1.ogg", id:"1", data:6},\n\t *          {src:"asset2.mp3", id:"works"}\n\t *      ];\n\t *      createjs.Sound.removeSounds(sounds, assetPath);\n\t *\n\t * @method removeSounds\n\t * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\n\t * {{#crossLink "Sound/removeSound"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Object} An array of Boolean values representing if the sounds with the same array index were\n\t * successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove all sounds that have been registered with {{#crossLink "Sound/registerSound"}}{{/crossLink}} or\n\t * {{#crossLink "Sound/registerSounds"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on all active sound instances before deleting them.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.removeAllSounds();\n\t *\n\t * @method removeAllSounds\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeAllSounds = function() {\n\t\ts._idHash = {};\n\t\ts._preloadHash = {};\n\t\tSoundChannel.removeAll();\n\t\tif (s.activePlugin) {s.activePlugin.removeAllSounds();}\n\t};\n\n\t/**\n\t * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\n\t * not completed preloading will not kick off a new internal preload if they are played.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     var mySound = "assetPath/asset0.ogg";\n\t *     if(createjs.Sound.loadComplete(mySound) {\n\t *         createjs.Sound.play(mySound);\n\t *     }\n\t *\n\t * @method loadComplete\n\t * @param {String} src The src or id that is being loaded.\n\t * @return {Boolean} If the src is already loaded.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.loadComplete = function (src) {\n\t\tif (!s.isReady()) { return false; }\n\t\tvar details = s._parsePath(src);\n\t\tif (details) {\n\t\t\tsrc = s._getSrcById(details.src).src;\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t}\n\t\tif(s._preloadHash[src] == undefined) {return false;}\n\t\treturn (s._preloadHash[src][0] == true);  // src only loads once, so if it\'s true for the first it\'s true for all\n\t};\n\n\t/**\n\t * Parse the path of a sound. Alternate extensions will be attempted in order if the\n\t * current extension is not supported\n\t * @method _parsePath\n\t * @param {String} value The path to an audio source.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}\n\t * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parsePath = function (value) {\n\t\tif (typeof(value) != "string") {value = value.toString();}\n\n\t\tvar match = value.match(s.FILE_PATTERN);\n\t\tif (match == null) {return false;}\n\n\t\tvar name = match[4];\n\t\tvar ext = match[5];\n\t\tvar c = s.capabilities;\n\t\tvar i = 0;\n\t\twhile (!c[ext]) {\n\t\t\text = s.alternateExtensions[i++];\n\t\t\tif (i > s.alternateExtensions.length) { return null;}\t// no extensions are supported\n\t\t}\n\t\tvalue = value.replace("."+match[5], "."+ext);\n\n\t\tvar ret = {name:name, src:value, extension:ext};\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Parse the path of a sound based on properties of src matching with supported extensions.\n\t * Returns false if none of the properties are supported\n\t * @method _parseSrc\n\t * @param {Object} value The paths to an audio source, indexed by extension type.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink "Sound/activePlugin:property"}}{{/crossLink}}\n\t * and returned to a preloader like <a href="http://preloadjs.com" target="_blank">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parseSrc = function (value) {\n\t\tvar ret = {name:undefined, src:undefined, extension:undefined};\n\t\tvar c = s.capabilities;\n\n\t\tfor (var prop in value) {\n\t\t  if(value.hasOwnProperty(prop) && c[prop]) {\n\t\t\t\tret.src = value[prop];\n\t\t\t\tret.extension = prop;\n\t\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif (!ret.src) {return false;}\t// no matches\n\n\t\tvar i = ret.src.lastIndexOf("/");\n\t\tif (i != -1) {\n\t\t\tret.name = ret.src.slice(i+1);\n\t\t} else {\n\t\t\tret.name = ret.src;\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/* ---------------\n\t Static API.\n\t --------------- */\n\t/**\n\t * Play a sound and get a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to control. If the sound fails to play, a\n\t * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink "Sound/PLAY_FAILED:property"}}{{/crossLink}}.\n\t * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}},\n\t * since the failure could be due to lack of available channels. If the src does not have a supported extension or\n\t * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.on("fileload", handleLoad);\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\n\t *      function handleLoad(event) {\n\t *      \tcreatejs.Sound.play("myID");\n\t *      \t// store off AbstractSoundInstance for controlling\n\t *      \tvar myInstance = createjs.Sound.play("myID", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String} src The src or ID of the audio.\n\t * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\n\t * @static\n\t */\n\ts.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});\n\t\t}\n\t\tvar instance = s.createInstance(src, playProps.startTime, playProps.duration);\n\t\tvar ok = s._playInstance(instance, playProps);\n\t\tif (!ok) {instance._playFailed();}\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Creates a {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} using the passed in src. If the src does not have a\n\t * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\n\t * called safely but does nothing.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = null;\n\t *      createjs.Sound.on("fileload", handleLoad);\n\t *      createjs.Sound.registerSound("myAudioPath/mySound.mp3", "myID", 3);\n\t *      function handleLoad(event) {\n\t *      \tmyInstance = createjs.Sound.createInstance("myID");\n\t *      \t// alternately we could call the following\n\t *      \tmyInstance = createjs.Sound.createInstance("myAudioPath/mySound.mp3");\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * @method createInstance\n\t * @param {String} src The src or ID of the audio.\n\t * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} that can be controlled after it is created.\n\t * Unsupported extensions will return the default AbstractSoundInstance.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.createInstance = function (src, startTime, duration) {\n\t\tif (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\n\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[src];\t// for audio sprites, which create and store defaults by id\n\t\tsrc = s._getSrcById(src);\n\n\t\tvar details = s._parsePath(src.src);\n\n\t\tvar instance = null;\n\t\tif (details != null && details.src != null) {\n\t\t\tSoundChannel.create(details.src);\n\t\t\tif (startTime == null) {startTime = src.startTime;}\n\t\t\tinstance = s.activePlugin.create(details.src, startTime, duration || src.duration);\n\n\t\t\tdefaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];\n\t\t\tif(defaultPlayProps) {\n\t\t\t\tinstance.applyPlayProps(defaultPlayProps);\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = new createjs.DefaultSoundInstance(src, startTime, duration);\n\t\t}\n\n\t\tinstance.uniqueId = s._lastID++;\n\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\n\t * call AbstractSoundInstance {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.stop();\n\t *\n\t * @method stop\n\t * @static\n\t */\n\ts.stop = function () {\n\t\tvar instances = this._instances;\n\t\tfor (var i = instances.length; i--; ) {\n\t\t\tinstances[i].stop();  // NOTE stop removes instance from this._instances\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.\n\t *\n\t * @method setVolume\n\t * @param {Number} value The master volume value. The acceptable range is 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.setVolume = function (value) {\n\t\tif (Number(value) == null) {return false;}\n\t\tvalue = Math.max(0, Math.min(1, value));\n\t\ts._masterVolume = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/volume:property"}}{{/crossLink}} instead.\n\t *\n\t * @method getVolume\n\t * @return {Number} The master volume, in a range of 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getVolume = function () {\n\t\treturn this._masterVolume;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.\n\t *\n\t * @method setMute\n\t * @param {Boolean} value Whether the audio should be muted or not.\n\t * @return {Boolean} If the mute was set.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.setMute = function (value) {\n\t\tif (value == null) {return false;}\n\n\t\tthis._masterMute = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink "Sound/muted:property"}}{{/crossLink}} instead.\n\t *\n\t * @method getMute\n\t * @return {Boolean} The mute value of Sound.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.getMute = function () {\n\t\treturn this._masterMute;\n\t};\n\n\t/**\n\t * Set the default playback properties for all new SoundInstances of the passed in src or ID.\n\t * See {{#crossLink "PlayPropsConfig"}}{{/crossLink}} for available properties.\n\t *\n\t * @method setDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.\n\t * @since 0.6.1\n\t */\n\ts.setDefaultPlayProps = function(src, playProps) {\n\t\tsrc = s._getSrcById(src);\n\t\ts._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);\n\t};\n\n\t/**\n\t * Get the default playback properties for the passed in src or ID.  These properties are applied to all\n\t * new SoundInstances.  Returns null if default does not exist.\n\t *\n\t * @method getDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist\n\t * @since 0.6.1\n\t */\n\ts.getDefaultPlayProps = function(src) {\n\t\tsrc = s._getSrcById(src);\n\t\treturn s._defaultPlayPropsHash[s._parsePath(src.src).src];\n\t};\n\n\n\t/* ---------------\n\t Internal methods\n\t --------------- */\n\t/**\n\t * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\n\t * control delays.\n\t * @method _playInstance\n\t * @param {AbstractSoundInstance} instance The {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to start playing.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\n\t * have a delay will return true, but may still fail to play.\n\t * @protected\n\t * @static\n\t */\n\ts._playInstance = function (instance, playProps) {\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};\n\t\tif (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};\n\t\tif (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}\n\t\tif (playProps.offset == null) {playProps.offset = instance.getPosition();}\n\t\tif (playProps.loop == null) {playProps.loop = instance.loop;}\n\t\tif (playProps.volume == null) {playProps.volume = instance.volume;}\n\t\tif (playProps.pan == null) {playProps.pan = instance.pan;}\n\n\t\tif (playProps.delay == 0) {\n\t\t\tvar ok = s._beginPlaying(instance, playProps);\n\t\t\tif (!ok) {return false;}\n\t\t} else {\n\t\t\t//Note that we can\'t pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\n\t\t\t// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\n\t\t\tvar delayTimeoutId = setTimeout(function () {\n\t\t\t\ts._beginPlaying(instance, playProps);\n\t\t\t}, playProps.delay);\n\t\t\tinstance.delayTimeoutId = delayTimeoutId;\n\t\t}\n\n\t\tthis._instances.push(instance);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Begin playback. This is called immediately or after delay by {{#crossLink "Sound/playInstance"}}{{/crossLink}}.\n\t * @method _beginPlaying\n\t * @param {AbstractSoundInstance} instance A {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} to begin playback.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\n\t * start, this will return false.\n\t * @protected\n\t * @static\n\t */\n\ts._beginPlaying = function (instance, playProps) {\n\t\tif (!SoundChannel.add(instance, playProps.interrupt)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar result = instance._beginPlaying(playProps);\n\t\tif (!result) {\n\t\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\t\tif (index > -1) {this._instances.splice(index, 1);}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\n\t * instead.\n\t * @method _getSrcById\n\t * @param {String} value The ID the sound was registered with.\n\t * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\n\t * @protected\n\t * @static\n\t */\n\ts._getSrcById = function (value) {\n\t\treturn s._idHash[value] || {src: value};\n\t};\n\n\t/**\n\t * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\n\t * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\n\t * instances themselves.\n\t * @method _playFinished\n\t * @param {AbstractSoundInstance} instance The instance that finished playback.\n\t * @protected\n\t * @static\n\t */\n\ts._playFinished = function (instance) {\n\t\tSoundChannel.remove(instance);\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index > -1) {this._instances.splice(index, 1);}\t// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\n\t};\n\n\tcreatejs.Sound = Sound;\n\n\t/**\n\t * An internal class that manages the number of active {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} instances for\n\t * each sound type. This method is only used internally by the {{#crossLink "Sound"}}{{/crossLink}} class.\n\t *\n\t * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\n\t * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\n\t * browser support.\n\t *\n\t * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\n\t * sound that is already playing.\n\t * #class SoundChannel\n\t * @param {String} src The source of the instances\n\t * @param {Number} [max=1] The number of instances allowed\n\t * @constructor\n\t * @protected\n\t */\n\tfunction SoundChannel(src, max) {\n\t\tthis.init(src, max);\n\t}\n\n\t/* ------------\n\t Static API\n\t ------------ */\n\t/**\n\t * A hash of channel instances indexed by source.\n\t * #property channels\n\t * @type {Object}\n\t * @static\n\t */\n\tSoundChannel.channels = {};\n\n\t/**\n\t * Create a sound channel. Note that if the sound channel already exists, this will fail.\n\t * #method create\n\t * @param {String} src The source for the channel\n\t * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink "SoundChannel.maxDefault"}}{{/crossLink}}.\n\t * @return {Boolean} If the channels were created.\n\t * @static\n\t */\n\tSoundChannel.create = function (src, max) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {\n\t\t\tSoundChannel.channels[src] = new SoundChannel(src, max);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t/**\n\t * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\n\t * #method remove\n\t * @param {String} src The source for the channel\n\t * @return {Boolean} If the channels were deleted.\n\t * @static\n\t */\n\tSoundChannel.removeSrc = function (src) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._removeAll();\t// this stops and removes all active instances\n\t\tdelete(SoundChannel.channels[src]);\n\t\treturn true;\n\t};\n\t/**\n\t * Delete all sound channels, stop and delete all related instances.\n\t * #method removeAll\n\t * @static\n\t */\n\tSoundChannel.removeAll = function () {\n\t\tfor(var channel in SoundChannel.channels) {\n\t\t\tSoundChannel.channels[channel]._removeAll();\t// this stops and removes all active instances\n\t\t}\n\t\tSoundChannel.channels = {};\n\t};\n\t/**\n\t * Add an instance to a sound channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add to the channel\n\t * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink "Sound/play"}}{{/crossLink}}\n\t * for details on interrupt modes.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t * @static\n\t */\n\tSoundChannel.add = function (instance, interrupt) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\treturn channel._add(instance, interrupt);\n\t};\n\t/**\n\t * Remove an instance from the channel.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove from the channel\n\t * @return The success of the method call. If there is no channel, it will return false.\n\t * @static\n\t */\n\tSoundChannel.remove = function (instance) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._remove(instance);\n\t\treturn true;\n\t};\n\t/**\n\t * Get the maximum number of sounds you can have in a channel.\n\t * #method maxPerChannel\n\t * @return {Number} The maximum number of sounds you can have in a channel.\n\t */\n\tSoundChannel.maxPerChannel = function () {\n\t\treturn p.maxDefault;\n\t};\n\t/**\n\t * Get a channel instance by its src.\n\t * #method get\n\t * @param {String} src The src to use to look up the channel\n\t * @static\n\t */\n\tSoundChannel.get = function (src) {\n\t\treturn SoundChannel.channels[src];\n\t};\n\n\tvar p = SoundChannel.prototype;\n\tp.constructor = SoundChannel;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n\t/**\n\t * The source of the channel.\n\t * #property src\n\t * @type {String}\n\t */\n\tp.src = null;\n\n\t/**\n\t * The maximum number of instances in this channel.  -1 indicates no limit\n\t * #property max\n\t * @type {Number}\n\t */\n\tp.max = null;\n\n\t/**\n\t * The default value to set for max, if it isn\'t passed in.  Also used if -1 is passed.\n\t * #property maxDefault\n\t * @type {Number}\n\t * @default 100\n\t * @since 0.4.0\n\t */\n\tp.maxDefault = 100;\n\n\t/**\n\t * The current number of active instances.\n\t * #property length\n\t * @type {Number}\n\t */\n\tp.length = 0;\n\n\t/**\n\t * Initialize the channel.\n\t * #method init\n\t * @param {String} src The source of the channel\n\t * @param {Number} max The maximum number of instances in the channel\n\t * @protected\n\t */\n\tp.init = function (src, max) {\n\t\tthis.src = src;\n\t\tthis.max = max || this.maxDefault;\n\t\tif (this.max == -1) {this.max = this.maxDefault;}\n\t\tthis._instances = [];\n\t};\n\n\t/**\n\t * Get an instance by index.\n\t * #method get\n\t * @param {Number} index The index to return.\n\t * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\n\t */\n\tp._get = function (index) {\n\t\treturn this._instances[index];\n\t};\n\n\t/**\n\t * Add a new instance to the channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t */\n\tp._add = function (instance, interrupt) {\n\t\tif (!this._getSlot(interrupt, instance)) {return false;}\n\t\tthis._instances.push(instance);\n\t\tthis.length++;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove\n\t * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\n\t * return false.\n\t */\n\tp._remove = function (instance) {\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index == -1) {return false;}\n\t\tthis._instances.splice(index, 1);\n\t\tthis.length--;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\n\t * #method removeAll\n\t */\n\tp._removeAll = function () {\n\t\t// Note that stop() removes the item from the list\n\t\tfor (var i=this.length-1; i>=0; i--) {\n\t\t\tthis._instances[i].stop();\n\t\t}\n\t};\n\n\t/**\n\t * Get an available slot depending on interrupt value and if slots are available.\n\t * #method getSlot\n\t * @param {String} interrupt The interrupt value to use.\n\t * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\n\t * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\n\t * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\n\t */\n\tp._getSlot = function (interrupt, instance) {\n\t\tvar target, replacement;\n\n\t\tif (interrupt != Sound.INTERRUPT_NONE) {\n\t\t\t// First replacement candidate\n\t\t\treplacement = this._get(0);\n\t\t\tif (replacement == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = this.max; i < l; i++) {\n\t\t\ttarget = this._get(i);\n\n\t\t\t// Available Space\n\t\t\tif (target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Audio is complete or not playing\n\t\t\tif (target.playState == Sound.PLAY_FINISHED ||\n\t\t\t\ttarget.playState == Sound.PLAY_INTERRUPTED ||\n\t\t\t\ttarget.playState == Sound.PLAY_FAILED) {\n\t\t\t\treplacement = target;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (interrupt == Sound.INTERRUPT_NONE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Audio is a better candidate than the current target, according to playhead\n\t\t\tif ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\n\t\t\t\t(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\n\t\t\t\t\treplacement = target;\n\t\t\t}\n\t\t}\n\n\t\tif (replacement != null) {\n\t\t\treplacement._interrupt();\n\t\t\tthis._remove(replacement);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tp.toString = function () {\n\t\treturn "[Sound SoundChannel]";\n\t};\n\t// do not add SoundChannel to namespace\n\n}());\n\n//##############################################################################\n// AbstractSoundInstance.js\n//##############################################################################\n\n/**\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink "Sound/play"}}{{/crossLink}} or\n * {{#crossLink "Sound/createInstance"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\n * for control by the user.\n *\n * <h4>Example</h4>\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\n *\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\n * API method {{#crossLink "Sound/play"}}{{/crossLink}} for a list of arguments.\n *\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\n * is then de-referenced from the {{#crossLink "Sound"}}{{/crossLink}} class so that it can be cleaned up. If audio\n * playback has completed, a simple call to the {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}} instance method\n * will rebuild the references the Sound class need to control it.\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3", {loop:2});\n *      myInstance.on("loop", handleLoop);\n *      function handleLoop(event) {\n *          myInstance.volume = myInstance.volume * 0.5;\n *      }\n *\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\n *\n *      var myInstance = createjs.Sound.play("myAssetPath/mySrcFile.mp3");\n *      myInstance.on("complete", handleComplete);\n *      myInstance.on("loop", handleLoop);\n *      myInstance.on("failed", handleFailed);\n *\n *\n * @class AbstractSoundInstance\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @extends EventDispatcher\n * @constructor\n */\n\n(function () {\n\t"use strict";\n\n\n// Constructor:\n\tvar AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t// public properties:\n\t\t/**\n\t\t * The source of the sound.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = src;\n\n\t\t/**\n\t\t * The unique ID of the instance. This is set by {{#crossLink "Sound"}}{{/crossLink}}.\n\t\t * @property uniqueId\n\t\t * @type {String} | Number\n\t\t * @default -1\n\t\t */\n\t\tthis.uniqueId = -1;\n\n\t\t/**\n\t\t * The play state of the sound. Play states are defined as constants on {{#crossLink "Sound"}}{{/crossLink}}.\n\t\t * @property playState\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.playState = null;\n\n\t\t/**\n\t\t * A Timeout created by {{#crossLink "Sound"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\n\t\t * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\n\t\t * @property delayTimeoutId\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.delayTimeoutId = null;\n\t\t// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\n\n\n\t// private properties\n\t// Getter / Setter Properties\n\t\t// OJR TODO find original reason that we didn\'t use defined functions.  I think it was performance related\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1.\n\t\t *\n\t\t * The actual output volume of a sound can be calculated using:\n\t\t * <code>myInstance.volume * createjs.Sound.getVolume();</code>\n\t\t *\n\t\t * @property volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._volume =  1;\n\t\tObject.defineProperty(this, "volume", {\n\t\t\tget: this.getVolume,\n\t\t\tset: this.setVolume\n\t\t});\n\n\t\t/**\n\t\t * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\n\t\t *\n\t\t * <br />Note in WebAudioPlugin this only gives us the "x" value of what is actually 3D audio.\n\t\t *\n\t\t * @property pan\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pan =  0;\n\t\tObject.defineProperty(this, "pan", {\n\t\t\tget: this.getPan,\n\t\t\tset: this.setPan\n\t\t});\n\n\t\t/**\n\t\t * Audio sprite property used to determine the starting offset.\n\t\t * @property startTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._startTime = Math.max(0, startTime || 0);\n\t\tObject.defineProperty(this, "startTime", {\n\t\t\tget: this.getStartTime,\n\t\t\tset: this.setStartTime\n\t\t});\n\n\t\t/**\n\t\t * Sets or gets the length of the audio clip, value is in milliseconds.\n\t\t *\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._duration = Math.max(0, duration || 0);\n\t\tObject.defineProperty(this, "duration", {\n\t\t\tget: this.getDuration,\n\t\t\tset: this.setDuration\n\t\t});\n\n\t\t/**\n\t\t * Object that holds plugin specific resource need for audio playback.\n\t\t * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\n\t\t * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\n\t\t *\n\t\t * @property playbackResource\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._playbackResource = null;\n\t\tObject.defineProperty(this, "playbackResource", {\n\t\t\tget: this.getPlaybackResource,\n\t\t\tset: this.setPlaybackResource\n\t\t});\n\t\tif(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\n\n\t\t/**\n\t\t * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\n\t\t *\n\t\t * @property position\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._position = 0;\n\t\tObject.defineProperty(this, "position", {\n\t\t\tget: this.getPosition,\n\t\t\tset: this.setPosition\n\t\t});\n\n\t\t/**\n\t\t * The number of play loops remaining. Negative values will loop infinitely.\n\t\t *\n\t\t * @property loop\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @public\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._loop = 0;\n\t\tObject.defineProperty(this, "loop", {\n\t\t\tget: this.getLoop,\n\t\t\tset: this.setLoop\n\t\t});\n\n\t\t/**\n\t\t * Mutes or unmutes the current audio instance.\n\t\t *\n\t\t * @property muted\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._muted = false;\n\t\tObject.defineProperty(this, "muted", {\n\t\t\tget: this.getMuted,\n\t\t\tset: this.setMuted\n\t\t});\n\n\t\t/**\n\t\t * Pauses or resumes the current audio instance.\n\t\t *\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = false;\n\t\tObject.defineProperty(this, "paused", {\n\t\t\tget: this.getPaused,\n\t\t\tset: this.setPaused\n\t\t});\n\n\n\t// Events\n\t\t/**\n\t\t * The event that is fired when playback has started successfully.\n\t\t * @event succeeded\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback is interrupted. This happens when another sound with the same\n\t\t * src property is played using an interrupt value that causes this instance to stop playing.\n\t\t * @event interrupted\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback has failed. This happens when there are too many channels with the same\n\t\t * src property already playing (and the interrupt value doesn\'t cause an interrupt of another instance), or\n\t\t * the sound could not be played, perhaps due to a 404 error.\n\t\t * @event failed\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when a sound has completed playing but has loops remaining.\n\t\t * @event loop\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback completes. This means that the sound has finished playing in its\n\t\t * entirety, including its loop iterations.\n\t\t * @event complete\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\t};\n\n\tvar p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods:\n\t/**\n\t * Play an instance. This method is intended to be called on SoundInstances that already exist (created\n\t * with the Sound API {{#crossLink "Sound/createInstance"}}{{/crossLink}} or {{#crossLink "Sound/play"}}{{/crossLink}}).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = createjs.Sound.createInstance(mySrc);\n\t *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});\n\t *\n\t * Note that if this sound is already playing, this call will still set the passed in parameters.\n\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink "PlayPropsConfig"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String | Object} [interrupt="none"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink "PlayPropsConfig"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink "Sound/defaultInterruptBehavior:property"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * Note that pan is not supported for HTML Audio.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.play = function (interrupt, delay, offset, loop, volume, pan) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});\n\t\t}\n\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.applyPlayProps(playProps);\n\t\t\tif (this._paused) {\tthis.setPaused(false); }\n\t\t\treturn;\n\t\t}\n\t\tthis._cleanUp();\n\t\tcreatejs.Sound._playInstance(this, playProps);\t// make this an event dispatch??\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink "AbstractSoundInstance/resume"}}{{/crossLink}}\n\t * will fail. To start playback again, call {{#crossLink "AbstractSoundInstance/play"}}{{/crossLink}}.\n     *\n     * If you don\'t want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink "AbstractSoundInstance/paused"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     myInstance.stop();\n\t *\n\t * @method stop\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.stop = function () {\n\t\tthis._position = 0;\n\t\tthis._paused = false;\n\t\tthis._handleStop();\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\n\t * @method destroy\n\t * @since 0.6.0\n\t */\n\tp.destroy = function() {\n\t\tthis._cleanUp();\n\t\tthis.src = null;\n\t\tthis.playbackResource = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.\n\t * @method applyPlayProps\n\t * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.\n\t * @since 0.6.1\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.applyPlayProps = function(playProps) {\n\t\tif (playProps.offset != null) { this.setPosition(playProps.offset) }\n\t\tif (playProps.loop != null) { this.setLoop(playProps.loop); }\n\t\tif (playProps.volume != null) { this.setVolume(playProps.volume); }\n\t\tif (playProps.pan != null) { this.setPan(playProps.pan); }\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\t\treturn this;\n\t};\n\n\tp.toString = function () {\n\t\treturn "[AbstractSoundInstance]";\n\t};\n\n// get/set methods that allow support for IE8\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method getPaused\n\t * @returns {boolean} If the instance is currently paused\n\t * @since 0.6.0\n\t */\n\tp.getPaused = function() {\n\t\treturn this._paused;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/paused:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPaused\n\t * @param {boolean} value\n\t * @since 0.6.0\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setPaused = function (value) {\n\t\tif ((value !== true && value !== false) || this._paused == value) {return;}\n\t\tif (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\n\t\tthis._paused = value;\n\t\tif(value) {\n\t\t\tthis._pause();\n\t\t} else {\n\t\t\tthis._resume();\n\t\t}\n\t\tclearTimeout(this.delayTimeoutId);\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setVolume = function (value) {\n\t\tif (value == this._volume) { return this; }\n\t\tthis._volume = Math.max(0, Math.min(1, value));\n\t\tif (!this._muted) {\n\t\t\tthis._updateVolume();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/volume:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getVolume\n\t * @return {Number} The current volume of the sound instance.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setMuted\n\t * @param {Boolean} value If the sound should be muted.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t * @since 0.6.0\n\t */\n\tp.setMuted = function (value) {\n\t\tif (value !== true && value !== false) {return;}\n\t\tthis._muted = value;\n\t\tthis._updateVolume();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/muted:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getMuted\n\t * @return {Boolean} If the sound is muted.\n\t * @since 0.6.0\n\t */\n\tp.getMuted = function () {\n\t\treturn this._muted;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPan\n\t * @param {Number} value The pan value, between -1 (left) and 1 (right).\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPan = function (value) {\n\t\tif(value == this._pan) { return this; }\n\t\tthis._pan = Math.max(-1, Math.min(1, value));\n\t\tthis._updatePan();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/pan:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPan\n\t * @return {Number} The value of the pan, between -1 (left) and 1 (right).\n\t */\n\tp.getPan = function () {\n\t\treturn this._pan;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPosition\n\t * @return {Number} The position of the playhead in the sound, in milliseconds.\n\t */\n\tp.getPosition = function () {\n\t\tif (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._position = this._calculateCurrentPosition();\n\t\t}\n\t\treturn this._position;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/position:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPosition\n\t * @param {Number} value The position to place the playhead, in milliseconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPosition = function (value) {\n\t\tthis._position = Math.max(0, value);\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._updatePosition();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getStartTime\n\t * @return {Number} The startTime of the sound instance in milliseconds.\n\t */\n\tp.getStartTime = function () {\n\t\treturn this._startTime;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/startTime:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setStartTime\n\t * @param {number} value The new startTime time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setStartTime = function (value) {\n\t\tif (value == this._startTime) { return this; }\n\t\tthis._startTime = Math.max(0, value || 0);\n\t\tthis._updateStartTime();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getDuration\n\t * @return {Number} The duration of the sound instance in milliseconds.\n\t */\n\tp.getDuration = function () {\n\t\treturn this._duration;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/duration:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setDuration\n\t * @param {number} value The new duration time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t */\n\tp.setDuration = function (value) {\n\t\tif (value == this._duration) { return this; }\n\t\tthis._duration = Math.max(0, value || 0);\n\t\tthis._updateDuration();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t **/\n\tp.setPlaybackResource = function (value) {\n\t\tthis._playbackResource = value;\n\t\tif (this._duration == 0) { this._setDurationFromSource(); }\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/playbackResource:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {Object} playback resource used for playing audio\n\t * @since 0.6.0\n\t **/\n\tp.getPlaybackResource = function () {\n\t\treturn this._playbackResource;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getLoop\n\t * @return {number}\n\t * @since 0.6.0\n\t **/\n\tp.getLoop = function () {\n\t\treturn this._loop;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink "AbstractSoundInstance/loop:property"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method setLoop\n\t * @param {number} value The number of times to loop after play.\n\t * @since 0.6.0\n\t */\n\tp.setLoop = function (value) {\n\t\tif(this._playbackResource != null) {\n\t\t\t// remove looping\n\t\t\tif (this._loop != 0 && value == 0) {\n\t\t\t\tthis._removeLooping(value);\n\t\t\t}\n\t\t\t// add looping\n\t\t\telse if (this._loop == 0 && value != 0) {\n\t\t\t\tthis._addLooping(value);\n\t\t\t}\n\t\t}\n\t\tthis._loop = value;\n\t};\n\n\n// Private Methods:\n\t/**\n\t * A helper method that dispatches all events for AbstractSoundInstance.\n\t * @method _sendEvent\n\t * @param {String} type The event type\n\t * @protected\n\t */\n\tp._sendEvent = function (type) {\n\t\tvar event = new createjs.Event(type);\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Clean up the instance. Remove references and clean up any additional properties such as timers.\n\t * @method _cleanUp\n\t * @protected\n\t */\n\tp._cleanUp = function () {\n\t\tclearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\n\t\tthis._handleCleanUp();\n\t\tthis._paused = false;\n\n\t\tcreatejs.Sound._playFinished(this);\t// TODO change to an event\n\t};\n\n\t/**\n\t * The sound has been interrupted.\n\t * @method _interrupt\n\t * @protected\n\t */\n\tp._interrupt = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_INTERRUPTED;\n\t\tthis._sendEvent("interrupted");\n\t};\n\n\t/**\n\t * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\n\t * src is loaded, otherwise playback will fail.\n\t * @method _beginPlaying\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If playback succeeded.\n\t * @protected\n\t */\n\t// OJR FlashAudioSoundInstance overwrites\n\tp._beginPlaying = function (playProps) {\n\t\tthis.setPosition(playProps.offset);\n\t\tthis.setLoop(playProps.loop);\n\t\tthis.setVolume(playProps.volume);\n\t\tthis.setPan(playProps.pan);\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\n\t\tif (this._playbackResource != null && this._position < this._duration) {\n\t\t\tthis._paused = false;\n\t\t\tthis._handleSoundReady();\n\t\t\tthis.playState = createjs.Sound.PLAY_SUCCEEDED;\n\t\t\tthis._sendEvent("succeeded");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis._playFailed();\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Play has failed, which can happen for a variety of reasons.\n\t * Cleans up instance and dispatches failed event\n\t * @method _playFailed\n\t * @private\n\t */\n\tp._playFailed = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FAILED;\n\t\tthis._sendEvent("failed");\n\t};\n\n\t/**\n\t * Audio has finished playing. Manually loop it if required.\n\t * @method _handleSoundComplete\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSoundComplete = function (event) {\n\t\tthis._position = 0;  // have to set this as it can be set by pause during playback\n\n\t\tif (this._loop != 0) {\n\t\t\tthis._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\n\t\t\tthis._handleLoop();\n\t\t\tthis._sendEvent("loop");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\tthis._sendEvent("complete");\n\t};\n\n// Plugin specific code\n\t/**\n\t * Handles starting playback when the sound is ready for playing.\n\t * @method _handleSoundReady\n\t * @protected\n \t */\n\tp._handleSoundReady = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\n\t * and master mute value.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the pan\n\t * @method _updatePan\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePan = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the startTime of the audio.\n\t * @method _updateStartTime\n\t * @protected\n\t * @since 0.6.1\n\t */\n\tp._updateStartTime = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the duration of the audio.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updateDuration = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to get the duration of the audio from the source we\'ll be playing.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._setDurationFromSource = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function that calculates the current position of the playhead and sets this._position to that value\n\t * @method _calculateCurrentPosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._calculateCurrentPosition = function () {\n\t\t// plugin specific code that sets this.position\n\t};\n\n\t/**\n\t * Internal function used to update the position of the playhead.\n\t * @method _updatePosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePosition = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is removed during playback.\n\t * @method _removeLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._removeLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is added during playback.\n\t * @method _addLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when pausing playback\n\t * @method _pause\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._pause = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when resuming playback\n\t * @method _resume\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._resume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when stopping playback\n\t * @method _handleStop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleStop = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance is being cleaned up\n\t * @method _handleCleanUp\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleCleanUp = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance has played to end and is looping\n\t * @method _handleLoop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleLoop = function () {\n\t\t// plugin specific code\n\t};\n\n\tcreatejs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, "EventDispatcher");\n\tcreatejs.DefaultSoundInstance = createjs.AbstractSoundInstance;\t// used when no plugin is supported\n}());\n\n//##############################################################################\n// AbstractPlugin.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\n// constructor:\n \t/**\n\t * A default plugin class used as a base for all other plugins.\n\t * @class AbstractPlugin\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\n\tvar AbstractPlugin = function () {\n\t// private properties:\n\t\t/**\n\t\t * The capabilities of the plugin.\n\t\t * method and is used internally.\n\t\t * @property _capabilities\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t * @static\n\t\t */\n\t\tthis._capabilities = null;\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaders = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\n\t\t * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\n\t\t * is complete (for example arrayBuffers for web audio).\n\t\t * @property _audioSources\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._audioSources = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\n\t\t * and properly destroy them if sources are removed\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._soundInstances = {};\n\n\t\t/**\n\t\t * The internal master volume value of the plugin.\n\t\t * @property _volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @protected\n\t\t */\n\t\tthis._volume = 1;\n\n\t\t/**\n\t\t * A reference to a loader class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaderClass;\n\n\t\t/**\n\t\t * A reference to an AbstractSoundInstance class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected;\n\t\t */\n\t\tthis._soundInstanceClass;\n\t};\n\tvar p = AbstractPlugin.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// Static Properties:\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\n\t/**\n\t * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\tAbstractPlugin._capabilities = null;\n\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\tAbstractPlugin.isSupported = function () {\n\t\treturn true;\n\t};\n\n\n// public methods:\n\t/**\n\t * Pre-register a sound for preloading and setup. This is called by {{#crossLink "Sound"}}{{/crossLink}}.\n\t * Note all plugins provide a <code>Loader</code> instance, which <a href="http://preloadjs.com" target="_blank">PreloadJS</a>\n\t * can use to assist with preloading.\n\t * @method register\n\t * @param {String} loadItem An Object containing the source of the audio\n\t * Note that not every plugin will manage this value.\n\t * @return {Object} A result object, containing a "tag" for preloading purposes.\n\t */\n\tp.register = function (loadItem) {\n\t\tvar loader = this._loaders[loadItem.src];\n\t\tif(loader && !loader.canceled) {return this._loaders[loadItem.src];}\t// already loading/loaded this, so don\'t load twice\n\t\t// OJR potential issue that we won\'t be firing loaded event, might need to trigger if this is already loaded?\n\t\tthis._audioSources[loadItem.src] = true;\n\t\tthis._soundInstances[loadItem.src] = [];\n\t\tloader = new this._loaderClass(loadItem);\n\t\tloader.on("complete", this._handlePreloadComplete, this);\n\t\tthis._loaders[loadItem.src] = loader;\n\t\treturn loader;\n\t};\n\n\t// note sound calls register before calling preload\n\t/**\n\t * Internally preload a sound.\n\t * @method preload\n\t * @param {Loader} loader The sound URI to load.\n\t */\n\tp.preload = function (loader) {\n\t\tloader.on("error", this._handlePreloadError, this);\n\t\tloader.load();\n\t};\n\n\t/**\n\t * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\n\t * or has already finished loading.\n\t * @method isPreloadStarted\n\t * @param {String} src The sound URI to check.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadStarted = function (src) {\n\t\treturn (this._audioSources[src] != null);\n\t};\n\n\t/**\n\t * Checks if preloading has finished for a specific source.\n\t * @method isPreloadComplete\n\t * @param {String} src The sound URI to load.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadComplete = function (src) {\n\t\treturn (!(this._audioSources[src] == null || this._audioSources[src] == true));\n\t};\n\n\t/**\n\t * Remove a sound added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeSound\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeSound = function (src) {\n\t\tif (!this._soundInstances[src]) { return; }\n\t\tfor (var i = this._soundInstances[src].length; i--; ) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.destroy();\n\t\t}\n\t\tdelete(this._soundInstances[src]);\n\t\tdelete(this._audioSources[src]);\n\t\tif(this._loaders[src]) { this._loaders[src].destroy(); }\n\t\tdelete(this._loaders[src]);\n\t};\n\n\t/**\n\t * Remove all sounds added using {{#crossLink "WebAudioPlugin/register"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeAllSounds\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeAllSounds = function () {\n\t\tfor(var key in this._audioSources) {\n\t\t\tthis.removeSound(key);\n\t\t}\n\t};\n\n\t/**\n\t * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\n\t * @method create\n\t * @param {String} src The sound source to use.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @return {AbstractSoundInstance} A sound instance for playback and control.\n\t */\n\tp.create = function (src, startTime, duration) {\n\t\tif (!this.isPreloadStarted(src)) {\n\t\t\tthis.preload(this.register(src));\n\t\t}\n\t\tvar si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\n\t\tthis._soundInstances[src].push(si);\n\t\treturn si;\n\t};\n\n\t// if a plugin does not support volume and mute, it should set these to null\n\t/**\n\t * Set the master volume of the plugin, which affects all SoundInstances.\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\n\t * instances manually otherwise.\n\t */\n\tp.setVolume = function (value) {\n\t\tthis._volume = value;\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the master volume of the plugin, which affects all SoundInstances.\n\t * @method getVolume\n\t * @return {Number} The volume level, between 0 and 1.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * Mute all sounds via the plugin.\n\t * @method setMute\n\t * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\n\t * the mute value of Sound {{#crossLink "Sound/getMute"}}{{/crossLink}}, so this property is not used here.\n\t * @return {Boolean} If the mute call succeeds.\n\t */\n\tp.setMute = function (value) {\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t// plugins should overwrite this method\n\tp.toString = function () {\n\t\treturn "[AbstractPlugin]";\n\t};\n\n\n// private methods:\n\t/**\n\t * Handles internal preload completion.\n\t * @method _handlePreloadComplete\n\t * @protected\n\t */\n\tp._handlePreloadComplete = function (event) {\n\t\tvar src = event.target.getItem().src;\n\t\tthis._audioSources[src] = event.result;\n\t\tfor (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.setPlaybackResource(this._audioSources[src]);\n\t\t\t// ToDo consider adding play call here if playstate == playfailed\n\t\t}\n\t};\n\n\t/**\n\t * Handles internal preload erros\n\t * @method _handlePreloadError\n\t * @param event\n\t * @protected\n\t */\n\tp._handlePreloadError = function(event) {\n\t\t//delete(this._audioSources[src]);\n\t};\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// Plugin Specific code\n\t};\n\n\tcreatejs.AbstractPlugin = AbstractPlugin;\n}());\n\n//##############################################################################\n// WebAudioLoader.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\n\t * the preloader, and the load method is called when the asset needs to be requested.\n\t *\n\t * @class WebAudioLoader\n\t * @param {String} loadItem The item to be loaded\n\t * @extends XHRRequest\n\t * @protected\n\t */\n\tfunction Loader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\n\n\t};\n\tvar p = createjs.extend(Loader, createjs.AbstractLoader);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * web audio context required for decoding audio\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\tLoader.context = null;\n\n\n// public methods\n\tp.toString = function () {\n\t\treturn "[WebAudioLoader]";\n\t};\n\n\n// private methods\n\tp._createRequest = function() {\n\t\tthis._request = new createjs.XHRRequest(this._item, false);\n\t\tthis._request.setResponseType("arraybuffer");\n\t};\n\n\tp._sendComplete = function (event) {\n\t\t// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\n\t\tLoader.context.decodeAudioData(this._rawResult,\n\t         createjs.proxy(this._handleAudioDecoded, this),\n\t         createjs.proxy(this._sendError, this));\n\t};\n\n\n\t/**\n\t* The audio has been decoded.\n\t* @method handleAudioDecoded\n\t* @param decoded\n\t* @protected\n\t*/\n\tp._handleAudioDecoded = function (decodedAudio) {\n\t\tthis._result = decodedAudio;\n\t\tthis.AbstractLoader__sendComplete();\n\t};\n\n\tcreatejs.WebAudioLoader = createjs.promote(Loader, "AbstractLoader");\n}());\n\n//##############################################################################\n// WebAudioSoundInstance.js\n//##############################################################################\n\n/**\n * WebAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\n * {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n *\n * WebAudioSoundInstance exposes audioNodes for advanced users.\n *\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @class WebAudioSoundInstance\n * @extends AbstractSoundInstance\n * @constructor\n */\n(function () {\n\t"use strict";\n\n\tfunction WebAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// public properties\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink "WebAudioSoundInstance/destinationNode:property"}}{{/crossLink}}.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.gainNode = s.context.createGain();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\n\t\t * @property panNode\n\t\t * @type {AudioPannerNode}\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.panNode = s.context.createPanner();\n\t\tthis.panNode.panningModel = s._panningModel;\n\t\tthis.panNode.connect(this.gainNode);\n\t\tthis._updatePan();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink "WebAudioSoundInstance/panNode:property"}}{{/crossLink}}.\n\t\t * @property sourceNode\n\t\t * @type {AudioNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.sourceNode = null;\n\n\n// private properties\n\t\t/**\n\t\t * Timeout that is created internally to handle sound playing to completion.\n\t\t * Stored so we can remove it when stop, pause, or cleanup are called\n\t\t * @property _soundCompleteTimeout\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._soundCompleteTimeout = null;\n\n\t\t/**\n\t\t * NOTE this is only intended for use by very advanced users.\n\t\t * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\n\t\t * looping. Connected to {{#crossLink "WebAudioSoundInstance/gainNode:property"}}{{/crossLink}}.\n\t\t * @property _sourceNodeNext\n\t\t * @type {AudioNode}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.1\n\t\t *\n\t\t */\n\t\tthis._sourceNodeNext = null;\n\n\t\t/**\n\t\t * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\n\t\t * @property _playbackStartTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._playbackStartTime = 0;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t};\n\tvar p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\n\tvar s = WebAudioSoundInstance;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n  \t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.context = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  \n\t * This is and should be the same scratch buffer referenced by {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.\n  \t * @property _scratchBuffer\n\t * @type {AudioBufferSourceNode}\n\t * @static\n\t */\n\ts._scratchBuffer = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\n\t * @property destinationNode\n\t * @type {AudioNode}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.destinationNode = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._panningModel = "equalpower";\n\n\n// Public methods\n\tp.destroy = function() {\n\t\tthis.AbstractSoundInstance_destroy();\n\n\t\tthis.panNode.disconnect(0);\n\t\tthis.panNode = null;\n\t\tthis.gainNode.disconnect(0);\n\t\tthis.gainNode = null;\n\t};\n\n\tp.toString = function () {\n\t\treturn "[WebAudioSoundInstance]";\n\t};\n\n\n// Private Methods\n\tp._updatePan = function() {\n\t\tthis.panNode.setPosition(this._pan, 0, -0.5);\n\t\t// z need to be -0.5 otherwise the sound only plays in left, right, or center\n\t};\n\n\tp._removeLooping = function(value) {\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t};\n\n\tp._addLooping = function(value) {\n\t\tif (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = this.playbackResource.duration * 1000;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tif (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\t}\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\t\t// OJR there appears to be a bug that this doesn\'t always work in webkit (Chrome and Safari). According to the documentation, this should work.\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tthis._playbackStartTime = 0;\t// This is used by getPosition\n\t};\n\n\t/**\n\t * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\n\t * @method _cleanUpAudioNode\n\t * @param audioNode\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._cleanUpAudioNode = function(audioNode) {\n\t\tif(audioNode) {\n\t\t\taudioNode.stop(0);\n\t\t\taudioNode.disconnect(0);\n\t\t\t// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other\n\t\t\t// browser implementations.\n\t\t\ttry { audioNode.buffer = s._scratchBuffer; } catch(e) {}\n\t\t\taudioNode = null;\n\t\t}\n\t\treturn audioNode;\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tthis.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\n\n\t\tvar dur = this._duration * 0.001;\n\t\tvar pos = this._position * 0.001;\n\t\tif (pos > dur) {pos = dur;}\n\t\tthis.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\n\t\tthis._playbackStartTime = this.sourceNode.startTime - pos;\n\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\n\n\t\tif(this._loop != 0) {\n\t\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\t}\n\t};\n\n\t/**\n\t * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\n\t * @method _createAndPlayAudioNode\n\t * @param {Number} startTime The time to add this to the web audio context, in seconds.\n\t * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._createAndPlayAudioNode = function(startTime, offset) {\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.buffer = this.playbackResource;\n\t\taudioNode.connect(this.panNode);\n\t\tvar dur = this._duration * 0.001;\n\t\taudioNode.startTime = startTime + dur;\n\t\taudioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\n\t\treturn audioNode;\n\t};\n\n\tp._pause = function () {\n\t\tthis._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\t};\n\n\tp._resume = function () {\n\t\tthis._handleSoundReady();\n\t};\n\n\t/*\n\tp._handleStop = function () {\n\t\t// web audio does not need to do anything extra\n\t};\n\t*/\n\n\tp._updateVolume = function () {\n\t\tvar newVolume = this._muted ? 0 : this._volume;\n\t  \tif (newVolume != this.gainNode.gain.value) {\n\t\t  this.gainNode.gain.value = newVolume;\n  \t\t}\n\t};\n\n\tp._calculateCurrentPosition = function () {\n\t\treturn ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\n\t};\n\n\tp._updatePosition = function () {\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tif (!this._paused) {this._handleSoundReady();}\n\t};\n\n\t// OJR we are using a look ahead approach to ensure smooth looping.\n\t// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\n\t// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\n\t// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\n\tp._handleLoop = function () {\n\t\tthis._cleanUpAudioNode(this.sourceNode);\n\t\tthis.sourceNode = this._sourceNodeNext;\n\t\tthis._playbackStartTime = this.sourceNode.startTime;\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\n\t};\n\n\tp._updateDuration = function () {\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._pause();\n\t\t\tthis._resume();\n\t\t}\n\t};\n\n\tcreatejs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance");\n}());\n\n//##############################################################################\n// WebAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t"use strict";\n\n\t/**\n\t * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\n\t * anywhere that it is supported. To change plugin priority, check out the Sound API\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} method.\n\n\t * <h4>Known Browser and OS issues for Web Audio</h4>\n\t * <b>Firefox 25</b>\n\t * <li>\n\t *     mp3 audio files do not load properly on all windows machines, reported <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=929969" target="_blank">here</a>.\n\t *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default\n\t *     extension, until this bug is resolved\n\t * </li>\n\t *\n\t * <b>Webkit (Chrome and Safari)</b>\n\t * <li>\n\t *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\n\t * \t   are playing a lot of audio files.\n\t * </li>\n\t *\n\t * <b>iOS 6 limitations</b>\n\t * <ul>\n\t *     <li>\n\t *         Sound is initially muted and will only unmute through play being called inside a user initiated event\n\t *         (touch/click). Please read the mobile playback notes in the the {{#crossLink "Sound"}}{{/crossLink}}\n\t *         class for a full overview of the limitations, and how to get around them.\n\t *     </li>\n\t *\t   <li>\n\t *\t       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid\n\t *\t       this bug by ensuring the audio and video audio share the same sample rate.\n\t *\t   </li>\n\t * </ul>\n\t * @class WebAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t * @since 0.4.0\n\t */\n\tfunction WebAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n// Private Properties\n\t\t/**\n\t\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n\t\t * @property _panningModel\n\t\t * @type {Number / String}\n\t\t * @protected\n\t\t */\n\t\tthis._panningModel = s._panningModel;;\n\n\t\t/**\n\t\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t\t * need to be created within this context.\n\t\t * @property context\n\t\t * @type {AudioContext}\n\t\t */\n\t\tthis.context = s.context;\n\n\t\t/**\n\t\t * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\n\t\t * It is connected to <code>context.destination</code>.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\n\t\t * @property dynamicsCompressorNode\n\t\t * @type {AudioNode}\n\t\t */\n\t\tthis.dynamicsCompressorNode = this.context.createDynamicsCompressor();\n\t\tthis.dynamicsCompressorNode.connect(this.context.destination);\n\n\t\t/**\n\t\t * A GainNode for controlling master volume. It is connected to {{#crossLink "WebAudioPlugin/dynamicsCompressorNode:property"}}{{/crossLink}}.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t */\n\t\tthis.gainNode = this.context.createGain();\n\t\tthis.gainNode.connect(this.dynamicsCompressorNode);\n\t\tcreatejs.WebAudioSoundInstance.destinationNode = this.gainNode;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.WebAudioLoader;\n\t\tthis._soundInstanceClass = createjs.WebAudioSoundInstance;\n\n\t\tthis._addPropsToClasses();\n\t}\n\tvar p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\tvar s = WebAudioPlugin;\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink "WebAudioPlugin/_generateCapabilities:method"}}{{/crossLink}}\n\t * method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be "equalpower" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t */\n\ts._panningModel = "equalpower";\n\n\t/**\n\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t * need to be created within this context.\n\t *\n\t * Advanced users can set this to an existing context, but <b>must</b> do so before they call\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.\n\t *\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\ts.context = null;\n\n\t/**\n\t * The scratch buffer that will be assigned to the buffer property of a source node on close.\n\t * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102\n\t *\n\t * Advanced users can set this to an existing source node, but <b>must</b> do so before they call\n\t * {{#crossLink "Sound/registerPlugins"}}{{/crossLink}} or {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}.\n\t *\n\t * @property _scratchBuffer\n\t * @type {AudioBuffer}\n\t * @protected\n\t * @static\n\t */\n\t s._scratchBuffer = null;\n\n\t/**\n\t * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n\t * empty sound.\n\t * @property _unlocked\n\t * @type {boolean}\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlocked = false;\n\n\n// Static Public Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\t// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\n\t\tvar isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\n\t\t// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\n\t\tif (location.protocol == "file:" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\n\t\ts._generateCapabilities();\n\t\tif (s.context == null) {return false;}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n\t * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\n\t * {{#crossLink "WebAudioPlugin"}}{{/crossLink}} is initialized (by Sound {{#crossLink "Sound/initializeDefaultPlugins"}}{{/crossLink}}\n\t * for example).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     function handleTouch(event) {\n\t *         createjs.WebAudioPlugin.playEmptySound();\n\t *     }\n\t *\n\t * @method playEmptySound\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.playEmptySound = function() {\n\t\tif (s.context == null) {return;}\n\t\tvar source = s.context.createBufferSource();\n\t\tsource.buffer = s._scratchBuffer;\n\t\tsource.connect(s.context.destination);\n\t\tsource.start(0, 0, 0);\n\t};\n\n\n// Static Private Methods\n\t/**\n\t * Determine if XHR is supported, which is necessary for web audio.\n\t * @method _isFileXHRSupported\n\t * @return {Boolean} If XHR is supported.\n\t * @since 0.4.2\n\t * @protected\n\t * @static\n\t */\n\ts._isFileXHRSupported = function() {\n\t\t// it\'s much easier to detect when something goes wrong, so let\'s start optimistically\n\t\tvar supported = true;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\ttry {\n\t\t\txhr.open("GET", "WebAudioPluginTest.fail", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t\treturn supported;\n\t\t}\n\t\txhr.onerror = function() { supported = false; }; // cause irrelevant\n\t\t// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\n\t\txhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != "")); };\n\t\ttry {\n\t\t\txhr.send();\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t}\n\n\t\treturn supported;\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\t// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\n\t\tvar t = document.createElement("audio");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\tif (s.context == null) {\n\t\t\tif (window.AudioContext) {\n\t\t\t\ts.context = new AudioContext();\n\t\t\t} else if (window.webkitAudioContext) {\n\t\t\t\ts.context = new webkitAudioContext();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (s._scratchBuffer == null) {\n\t\t\ts._scratchBuffer = s.context.createBuffer(1, 1, 22050);\n\t\t}\n\n\t\ts._compatibilitySetUp();\n\n\t\t// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.\n\t\tif ("ontouchstart" in window && s.context.state != "running") {\n\t\t\ts._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n\t\t\tdocument.addEventListener("mousedown", s._unlock, true);\n\t\t\tdocument.addEventListener("touchend", s._unlock, true);\n\t\t}\n\n\n\t\ts._capabilities = {\n\t\t\tpanning:true,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\n\t\t}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\n\n\t\t// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\n\t\t// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\n\t\tif (s.context.destination.numberOfChannels < 2) {\n\t\t\ts._capabilities.panning = false;\n\t\t}\n\t};\n\n\t/**\n\t * Set up compatibility if only deprecated web audio calls are supported.\n\t * See http://www.w3.org/TR/webaudio/#DeprecationNotes\n\t * Needed so we can support new browsers that don\'t support deprecated calls (Firefox) as well as old browsers that\n\t * don\'t support new calls.\n\t *\n\t * @method _compatibilitySetUp\n\t * @static\n\t * @protected\n\t * @since 0.4.2\n\t */\n\ts._compatibilitySetUp = function() {\n\t\ts._panningModel = "equalpower";\n\t\t//assume that if one new call is supported, they all are\n\t\tif (s.context.createGain) { return; }\n\n\t\t// simple name change, functionality the same\n\t\ts.context.createGain = s.context.createGainNode;\n\n\t\t// source node, add to prototype\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.__proto__.start = audioNode.__proto__.noteGrainOn;\t// note that noteGrainOn requires all 3 parameters\n\t\taudioNode.__proto__.stop = audioNode.__proto__.noteOff;\n\n\t\t// panningModel\n\t\ts._panningModel = 0;\n\t};\n\n\t/**\n\t * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n\t * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n\t * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n\t *\n\t * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n\t * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n\t * stick with `mousedown` and `touchend`.\n\t * @method _unlock\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlock = function() {\n\t\tif (s._unlocked) { return; }\n\t\ts.playEmptySound();\n\t\tif (s.context.state == "running") {\n\t\t\tdocument.removeEventListener("mousedown", s._unlock, true);\n\t\t\tdocument.removeEventListener("touchend", s._unlock, true);\n\t\t\ts._unlocked = true;\n\t\t}\n\t};\n\n\n// Public Methods\n\tp.toString = function () {\n\t\treturn "[WebAudioPlugin]";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\n\t * @method _addPropsToClasses\n\t * @static\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addPropsToClasses = function() {\n\t\tvar c = this._soundInstanceClass;\n\t\tc.context = this.context;\n\t\tc._scratchBuffer = s._scratchBuffer;\n\t\tc.destinationNode = this.gainNode;\n\t\tc._panningModel = this._panningModel;\n\n\t\tthis._loaderClass.context = this.context;\n\t};\n\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\tvar newVolume = createjs.Sound._masterMute ? 0 : this._volume;\n\t\tif (newVolume != this.gainNode.gain.value) {\n\t\t\tthis.gainNode.gain.value = newVolume;\n\t\t}\n\t};\n\n\tcreatejs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin");\n}());\n\n//##############################################################################\n// HTMLAudioTagPool.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.\n\t * @class HTMLAudioTagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction HTMLAudioTagPool() {\n\t\t\tthrow "HTMLAudioTagPool cannot be instantiated";\n\t}\n\n\tvar s = HTMLAudioTagPool;\n\n// Static Properties\n\t/**\n\t * A hash lookup of each base audio tag, indexed by the audio source.\n\t * @property _tags\n\t * @type {{}}\n\t * @static\n\t * @protected\n\t */\n\ts._tags = {};\n\n\t/**\n\t * An object pool for html audio tags\n\t * @property _tagPool\n\t * @type {TagPool}\n\t * @static\n\t * @protected\n\t */\n\ts._tagPool = new TagPool();\n\n\t/**\n\t * A hash lookup of if a base audio tag is available, indexed by the audio source\n\t * @property _tagsUsed\n\t * @type {{}}\n\t * @protected\n\t * @static\n\t */\n\ts._tagUsed = {};\n\n// Static Methods\n\t/**\n\t  * Get an audio tag with the given source.\n\t  * @method get\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @static\n\t  */\n\t s.get = function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null) {\n\t\t\t// create new base tag\n\t\t\tt = s._tags[src] = s._tagPool.get();\n\t\t\tt.src = src;\n\t\t} else {\n\t\t\t// get base or pool\n\t\t\tif (s._tagUsed[src]) {\n\t\t\t\tt = s._tagPool.get();\n\t\t\t\tt.src = src;\n\t\t\t} else {\n\t\t\t\ts._tagUsed[src] = true;\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t };\n\n\t /**\n\t  * Return an audio tag to the pool.\n\t  * @method set\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @param {HTMLElement} tag Audio tag to set.\n\t  * @static\n\t  */\n\t s.set = function (src, tag) {\n\t\t // check if this is base, if yes set boolean if not return to pool\n\t\t if(tag == s._tags[src]) {\n\t\t\t s._tagUsed[src] = false;\n\t\t } else {\n\t\t\t s._tagPool.set(tag);\n\t\t }\n\t };\n\n\t/**\n\t * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.\n\t * @method remove\n\t * @param {String} src The source for the tag\n\t * @return {Boolean} If the TagPool was deleted.\n\t * @static\n\t */\n\ts.remove = function (src) {\n\t\tvar tag = s._tags[src];\n\t\tif (tag == null) {return false;}\n\t\ts._tagPool.set(tag);\n\t\tdelete(s._tags[src]);\n\t\tdelete(s._tagUsed[src]);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Gets the duration of the src audio in milliseconds\n\t * @method getDuration\n\t * @param {String} src The source file used by the audio tag.\n\t * @return {Number} Duration of src in milliseconds\n\t * @static\n\t */\n\ts.getDuration= function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null || !t.duration) {return 0;}\t// OJR duration is NaN if loading has not completed\n\t\treturn t.duration * 1000;\n\t};\n\n\tcreatejs.HTMLAudioTagPool = HTMLAudioTagPool;\n\n\n// ************************************************************************************************************\n\t/**\n\t * The TagPool is an object pool for HTMLAudio tag instances.\n\t * #class TagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction TagPool(src) {\n\n// Public Properties\n\t\t/**\n\t\t * A list of all available tags in the pool.\n\t\t * #property tags\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._tags = [];\n\t};\n\n\tvar p = TagPool.prototype;\n\tp.constructor = TagPool;\n\n\n// Public Methods\n\t/**\n\t * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\n\t * #method get\n\t * @return {HTMLAudioElement} An HTML audio tag.\n\t */\n\tp.get = function () {\n\t\tvar tag;\n\t\tif (this._tags.length == 0) {\n\t\t\ttag = this._createTag();\n\t\t} else {\n\t\t\ttag = this._tags.pop();\n\t\t}\n\t\tif (tag.parentNode == null) {document.body.appendChild(tag);}\n\t\treturn tag;\n\t};\n\n\t/**\n\t * Put an HTMLAudioElement back in the pool for use.\n\t * #method set\n\t * @param {HTMLAudioElement} tag HTML audio tag\n\t */\n\tp.set = function (tag) {\n\t\t// OJR this first step seems unnecessary\n\t\tvar index = createjs.indexOf(this._tags, tag);\n\t\tif (index == -1) {\n\t\t\tthis._tags.src = null;\n\t\t\tthis._tags.push(tag);\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn "[TagPool]";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Create an HTML audio tag.\n\t * #method _createTag\n\t * @param {String} src The source file to set for the audio tag.\n\t * @return {HTMLElement} Returns an HTML audio tag.\n\t * @protected\n\t */\n\tp._createTag = function () {\n\t\tvar tag = document.createElement("audio");\n\t\ttag.autoplay = false;\n\t\ttag.preload = "none";\n\t\t//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.\n\t\treturn tag;\n\t};\n\n}());\n\n//##############################################################################\n// HTMLAudioSoundInstance.js\n//##############################################################################\n\n(function () {\n\t"use strict";\n\n\t/**\n\t * HTMLAudioSoundInstance extends the base api of {{#crossLink "AbstractSoundInstance"}}{{/crossLink}} and is used by\n\t * {{#crossLink "HTMLAudioPlugin"}}{{/crossLink}}.\n\t *\n\t * @param {String} src The path to and file name of the sound.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n\t * @class HTMLAudioSoundInstance\n\t * @extends AbstractSoundInstance\n\t * @constructor\n\t */\n\tfunction HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// Private Properties\n\t\tthis._audioSpriteStopTime = null;\n\t\tthis._delayTimeoutId = null;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t\tthis._readyHandler = createjs.proxy(this._handleTagReady, this);\n\t\tthis._stalledHandler = createjs.proxy(this._playFailed, this);\n\t\tthis._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\n\t\tthis._loopHandler = createjs.proxy(this._handleSoundComplete, this);\n\n\t\tif (duration) {\n\t\t\tthis._audioSpriteStopTime = (startTime + duration) * 0.001;\n\t\t} else {\n\t\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\t}\n\t}\n\tvar p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods\n\t/**\n\t * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master volume.\n\t * undoc\'d because it is not meant to be used outside of Sound\n\t * #method setMasterVolume\n\t * @param value\n\t */\n\tp.setMasterVolume = function (value) {\n\t\tthis._updateVolume();\n\t};\n\n\t/**\n\t * Called by {{#crossLink "Sound"}}{{/crossLink}} when plugin does not handle master mute.\n\t * undoc\'d because it is not meant to be used outside of Sound\n\t * #method setMasterMute\n\t * @param value\n\t */\n\tp.setMasterMute = function (isMuted) {\n\t\tthis._updateVolume();\n\t};\n\n\tp.toString = function () {\n\t\treturn "[HTMLAudioSoundInstance]";\n\t};\n\n//Private Methods\n\tp._removeLooping = function() {\n\t\tif(this._playbackResource == null) {return;}\n\t\tthis._playbackResource.loop = false;\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\tp._addLooping = function() {\n\t\tif(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.loop = true;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tvar tag = this._playbackResource;\n\t\tif (tag != null) {\n\t\t\ttag.pause();\n\t\t\ttag.loop = false;\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\n\t\t\ttry {\n\t\t\t\ttag.currentTime = this._startTime;\n\t\t\t} catch (e) {\n\t\t\t} // Reset Position\n\t\t\tcreatejs.HTMLAudioTagPool.set(this.src, tag);\n\t\t\tthis._playbackResource = null;\n\t\t}\n\t};\n\n\tp._beginPlaying = function (playProps) {\n\t\tthis._playbackResource = createjs.HTMLAudioTagPool.get(this.src);\n\t\treturn this.AbstractSoundInstance__beginPlaying(playProps);\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tif (this._playbackResource.readyState !== 4) {\n\t\t\tvar tag = this._playbackResource;\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.preload = "auto"; // This is necessary for Firefox, as it won\'t ever "load" until this is set.\n\t\t\ttag.load();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateVolume();\n\t\tthis._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\n\t\tif (this._audioSpriteStopTime) {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t} else {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tif(this._loop != 0) {\n\t\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\t\tthis._playbackResource.loop = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._playbackResource.play();\n\t};\n\n\t/**\n\t * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\n\t * @method _handleTagReady\n\t * @param event\n\t * @protected\n\t */\n\tp._handleTagReady = function (event) {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\n\t\tthis._handleSoundReady();\n\t};\n\n\tp._pause = function () {\n\t\tthis._playbackResource.pause();\n\t};\n\n\tp._resume = function () {\n\t\tthis._playbackResource.play();\n\t};\n\n\tp._updateVolume = function () {\n\t\tif (this._playbackResource != null) {\n\t\t\tvar newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\n\t\t\tif (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\n\t\t}\n\t};\n\n\tp._calculateCurrentPosition = function() {\n\t\treturn (this._playbackResource.currentTime * 1000) - this._startTime;\n\t};\n\n\tp._updatePosition = function() {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\ttry {\n\t\t\tthis._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\n\t\t} catch (error) { // Out of range\n\t\t\tthis._handleSetPositionSeek(null);\n\t\t}\n\t};\n\n\t/**\n\t * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\n\t * @method _handleSetPositionSeek\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSetPositionSeek = function(event) {\n\t\tif (this._playbackResource == null) { return; }\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\t/**\n\t * Timer used to loop audio sprites.\n\t * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\n\t * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\n\t *\n\t * @method _handleAudioSpriteLoop\n\t * @param event\n\t * @private\n\t */\n\tp._handleAudioSpriteLoop = function (event) {\n\t\tif(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.pause();\n\t\tif(this._loop == 0) {\n\t\t\tthis._handleSoundComplete(null);\n\t\t} else {\n\t\t\tthis._position = 0;\n\t\t\tthis._loop--;\n\t\t\tthis._playbackResource.currentTime = this._startTime * 0.001;\n\t\t\tif(!this._paused) {this._playbackResource.play();}\n\t\t\tthis._sendEvent("loop");\n\t\t}\n\t};\n\n\t// NOTE with this approach audio will loop as reliably as the browser allows\n\t// but we could end up sending the loop event after next loop playback begins\n\tp._handleLoop = function (event) {\n\t\tif(this._loop == 0) {\n\t\t\tthis._playbackResource.loop = false;\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t}\n\t};\n\n\tp._updateStartTime = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._updateDuration = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\tthis._playbackResource = null;\n\t};\n\n\tcreatejs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance");\n}());\n\n//##############################################################################\n// HTMLAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t"use strict";\n\n\t/**\n\t * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\n\t * by default, after the {{#crossLink "WebAudioPlugin"}}{{/crossLink}}.  For older browsers that do not support html\n\t * audio, include and install the {{#crossLink "FlashAudioPlugin"}}{{/crossLink}}.\n\t *\n\t * <h4>Known Browser and OS issues for HTML Audio</h4>\n\t * <b>All browsers</b><br />\n\t * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\n\t * this limit, you can expect to see unpredictable results. Please use {{#crossLink "Sound.MAX_INSTANCES"}}{{/crossLink}} as\n\t * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.\n\t *\n     * <b>IE html limitations</b><br />\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags if it\'s not default.  We\'ve found default encoding with\n     * 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink "HTMLAudioPlugin.MAX_INSTANCES"}}{{/crossLink}} for a safe estimate.\n\t * Note that audio sprites can be used as a solution to this issue.</li></ul>\n\t *\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 limitations</b><br />\n\t * <ul><li>can only have one &lt;audio&gt; tag</li>\n\t * \t\t<li>can not preload or autoplay the audio</li>\n\t * \t\t<li>can not cache the audio</li>\n\t * \t\t<li>can not play the audio except inside a user initiated event.</li>\n\t *\t\t<li>Note it is recommended to use {{#crossLink "WebAudioPlugin"}}{{/crossLink}} for iOS (6+)</li>\n\t * \t\t<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\n\t * </ul>\n\t *\n\t * <b>Android Native Browser limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\n\t * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\n\t * <ul> <li>Can only play 1 sound at a time.</li>\n\t *      <li>Sound is not cached.</li>\n\t *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\n\t *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\n\t * </ul>\n\t *\n\t * See {{#crossLink "Sound"}}{{/crossLink}} for general notes on known issues.\n\t *\n\t * @class HTMLAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t */\n\tfunction HTMLAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n\t// Public Properties\n\t\t/**\n\t\t * This is no longer needed as we are now using object pooling for tags.\n\t\t *\n\t\t * <b>NOTE this property only exists as a limitation of HTML audio.</b>\n\t\t * @property defaultNumChannels\n\t\t * @type {Number}\n\t\t * @default 2\n\t\t * @since 0.4.0\n\t\t * @deprecated\n\t\t */\n\t\tthis.defaultNumChannels = 2;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.SoundLoader;\n\t\tthis._soundInstanceClass = createjs.HTMLAudioSoundInstance;\n\t}\n\n\tvar p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\n\tvar s = HTMLAudioPlugin;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\t/**\n\t * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.\n\t * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\n\t * Audio sprites work around this limitation.\n\t * @property MAX_INSTANCES\n\t * @type {Number}\n\t * @default 30\n\t * @static\n\t */\n\ts.MAX_INSTANCES = 30;\n\n\t/**\n\t * Event constant for the "canPlayThrough" event for cleaner code.\n\t * @property _AUDIO_READY\n\t * @type {String}\n\t * @default canplaythrough\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_READY = "canplaythrough";\n\n\t/**\n\t * Event constant for the "ended" event for cleaner code.\n\t * @property _AUDIO_ENDED\n\t * @type {String}\n\t * @default ended\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_ENDED = "ended";\n\n\t/**\n\t * Event constant for the "seeked" event for cleaner code.  We utilize this event for maintaining loop events.\n\t * @property _AUDIO_SEEKED\n\t * @type {String}\n\t * @default seeked\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_SEEKED = "seeked";\n\n\t/**\n\t * Event constant for the "stalled" event for cleaner code.\n\t * @property _AUDIO_STALLED\n\t * @type {String}\n\t * @default stalled\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_STALLED = "stalled";\n\n\t/**\n\t * Event constant for the "timeupdate" event for cleaner code.  Utilized for looping audio sprites.\n\t * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\n\t * @property _TIME_UPDATE\n\t * @type {String}\n\t * @default timeupdate\n\t * @static\n\t * @protected\n\t */\n\ts._TIME_UPDATE = "timeupdate";\n\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink "HTMLAudioPlugin/_generateCapabilities"}}{{/crossLink}}\n\t * method. Please see the Sound {{#crossLink "Sound/getCapabilities"}}{{/crossLink}} method for an overview of all\n\t * of the available properties.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\n// Static Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\n\t * browsers, but is disabled in iOS because of its limitations.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\ts._generateCapabilities();\n\t\treturn (s._capabilities != null);\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink "Sound/getCapabilities"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\tvar t = document.createElement("audio");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\ts._capabilities = {\n\t\t\tpanning:false,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != "");\n\t\t}  // OJR another way to do this might be canPlayType:"m4a", codex: mp4\n\t};\n\n\n// public methods\n\tp.register = function (loadItem) {\n\t\tvar tag = createjs.HTMLAudioTagPool.get(loadItem.src);\n\t\tvar loader = this.AbstractPlugin_register(loadItem);\n\t\tloader.setTag(tag);\n\n\t\treturn loader;\n\t};\n\n\tp.removeSound = function (src) {\n\t\tthis.AbstractPlugin_removeSound(src);\n\t\tcreatejs.HTMLAudioTagPool.remove(src);\n\t};\n\n\tp.create = function (src, startTime, duration) {\n\t\tvar si = this.AbstractPlugin_create(src, startTime, duration);\n\t\tsi.setPlaybackResource(null);\n\t\treturn si;\n\t};\n\n\tp.toString = function () {\n\t\treturn "[HTMLAudioPlugin]";\n\t};\n\n\t// plugin does not support these\n\tp.setVolume = p.getVolume = p.setMute = null;\n\n\n\tcreatejs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, "AbstractPlugin");\n}());\n\n//##############################################################################\n// Tween.js\n//##############################################################################\n\n// TODO: possibly add a END actionsMode (only runs actions that == position)?\n// TODO: evaluate a way to decouple paused from tick registration.\n\n\n\n\n(function() {\n\t"use strict";\n\n\n// constructor\n\t/**\n\t * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      target.alpha = 1;\n\t *\t    createjs.Tween.get(target)\n\t *\t         .wait(500)\n\t *\t         .to({alpha:0, visible:false}, 1000)\n\t *\t         .call(handleComplete);\n\t *\t    function handleComplete() {\n\t *\t    \t//Tween complete\n\t *\t    }\n\t *\n\t * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected\n\t * behaviour. To stop all tweens on an object, use {{#crossLink "Tween/removeTweens"}}{{/crossLink}} or pass `override:true`\n\t * in the props argument.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100});\n\t *\n\t * Subscribe to the {{#crossLink "Tween/change:event"}}{{/crossLink}} event to get notified when a property of the\n\t * target is changed.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener("change", handleChange);\n\t *      function handleChange(event) {\n\t *          // The tween changed.\n\t *      }\n\t *\n\t * See the Tween {{#crossLink "Tween/get"}}{{/crossLink}} method for additional param documentation.\n\t * @class Tween\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.\n\t * All properties default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on this tween.</LI>\n\t *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the "change" event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual\n\t * plugins\' documentation for details.\n\t * @extends EventDispatcher\n\t * @constructor\n\t */\n\tfunction Tween(target, props, pluginData) {\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink "Ticker"}}{{/crossLink}},\n\t\t * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>\n\t\t * is called. See the Tween {{#crossLink "Tween/tick"}}{{/crossLink}} method for more info. Can be set via the props\n\t\t * parameter.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\t\n\t\t/**\n\t\t * If true, the tween will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loop = false;\n\t\n\t\t/**\n\t\t * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\t\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by setting it to a property of pluginData with the same name as the plugin class.\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName = data;\n\t\t * <br/>\n\t\t * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by "_enabled".<br/>\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName_enabled = false;<br/>\n\t\t * <br/>\n\t\t * Some plugins also store instance data in this object, usually in a property named _PluginClassName.\n\t\t * See the documentation for individual plugins for more details.\n\t\t * @property pluginData\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = pluginData || {};\n\t\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed. Changing\n\t\t * this property after the tween is created will not have any effect.\n\t\t * @property target\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and duration.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.position = null;\n\t\n\t\t/**\n\t\t * Indicates the tween\'s current position is within a passive wait.\n\t\t * @property passive\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t **/\n\t\tthis.passive = false;\n\t\n\t// private properties:\t\n\t\t/**\n\t\t * @property _paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._paused = false;\n\t\n\t\t/**\n\t\t * @property _curQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._curQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _initQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._initQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _steps\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._steps = [];\n\t\n\t\t/**\n\t\t * @property _actions\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._actions = [];\n\t\n\t\t/**\n\t\t * Raw position.\n\t\t * @property _prevPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The position within the current step.\n\t\t * @property _stepPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._stepPosition = 0; // this is needed by MovieClip.\n\t\n\t\t/**\n\t\t * Normalized position.\n\t\t * @property _prevPos\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @protected\n\t\t */\n\t\tthis._prevPos = -1;\n\t\n\t\t/**\n\t\t * @property _target\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._target = target;\n\t\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._useTicks = false;\n\t\n\t\t/**\n\t\t * @property _inited\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._inited = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the tween is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop;\n\t\t\tprops.onChange && this.addEventListener("change", props.onChange);\n\t\t\tif (props.override) { Tween.removeTweens(target); }\n\t\t}\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }\n\n\t};\n\n\tvar p = createjs.extend(Tween, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// static properties\n\t/**\n\t * Constant defining the none actionsMode for use with setPosition.\n\t * @property NONE\n\t * @type Number\n\t * @default 0\n\t * @static\n\t */\n\tTween.NONE = 0;\n\n\t/**\n\t * Constant defining the loop actionsMode for use with setPosition.\n\t * @property LOOP\n\t * @type Number\n\t * @default 1\n\t * @static\n\t */\n\tTween.LOOP = 1;\n\n\t/**\n\t * Constant defining the reverse actionsMode for use with setPosition.\n\t * @property REVERSE\n\t * @type Number\n\t * @default 2\n\t * @static\n\t */\n\tTween.REVERSE = 2;\n\n\t/**\n\t * Constant returned by plugins to tell the tween not to use default assignment.\n\t * @property IGNORE\n\t * @type Object\n\t * @static\n\t */\n\tTween.IGNORE = {};\n\n\t/**\n\t * @property _listeners\n\t * @type Array[Tween]\n\t * @static\n\t * @protected\n\t */\n\tTween._tweens = [];\n\n\t/**\n\t * @property _plugins\n\t * @type Object\n\t * @static\n\t * @protected\n\t */\n\tTween._plugins = {};\n\n\n// static methods\t\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using "new Tween(...)", but looks cleaner\n\t * with the chained syntax of TweenJS.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar tween = createjs.Tween.get(target);\n\t *\n\t * @method get\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).\n\t * All properties default to `false`. Supported props are:\n\t * <UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on\n\t *    this tween.</LI>\n\t *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with\n\t *    the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the {{#crossLink "Tween/change:event"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins\'\n\t * documentation for details.\n\t * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the\n\t * same as calling `Tween.removeTweens(target)`.\n\t * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be\n\t * applied to the returned tween instance.\n\t * @static\n\t */\n\tTween.get = function(target, props, pluginData, override) {\n\t\tif (override) { Tween.removeTweens(target); }\n\t\treturn new Tween(target, props, pluginData);\n\t};\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own "heartbeat" implementation.\n\t * @method tick\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}}\n\t * will ignore this, but all others will pause if this is `true`.\n\t * @static\n\t */\n\tTween.tick = function(delta, paused) {\n\t\tvar tweens = Tween._tweens.slice(); // to avoid race conditions.\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }\n\t\t\ttween.tick(tween._useTicks?1:delta);\n\t\t}\n\t};\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {{#crossLink "Ticker/tick:event"}}{{/crossLink}} events from the createjs {{#crossLink "Ticker"}}{{/crossLink}}.\n\t * No other events are handled in Tween.\n\t * @method handleEvent\n\t * @param {Object} event An event object passed in by the {{#crossLink "EventDispatcher"}}{{/crossLink}}. Will\n\t * usually be of type "tick".\n\t * @private\n\t * @static\n\t * @since 0.4.2\n\t */\n\tTween.handleEvent = function(event) {\n\t\tif (event.type == "tick") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t * @method removeTweens\n\t * @param {Object} target The target object to remove existing tweens from.\n\t * @static\n\t */\n\tTween.removeTweens = function(target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif (tween._target == target) {\n\t\t\t\ttween._paused = true;\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t};\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t * @method removeAllTweens\n\t * @static\n\t * @since 0.4.1\n\t */\n\tTween.removeAllTweens = function() {\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i= 0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\ttween._paused = true;\n\t\t\ttween.target&&(tween.target.tweenjs_count = 0);\n\t\t}\n\t\ttweens.length = 0;\n\t};\n\n\t/**\n\t * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.\n\t * @method hasActiveTweens\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} If there are active tweens.\n\t * @static\n\t */\n\tTween.hasActiveTweens = function(target) {\n\t\tif (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }\n\t\treturn Tween._tweens && !!Tween._tweens.length;\n\t};\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "CSSPlugin"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins.\n\t * @method installPlugin\n\t * @static\n\t * @param {Object} plugin The plugin class to install\n\t * @param {Array} properties An array of properties that the plugin will handle.\n\t */\n\tTween.installPlugin = function(plugin, properties) {\n\t\tvar priority = plugin.priority;\n\t\tif (priority == null) { plugin.priority = priority = 0; }\n\t\tfor (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {\n\t\t\tvar n = properties[i];\n\t\t\tif (!p[n]) { p[n] = [plugin]; }\n\t\t\telse {\n\t\t\t\tvar arr = p[n];\n\t\t\t\tfor (var j=0,jl=arr.length;j<jl;j++) {\n\t\t\t\t\tif (priority < arr[j].priority) { break; }\n\t\t\t\t}\n\t\t\t\tp[n].splice(j,0,plugin);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t * @method _register\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.\n\t * @static\n\t * @protected\n\t */\n\tTween._register = function(tween, value) {\n\t\tvar target = tween._target;\n\t\tvar tweens = Tween._tweens;\n\t\tif (value && !tween._registered) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects in ES5\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }\n\t\t\ttweens.push(tween);\n\t\t\tif (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener("tick", Tween); Tween._inited = true; }\n\t\t} else if (!value && tween._registered) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tvar i = tweens.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (tweens[i] == tween) {\n\t\t\t\t\ttweens.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttween._registered = value;\n\t};\n\n\n// events:\n\t/**\n\t * Called whenever the tween\'s position changes.\n\t * @event change\n\t * @since 0.4.0\n\t **/\n\t\n\n// public methods:\n\t/**\n\t * Queues a wait (essentially an empty tween).\n\t * <h4>Example</h4>\n\t *\n\t *\t\t//This tween will wait 1s before alpha is faded to 0.\n\t *\t\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n\t *\n\t * @method wait\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {{#crossLink "Timeline"}}{{/crossLink}} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t **/\n\tp.wait = function(duration, passive) {\n\t\tif (duration == null || duration <= 0) { return this; }\n\t\tvar o = this._cloneProps(this._curQueueProps);\n\t\treturn this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});\n\t};\n\n\t/**\n\t * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tcreatejs.Tween.get(target).to({alpha:0}, 1000);\n\t *\n\t * @method to\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease="linear"] The easing function to use for this tween. See the {{#crossLink "Ease"}}{{/crossLink}}\n\t * class for a list of built-in ease functions.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.to = function(props, duration, ease) {\n\t\tif (isNaN(duration) || duration < 0) { duration = 0; }\n\t\treturn this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});\n\t};\n\n\t/**\n\t * Queues an action to call the specified function.\n\t * <h4>Example</h4>\n\t *\n\t *   \t//would call myFunction() after 1 second.\n\t *   \tmyTween.wait(1000).call(myFunction);\n\t *\n\t * @method call\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t *      will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target\'s\n\t *      scope.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.call = function(callback, params, scope) {\n\t\treturn this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});\n\t};\n\n\t// TODO: add clarification between this and a 0 duration .to:\n\t/**\n\t * Queues an action to set the specified props on the specified target. If target is null, it will use this tween\'s\n\t * target.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.wait(1000).set({visible:false},foo);\n\t *\n\t * @method set\n\t * @param {Object} props The properties to set (ex. `{visible:false}`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween\'s target.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.set = function(props, target) {\n\t\treturn this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});\n\t};\n\n\t/**\n\t * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.to({x:100},500).play(otherTween);\n\t *\n\t * @method play\n\t * @param {Tween} tween The tween to play.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.play = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [false], tween);\n\t};\n\n\t/**\n\t * Queues an action to pause the specified tween.\n\t * @method pause\n\t * @param {Tween} tween The tween to pause. If null, it pauses this tween.\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.pause = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [true], tween);\n\t};\n\n\t/**\n\t * Advances the tween to a specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):\n\t * <ul>\n\t *      <li>{{#crossLink "Tween/NONE:property"}}{{/crossLink}} (0) - run no actions.</li>\n\t *      <li>{{#crossLink "Tween/LOOP:property"}}{{/crossLink}} (1) - if new position is less than old, then run all\n\t *      actions between old and duration, then all actions between 0 and new.</li>\n\t *      <li>{{#crossLink "Tween/REVERSE:property"}}{{/crossLink}} (2) - if new position is less than old, run all\n\t *      actions between them in reverse.</li>\n\t * </ul>\n\t * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink "Tween/loop:property"}}{{/crossLink}}\n\t * is `false`).\n\t */\n\tp.setPosition = function(value, actionsMode) {\n\t\tif (value < 0) { value = 0; }\n\t\tif (actionsMode == null) { actionsMode = 1; }\n\n\t\t// normalize position:\n\t\tvar t = value;\n\t\tvar end = false;\n\t\tif (t >= this.duration) {\n\t\t\tif (this.loop) { t = t%this.duration; }\n\t\t\telse {\n\t\t\t\tt = this.duration;\n\t\t\t\tend = true;\n\t\t\t}\n\t\t}\n\t\tif (t == this._prevPos) { return end; }\n\n\n\t\tvar prevPos = this._prevPos;\n\t\tthis.position = this._prevPos = t; // set this in advance in case an action modifies position.\n\t\tthis._prevPosition = value;\n\n\t\t// handle tweens:\n\t\tif (this._target) {\n\t\t\tif (end) {\n\t\t\t\t// addresses problems with an ending zero length step.\n\t\t\t\tthis._updateTargetProps(null,1);\n\t\t\t} else if (this._steps.length > 0) {\n\t\t\t\t// find our new tween index:\n\t\t\t\tfor (var i=0, l=this._steps.length; i<l; i++) {\n\t\t\t\t\tif (this._steps[i].t > t) { break; }\n\t\t\t\t}\n\t\t\t\tvar step = this._steps[i-1];\n\t\t\t\tthis._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);\n\t\t\t}\n\t\t}\n\n\t\t// run actions:\n\t\tif (actionsMode != 0 && this._actions.length > 0) {\n\t\t\tif (this._useTicks) {\n\t\t\t\t// only run the actions we landed on.\n\t\t\t\tthis._runActions(t,t);\n\t\t\t} else if (actionsMode == 1 && t<prevPos) {\n\t\t\t\tif (prevPos != this.duration) { this._runActions(prevPos, this.duration); }\n\t\t\t\tthis._runActions(0, t, true);\n\t\t\t} else {\n\t\t\t\tthis._runActions(prevPos, t);\n\t\t\t}\n\t\t}\n\n\t\tif (end) { this.setPaused(true); }\n\n        this.dispatchEvent("change");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via {{#crossLink "Tween/tick"}}{{/crossLink}}), but is\n\t * exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).\n\t */\n\tp.tick = function(delta) {\n\t\tif (this._paused) { return; }\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * Pauses or plays this tween.\n\t * @method setPaused\n\t * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.setPaused = function(value) {\n\t\tif (this._paused === !!value) { return this; }\n\t\tthis._paused = !!value;\n\t\tTween._register(this, !value);\n\t\treturn this;\n\t};\n\n\t// tiny api (primarily for tool output):\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn "[Tween]";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow("Tween can not be cloned.")\n\t};\n\n// private methods:\n\t/**\n\t * @method _updateTargetProps\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @protected\n\t */\n\tp._updateTargetProps = function(step, ratio) {\n\t\tvar p0,p1,v,v0,v1,arr;\n\t\tif (!step && ratio == 1) {\n\t\t\t// GDS: when does this run? Just at the very end? Shouldn\'t.\n\t\t\tthis.passive = false;\n\t\t\tp0 = p1 = this._curQueueProps;\n\t\t} else {\n\t\t\tthis.passive = !!step.v;\n\t\t\tif (this.passive) { return; } // don\'t update props.\n\t\t\t// apply ease to ratio.\n\t\t\tif (step.e) { ratio = step.e(ratio,0,1,1); }\n\t\t\tp0 = step.p0;\n\t\t\tp1 = step.p1;\n\t\t}\n\n\t\tfor (var n in this._initQueueProps) {\n\t\t\tif ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }\n\t\t\tif ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }\n\t\t\tif (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != "number")) {\n\t\t\t\t// no interpolation - either at start, end, values don\'t change, or the value is non-numeric.\n\t\t\t\tv = ratio == 1 ? v1 : v0;\n\t\t\t} else {\n\t\t\t\tv = v0+(v1-v0)*ratio;\n\t\t\t}\n\n\t\t\tvar ignore = false;\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tfor (var i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\tvar v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);\n\t\t\t\t\tif (v2 == Tween.IGNORE) { ignore = true; }\n\t\t\t\t\telse { v = v2; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ignore) { this._target[n] = v; }\n\t\t}\n\n\t};\n\n\t/**\n\t * @method _runActions\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t * @protected\n\t */\n\tp._runActions = function(startPos, endPos, includeStart) {\n\t\tvar sPos = startPos;\n\t\tvar ePos = endPos;\n\t\tvar i = -1;\n\t\tvar j = this._actions.length;\n\t\tvar k = 1;\n\t\tif (startPos > endPos) {\n\t\t\t// running backwards, flip everything:\n\t\t\tsPos = endPos;\n\t\t\tePos = startPos;\n\t\t\ti = j;\n\t\t\tj = k = -1;\n\t\t}\n\t\twhile ((i+=k) != j) {\n\t\t\tvar action = this._actions[i];\n\t\t\tvar pos = action.t;\n\t\t\tif (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {\n\t\t\t\taction.f.apply(action.o, action.p);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _appendQueueProps\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._appendQueueProps = function(o) {\n\t\tvar arr,oldValue,i, l, injectProps;\n\t\tfor (var n in o) {\n\t\t\tif (this._initQueueProps[n] === undefined) {\n\t\t\t\toldValue = this._target[n];\n\n\t\t\t\t// init plugins:\n\t\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\t\tfor (i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\t\toldValue = arr[i].init(this, n, oldValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;\n\t\t\t} else {\n\t\t\t\toldValue = this._curQueueProps[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (var n in o) {\n\t\t\toldValue = this._curQueueProps[n];\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tinjectProps = injectProps||{};\n\t\t\t\tfor (i=0, l=arr.length;i<l;i++) {\n\t\t\t\t\t// TODO: remove the check for .step in the next version. It\'s here for backwards compatibility.\n\t\t\t\t\tif (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._curQueueProps[n] = o[n];\n\t\t}\n\t\tif (injectProps) { this._appendQueueProps(injectProps); }\n\t\treturn this._curQueueProps;\n\t};\n\n\t/**\n\t * @method _cloneProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._cloneProps = function(props) {\n\t\tvar o = {};\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _addStep\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addStep = function(o) {\n\t\tif (o.d > 0) {\n\t\t\tthis._steps.push(o);\n\t\t\to.t = this.duration;\n\t\t\tthis.duration += o.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _addAction\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addAction = function(o) {\n\t\to.t = this.duration;\n\t\tthis._actions.push(o);\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _set\n\t * @param {Object} props\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._set = function(props, o) {\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t};\n\n\tcreatejs.Tween = createjs.promote(Tween, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// Timeline.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\t\n\n// constructor\t\n\t/**\n\t * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n\t * timeline is looping, the tweens on it may appear to loop even if the "loop" property of the tween is false.\n\t * @class Timeline\n\t * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink "Timeline/addTween"}}{{/crossLink}}\n\t * for more info.\n\t * @param {Object} labels An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.\n\t * See {{#crossLink "Timeline/setLabels"}}{{/crossLink}}\n\t * for details.\n\t * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties\n\t * default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this timeline.</LI>\n\t *    <LI> onChange: specifies a listener to add for the {{#crossLink "Timeline/change:event"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction Timeline(tweens, labels, props) {\n\t\tthis.EventDispatcher_constructor();\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this timeline to continue playing when a global pause is active.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.ignoreGlobalPause = false;\n\n\t\t/**\n\t\t * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually\n\t\t * automatically updated as you modify the timeline. See {{#crossLink "Timeline/updateDuration"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property duration\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.duration = 0;\n\n\t\t/**\n\t\t * If true, the timeline will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.loop = false;\n\n\t\t/**\n\t\t * The current normalized position of the timeline. This will always be a value between 0 and\n\t\t * {{#crossLink "Timeline/duration:property"}}{{/crossLink}}.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type Object\n\t\t * @readonly\n\t\t **/\n\t\tthis.position = null;\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _paused\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * @property _tweens\n\t\t * @type Array[Tween]\n\t\t * @protected\n\t\t **/\n\t\tthis._tweens = [];\n\n\t\t/**\n\t\t * @property _labels\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @property _labelList\n\t\t * @type Array[Object]\n\t\t * @protected\n\t\t **/\n\t\tthis._labelList = null;\n\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPosition = 0;\n\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPos = -1;\n\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @protected\n\t\t **/\n\t\tthis._useTicks = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the timeline is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.loop = props.loop;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tprops.onChange&&this.addEventListener("change", props.onChange);\n\t\t}\n\t\tif (tweens) { this.addTween.apply(this, tweens); }\n\t\tthis.setLabels(labels);\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }\n\t\t\n\t};\n\t\n\tvar p = createjs.extend(Timeline, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// events:\n\t/**\n\t * Called whenever the timeline\'s position changes.\n\t * @event change\n\t * @since 0.5.0\n\t **/\n\n\n// public methods:\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t * @method addTween\n\t * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t **/\n\tp.addTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addTween(arguments[i]); }\n\t\t\treturn arguments[0];\n\t\t} else if (l == 0) { return null; }\n\t\tthis.removeTween(tween);\n\t\tthis._tweens.push(tween);\n\t\ttween.setPaused(true);\n\t\ttween._paused = false;\n\t\ttween._useTicks = this._useTicks;\n\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\tif (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }\n\t\treturn tween;\n\t};\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t * @method removeTween\n\t * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.\n\t * @return Boolean Returns `true` if all of the tweens were successfully removed.\n\t **/\n\tp.removeTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }\n\t\t\treturn good;\n\t\t} else if (l == 0) { return false; }\n\n\t\tvar tweens = this._tweens;\n\t\tvar i = tweens.length;\n\t\twhile (i--) {\n\t\t\tif (tweens[i] == tween) {\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Adds a label that can be used with {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.\n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t **/\n\tp.addLabel = function(label, position) {\n\t\tthis._labels[label] = position;\n\t\tvar list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, {label:label, position:position});\n\t\t}\n\t};\n\n\t/**\n\t * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.\n\t * @method setLabels\n\t * @param {Object} o An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}\n\t * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).\n\t **/\n\tp.setLabels = function(o) {\n\t\tthis._labels = o ?  o : {};\n\t};\n\n\t/**\n\t * Returns a sorted list of the labels defined on this timeline.\n\t * @method getLabels\n\t * @return {Array[Object]} A sorted array of objects with label and position properties.\n\t **/\n\tp.getLabels = function() {\n\t\tvar list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tvar labels = this._labels;\n\t\t\tfor (var n in labels) {\n\t\t\t\tlist.push({label:n, position:labels[n]});\n\t\t\t}\n\t\t\tlist.sort(function (a,b) { return a.position- b.position; });\n\t\t}\n\t\treturn list;\n\t};\n\n\t/**\n\t * Returns the name of the label on or immediately before the current position. For example, given a timeline with\n\t * two labels, "first" on frame index 4, and "second" on frame 8, getCurrentLabel would return:\n\t * <UL>\n\t * \t\t<LI>null if the current position is 2.</LI>\n\t * \t\t<LI>"first" if the current position is 4.</LI>\n\t * \t\t<LI>"first" if the current position is 7.</LI>\n\t * \t\t<LI>"second" if the current position is 15.</LI>\n\t * </UL>\n\t * @method getCurrentLabel\n\t * @return {String} The name of the current label or null if there is no label\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tvar labels = this.getLabels();\n\t\tvar pos = this.position;\n\t\tvar l = labels.length;\n\t\tif (l) {\n\t\t\tfor (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }\n\t\t\treturn (i==0) ? null : labels[i-1].label;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.setPaused(false);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.setPaused(true);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Advances the timeline to the specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).\n\t * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink "Tween/setPosition"}}{{/crossLink}}\n\t * method for more details.\n\t * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink "Timeline/loop:property"}}{{/crossLink}}\n\t * is `false`).\n\t **/\n\tp.setPosition = function(value, actionsMode) {\n\t\tvar t = this._calcPosition(value);\n\t\tvar end = !this.loop && value >= this.duration;\n\t\tif (t == this._prevPos) { return end; }\n\t\tthis._prevPosition = value;\n\t\tthis.position = this._prevPos = t; // in case an action changes the current frame.\n\t\tfor (var i=0, l=this._tweens.length; i<l; i++) {\n\t\t\tthis._tweens[i].setPosition(t, actionsMode);\n\t\t\tif (t != this._prevPos) { return false; } // an action changed this timeline\'s position.\n\t\t}\n\t\tif (end) { this.setPaused(true); }\n\t\tthis.dispatchEvent("change");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Pauses or plays this timeline.\n\t * @method setPaused\n\t * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).\n\t **/\n\tp.setPaused = function(value) {\n\t\tthis._paused = !!value; \n\t\tcreatejs.Tween._register(this, !value);\n\t};\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t * @method updateDuration\n\t **/\n\tp.updateDuration = function() {\n\t\tthis.duration = 0;\n\t\tfor (var i=0,l=this._tweens.length; i<l; i++) {\n\t\t\tvar tween = this._tweens[i];\n\t\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\t}\n\t};\n\n\t/**\n\t * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via the {{#crossLink "Tween/tick:event"}}{{/crossLink}}\n\t * event), but is exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).\n\t **/\n\tp.tick = function(delta) {\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t * @method resolve\n\t * @param {String|Number} positionOrLabel A numeric position value or label string.\n\t **/\n\tp.resolve = function(positionOrLabel) {\n\t\tvar pos = Number(positionOrLabel);\n\t\tif (isNaN(pos)) { pos = this._labels[positionOrLabel]; }\n\t\treturn pos;\n\t};\n\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn "[Timeline]";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t **/\n\tp.clone = function() {\n\t\tthrow("Timeline can not be cloned.")\n\t};\n\n// private methods:\n\t/**\n\t * @method _goto\n\t * @param {String | Number} positionOrLabel\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos); }\n\t};\n\t\n\t/**\n\t * @method _calcPosition\n\t * @param {Number} value\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._calcPosition = function(value) {\n\t\tif (value < 0) { return 0; }\n\t\tif (value < this.duration) { return value; }\n\t\treturn this.loop ? value%this.duration : this.duration;\n\t};\n\n\tcreatejs.Timeline = createjs.promote(Timeline, "EventDispatcher");\n\n}());\n\n//##############################################################################\n// Ease.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n\t * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n\t *\n\t * Most methods on Ease can be passed directly as easing functions:\n\t *\n\t *      Tween.get(target).to({x:100}, 500, Ease.linear);\n\t *\n\t * However, methods beginning with "get" will return an easing function based on parameter values:\n\t *\n\t *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n\t *\n\t * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an\n\t * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.\n\t *\n\t * <em>Equations derived from work by Robert Penner.</em>\n\t * @class Ease\n\t * @static\n\t **/\n\tfunction Ease() {\n\t\tthrow "Ease cannot be instantiated.";\n\t}\n\n\n// static methods and properties\n\t/**\n\t * @method linear\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.linear = function(t) { return t; };\n\n\t/**\n\t * Identical to linear.\n\t * @method none\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.none = Ease.linear;\n\n\t/**\n\t * Mimics the simple -100 to 100 easing in Flash Pro.\n\t * @method get\n\t * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.get = function(amount) {\n\t\tif (amount < -1) { amount = -1; }\n\t\tif (amount > 1) { amount = 1; }\n\t\treturn function(t) {\n\t\t\tif (amount==0) { return t; }\n\t\t\tif (amount<0) { return t*(t*-amount+1+amount); }\n\t\t\treturn t*((2-t)*amount+(1-amount));\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowIn\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowIn = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn Math.pow(t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowOut = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn 1-Math.pow(1-t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowInOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowInOut = function(pow) {\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*Math.pow(t,pow);\n\t\t\treturn 1-0.5*Math.abs(Math.pow(2-t,pow));\n\t\t};\n\t};\n\n\t/**\n\t * @method quadIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadIn = Ease.getPowIn(2);\n\t/**\n\t * @method quadOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadOut = Ease.getPowOut(2);\n\t/**\n\t * @method quadInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadInOut = Ease.getPowInOut(2);\n\n\t/**\n\t * @method cubicIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicIn = Ease.getPowIn(3);\n\t/**\n\t * @method cubicOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicOut = Ease.getPowOut(3);\n\t/**\n\t * @method cubicInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicInOut = Ease.getPowInOut(3);\n\n\t/**\n\t * @method quartIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartIn = Ease.getPowIn(4);\n\t/**\n\t * @method quartOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartOut = Ease.getPowOut(4);\n\t/**\n\t * @method quartInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartInOut = Ease.getPowInOut(4);\n\n\t/**\n\t * @method quintIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintIn = Ease.getPowIn(5);\n\t/**\n\t * @method quintOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintOut = Ease.getPowOut(5);\n\t/**\n\t * @method quintInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintInOut = Ease.getPowInOut(5);\n\n\t/**\n\t * @method sineIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineIn = function(t) {\n\t\treturn 1-Math.cos(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineOut = function(t) {\n\t\treturn Math.sin(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineInOut = function(t) {\n\t\treturn -0.5*(Math.cos(Math.PI*t) - 1);\n\t};\n\n\t/**\n\t * Configurable "back in" ease.\n\t * @method getBackIn\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackIn = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn t*t*((amount+1)*t-amount);\n\t\t};\n\t};\n\t/**\n\t * @method backIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backIn = Ease.getBackIn(1.7);\n\n\t/**\n\t * Configurable "back out" ease.\n\t * @method getBackOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackOut = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn (--t*t*((amount+1)*t + amount) + 1);\n\t\t};\n\t};\n\t/**\n\t * @method backOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backOut = Ease.getBackOut(1.7);\n\n\t/**\n\t * Configurable "back in out" ease.\n\t * @method getBackInOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackInOut = function(amount) {\n\t\tamount*=1.525;\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));\n\t\t\treturn 0.5*((t-=2)*t*((amount+1)*t+amount)+2);\n\t\t};\n\t};\n\t/**\n\t * @method backInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backInOut = Ease.getBackInOut(1.7);\n\n\t/**\n\t * @method circIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circIn = function(t) {\n\t\treturn -(Math.sqrt(1-t*t)- 1);\n\t};\n\n\t/**\n\t * @method circOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circOut = function(t) {\n\t\treturn Math.sqrt(1-(--t)*t);\n\t};\n\n\t/**\n\t * @method circInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circInOut = function(t) {\n\t\tif ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);\n\t\treturn 0.5*(Math.sqrt(1-(t-=2)*t)+1);\n\t};\n\n\t/**\n\t * @method bounceIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceIn = function(t) {\n\t\treturn 1-Ease.bounceOut(1-t);\n\t};\n\n\t/**\n\t * @method bounceOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceOut = function(t) {\n\t\tif (t < 1/2.75) {\n\t\t\treturn (7.5625*t*t);\n\t\t} else if (t < 2/2.75) {\n\t\t\treturn (7.5625*(t-=1.5/2.75)*t+0.75);\n\t\t} else if (t < 2.5/2.75) {\n\t\t\treturn (7.5625*(t-=2.25/2.75)*t+0.9375);\n\t\t} else {\n\t\t\treturn (7.5625*(t-=2.625/2.75)*t +0.984375);\n\t\t}\n\t};\n\n\t/**\n\t * @method bounceInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceInOut = function(t) {\n\t\tif (t<0.5) return Ease.bounceIn (t*2) * .5;\n\t\treturn Ease.bounceOut(t*2-1)*0.5+0.5;\n\t};\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticIn\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticIn = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2*Math.asin(1/amplitude);\n\t\t\treturn -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));\n\t\t};\n\t};\n\t/**\n\t * @method elasticIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticIn = Ease.getElasticIn(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\treturn (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);\n\t\t};\n\t};\n\t/**\n\t * @method elasticOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticOut = Ease.getElasticOut(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticInOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticInOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\tif ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));\n\t\t\treturn amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;\n\t\t};\n\t};\n\t/**\n\t * @method elasticInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);\n\n\tcreatejs.Ease = Ease;\n\n}());\n\n//##############################################################################\n// MotionGuidePlugin.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * A TweenJS plugin for working with motion guides.\n\t *\n\t * To use, install the plugin after TweenJS has loaded. Next tween the \'guide\' property with an object as detailed below.\n\t *\n\t *       createjs.MotionGuidePlugin.install();\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Using a Motion Guide\n\t *\t    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n\t *\t    // Visualizing the line\n\t *\t    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n\t *\n\t * Each path needs pre-computation to ensure there\'s fast performance. Because of the pre-computation there\'s no\n\t * built in support for path changes mid tween. These are the Guide Object\'s properties:<UL>\n\t *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n\t *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n\t *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n\t *      <LI> orient: Optional, string : "fixed"/"auto"/"cw"/"ccw"<UL>\n\t *\t\t\t\t<LI>"fixed" forces the object to face down the path all movement (relative to start rotation),</LI>\n\t *      \t\t<LI>"auto" rotates the object along the path relative to the line.</LI>\n\t *      \t\t<LI>"cw"/"ccw" force clockwise or counter clockwise rotations including flash like behaviour</LI>\n\t * \t\t</UL></LI>\n\t * </UL>\n\t * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n\t * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n\t * outside 0-1 range of tweens will be a "best guess" from the appropriate part of the defined curve.\n\t *\n\t * @class MotionGuidePlugin\n\t * @constructor\n\t **/\n\tfunction MotionGuidePlugin() {\n\t\tthrow("MotionGuidePlugin cannot be instantiated.")\n\t};\n\n\n// static properties:\n\t/**\n\t * @property priority\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.priority = 0; // high priority, should run sooner\n\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffE;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormE;\n\n\n// static methods\n\t/**\n\t * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n\t * @method install\n\t * @static\n\t **/\n\tMotionGuidePlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MotionGuidePlugin, ["guide", "x", "y", "rotation"]);\n\t\treturn createjs.Tween.IGNORE;\n\t};\n\n\t/**\n\t * @method init\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.init = function(tween, prop, value) {\n\t\tvar target = tween.target;\n\t\tif(!target.hasOwnProperty("x")){ target.x = 0; }\n\t\tif(!target.hasOwnProperty("y")){ target.y = 0; }\n\t\tif(!target.hasOwnProperty("rotation")){ target.rotation = 0; }\n\n\t\tif(prop=="rotation"){ tween.__needsRot = true; }\n\t\treturn prop=="guide"?null:value;\n\t};\n\n\t/**\n\t * @method step\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {\n\t\t// other props\n\t\tif(prop == "rotation"){\n\t\t\ttween.__rotGlobalS = startValue;\n\t\t\ttween.__rotGlobalE = endValue;\n\t\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\t}\n\t\tif(prop != "guide"){ return endValue; }\n\n\t\t// guide only information - Start -\n\t\tvar temp, data = endValue;\n\t\tif(!data.hasOwnProperty("path")){ data.path = []; }\n\t\tvar path = data.path;\n\t\tif(!data.hasOwnProperty("end")){ data.end = 1; }\n\t\tif(!data.hasOwnProperty("start")){\n\t\t\tdata.start = (startValue&&startValue.hasOwnProperty("end")&&startValue.path===path)?startValue.end:0;\n\t\t}\n\n\t\t// Figure out subline information\n\t\tif(data.hasOwnProperty("_segments") && data._length){ return endValue; }\n\t\tvar l = path.length;\n\t\tvar accuracy = 10;\t\t// Adjust to improve line following precision but sacrifice performance (# of seg)\n\t\tif(l >= 6 && (l-2) % 4 == 0){\t// Enough points && contains correct number per entry ignoring start\n\t\t\tdata._segments = [];\n\t\t\tdata._length = 0;\n\t\t\tfor(var i=2; i<l; i+=4){\n\t\t\t\tvar sx = path[i-2], sy = path[i-1];\n\t\t\t\tvar cx = path[i+0], cy = path[i+1];\n\t\t\t\tvar ex = path[i+2], ey = path[i+3];\n\t\t\t\tvar oldX = sx, oldY = sy;\n\t\t\t\tvar tempX, tempY, total = 0;\n\t\t\t\tvar sublines = [];\n\t\t\t\tfor(var j=1; j<=accuracy; j++){\n\t\t\t\t\tvar t = j/accuracy;\n\t\t\t\t\tvar inv = 1 - t;\n\t\t\t\t\ttempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;\n\t\t\t\t\ttempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;\n\t\t\t\t\ttotal += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];\n\t\t\t\t\toldX = tempX;\n\t\t\t\t\toldY = tempY;\n\t\t\t\t}\n\t\t\t\tdata._segments.push(total);\n\t\t\t\tdata._segments.push(sublines);\n\t\t\t\tdata._length += total;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow("invalid \'path\' data, please see documentation for valid paths");\n\t\t}\n\n\t\t// Setup x/y tweens\n\t\ttemp = data.orient;\n\t\tdata.orient = true;\n\t\tvar o = {};\n\t\tMotionGuidePlugin.calc(data, data.start, o);\n\t\ttween.__rotPathS = Number(o.rotation.toFixed(5));\n\t\tMotionGuidePlugin.calc(data, data.end, o);\n\t\ttween.__rotPathE = Number(o.rotation.toFixed(5));\n\t\tdata.orient = false;\t//here and now we don\'t know if we need to\n\t\tMotionGuidePlugin.calc(data, data.end, injectProps);\n\t\tdata.orient = temp;\n\n\t\t// Setup rotation properties\n\t\tif(!data.orient){ return endValue; }\n\t\ttween.__guideData = data;\n\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\treturn endValue;\n\t};\n\n\t/**\n\t * @method testRotData\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.testRotData = function(tween, injectProps){\n\n\t\t// no rotation informat? if we need it come back, if we don\'t use 0 & ensure we have guide data\n\t\tif(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){\n\t\t\tif(tween.__needsRot){ return; }\n\t\t\tif(tween._curQueueProps.rotation !== undefined){\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;\n\t\t\t} else {\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;\n\t\t\t}\n\t\t}\n\t\tif(tween.__guideData === undefined){ return; }\n\n\t\t// Process rotation properties\n\t\tvar data = tween.__guideData;\n\t\tvar rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;\n\t\tvar rotPathD = tween.__rotPathE - tween.__rotPathS;\n\t\tvar rot = rotGlobalD - rotPathD;\n\n\t\tif(data.orient == "auto"){\n\t\t\tif(rot > 180){\t\t\trot -= 360; }\n\t\t\telse if(rot < -180){\trot += 360; }\n\n\t\t} else if(data.orient == "cw"){\n\t\t\twhile(rot < 0){ rot += 360; }\n\t\t\tif(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }\n\n\t\t} else if(data.orient == "ccw"){\n\t\t\trot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));\t// sign flipping on path\n\t\t\twhile(rot > 0){ rot -= 360; }\n\t\t\tif(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }\n\t\t}\n\n\t\tdata.rotDelta = rot;\n\t\tdata.rotOffS = tween.__rotGlobalS - tween.__rotPathS;\n\n\t\t// reset\n\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;\n\t};\n\n\t/**\n\t * @method tween\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tvar data = endValues.guide;\n\t\tif(data == undefined || data === startValues.guide){ return value; }\n\t\tif(data.lastRatio != ratio){\n\t\t\t// first time through so calculate what I need to\n\t\t\tvar t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);\n\t\t\tMotionGuidePlugin.calc(data, t, tween.target);\n\t\t\tswitch(data.orient){\n\t\t\t\tcase "cw":\t\t// mix in the original rotation\n\t\t\t\tcase "ccw":\n\t\t\t\tcase "auto": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;\n\t\t\t\tcase "fixed":\t// follow fixed behaviour to solve potential issues\n\t\t\t\tdefault: tween.target.rotation += data.rotOffS; break;\n\t\t\t}\n\t\t\tdata.lastRatio = ratio;\n\t\t}\n\t\tif(prop == "rotation" && ((!data.orient) || data.orient == "false")){ return value; }\n\t\treturn tween.target[prop];\n\t};\n\n\t/**\n\t * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.\n\t * Assumes a path object with all optional parameters specified.\n\t * @param data Data object you would pass to the "guide:" property in a Tween\n\t * @param ratio 0-1 Distance along path, values outside 0-1 are "best guess"\n\t * @param target Object to copy the results onto, will use a new object if not supplied.\n\t * @return {Object} The target object or a new object w/ the tweened properties\n\t * @static\n\t */\n\tMotionGuidePlugin.calc = function(data, ratio, target) {\n\t\tif(data._segments == undefined){ throw("Missing critical pre-calculated information, please file a bug"); }\n\t\tif(target == undefined){ target = {x:0, y:0, rotation:0}; }\n\t\tvar seg = data._segments;\n\t\tvar path = data.path;\n\n\t\t// find segment\n\t\tvar pos = data._length * ratio;\n\t\tvar cap = seg.length - 2;\n\t\tvar n = 0;\n\t\twhile(pos > seg[n] && n < cap){\n\t\t\tpos -= seg[n];\n\t\t\tn+=2;\n\t\t}\n\n\t\t// find subline\n\t\tvar sublines = seg[n+1];\n\t\tvar i = 0;\n\t\tcap = sublines.length-1;\n\t\twhile(pos > sublines[i] && i < cap){\n\t\t\tpos -= sublines[i];\n\t\t\ti++;\n\t\t}\n\t\tvar t = (i/++cap)+(pos/(cap*sublines[i]));\n\n\t\t// find x/y\n\t\tn = (n*2)+2;\n\t\tvar inv = 1 - t;\n\t\ttarget.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];\n\t\ttarget.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];\n\n\t\t// orientation\n\t\tif(data.orient){\n\t\t\ttarget.rotation = 57.2957795 * Math.atan2(\n\t\t\t\t(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,\n\t\t\t\t(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tcreatejs.MotionGuidePlugin = MotionGuidePlugin;\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t"use strict";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class TweenJS\n\t **/\n\tvar s = createjs.TweenJS = createjs.TweenJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/"0.6.2"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/"Thu, 26 Nov 2015 20:44:31 GMT"; // injected by build process\n\n})();\nif( true && typeof module.exports !== "undefined") module.exports = this.createjs;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1)(module), __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlanMtbW9kdWxlL2NyZWF0ZWpzLmpzPzY1NjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNElBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxrRUFBa0UsNEJBQTRCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8scUNBQXFDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUNBQXFDLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0NBQXNDLFlBQVk7QUFDdEUsT0FBTywrQ0FBK0MsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsK0NBQStDLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNkJBQTZCLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsV0FBVyx1Q0FBdUMsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUNBQXlDLFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx5Q0FBeUMsWUFBWTtBQUNoRSxNQUFNLGtEQUFrRCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkMsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQyxZQUFZO0FBQ3BGO0FBQ0EsTUFBTSxvQ0FBb0MsWUFBWTtBQUN0RCxNQUFNLG9EQUFvRCxZQUFZO0FBQ3RFO0FBQ0EsdURBQXVELHdEQUF3RDtBQUMvRztBQUNBLGlCQUFpQiw2QkFBNkIsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlELFlBQVk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsbUNBQW1DO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUNBQXVDLFlBQVksT0FBTyx3Q0FBd0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQXNEO0FBQ2xFLHdCQUF3QjtBQUN4QixhQUFhLDhCQUE4QjtBQUMzQyxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZCQUE2QixZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZLEVBQUU7QUFDZCxZQUFZLFFBQVE7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGtCQUFrQjtBQUM5QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsNEJBQTRCLEtBQUs7QUFDakM7QUFDQSxlQUFlLHlCQUF5QixFQUFFO0FBQzFDLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQsZ0NBQWdDLHNDQUFzQztBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sd0JBQXdCLEVBQUUsYUFBYTs7QUFFOUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7O0FBRUE7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFpRCxZQUFZO0FBQ3RGO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDLFFBQVEsK0JBQStCLEVBQUU7QUFDekMsUUFBUSxrQ0FBa0MsRUFBRTtBQUM1Qzs7QUFFQSxxQkFBcUI7QUFDckIsZ0JBQWdCLDhDQUE4QztBQUM5RDtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdDQUF3QyxZQUFZO0FBQ3ZILDhEQUE4RCxvQ0FBb0MsWUFBWTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QyxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLFlBQVksV0FBVyxrQ0FBa0M7QUFDL0c7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0MsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDLFlBQVk7QUFDNUUsVUFBVSxtQ0FBbUMsWUFBWTtBQUN6RCwwQ0FBMEMsa0NBQWtDLFlBQVk7QUFDeEY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sK0JBQStCLFlBQVksSUFBSSwyQkFBMkIsWUFBWTtBQUM1RixNQUFNLG1DQUFtQyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJGQUEyRixrQ0FBa0MsWUFBWTtBQUN6SSxNQUFNLCtCQUErQixZQUFZLFFBQVEsb0NBQW9DLFlBQVk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDLFlBQVk7QUFDbkU7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlDQUF5QyxZQUFZO0FBQ25FO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMENBQTBDLFlBQVk7QUFDcEU7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywwQ0FBMEMsWUFBWTtBQUNwRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBbUQ7QUFDakUsZUFBZTtBQUNmLEdBQUc7QUFDSCxFQUFFLFlBQVksZ0JBQWdCOzs7QUFHOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7O0FBRTlDO0FBQ0E7QUFDQSxlQUFlLFNBQVMsT0FBTyxpQkFBaUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsdUNBQXVDLFlBQVk7QUFDakU7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVDQUF1QyxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEZBQTRGLDBCQUEwQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrQkFBK0IsWUFBWSxtREFBbUQsa0NBQWtDO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLEVBQUU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyx5QkFBeUI7O0FBRW5FO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCLFlBQVksT0FBTyxzQkFBc0IsWUFBWTtBQUNqRztBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSxxQkFBcUI7QUFDakMsYUFBYTtBQUNiLEdBQUc7QUFDSCxFQUFFLGFBQWE7OztBQUdmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUNBQXVDLFlBQVksT0FBTyx3Q0FBd0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlEQUF5RCx1REFBdUQ7QUFDaEgsbUJBQW1CLHVDQUF1QyxZQUFZO0FBQ3RFO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksZUFBZTtBQUMzQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QyxZQUFZLE9BQU8sd0NBQXdDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakUsc0NBQXNDLCtCQUErQjtBQUNyRSxtQkFBbUIsd0JBQXdCLFlBQVk7QUFDdkQsbUJBQW1CLHlCQUF5QixZQUFZO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDLGlDQUFpQywwQkFBMEI7QUFDM0Qsa0NBQWtDLDJCQUEyQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRFQUE0RSwwQkFBMEIsWUFBWTtBQUNsSCxNQUFNLHVCQUF1QixZQUFZO0FBQ3pDLHlCQUF5QixtQ0FBbUMsWUFBWSxNQUFNLG1DQUFtQyxZQUFZO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsc0NBQXNDLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFROzs7QUFHekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUNBQXVDLFlBQVksT0FBTyx3Q0FBd0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QyxZQUFZO0FBQ3hFO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLG1CQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QyxZQUFZO0FBQ3hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0gsRUFBRSxhQUFhOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHVGQUF1Riw4QkFBOEI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUErQyxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxrQ0FBa0M7QUFDdEksNkJBQTZCLHVCQUF1QixZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQThDLFlBQVk7QUFDeEYsMkJBQTJCLHVCQUF1QixZQUFZO0FBQzlELDJCQUEyQixvQ0FBb0MsWUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQyxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLHlHQUF5RyxtQ0FBbUM7QUFDNUk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCwyQ0FBMkM7QUFDaEc7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxnREFBZ0QsWUFBWTtBQUMxRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDBCQUEwQixZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQix5QkFBeUIsRUFBRSxFQUFFO0FBQy9FLHdCQUF3QiwyQkFBMkIsMEJBQTBCLEVBQUUsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBLHVCQUF1QiwrSEFBK0g7QUFDdEo7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEMsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCLEVBQUU7QUFDNUUscUVBQXFFLGtCQUFrQixFQUFFO0FBQ3pGLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7O0FBRXREOztBQUVBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILDhCQUE4QjtBQUNqSiwyQ0FBMkMsc0JBQXNCLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGdDQUFnQyxZQUFZO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBDQUEwQyxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQyxZQUFZO0FBQ3pFLDBCQUEwQixnQ0FBZ0MsWUFBWTtBQUN0RSwrQkFBK0IsNkJBQTZCLFlBQVksS0FBSywrQkFBK0IsWUFBWTtBQUN4SCx5QkFBeUIsdUNBQXVDLFlBQVk7QUFDNUUsNkJBQTZCLDBDQUEwQyxZQUFZO0FBQ25GLHdCQUF3Qiw4QkFBOEIsWUFBWTtBQUNsRSw2QkFBNkIsbUNBQW1DLFlBQVk7QUFDNUUsd0JBQXdCLCtCQUErQixZQUFZO0FBQ25FLDRCQUE0QixtQ0FBbUMsWUFBWTtBQUMzRSx5QkFBeUIsaURBQWlELFlBQVk7QUFDdEYsNkJBQTZCLGlEQUFpRCxZQUFZO0FBQzFGLHlCQUF5Qix5Q0FBeUMsWUFBWTtBQUM5RSw2QkFBNkIsaUNBQWlDLFlBQVk7QUFDMUUsOEJBQThCLHdDQUF3QyxZQUFZLEtBQUssdUNBQXVDLFlBQVk7QUFDMUksNEJBQTRCLHFDQUFxQyxZQUFZO0FBQzdFLHlCQUF5QixtREFBbUQsWUFBWTtBQUN4Riw2QkFBNkIsbURBQW1ELFlBQVk7QUFDNUYseUJBQXlCLDJDQUEyQyxZQUFZO0FBQ2hGLDZCQUE2QixtQ0FBbUMsWUFBWTtBQUM1RSx5QkFBeUIsa0NBQWtDLFlBQVk7QUFDdkUsNkJBQTZCLHVDQUF1QyxZQUFZO0FBQ2hGLHlCQUF5Qiw4Q0FBOEMsWUFBWTtBQUNuRiw2QkFBNkIsb0NBQW9DLFlBQVk7QUFDN0UseUJBQXlCLHFDQUFxQyxZQUFZO0FBQzFFLDZCQUE2QixzQ0FBc0MsWUFBWTtBQUMvRSx3QkFBd0Isb0NBQW9DLFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLFVBQVUsdUNBQXVDLFlBQVksT0FBTyx3Q0FBd0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNkJBQTZCLG1DQUFtQyxZQUFZO0FBQzVFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELG9DQUFvQyxZQUFZO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLG9EQUFvRCx3Q0FBd0MsWUFBWTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELHdDQUF3QyxZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYywrQ0FBK0MsWUFBWTtBQUN6RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtGQUErRiwwQ0FBMEM7QUFDekk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnR0FBZ0csOEJBQThCO0FBQzlIO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixvQ0FBb0MsWUFBWTtBQUNwSTtBQUNBO0FBQ0EsWUFBWSxPQUFPLGdGQUFnRixvQ0FBb0M7QUFDdkk7QUFDQSxZQUFZLE9BQU8sK0VBQStFLG9DQUFvQztBQUN0STtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsZ0NBQWdDLFlBQVk7QUFDekc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOEJBQThCLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQSxhQUFhLE9BQU8sRUFBRTtBQUN0QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMENBQTBDLFlBQVk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLCtCQUErQjtBQUN0RztBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sZ0ZBQWdGLG9DQUFvQztBQUN2STtBQUNBLFlBQVksT0FBTywrRUFBK0Usb0NBQW9DO0FBQ3RJO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLLE9BQU8seUJBQXlCOztBQUVyRCxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWSw2QkFBNkIseUJBQXlCLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUN2UDtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0EsYUFBYTtBQUNiLEVBQUUsa0NBQWtDLDJCQUEyQjs7QUFFL0Q7QUFDQSxtQ0FBbUMsZ0NBQWdDLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUNsSTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYixFQUFFLGtDQUFrQyw0QkFBNEI7OztBQUdoRTtBQUNBLG1DQUFtQywrQkFBK0IsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQ2pJO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsRUFBRSxrQ0FBa0MsNERBQTREOztBQUVoRztBQUNBLG1DQUFtQyw2QkFBNkIsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQy9IO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxFQUFFLGtDQUFrQywwRkFBMEY7O0FBRTlIO0FBQ0EsbUNBQW1DLDBDQUEwQyxZQUFZLE9BQU8sZ0NBQWdDLFlBQVk7QUFDNUk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsRUFBRSxrQ0FBa0MsMERBQTBEOztBQUU5RjtBQUNBLG1DQUFtQyx1Q0FBdUMsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQ3pJO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixFQUFFLGtDQUFrQywrRUFBK0U7O0FBRW5IO0FBQ0EsbUNBQW1DLDhCQUE4QixZQUFZLE9BQU8sZ0NBQWdDLFlBQVk7QUFDaEk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsRUFBRSxrQ0FBa0MsMENBQTBDOztBQUU5RTtBQUNBLG1DQUFtQyxtQ0FBbUMsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxFQUFFLGtDQUFrQyxpQkFBaUI7O0FBRXJEO0FBQ0EsdURBQXVELHlCQUF5QixZQUFZLE9BQU8sZ0NBQWdDLFlBQVk7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLEVBQUUsa0NBQWtDLGlCQUFpQjs7QUFFckQ7QUFDQSxtQ0FBbUMsbUNBQW1DLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUNySTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFlBQVksWUFBWSwyREFBMkQ7QUFDbkY7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLHdEQUF3RCxvQ0FBb0MsWUFBWTtBQUN4RyxVQUFVLGlEQUFpRCxZQUFZO0FBQ3ZFO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssT0FBTyxzQ0FBc0M7QUFDbEYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQ0FBb0MsWUFBWTtBQUN4RyxVQUFVLGlEQUFpRCxZQUFZO0FBQ3ZFO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssT0FBTyxzQ0FBc0M7QUFDbEYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQ0FBb0MsWUFBWTtBQUN4RyxVQUFVLHlDQUF5QyxZQUFZO0FBQy9EO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEUsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxxQ0FBcUMsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQ3ZJO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHlCQUF5QixZQUFZLCtCQUErQjtBQUNwRTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQSx3REFBd0Qsc0NBQXNDLFlBQVk7QUFDMUcsVUFBVSxtREFBbUQsWUFBWTtBQUN6RTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0NBQXNDLFlBQVk7QUFDMUcsVUFBVSxtREFBbUQsWUFBWTtBQUN6RTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQ0FBc0MsWUFBWTtBQUN0RyxVQUFVLDJDQUEyQyxZQUFZO0FBQ2pFO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsd0NBQXdDLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUMxSTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsdUNBQXVDLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUN6STtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRix3QkFBd0I7QUFDeEIsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsOENBQThDLFlBQVksT0FBTyxnQ0FBZ0MsWUFBWTtBQUNoSjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGtCQUFrQixXQUFXO0FBQzdCLGdCQUFnQixpQkFBaUI7QUFDakMsa0JBQWtCLFdBQVc7QUFDN0IsZ0JBQWdCLGlCQUFpQjtBQUNqQyxrQkFBa0IsV0FBVztBQUM3QixnQkFBZ0IsaUJBQWlCO0FBQ2pDLGtCQUFrQixXQUFXOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxvQ0FBb0MsWUFBWSxPQUFPLGdDQUFnQyxZQUFZO0FBQ3RJO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxFQUFFLGtDQUFrQyxvREFBb0Q7O0FBRXhGO0FBQ0EsbUNBQW1DLHFDQUFxQyxZQUFZLE9BQU8sZ0NBQWdDLFlBQVk7QUFDdkk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHNDQUFzQyxZQUFZLE9BQU8sZ0NBQWdDLFlBQVk7QUFDeEk7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOzs7QUFHdkM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQixZQUFZLElBQUksdUJBQXVCLFlBQVksUUFBUSxzQkFBc0IsWUFBWTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtHQUErRyxzQkFBc0I7QUFDckk7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsWUFBWTtBQUNsRCxzRUFBc0UsK0NBQStDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELHVDQUF1QyxZQUFZO0FBQ2hIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDBCQUEwQixZQUFZLE1BQU0sc0JBQXNCLFlBQVk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCw0Q0FBNEMsWUFBWTtBQUN6RztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEMsWUFBWTtBQUN6RjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sMkNBQTJDLFlBQVk7QUFDOUQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8seUNBQXlDLFlBQVk7QUFDNUQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyR0FBMkcsc0JBQXNCO0FBQ2pJLFVBQVUsNEJBQTRCLFlBQVk7QUFDbEQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLCtDQUErQyxZQUFZO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCLFlBQVk7QUFDekQsa0NBQWtDLDhCQUE4QixZQUFZO0FBQzVFO0FBQ0Esa0dBQWtHLHNCQUFzQixZQUFZO0FBQ3BJO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELHNDQUFzQyxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRixxQ0FBcUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkIsWUFBWTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLFlBQVk7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBc0MsWUFBWSxhQUFhLDZDQUE2QyxZQUFZO0FBQzlILGNBQWMsMkJBQTJCLFlBQVk7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHNDQUFzQyxZQUFZLGFBQWEsNENBQTRDLFlBQVk7QUFDN0gsY0FBYywyQkFBMkIsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsOENBQThDLFlBQVk7QUFDekYsd0RBQXdELDBCQUEwQixZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQ0FBZ0MsWUFBWTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0MsWUFBWTtBQUN6RixjQUFjLDJCQUEyQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiw2Q0FBNkMsWUFBWTtBQUN4Rix3REFBd0QsMEJBQTBCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLCtCQUErQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQ0FBc0MsWUFBWTtBQUN6RixjQUFjLDJCQUEyQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsOENBQThDLFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsOENBQThDLFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QixZQUFZO0FBQzNFO0FBQ0EsTUFBTSwyQkFBMkIsWUFBWTtBQUM3QztBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBNkMsWUFBWTtBQUN2RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQyxZQUFZO0FBQ2pIO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFxRDtBQUNsRixpQkFBaUIsa0NBQWtDO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHVCQUF1QjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtR0FBbUc7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQXFEO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxvQ0FBb0MsWUFBWTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsNkNBQTZDLG1EQUFtRDtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxlQUFlO0FBQzNCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxlQUFlO0FBQzNCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBNEMsWUFBWSxPQUFPLDRDQUE0QyxZQUFZO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksY0FBYztBQUMxQixZQUFZLGVBQWU7QUFDM0IsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLHNCQUFzQixZQUFZO0FBQ3hHLDZFQUE2RSw0Q0FBNEM7QUFDekgsVUFBVSw0Q0FBNEMsWUFBWTtBQUNsRTtBQUNBLFlBQVksU0FBUyxjQUFjLHlCQUF5QixZQUFZO0FBQ3hFO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxzQkFBc0IsWUFBWTtBQUN4RztBQUNBLFlBQVksYUFBYSxhQUFhLDZCQUE2QixZQUFZO0FBQy9FO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFpRDtBQUNwRSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0M7QUFDQSxrREFBa0Qsc0NBQXNDLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUF3QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUF3QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7O0FBRXZELGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQSxlQUFlLDBDQUEwQyxFQUFFO0FBQzNELGVBQWUsMkJBQTJCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCLFVBQVUsRUFBRSxxQkFBcUIsVUFBVTtBQUN6RSxvQ0FBb0MsVUFBVSxFQUFFLHFCQUFxQixVQUFVO0FBQy9FLDhCQUE4QixVQUFVLEVBQUUscUJBQXFCLFVBQVU7O0FBRXpFLDhCQUE4QixVQUFVLEVBQUUscUJBQXFCLFVBQVU7QUFDekUsb0NBQW9DLFVBQVUsRUFBRSxxQkFBcUIsVUFBVTtBQUMvRSw4QkFBOEIsVUFBVSxFQUFFLHFCQUFxQixVQUFVOztBQUV6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUIsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0IsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQ0FBbUMsWUFBWSxJQUFJLHNDQUFzQyxZQUFZO0FBQzVHLE9BQU8sdUNBQXVDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYywrQ0FBK0MsWUFBWTtBQUN6RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7O0FBRS9EO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQztBQUNBLDRCQUE0QixVQUFVOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxPQUFPLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBLGdCQUFnQixPQUFPLE9BQU8sdUNBQXVDO0FBQ3JFO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLLE9BQU8sK0NBQStDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssT0FBTyxxQkFBcUI7QUFDakQsMEJBQTBCLFlBQVksRUFBRTtBQUN4QztBQUNBLGdCQUFnQixLQUFLLE9BQU8seUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakMsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQywyQkFBMkIsWUFBWTtBQUN2QywyQkFBMkIsWUFBWTtBQUN2QywwQ0FBMEMsT0FBTztBQUNqRDtBQUNBLGFBQWEsUUFBUSxFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFLGVBQWUsSUFBSTtBQUNuQiwwQkFBMEIsT0FBTztBQUNqQztBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELG9EQUFvRDtBQUM5RztBQUNBO0FBQ0EsdUZBQXVGLDhDQUE4QyxZQUFZO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9EQUFvRDtBQUM5RyxZQUFZLHVDQUF1QyxZQUFZO0FBQy9EO0FBQ0EsMEJBQTBCLDhDQUE4QyxZQUFZO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUErQyxZQUFZLE9BQU8sNENBQTRDLFlBQVk7QUFDOUo7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsK0NBQStDLFlBQVk7QUFDNUU7QUFDQSxxQkFBcUIsK0NBQStDLFlBQVk7QUFDaEY7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0EsOEZBQThGLFVBQVU7QUFDeEcsa0RBQWtELFVBQVU7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBdUQ7QUFDaEYsSUFBSTtBQUNKLHNFQUFzRSxVQUFVOztBQUVoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLFVBQVUsc0RBQXNEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQStEOztBQUU5RTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7O0FBRTFDO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsNkRBQTZELFVBQVU7QUFDdkUsY0FBYyw4REFBOEQ7QUFDNUUsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLFlBQVkscUNBQXFDLDJCQUEyQjtBQUN0STtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsdUJBQXVCLFlBQVk7QUFDckcsaUNBQWlDLDZCQUE2QixZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEMsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNkNBQTZDLFlBQVksUUFBUSwyQkFBMkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QyxZQUFZLE9BQU8sd0NBQXdDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRiwyQkFBMkI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBNkMsWUFBWTtBQUMzRSxjQUFjLDJCQUEyQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNELGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixHQUFHO0FBQ0gsRUFBRSxhQUFhOzs7QUFHZjtBQUNBO0FBQ0EsaUVBQWlFLDJCQUEyQjtBQUM1RixhQUFhLDRDQUE0QyxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxpRUFBaUUsdUJBQXVCLFlBQVk7QUFDdkg7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLDBCQUEwQixrQkFBa0I7QUFDNUMsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxTQUFTLGdFQUFnRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0YsNkJBQTZCO0FBQ3JILGFBQWEsNENBQTRDLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUNBQWlDLFlBQVk7QUFDcEcsUUFBUSxrQ0FBa0MsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0Esb0ZBQW9GLFFBQVE7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELDZCQUE2QixZQUFZLGlCQUFpQix5Q0FBeUM7QUFDcEosNkZBQTZGLHVCQUF1QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7O0FBRUE7QUFDQSwwQ0FBMEMseUNBQXlDLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLDhDQUE4QztBQUNsSCxVQUFVLDZDQUE2QyxZQUFZLDBCQUEwQiw2Q0FBNkM7QUFDMUksVUFBVSw0Q0FBNEMsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLHFEQUFxRCxvQkFBb0IsRUFBRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQix5QkFBeUI7QUFDakUsc0JBQXNCLG9CQUFvQiwyQkFBMkI7QUFDckUscUJBQXFCLDhCQUE4Qiw2QkFBNkI7QUFDaEYsc0JBQXNCLDhCQUE4QiwyQkFBMkI7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0NBQW9DLEVBQUU7QUFDN0MsZUFBZSxXQUFXLGtGQUFrRjs7QUFFNUc7QUFDQTs7QUFFQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUMsU0FBUztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0EsU0FBUyxrQkFBa0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUSxFQUFFO0FBQ3pELHFCQUFxQixRQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsRUFBRTs7QUFFekQ7QUFDQSx5Q0FBeUMsMkRBQTJEOztBQUVwRyxlQUFlLHlFQUF5RSxnQkFBZ0I7O0FBRXhHLDBCQUEwQiw0REFBNEQ7QUFDdEY7O0FBRUE7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0EsR0FBRyxPQUFPLGlCQUFpQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRCxvREFBb0QsNkJBQTZCLEVBQUU7O0FBRW5GLHNCQUFzQixrREFBa0Q7QUFDeEU7QUFDQSxlQUFlLHNFQUFzRTs7QUFFckYsbUJBQW1CLDJFQUEyRSxlQUFlO0FBQzdHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRLEVBQUU7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsUUFBUTs7QUFFM0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQTBDOztBQUV4RTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksV0FBVztBQUN2QixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFFBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBaUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxRQUFRO0FBQ2pDLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTLFFBQVE7QUFDakMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9DQUFvQztBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQ0FBb0M7QUFDckc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0NBQW9DO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QixZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DLFlBQVksTUFBTSxtQ0FBbUMsWUFBWTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLHNDQUFzQyw0QkFBNEIsWUFBWTtBQUM5RSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEIsWUFBWTtBQUN6RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQ0FBaUMsWUFBWTtBQUNuRjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkIsWUFBWTtBQUM1RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7OztBQUdBLGlDQUFpQyxvQ0FBb0M7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7O0FBR3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLGtDQUFrQyw0R0FBNEc7QUFDOUk7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RyxTQUFTLG1DQUFtQyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxtQ0FBbUM7QUFDekcsbUNBQW1DLG1DQUFtQyxZQUFZLE1BQU0sNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwwQkFBMEIsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDLFlBQVk7QUFDdEY7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEdBQTBHLHNCQUFzQjtBQUNoSTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csNEJBQTRCLFlBQVk7QUFDaEosTUFBTSxtQ0FBbUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0MsZ0JBQWdCO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9GQUFvRix5QkFBeUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0NBQW9DLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLG1DQUFtQyx5QkFBeUIsWUFBWTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDRDQUE0QztBQUNqSSx1QkFBdUIsMkJBQTJCLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQWdELGtDQUFrQzs7O0FBRzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COzs7QUFHbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhOztBQUUvRDtBQUNBLHFCQUFxQix1QkFBdUIsZ0NBQWdDO0FBQzVFLFFBQVEscUJBQXFCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCwyQ0FBMkMsWUFBWTtBQUN2RztBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQiw4Q0FBOEMsYUFBYTtBQUMzRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBZ0Q7QUFDbEUsa0JBQWtCLGlCQUFpQjtBQUNuQyxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGdEQUFnRDtBQUMvRCxlQUFlLGlCQUFpQjtBQUNoQyx3QkFBd0IsZ0NBQWdDO0FBQ3hELGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEUsUUFBUSxpREFBaUQ7QUFDekQ7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBZ0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxZQUFZO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7O0FBRXhCO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRCxlQUFlLGlDQUFpQzs7QUFFaEQsa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkRBQTJELEtBQUssRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixVQUFVOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNDQUFzQztBQUNuRjs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0VBQXdFLDBCQUEwQixZQUFZO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQ0FBc0MsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxNQUFNLEtBQUssVUFBVSxJQUFJO0FBQ25EO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxNQUFNLElBQUksVUFBVSxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sa0VBQWtFLCtDQUErQyxZQUFZO0FBQ2hKLE1BQU0sZ0RBQWdELFlBQVksT0FBTywyQ0FBMkMsWUFBWTtBQUNoSSxxQkFBcUIsK0NBQStDLFlBQVk7QUFDaEYsWUFBWSxPQUFPLDJDQUEyQyxpREFBaUQ7QUFDL0c7QUFDQSxZQUFZLFFBQVEscUNBQXFDLHdDQUF3QztBQUNqRztBQUNBLFlBQVksT0FBTyxpREFBaUQsNENBQTRDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSSxNQUFNLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbURBQW1EOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QixZQUFZO0FBQzVEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsMENBQTBDLFlBQVk7QUFDcEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0RBQWdELFlBQVk7QUFDMUU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw0Q0FBNEMsWUFBWTtBQUN0RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSw0Q0FBNEM7QUFDM0g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLHFCQUFxQjtBQUN0QyxjQUFjO0FBQ2QsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBd0MsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFROztBQUV6QztBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUEsZ0NBQWdDLHNCQUFzQjs7QUFFdEQ7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EseUNBQXlDLFVBQVUsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZ0JBQWdCO0FBQzVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9FQUFvRTtBQUM5RjtBQUNBLGVBQWUsK0RBQStEO0FBQzlFO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE9BQU87QUFDbkIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLDBCQUEwQjtBQUN0QyxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0ZBQW9GLDRCQUE0QixZQUFZO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBLG1CQUFtQix3REFBd0Q7QUFDM0UsaUJBQWlCLHdEQUF3RDtBQUN6RSxhQUFhLHVEQUF1RDtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1QkFBdUI7QUFDMUgsYUFBYSxtQ0FBbUMsWUFBWTtBQUM1RCx5RkFBeUYsa0NBQWtDO0FBQzNILGtCQUFrQix1QkFBdUIsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLGNBQWM7QUFDMUI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxrQkFBa0I7QUFDOUIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlGQUF5RjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0RBQW9ELDRCQUE0QixZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFEQUFxRDtBQUM5RyxTQUFTLHNEQUFzRCxZQUFZO0FBQzNFO0FBQ0EsWUFBWSxPQUFPLHFCQUFxQiwrQ0FBK0MsWUFBWTtBQUNuRyxNQUFNLDRCQUE0QixZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywrQ0FBK0MsWUFBWSxvQ0FBb0MsNEJBQTRCLFlBQVk7QUFDaEosMEZBQTBGLHVCQUF1QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLFlBQVk7QUFDbEUsV0FBVyx5Q0FBeUMsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRywwQkFBMEI7QUFDaEk7QUFDQTtBQUNBLFlBQVksY0FBYyxxQkFBcUIsOEJBQThCLFlBQVk7QUFDekYsWUFBWSxVQUFVLGtCQUFrQiwwQkFBMEIsWUFBWTtBQUM5RTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQixZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRCxjQUFjLGFBQWE7QUFDM0I7QUFDQSw0QkFBNEIsc0lBQXNJO0FBQ2xLOztBQUVBO0FBQ0EsNkRBQTZELDRCQUE0QixZQUFZO0FBQ3JHO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsdUJBQXVCLDBCQUEwQixZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usa0RBQWtEO0FBQ3BIO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVLGtCQUFrQiwwQkFBMEIsWUFBWTtBQUM5RSw4REFBOEQsd0NBQXdDO0FBQ3RHO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Qsd0JBQXdCLFFBQVE7O0FBRWhDO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQSwrREFBK0Qsa0NBQWtDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0IsRUFBRTtBQUNyRCwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPLE9BQU8sZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDRCQUE0QixZQUFZO0FBQ3ZEO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw0QkFBNEIsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsRUFBRTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHNDQUFzQyxFQUFFOztBQUVyRSw4REFBOEQseUNBQXlDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDLGNBQWMsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBCQUEwQixZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0Msb0RBQW9EO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFLHVCQUF1QixRQUFROztBQUUvQjtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQWtFO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9DQUFvQyxZQUFZO0FBQzFELE1BQU0sMENBQTBDLFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlDQUFpQyxZQUFZO0FBQ3pGLDZGQUE2RiwyQkFBMkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQixZQUFZO0FBQ3pELGVBQWUsZ0NBQWdDLFlBQVk7QUFDM0QsZUFBZSwyQkFBMkIsWUFBWTtBQUN0RCxlQUFlLDRCQUE0QixZQUFZO0FBQ3ZELGVBQWUsa0NBQWtDLFlBQVksK0JBQStCLDRCQUE0QixZQUFZO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QyxZQUFZLE9BQU8sd0NBQXdDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckMsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxhQUFhOzs7QUFHcEQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsaUNBQWlDO0FBQzdIO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUIsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQyxZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QixZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLDhCQUE4QixjQUFjOztBQUU1QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxVQUFVLDJCQUEyQjs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckMseURBQXlELGFBQWE7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QixZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBLHdCQUF3QixhQUFhO0FBQ3JDLHdCQUF3QixhQUFhOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QixZQUFZO0FBQzdDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseUVBQXlFLGtDQUFrQyxZQUFZO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCLFlBQVksOENBQThDLGtDQUFrQztBQUM3SDtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUMsWUFBWSxPQUFPLHdDQUF3QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLElBQUk7QUFDZixZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEIsWUFBWTtBQUM5QyxtQkFBbUIsNEJBQTRCLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QixZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CLCtFQUErRSw0QkFBNEI7QUFDM0k7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNEVBQTRFLDRCQUE0QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QixZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7O0FBRUE7QUFDQSwwREFBMEQsc0JBQXNCLFlBQVk7QUFDNUY7QUFDQSw2Q0FBNkMsMkJBQTJCLFlBQVk7QUFDcEYsMERBQTBELDhDQUE4QztBQUN4RztBQUNBO0FBQ0EsWUFBWSxNQUFNLGFBQWEsc0JBQXNCLFlBQVk7QUFDakUsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RSxzQkFBc0IsYUFBYTs7QUFFbkM7QUFDQSxtQkFBbUIsV0FBVzs7QUFFOUI7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Qsd0ZBQXdGLHlCQUF5QjtBQUNqSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTSxhQUFhLHNCQUFzQixZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQ0FBaUMsMkJBQTJCO0FBQzVELHdGQUF3RiwwQkFBMEI7O0FBRWxIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7O0FBRWhEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0UsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQzs7QUFFekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLEdBQUcsb0JBQW9CO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksY0FBYztBQUMxQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isc0JBQXNCLFlBQVk7QUFDeEQ7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0IsWUFBWTtBQUNuRDtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLEtBQTRCLElBQUksc0JBQVU7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0NBQWtDLGlEQUFpRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhELENBQUM7QUFDRCxHQUFHLEtBQTZCLDBFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyA9ICh0aGlzLmNyZWF0ZWpzIHx8IHt9KSk7XG4vKiFcbiogQ3JlYXRlSlNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdE15U3ViQ2xhc3MucHJvdG90eXBlLmRvU29tZXRoaW5nID0gZnVuY3Rpb24oKSB7IH1cbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgTXlTdWJDbGFzcygpO1xuICogXHRjb25zb2xlLmxvZyhmb28gaW5zdGFuY2VvZiBNeVN1cGVyQ2xhc3MpOyAvLyB0cnVlXG4gKiBcdGNvbnNvbGUubG9nKGZvby5wcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE15U3ViQ2xhc3MpOyAvLyB0cnVlXG4gKlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBzdWJjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyY2xhc3MgVGhlIHN1cGVyY2xhc3MgdG8gZXh0ZW5kLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzJ3MgbmV3IHByb3RvdHlwZS5cbiAqL1xuY3JlYXRlanMuZXh0ZW5kID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gbygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzOyB9XG5cdG8ucHJvdG90eXBlID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG5cdHJldHVybiAoc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IG8oKSk7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJvbW90ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGxldmVsIDIgZXZlbnQgc3RhbmRhcmQuIEluIGdlbmVyYWwsIGNhbmNlbGFibGUgZXZlbnRzIHRoYXQgaGF2ZSBgcHJldmVudERlZmF1bHQoKWAgY2FsbGVkIHdpbGxcblx0ICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcblx0ICogRXZlbnREaXNwYXRjaGVyIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9pbml0aWFsaXplXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogXG5cdCAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcblx0ICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cblx0ICogXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBhbHNvIGV4cG9zZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvIFxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cblx0ICpcblx0ICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7XG5cdCAqXG5cdCAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICpcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0ICsgXCIgV2FzIENsaWNrZWRcIik7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiA8Yj5NYWludGFpbmluZyBwcm9wZXIgc2NvcGU8L2I+PGJyIC8+XG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXG5cdCAqXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxuXHQgKiAgICAgIH0pO1xuXHQgKiAgICAgIFxuXHQgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIHRydWUsIFwib25cIiB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cblx0ICogICAgICB9KTtcblx0ICogXG5cdCAqIElmIHlvdSB3YW50IHRvIHVzZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQsIHlvdSBtYXkgd2FudCB0byB1c2UgZnVuY3Rpb24uYmluZCgpIG9yIGEgc2ltaWxhciBwcm94eSB0byBtYW5hZ2Vcblx0ICogc2NvcGUuXG5cdCAqXG5cdCAqIDxiPkJyb3dzZXIgc3VwcG9ydDwvYj5cblx0ICogVGhlIGV2ZW50IG1vZGVsIGluIENyZWF0ZUpTIGNhbiBiZSB1c2VkIHNlcGFyYXRlbHkgZnJvbSB0aGUgc3VpdGUgaW4gYW55IHByb2plY3QsIGhvd2V2ZXIgdGhlIGluaGVyaXRhbmNlIG1vZGVsXG5cdCAqIHJlcXVpcmVzIG1vZGVybiBicm93c2VycyAoSUU5KykuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHByb3BlcnR5IF9jYXB0dXJlTGlzdGVuZXJzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXG5cdCAqIFxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3Ncblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKG15T2JqZWN0KTsgLy8gYWRkIHRvIGEgc3BlY2lmaWMgaW5zdGFuY2Vcblx0ICogXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcblx0ICogcHJvdG90eXBlLlxuXHQgKiovXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdHRhcmdldC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XG5cdFx0dGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XG5cdFx0dGFyZ2V0Ll9kaXNwYXRjaEV2ZW50ID0gcC5fZGlzcGF0Y2hFdmVudDtcblx0XHR0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xuXHR9O1xuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuIE5vdGUgdGhhdCBhZGRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIHRvIHRoZSBzYW1lIGZ1bmN0aW9uIHdpbGwgcmVzdWx0IGluXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgT2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0ZW5lciBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICoqL1xuXHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuXHRcdHZhciBsaXN0ZW5lcnM7XG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzfHx7fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcblx0XHR9XG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cblx0XHRhcnIgPSBsaXN0ZW5lcnNbdHlwZV07IC8vIHJlbW92ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSBhcnJheVxuXHRcdGlmICghYXJyKSB7IGxpc3RlbmVyc1t0eXBlXSA9IFtsaXN0ZW5lcl07ICB9XG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxuXHRcdHJldHVybiBsaXN0ZW5lcjtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXG5cdCAqIFxuXHQgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLCBvciB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xuXHQgKiB0byBgb25gIHdpdGggdGhlIHNhbWUgcGFyYW1zIHdpbGwgY3JlYXRlIG11bHRpcGxlIGxpc3RlbmVycy5cblx0ICogXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogXG5cdCAqIFx0XHR2YXIgbGlzdGVuZXIgPSBteUJ0bi5vbihcImNsaWNrXCIsIGhhbmRsZUNsaWNrLCBudWxsLCBmYWxzZSwge2NvdW50OjN9KTtcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XG5cdCAqIFx0XHRcdGNvbnNvbGUubG9nKHRoaXMgPT0gbXlCdG4pOyAvLyB0cnVlIC0gc2NvcGUgZGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcblx0ICogXHRcdFx0XHRteUJ0bi5vZmYoXCJjbGlja1wiLCBsaXN0ZW5lcik7XG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcblx0ICogXHRcdFx0fVxuXHQgKiBcdFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCBvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFRoZSBzY29wZSB0byBleGVjdXRlIHRoZSBsaXN0ZW5lciBpbi4gRGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXIvY3VycmVudFRhcmdldCBmb3IgZnVuY3Rpb24gbGlzdGVuZXJzLCBhbmQgdG8gdGhlIGxpc3RlbmVyIGl0c2VsZiBmb3Igb2JqZWN0IGxpc3RlbmVycyAoaWUuIHVzaW5nIGhhbmRsZUV2ZW50KS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmU9ZmFsc2VdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXG5cdCAqKi9cblx0cC5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBzY29wZSwgb25jZSwgZGF0YSwgdXNlQ2FwdHVyZSkge1xuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XG5cdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuXHRcdH1cblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcblx0XHRcdH0sIHVzZUNhcHR1cmUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXG5cdCAqXG5cdCAqIDxiPkltcG9ydGFudCBOb3RlOjwvYj4gdGhhdCB5b3UgbXVzdCBwYXNzIHRoZSBleGFjdCBmdW5jdGlvbiByZWZlcmVuY2UgdXNlZCB3aGVuIHRoZSBldmVudCB3YXMgYWRkZWQuIElmIGEgcHJveHlcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqKi9cblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpPTAsbD1hcnIubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXG5cdFx0XHRcdGVsc2UgeyBhcnIuc3BsaWNlKGksMSk7IH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcblx0ICogLm9uIG1ldGhvZC5cblx0ICogXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIuIFNlZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIG9mZlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqKi9cblx0cC5vZmYgPSBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCBvciBhbGwgbGlzdGVuZXJzIG9mIGFsbCB0eXBlcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxuXHQgKiAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXG5cdCAqIGRpc3BhdGNoRXZlbnQgd2lsbCBjb25zdHJ1Y3QgYW4gRXZlbnQgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5IHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLiBUaGlzIGxhdHRlciBhcHByb2FjaCBjYW5cblx0ICogYmUgdXNlZCB0byBhdm9pZCBldmVudCBvYmplY3QgaW5zdGFudGlhdGlvbiBmb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cyB0aGF0IG1heSBub3QgaGF2ZSBhbnkgbGlzdGVuZXJzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzXSBTcGVjaWZpZXMgdGhlIGBidWJibGVzYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbmNlbGFibGVdIFNwZWNpZmllcyB0aGUgYGNhbmNlbGFibGVgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBgcHJldmVudERlZmF1bHQoKWAgd2FzIGNhbGxlZCBvbiBhIGNhbmNlbGFibGUgZXZlbnQsIHRydWUgb3RoZXJ3aXNlLlxuXHQgKiovXG5cdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHQvLyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgYW5kIGl0IGRvZXNuJ3QgYnViYmxlOlxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdGlmICghYnViYmxlcyAmJiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50T2JqLnRhcmdldCAmJiBldmVudE9iai5jbG9uZSkge1xuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcy4gTWF5YmUgaW4gZmF2b3VyIG9mIGV2dE9iaiBpbnN0YW5jZW9mIEV2ZW50PyBPciAhIWV2dE9iai5jcmVhdGVFdmVudFxuXHRcdHRyeSB7IGV2ZW50T2JqLnRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9IC8vIHRyeS9jYXRjaCBhbGxvd3MgcmVkaXNwYXRjaGluZyBvZiBuYXRpdmUgZXZlbnRzXG5cblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xuXHRcdFx0d2hpbGUgKHRvcC5wYXJlbnQpIHsgbGlzdC5wdXNoKHRvcCA9IHRvcC5wYXJlbnQpOyB9XG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcblxuXHRcdFx0Ly8gY2FwdHVyZSAmIGF0VGFyZ2V0XG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBidWJibGluZ1xuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhZXZlbnRPYmouZGVmYXVsdFByZXZlbnRlZDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiovXG5cdHAuaGFzRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBvbiB0aGlzIG9iamVjdCBvciBhbnkgb2YgaXRzXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxuXHQgKiBcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB3aWxsVHJpZ2dlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqKi9cblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgbyA9IHRoaXM7XG5cdFx0d2hpbGUgKG8pIHtcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdG8gPSBvLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRXZlbnREaXNwYXRjaGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xuXHRcdHZhciBsLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZT09MSkgPyB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIDogdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XG5cdFx0XHRpZiAoIWFycnx8IShsPWFyci5sZW5ndGgpKSB7IHJldHVybjsgfVxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cblx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwgJiYgIWV2ZW50T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxuXHRcdFx0XHRlbHNlIHsgbyhldmVudE9iaik7IH1cblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcblx0XHRcdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFRpY2tlciBwcm92aWRlcyBhIGNlbnRyYWxpemVkIHRpY2sgb3IgaGVhcnRiZWF0IGJyb2FkY2FzdCBhdCBhIHNldCBpbnRlcnZhbC4gTGlzdGVuZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIHRpY2tcblx0ICogZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiBhIHNldCB0aW1lIGludGVydmFsIGhhcyBlbGFwc2VkLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGludGVydmFsIHRoYXQgdGhlIHRpY2sgZXZlbnQgaXMgY2FsbGVkIGlzIGEgdGFyZ2V0IGludGVydmFsLCBhbmQgbWF5IGJlIGJyb2FkY2FzdCBhdCBhIHNsb3dlciBpbnRlcnZhbFxuXHQgKiB3aGVuIHVuZGVyIGhpZ2ggQ1BVIGxvYWQuIFRoZSBUaWNrZXIgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgKGV4LiBgVGlja2VyLmZyYW1lcmF0ZSA9IDMwO2ApIGFuZFxuXHQgKiBjYW4gbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgZWFjaCB0aWNrIChha2EgZnJhbWUpXG5cdCAqICAgICAgICAgIGlmICghZXZlbnQucGF1c2VkKSB7XG5cdCAqICAgICAgICAgICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IHdoZW4gdGhlIFRpY2tlciBpcyBub3QgcGF1c2VkLlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgVGlja2VyXG5cdCAqIEB1c2VzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gVGlja2VyKCkge1xuXHRcdHRocm93IFwiVGlja2VyIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCI7XG5cdH1cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJLCBidXQgYXR0ZW1wdHMgdG8gc3luY2ggdGhlIHRpY2tzIHRvIHRhcmdldCBmcmFtZXJhdGUuIEl0XG5cdCAqIHVzZXMgYSBzaW1wbGUgaGV1cmlzdGljIHRoYXQgY29tcGFyZXMgdGhlIHRpbWUgb2YgdGhlIFJBRiByZXR1cm4gdG8gdGhlIHRhcmdldCB0aW1lIGZvciB0aGUgY3VycmVudCBmcmFtZSBhbmRcblx0ICogZGlzcGF0Y2hlcyB0aGUgdGljayB3aGVuIHRoZSB0aW1lIGlzIHdpdGhpbiBhIGNlcnRhaW4gdGhyZXNob2xkLlxuXHQgKlxuXHQgKiBUaGlzIG1vZGUgaGFzIGEgaGlnaGVyIHZhcmlhbmNlIGZvciB0aW1lIGJldHdlZW4gZnJhbWVzIHRoYW4ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgY29udGVudCBiZSB0aW1lIGJhc2VkIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB3aGlsZVxuXHQgKiBnYWluaW5nIHRoZSBiZW5lZml0cyBvZiB0aGF0IEFQSSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKlxuXHQgKiBWYXJpYW5jZSBpcyB1c3VhbGx5IGxvd2VzdCBmb3IgZnJhbWVyYXRlcyB0aGF0IGFyZSBhIGRpdmlzb3Igb2YgdGhlIFJBRiBmcmVxdWVuY3kuIFRoaXMgaXMgdXN1YWxseSA2MCwgc29cblx0ICogZnJhbWVyYXRlcyBvZiAxMCwgMTIsIDE1LCAyMCwgYW5kIDMwIHdvcmsgd2VsbC5cblx0ICpcblx0ICogRmFsbHMgYmFjayB0byB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSBpcyBub3Rcblx0ICogc3VwcG9ydGVkLlxuXHQgKiBAcHJvcGVydHkgUkFGX1NZTkNIRURcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInN5bmNoZWRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuUkFGX1NZTkNIRUQgPSBcInN5bmNoZWRcIjtcblxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgcGFzc2VzIHRocm91Z2ggdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBoZWFydGJlYXQsIGlnbm9yaW5nIHRoZSB0YXJnZXQgZnJhbWVyYXRlIGNvbXBsZXRlbHkuXG5cdCAqIEJlY2F1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyZXF1ZW5jeSBpcyBub3QgZGV0ZXJtaW5pc3RpYywgYW55IGNvbnRlbnQgdXNpbmcgdGhpcyBtb2RlIHNob3VsZCBiZSB0aW1lIGJhc2VkLlxuXHQgKiBZb3UgY2FuIGxldmVyYWdlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgb2JqZWN0J3MgXCJkZWx0YVwiIHByb3BlcnRpZXMgdG8gbWFrZSB0aGlzIGVhc2llci5cblx0ICpcblx0ICogRmFsbHMgYmFjayBvbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSBpcyBub3Rcblx0ICogc3VwcG9ydGVkLlxuXHQgKiBAcHJvcGVydHkgUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJyYWZcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuUkFGID0gXCJyYWZcIjtcblxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgc2V0VGltZW91dCBBUEkuIFRoaXMgcHJvdmlkZXMgcHJlZGljdGFibGUsIGFkYXB0aXZlIGZyYW1lIHRpbWluZywgYnV0IGRvZXMgbm90XG5cdCAqIHByb3ZpZGUgdGhlIGJlbmVmaXRzIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAoc2NyZWVuIHN5bmNoLCBiYWNrZ3JvdW5kIHRocm90dGxpbmcpLlxuXHQgKiBAcHJvcGVydHkgVElNRU9VVFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwidGltZW91dFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5USU1FT1VUID0gXCJ0aW1lb3V0XCI7XG5cblxuLy8gc3RhdGljIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB0aWNrLiBUaGUgZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGVhY2ggbGlzdGVuZXIgZXZlbiB3aGVuIHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkIHVzaW5nXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdXNlZDpcIiwgZXZlbnQucGF1c2VkLCBldmVudC5kZWx0YSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAZXZlbnQgdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aWNrZXIgaXMgY3VycmVudGx5IHBhdXNlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIGVsYXBzZWQgaW4gbXMgc2luY2UgdGhlIGxhc3QgdGljay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRvdGFsIHRpbWUgaW4gbXMgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJ1blRpbWUgVGhlIHRvdGFsIHRpbWUgaW4gbXMgdGhhdCBUaWNrZXIgd2FzIG5vdCBwYXVzZWQgc2luY2UgaXQgd2FzIGluaXRpYWxpemVkLiBGb3IgZXhhbXBsZSxcblx0ICogXHR5b3UgY291bGQgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHRoZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkIHNpbmNlIGluaXRpYWxpemF0aW9uIHdpdGggYHRpbWUtcnVuVGltZWAuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBwdWJsaWMgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkIGluIGZhdm91ciBvZiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGltaW5nTW9kZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBJZiB0cnVlLCB0aW1pbmdNb2RlIHdpbGxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBieSBkZWZhdWx0LlxuXHQgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm91ciBvZiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGltaW5nTW9kZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHByb3BlcnR5IHVzZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci51c2VSQUYgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHRoZSB0aW1pbmcgYXBpIChzZXRUaW1lb3V0IG9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSkgYW5kIG1vZGUgdG8gdXNlLiBTZWVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVRcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZcIn19e3svY3Jvc3NMaW5rfX0sIGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGX1NZTkNIRURcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vZGUgZGV0YWlscy5cblx0ICogQHByb3BlcnR5IHRpbWluZ01vZGVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBUaWNrZXIuVElNRU9VVFxuXHQgKiovXG5cdFRpY2tlci50aW1pbmdNb2RlID0gbnVsbDtcblxuXHQvKipcblx0ICogU3BlY2lmaWVzIGEgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIGRlbHRhIHByb3BlcnR5IGluIHRoZSB0aWNrIGV2ZW50IG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBidWlsZGluZyB0aW1lXG5cdCAqIGJhc2VkIGFuaW1hdGlvbnMgYW5kIHN5c3RlbXMgdG8gcHJldmVudCBpc3N1ZXMgY2F1c2VkIGJ5IGxhcmdlIHRpbWUgZ2FwcyBjYXVzZWQgYnkgYmFja2dyb3VuZCB0YWJzLCBzeXN0ZW0gc2xlZXAsXG5cdCAqIGFsZXJ0IGRpYWxvZ3MsIG9yIG90aGVyIGJsb2NraW5nIHJvdXRpbmVzLiBEb3VibGUgdGhlIGV4cGVjdGVkIGZyYW1lIGR1cmF0aW9uIGlzIG9mdGVuIGFuIGVmZmVjdGl2ZSB2YWx1ZVxuXHQgKiAoZXguIG1heERlbHRhPTUwIHdoZW4gcnVubmluZyBhdCA0MGZwcykuXG5cdCAqIFxuXHQgKiBUaGlzIGRvZXMgbm90IGltcGFjdCBhbnkgb3RoZXIgdmFsdWVzIChleC4gdGltZSwgcnVuVGltZSwgZXRjKSwgc28geW91IG1heSBleHBlcmllbmNlIGlzc3VlcyBpZiB5b3UgZW5hYmxlIG1heERlbHRhXG5cdCAqIHdoZW4gdXNpbmcgYm90aCBkZWx0YSBhbmQgb3RoZXIgdmFsdWVzLlxuXHQgKiBcblx0ICogSWYgMCwgdGhlcmUgaXMgbm8gbWF4aW11bS5cblx0ICogQHByb3BlcnR5IG1heERlbHRhXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKi9cblx0VGlja2VyLm1heERlbHRhID0gMDtcblx0XG5cdC8qKlxuXHQgKiBXaGVuIHRoZSB0aWNrZXIgaXMgcGF1c2VkLCBhbGwgbGlzdGVuZXJzIHdpbGwgc3RpbGwgcmVjZWl2ZSBhIHRpY2sgZXZlbnQsIGJ1dCB0aGUgPGNvZGU+cGF1c2VkPC9jb2RlPiBwcm9wZXJ0eVxuXHQgKiBvZiB0aGUgZXZlbnQgd2lsbCBiZSBgdHJ1ZWAuIEFsc28sIHdoaWxlIHBhdXNlZCB0aGUgYHJ1blRpbWVgIHdpbGwgbm90IGluY3JlYXNlLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldEV2ZW50VGltZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZVxuXHQgKiBpbmZvLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSB0cnVlO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQucGF1c2VkLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKGZhbHNlKSxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZSh0cnVlKSk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnBhdXNlZCA9IGZhbHNlO1xuXG5cbi8vIG1peC1pbnM6XG5cdC8vIEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzOlxuXHRUaWNrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IG51bGw7XG5cdFRpY2tlci5kaXNwYXRjaEV2ZW50ID0gbnVsbDtcblx0VGlja2VyLmhhc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIuX2xpc3RlbmVycyA9IG51bGw7XG5cdGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKFRpY2tlcik7IC8vIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcy5cblx0VGlja2VyLl9hZGRFdmVudExpc3RlbmVyID0gVGlja2VyLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFRpY2tlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0IVRpY2tlci5faW5pdGVkJiZUaWNrZXIuaW5pdCgpO1xuXHRcdHJldHVybiBUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIuYXBwbHkoVGlja2VyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2luaXRlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9zdGFydFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zdGFydFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BhdXNlZFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaW1lPTA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZFxuXHQgKiBAcHJvcGVydHkgX3RpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGlja3MgPSAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWQgd2hpbGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZFxuXHQgKiBAcHJvcGVydHkgX3BhdXNlZFRpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGlja3MgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2ludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faW50ZXJ2YWwgPSA1MDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9sYXN0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2xhc3RUaW1lID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF90aW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpY2tUaW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGlja1RpbWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSB0aW1lb3V0IG9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZC5cblx0ICogQHByb3BlcnR5IF90aW1lcklkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFxuXHQvKipcblx0ICogVHJ1ZSBpZiBjdXJyZW50bHkgdXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBmYWxzZSBpZiB1c2luZyBzZXRUaW1lb3V0LiBUaGlzIG1heSBiZSBkaWZmZXJlbnQgdGhhbiB0aW1pbmdNb2RlXG5cdCAqIGlmIHRoYXQgcHJvcGVydHkgY2hhbmdlZCBhbmQgYSB0aWNrIGhhc24ndCBmaXJlZC5cblx0ICogQHByb3BlcnR5IF9yYWZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XG5cbi8vIHN0YXRpYyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW50ZXJ2YWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG5cdFx0VGlja2VyLl9pbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdGlmICghVGlja2VyLl9pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW50ZXJ2YWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEZQUyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0VGlja2VyLnNldEludGVydmFsKDEwMDAvdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldEZQUyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxMDAwL1RpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiB0aWNrcy4gRGVmYXVsdCBpcyA1MCAoMjAgRlBTKS5cblx0ICogTm90ZSB0aGF0IGFjdHVhbCB0aW1lIGJldHdlZW4gdGlja3MgbWF5IGJlIG1vcmUgdGhhbiBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIENQVSBsb2FkLlxuXHQgKiBUaGlzIHByb3BlcnR5IGlzIGlnbm9yZWQgaWYgdGhlIHRpY2tlciBpcyB1c2luZyB0aGUgYFJBRmAgdGltaW5nIG1vZGUuXG5cdCAqIEBwcm9wZXJ0eSBpbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0IFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZCAoRlBTKS4gRWZmZWN0aXZlbHkganVzdCBhIHNob3J0Y3V0IHRvIGBpbnRlcnZhbGAsIHdoZXJlXG5cdCAqIGBmcmFtZXJhdGUgPT0gMTAwMC9pbnRlcnZhbGAuXG5cdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGlja2VyLCB7XG5cdFx0XHRpbnRlcnZhbDogeyBnZXQ6IFRpY2tlci5nZXRJbnRlcnZhbCwgc2V0OiBUaWNrZXIuc2V0SW50ZXJ2YWwgfSxcblx0XHRcdGZyYW1lcmF0ZTogeyBnZXQ6IFRpY2tlci5nZXRGUFMsIHNldDogVGlja2VyLnNldEZQUyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSk7IH1cblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTdGFydHMgdGhlIHRpY2suIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgbGlzdGVuZXIgaXMgYWRkZWQuXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl9pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0VGlja2VyLl9pbml0ZWQgPSB0cnVlO1xuXHRcdFRpY2tlci5fdGltZXMgPSBbXTtcblx0XHRUaWNrZXIuX3RpY2tUaW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fc3RhcnRUaW1lID0gVGlja2VyLl9nZXRUaW1lKCk7XG5cdFx0VGlja2VyLl90aW1lcy5wdXNoKFRpY2tlci5fbGFzdFRpbWUgPSAwKTtcblx0XHRUaWNrZXIuaW50ZXJ2YWwgPSBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0b3BzIHRoZSBUaWNrZXIgYW5kIHJlbW92ZXMgYWxsIGxpc3RlbmVycy4gVXNlIGluaXQoKSB0byByZXN0YXJ0IHRoZSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRpY2tlci5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3JhZikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0ZiYmZihUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoVGlja2VyLl90aW1lcklkKTtcblx0XHR9XG5cdFx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwidGlja1wiKTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBUaWNrZXIuX3RpbWVzID0gVGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXHRcdFRpY2tlci5fc3RhcnRUaW1lID0gVGlja2VyLl9sYXN0VGltZSA9IFRpY2tlci5fdGlja3MgPSAwO1xuXHRcdFRpY2tlci5faW5pdGVkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCB3aXRoaW4gYSB0aWNrLiBUaGlzIGNhbiB2YXJ5IHNpZ25pZmljYW50bHkgZnJvbSB0aGUgdmFsdWUgcHJvdmlkZWQgYnkgZ2V0TWVhc3VyZWRGUFNcblx0ICogYmVjYXVzZSBpdCBvbmx5IG1lYXN1cmVzIHRoZSB0aW1lIHNwZW50IHdpdGhpbiB0aGUgdGljayBleGVjdXRpb24gc3RhY2suIFxuXHQgKiBcblx0ICogRXhhbXBsZSAxOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAyMCwgZ2V0TWVhc3VyZWRGUFMoKSByZXR1cm5zIDIwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiA1MG1zIGJldHdlZW4gXG5cdCAqIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDE1bXMuIFRoaXMgaW5kaWNhdGVzIHRoYXQgXG5cdCAqIHRoZXJlIG1heSBiZSB1cCB0byAzNW1zIG9mIFwiaWRsZVwiIHRpbWUgYmV0d2VlbiB0aGUgZW5kIG9mIG9uZSB0aWNrIGFuZCB0aGUgc3RhcnQgb2YgdGhlIG5leHQuXG5cdCAqXG5cdCAqIEV4YW1wbGUgMjogV2l0aCBhIHRhcmdldCBGUFMgb2YgMzAsIGdldEZQUygpIHJldHVybnMgMTBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDEwMG1zIGJldHdlZW4gdGhlIGVuZCBvZlxuXHQgKiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMjBtcy4gVGhpcyB3b3VsZCBpbmRpY2F0ZSB0aGF0IHNvbWV0aGluZ1xuXHQgKiBvdGhlciB0aGFuIHRoZSB0aWNrIGlzIHVzaW5nIH44MG1zIChhbm90aGVyIHNjcmlwdCwgRE9NIHJlbmRlcmluZywgZXRjKS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFRpY2tUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aWNrc10gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2suXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC4gVG8gZ2V0IG9ubHkgdGhlIGxhc3QgdGljaydzIHRpbWUsIHBhc3MgaW4gMS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljayBpbiBtaWxsaXNlY29uZHMuXG5cdCAqKi9cblx0VGlja2VyLmdldE1lYXN1cmVkVGlja1RpbWUgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0dGw9MCwgdGltZXM9VGlja2VyLl90aWNrVGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAxKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGF2ZXJhZ2UgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aCwgdGlja3N8fChUaWNrZXIuZ2V0RlBTKCl8MCkpO1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aWNrczsgaSsrKSB7IHR0bCArPSB0aW1lc1tpXTsgfVxuXHRcdHJldHVybiB0dGwvdGlja3M7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkRlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aWNrc10gVGhlIG51bWJlciBvZiBwcmV2aW91cyB0aWNrcyBvdmVyIHdoaWNoIHRvIG1lYXN1cmUgdGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFjdHVhbCBmcmFtZXMgLyB0aWNrcyBwZXIgc2Vjb25kLiBEZXBlbmRpbmcgb24gcGVyZm9ybWFuY2UsIHRoaXMgbWF5IGRpZmZlclxuXHQgKiBmcm9tIHRoZSB0YXJnZXQgZnJhbWVzIHBlciBzZWNvbmQuXG5cdCAqKi9cblx0VGlja2VyLmdldE1lYXN1cmVkRlBTID0gZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgdGltZXMgPSBUaWNrZXIuX3RpbWVzO1xuXHRcdGlmICghdGltZXMgfHwgdGltZXMubGVuZ3RoIDwgMikgeyByZXR1cm4gLTE7IH1cblxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBmcHMgZm9yIHRoZSBwYXN0IH4xIHNlY29uZDpcblx0XHR0aWNrcyA9IE1hdGgubWluKHRpbWVzLmxlbmd0aC0xLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0cmV0dXJuIDEwMDAvKCh0aW1lc1swXS10aW1lc1t0aWNrc10pL3RpY2tzKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0VGlja2VyLnBhdXNlZCA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRQYXVzZWQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdHJldHVybiBUaWNrZXIucGF1c2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgdmlhIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbml0XCJ9fS5cblx0ICogUmV0dXJucyAtMSBpZiBUaWNrZXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHVzZVxuXHQgKiB0aGlzIGluIGEgdGltZSBzeW5jaHJvbml6ZWQgYW5pbWF0aW9uIHRvIGRldGVybWluZSB0aGUgZXhhY3QgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgZWxhcHNlZC5cblx0ICogQG1ldGhvZCBnZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcnVuVGltZT1mYWxzZV0gSWYgdHJ1ZSBvbmx5IHRpbWUgZWxhcHNlZCB3aGlsZSBUaWNrZXIgd2FzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRoZSB2YWx1ZSByZXR1cm5lZCB3aWxsIGJlIHRvdGFsIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZmlyc3QgdGljayBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIG9yIC0xLlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IFRpY2tlci5fZ2V0VGltZSgpIC0gKHJ1blRpbWUgPyBUaWNrZXIuX3BhdXNlZFRpbWUgOiAwKSA6IC0xO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGJ1dCByZXR1cm5zIHRoZSB0aW1lIG9uIHRoZSBtb3N0IHJlY2VudCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QuXG5cdCAqIEBtZXRob2QgZ2V0RXZlbnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHJ1blRpbWUge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlLCB0aGUgcnVuVGltZSBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGltZS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb3IgcnVuVGltZSBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9yIC0xLlxuXHQgKi9cblx0VGlja2VyLmdldEV2ZW50VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyAoVGlja2VyLl9sYXN0VGltZSB8fCBUaWNrZXIuX3N0YXJ0VGltZSkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgZ2V0VGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRpY2tzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdFxuXHQgKiB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZC4gSWYgdHJ1ZSBvbmx5IHRpY2sgZXZlbnRzIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgaXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGljayBldmVudHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0IHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVyblxuXHQgKiB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaWNrcyA9IGZ1bmN0aW9uKHBhdXNlYWJsZSkge1xuXHRcdHJldHVybiAgVGlja2VyLl90aWNrcyAtIChwYXVzZWFibGUgPyBUaWNrZXIuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN5bmNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlU3luY2ggPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cblx0XHQvLyBydW4gaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQsIHdpdGggYSBsaXR0bGUgYml0IG9mIGZsZXhpYmlsaXR5IHRvIGJlIGVhcmx5OlxuXHRcdGlmIChUaWNrZXIuX2dldFRpbWUoKSAtIFRpY2tlci5fbGFzdFRpbWUgPj0gKFRpY2tlci5faW50ZXJ2YWwtMSkqMC45Nykge1xuXHRcdFx0VGlja2VyLl90aWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVSQUYgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cFRpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zZXR1cFRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl90aW1lcklkICE9IG51bGwpIHsgcmV0dXJuOyB9IC8vIGF2b2lkIGR1cGxpY2F0ZXNcblxuXHRcdHZhciBtb2RlID0gVGlja2VyLnRpbWluZ01vZGV8fChUaWNrZXIudXNlUkFGJiZUaWNrZXIuUkFGX1NZTkNIRUQpO1xuXHRcdGlmIChtb2RlID09IFRpY2tlci5SQUZfU1lOQ0hFRCB8fCBtb2RlID09IFRpY2tlci5SQUYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0VGlja2VyLl90aW1lcklkID0gZihtb2RlID09IFRpY2tlci5SQUYgPyBUaWNrZXIuX2hhbmRsZVJBRiA6IFRpY2tlci5faGFuZGxlU3luY2gpO1xuXHRcdFx0XHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0VGlja2VyLl9yYWYgPSBmYWxzZTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBzZXRUaW1lb3V0KFRpY2tlci5faGFuZGxlVGltZW91dCwgVGlja2VyLl9pbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdXNlZCA9IFRpY2tlci5wYXVzZWQ7XG5cdFx0dmFyIHRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHR2YXIgZWxhcHNlZFRpbWUgPSB0aW1lLVRpY2tlci5fbGFzdFRpbWU7XG5cdFx0VGlja2VyLl9sYXN0VGltZSA9IHRpbWU7XG5cdFx0VGlja2VyLl90aWNrcysrO1xuXHRcdFxuXHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdFRpY2tlci5fcGF1c2VkVGlja3MrKztcblx0XHRcdFRpY2tlci5fcGF1c2VkVGltZSArPSBlbGFwc2VkVGltZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKFRpY2tlci5oYXNFdmVudExpc3RlbmVyKFwidGlja1wiKSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwidGlja1wiKTtcblx0XHRcdHZhciBtYXhEZWx0YSA9IFRpY2tlci5tYXhEZWx0YTtcblx0XHRcdGV2ZW50LmRlbHRhID0gKG1heERlbHRhICYmIGVsYXBzZWRUaW1lID4gbWF4RGVsdGEpID8gbWF4RGVsdGEgOiBlbGFwc2VkVGltZTtcblx0XHRcdGV2ZW50LnBhdXNlZCA9IHBhdXNlZDtcblx0XHRcdGV2ZW50LnRpbWUgPSB0aW1lO1xuXHRcdFx0ZXZlbnQucnVuVGltZSA9IHRpbWUtVGlja2VyLl9wYXVzZWRUaW1lO1xuXHRcdFx0VGlja2VyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRcblx0XHRUaWNrZXIuX3RpY2tUaW1lcy51bnNoaWZ0KFRpY2tlci5fZ2V0VGltZSgpLXRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpY2tUaW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aWNrVGltZXMucG9wKCk7IH1cblxuXHRcdFRpY2tlci5fdGltZXMudW5zaGlmdCh0aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aW1lcy5wb3AoKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgKHBlcmZvcm1hbmNlLm5vdyB8fCBwZXJmb3JtYW5jZS5tb3pOb3cgfHwgcGVyZm9ybWFuY2UubXNOb3cgfHwgcGVyZm9ybWFuY2Uub05vdyB8fCBwZXJmb3JtYW5jZS53ZWJraXROb3cpO1xuXHRUaWNrZXIuX2dldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKChub3cmJm5vdy5jYWxsKHBlcmZvcm1hbmNlKSl8fChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC0gVGlja2VyLl9zdGFydFRpbWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UaWNrZXIgPSBUaWNrZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVUlELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogR2xvYmFsIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgc2VxdWVudGlhbCB1bmlxdWUgSUQgbnVtYmVycy4gVGhlIFVJRCBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIDxjb2RlPlVJRC5nZXQoKTwvY29kZT4pXG5cdCAqIGFuZCBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICogQGNsYXNzIFVJRFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gVUlEKCkge1xuXHRcdHRocm93IFwiVUlEIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX25leHRJRFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFVJRC5fbmV4dElEID0gMDtcblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBpZC5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFVJRC5nZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVUlELl9uZXh0SUQrKztcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlVJRCA9IFVJRDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3VzZUV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUGFzc2VkIGFzIHRoZSBwYXJhbWV0ZXIgdG8gYWxsIG1vdXNlL3BvaW50ZXIvdG91Y2ggcmVsYXRlZCBldmVudHMuIEZvciBhIGxpc3Rpbmcgb2YgbW91c2UgZXZlbnRzIGFuZCB0aGVpciBwcm9wZXJ0aWVzLFxuXHQgKiBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGxpc3RpbmdzLlxuXHQgKiBAY2xhc3MgTW91c2VFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VYIFRoZSBub3JtYWxpemVkIHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VZIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG5hdGl2ZUV2ZW50IFRoZSBuYXRpdmUgRE9NIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBtb3VzZSBldmVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJRCBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmltYXJ5IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdYIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdZIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gcmVsYXRlZFRhcmdldCBUaGUgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LlxuXHQgKiBAZXh0ZW5kcyBFdmVudFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHN0YWdlWCwgc3RhZ2VZLCBuYXRpdmVFdmVudCwgcG9pbnRlcklELCBwcmltYXJ5LCByYXdYLCByYXdZLCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMuc3RhZ2VYID0gc3RhZ2VYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB5IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2UgaGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5zdGFnZVkgPSBzdGFnZVk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VYIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdYID0gKHJhd1g9PW51bGwpP3N0YWdlWDpyYXdYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHN0YWdlWSB2YWx1ZSwgdW5sZXNzXG5cdFx0ICogc3RhZ2UubW91c2VNb3ZlT3V0c2lkZSBpcyB0cnVlIGFuZCB0aGUgcG9pbnRlciBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBib3VuZHMuXG5cdFx0ICogQHByb3BlcnR5IHJhd1lcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMucmF3WSA9IChyYXdZPT1udWxsKT9zdGFnZVk6cmF3WTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBNb3VzZUV2ZW50IGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHByb3BlcnRpZXMgYW5kIEFQSSBmb3IgdGhpc1xuXHRcdCAqIGV2ZW50IG1heSBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIG51bGwgaWYgdGhlXG5cdFx0ICogRWFzZWxKUyBwcm9wZXJ0eSB3YXMgbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBmcm9tIGEgbmF0aXZlIE1vdXNlRXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IG5hdGl2ZUV2ZW50XG5cdFx0ICogQHR5cGUgSHRtbE1vdXNlRXZlbnRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIgKHRvdWNoIHBvaW50IG9yIGN1cnNvcikuIFRoaXMgd2lsbCBiZSBlaXRoZXIgLTEgZm9yIHRoZSBtb3VzZSwgb3IgdGhlIHN5c3RlbVxuXHRcdCAqIHN1cHBsaWVkIGlkIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwb2ludGVySURcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucG9pbnRlcklEID0gcG9pbnRlcklEO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LiBUaGlzIHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIHRoZSBtb3VzZS5cblx0XHQgKiBGb3IgdG91Y2ggcG9pbnRlcnMsIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBjdXJyZW50IHN0YWNrIHdpbGwgYmUgY29uc2lkZXJlZCB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmltYXJ5XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wcmltYXJ5ID0gISFwcmltYXJ5O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIGlmIGFwcGxpY2FibGUuIFRoaXMgaXMgdXNlZCBmb3IgbW91c2VvdXQvcm9sbG91dFxuXHRcdCAqIGV2ZW50cyB0byBpbmRpY2F0ZSB0aGUgb2JqZWN0IHRoYXQgdGhlIG1vdXNlIGVudGVyZWQgZnJvbSwgbW91c2VvdmVyL3JvbGxvdmVyIGZvciB0aGUgb2JqZWN0IHRoZSBtb3VzZSBleGl0ZWQsXG5cdFx0ICogYW5kIHN0YWdlbW91c2Vkb3duL3N0YWdlbW91c2V1cCBldmVudHMgZm9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhlIHVuZGVyIHRoZSBjdXJzb3IsIGlmIGFueS5cblx0XHQgKiBcblx0XHQgKiBPbmx5IHZhbGlkIGludGVyYWN0aW9uIHRhcmdldHMgd2lsbCBiZSByZXR1cm5lZCAoaWUuIG9iamVjdHMgd2l0aCBtb3VzZSBsaXN0ZW5lcnMgb3IgYSBjdXJzb3Igc2V0KS5cblx0XHQgKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW91c2VFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLng7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLnk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgYSB0b3VjaCBpbnB1dCAodmVyc3VzIGEgbW91c2UgaW5wdXQpLlxuXHQgKiBAcHJvcGVydHkgaXNUb3VjaFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfaXNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJJRCAhPT0gLTE7XG5cdH07XG5cdFxuXHRcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRsb2NhbFg6IHsgZ2V0OiBwLl9nZXRfbG9jYWxYIH0sXG5cdFx0XHRsb2NhbFk6IHsgZ2V0OiBwLl9nZXRfbG9jYWxZIH0sXG5cdFx0XHRpc1RvdWNoOiB7IGdldDogcC5fZ2V0X2lzVG91Y2ggfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1vdXNlRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TW91c2VFdmVudH0gYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUsIHRoaXMuc3RhZ2VYLCB0aGlzLnN0YWdlWSwgdGhpcy5uYXRpdmVFdmVudCwgdGhpcy5wb2ludGVySUQsIHRoaXMucHJpbWFyeSwgdGhpcy5yYXdYLCB0aGlzLnJhd1kpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTW91c2VFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIgc3RhZ2VYPVwiK3RoaXMuc3RhZ2VYK1wiIHN0YWdlWT1cIit0aGlzLnN0YWdlWStcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Nb3VzZUV2ZW50ID0gY3JlYXRlanMucHJvbW90ZShNb3VzZUV2ZW50LCBcIkV2ZW50XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hdHJpeDJELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LCBhbmQgcHJvdmlkZXMgdG9vbHMgZm9yIGNvbnN0cnVjdGluZyBhbmQgY29uY2F0ZW5hdGluZyBtYXRyaWNlcy5cblx0ICpcblx0ICogVGhpcyBtYXRyaXggY2FuIGJlIHZpc3VhbGl6ZWQgYXM6XG5cdCAqXG5cdCAqIFx0WyBhICBjICB0eFxuXHQgKiBcdCAgYiAgZCAgdHlcblx0ICogXHQgIDAgIDAgIDEgIF1cblx0ICpcblx0ICogTm90ZSB0aGUgbG9jYXRpb25zIG9mIGIgYW5kIGMuXG5cdCAqXG5cdCAqIEBjbGFzcyBNYXRyaXgyRFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2E9MV0gU3BlY2lmaWVzIHRoZSBhIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIFNwZWNpZmllcyB0aGUgYiBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYz0wXSBTcGVjaWZpZXMgdGhlIGMgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2Q9MV0gU3BlY2lmaWVzIHRoZSBkIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eD0wXSBTcGVjaWZpZXMgdGhlIHR4IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eT0wXSBTcGVjaWZpZXMgdGhlIHR5IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTWF0cml4MkQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoYSxiLGMsZCx0eCx0eSk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBhXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMCwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgYlxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDEsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGNcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMiwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgdHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogTXVsdGlwbGllciBmb3IgY29udmVydGluZyBkZWdyZWVzIHRvIHJhZGlhbnMuIFVzZWQgaW50ZXJuYWxseSBieSBNYXRyaXgyRC5cblx0ICogQHByb3BlcnR5IERFR19UT19SQURcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1hdHJpeDJELkRFR19UT19SQUQgPSBNYXRoLlBJLzE4MDtcblxuXG4vLyBzdGF0aWMgcHVibGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBBbiBpZGVudGl0eSBtYXRyaXgsIHJlcHJlc2VudGluZyBhIG51bGwgdHJhbnNmb3JtYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBpZGVudGl0eVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIE1hdHJpeDJEXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1hdHJpeDJELmlkZW50aXR5ID0gbnVsbDsgLy8gc2V0IGF0IGJvdHRvbSBvZiBjbGFzcyBkZWZpbml0aW9uLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuIFxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW2E9MV0gU3BlY2lmaWVzIHRoZSBhIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIFNwZWNpZmllcyB0aGUgYiBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYz0wXSBTcGVjaWZpZXMgdGhlIGMgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2Q9MV0gU3BlY2lmaWVzIHRoZSBkIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eD0wXSBTcGVjaWZpZXMgdGhlIHR4IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0eT0wXSBTcGVjaWZpZXMgdGhlIHR5IHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgZG9jcyBpbiB0aGUgY29uc3RydWN0b3IgaWYgdGhlc2UgY2hhbmdlOlxuXHRcdHRoaXMuYSA9IChhID09IG51bGwpID8gMSA6IGE7XG5cdFx0dGhpcy5iID0gYiB8fCAwO1xuXHRcdHRoaXMuYyA9IGMgfHwgMDtcblx0XHR0aGlzLmQgPSAoZCA9PSBudWxsKSA/IDEgOiBkO1xuXHRcdHRoaXMudHggPSB0eCB8fCAwO1xuXHRcdHRoaXMudHkgPSB0eSB8fCAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHByb3BlcnRpZXMgdG8gdGhpcyBtYXRyaXguIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHRoaXMgbWF0cml4KSAqIChzcGVjaWZpZWQgbWF0cml4KWAuXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciBkMSA9IHRoaXMuZDtcblx0XHRpZiAoYSAhPSAxIHx8IGIgIT0gMCB8fCBjICE9IDAgfHwgZCAhPSAxKSB7XG5cdFx0XHR0aGlzLmEgID0gYTEqYStjMSpiO1xuXHRcdFx0dGhpcy5iICA9IGIxKmErZDEqYjtcblx0XHRcdHRoaXMuYyAgPSBhMSpjK2MxKmQ7XG5cdFx0XHR0aGlzLmQgID0gYjEqYytkMSpkO1xuXHRcdH1cblx0XHR0aGlzLnR4ID0gYTEqdHgrYzEqdHkrdGhpcy50eDtcblx0XHR0aGlzLnR5ID0gYjEqdHgrZDEqdHkrdGhpcy50eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cblx0ICogQG1ldGhvZCBwcmVwZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciB0eDEgPSB0aGlzLnR4O1xuXG5cdFx0dGhpcy5hICA9IGEqYTErYyp0aGlzLmI7XG5cdFx0dGhpcy5iICA9IGIqYTErZCp0aGlzLmI7XG5cdFx0dGhpcy5jICA9IGEqYzErYyp0aGlzLmQ7XG5cdFx0dGhpcy5kICA9IGIqYzErZCp0aGlzLmQ7XG5cdFx0dGhpcy50eCA9IGEqdHgxK2MqdGhpcy50eSt0eDtcblx0XHR0aGlzLnR5ID0gYip0eDErZCp0aGlzLnR5K3R5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAodGhpcyBtYXRyaXgpICogKHNwZWNpZmllZCBtYXRyaXgpYC5cblx0ICogQG1ldGhvZCBhcHBlbmRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUHJlcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYChzcGVjaWZpZWQgbWF0cml4KSAqICh0aGlzIG1hdHJpeClgLlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNhbGN1bGF0ZSB0aGUgY29tYmluZWQgdHJhbnNmb3JtYXRpb24gZm9yIGEgY2hpbGQgb2JqZWN0IHVzaW5nOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgbXR4ID0gby5nZXRNYXRyaXgoKTtcblx0ICogXHR3aGlsZSAobyA9IG8ucGFyZW50KSB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHRcdG8ucHJlcGVuZE1hdHJpeChvLmdldE1hdHJpeCgpKTtcblx0ICogXHR9XG5cdCAqIEBtZXRob2QgcHJlcGVuZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmVwZW5kKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBhcHBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB0aGlzIHRvIGdlbmVyYXRlIGEgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb25zIG9mIGEgZGlzcGxheSBvYmplY3Q6XG5cdCAqIFxuXHQgKiBcdHZhciBtdHggPSBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0ICogXHRtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24pO1xuXHQgKiBAbWV0aG9kIGFwcGVuZFRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1lcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1ggT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdZIE9wdGlvbmFsLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kVHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHRpZiAocm90YXRpb24lMzYwKSB7XG5cdFx0XHR2YXIgciA9IHJvdGF0aW9uKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3Mocik7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4ocik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvcyA9IDE7XG5cdFx0XHRzaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChza2V3WCB8fCBza2V3WSkge1xuXHRcdFx0Ly8gVE9ETzogY2FuIHRoaXMgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBhcHBlbmQgb3BlcmF0aW9uP1xuXHRcdFx0c2tld1ggKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcblx0XHRcdHRoaXMuYXBwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCAwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hcHBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIHgsIHkpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAocmVnWCB8fCByZWdZKSB7XG5cdFx0XHQvLyBhcHBlbmQgdGhlIHJlZ2lzdHJhdGlvbiBvZmZzZXQ6XG5cdFx0XHR0aGlzLnR4IC09IHJlZ1gqdGhpcy5hK3JlZ1kqdGhpcy5jOyBcblx0XHRcdHRoaXMudHkgLT0gcmVnWCp0aGlzLmIrcmVnWSp0aGlzLmQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbWF0cml4IHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCBhbmQgcHJlcGVuZHMgdGhlbSB0byB0aGlzIG1hdHJpeC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBjYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybWF0aW9uIGZvciBhIGNoaWxkIG9iamVjdCB1c2luZzpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIG10eCA9IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHQgKiBcdGRvICB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgdHJhbnNmb3JtYXRpb24gaW4gdHVybjpcblx0ICogXHRcdG10eC5wcmVwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcblx0ICogXHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHQgKiBcdFxuXHQgKiBcdE5vdGUgdGhhdCB0aGUgYWJvdmUgZXhhbXBsZSB3b3VsZCBub3QgYWNjb3VudCBmb3Ige3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC90cmFuc2Zvcm1NYXRyaXg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogXHR2YWx1ZXMuIFNlZSB7eyNjcm9zc0xpbmsgXCJNYXRyaXgyRC9wcmVwZW5kTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIHRoYXQgZG9lcy5cblx0ICogQG1ldGhvZCBwcmVwZW5kVHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWCBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1kgT3B0aW9uYWwuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kVHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcblx0XHRpZiAocm90YXRpb24lMzYwKSB7XG5cdFx0XHR2YXIgciA9IHJvdGF0aW9uKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3Mocik7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4ocik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvcyA9IDE7XG5cdFx0XHRzaW4gPSAwO1xuXHRcdH1cblxuXHRcdGlmIChyZWdYIHx8IHJlZ1kpIHtcblx0XHRcdC8vIHByZXBlbmQgdGhlIHJlZ2lzdHJhdGlvbiBvZmZzZXQ6XG5cdFx0XHR0aGlzLnR4IC09IHJlZ1g7IHRoaXMudHkgLT0gcmVnWTtcblx0XHR9XG5cdFx0aWYgKHNrZXdYIHx8IHNrZXdZKSB7XG5cdFx0XHQvLyBUT0RPOiBjYW4gdGhpcyBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHByZXBlbmQgb3BlcmF0aW9uP1xuXHRcdFx0c2tld1ggKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0aGlzLnByZXBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIDAsIDApO1xuXHRcdFx0dGhpcy5wcmVwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnByZXBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIHgsIHkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIGNsb2Nrd2lzZSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHJvdGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgaW4gZGVncmVlcy4gVG8gdXNlIGEgdmFsdWUgaW4gcmFkaWFucywgbXVsdGlwbHkgaXQgYnkgYDE4MC9NYXRoLlBJYC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0YW5nbGUgPSBhbmdsZSpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cblx0XHR0aGlzLmEgPSBhMSpjb3MrdGhpcy5jKnNpbjtcblx0XHR0aGlzLmIgPSBiMSpjb3MrdGhpcy5kKnNpbjtcblx0XHR0aGlzLmMgPSAtYTEqc2luK3RoaXMuYypjb3M7XG5cdFx0dGhpcy5kID0gLWIxKnNpbit0aGlzLmQqY29zO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgc2tldyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHNrZXdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYIFRoZSBhbW91bnQgdG8gc2tldyBob3Jpem9udGFsbHkgaW4gZGVncmVlcy4gVG8gdXNlIGEgdmFsdWUgaW4gcmFkaWFucywgbXVsdGlwbHkgaXQgYnkgYDE4MC9NYXRoLlBJYC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZIFRoZSBhbW91bnQgdG8gc2tldyB2ZXJ0aWNhbGx5IGluIGRlZ3JlZXMuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuc2tldyA9IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuXHRcdHNrZXdYID0gc2tld1gqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRza2V3WSA9IHNrZXdZKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgMCwgMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHNjYWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5LiBFLkcuIGEgdmFsdWUgb2YgMiB3aWxsIGRvdWJsZSB0aGUgc2l6ZSBpbiB0aGUgWCBkaXJlY3Rpb24sIGFuZCAwLjUgd2lsbCBoYWx2ZSBpdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuc2NhbGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy5hICo9IHg7XG5cdFx0dGhpcy5iICo9IHg7XG5cdFx0dGhpcy5jICo9IHk7XG5cdFx0dGhpcy5kICo9IHk7XG5cdFx0Ly90aGlzLnR4ICo9IHg7XG5cdFx0Ly90aGlzLnR5ICo9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZXMgdGhlIG1hdHJpeCBvbiB0aGUgeCBhbmQgeSBheGVzLlxuXHQgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMudHggKz0gdGhpcy5hKnggKyB0aGlzLmMqeTtcblx0XHR0aGlzLnR5ICs9IHRoaXMuYip4ICsgdGhpcy5kKnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG1hdHJpeCB0byB0aG9zZSBvZiBhbiBpZGVudGl0eSBtYXRyaXggKG9uZSB0aGF0IGFwcGxpZXMgYSBudWxsIHRyYW5zZm9ybWF0aW9uKS5cblx0ICogQG1ldGhvZCBpZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmEgPSB0aGlzLmQgPSAxO1xuXHRcdHRoaXMuYiA9IHRoaXMuYyA9IHRoaXMudHggPSB0aGlzLnR5ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogSW52ZXJ0cyB0aGUgbWF0cml4LCBjYXVzaW5nIGl0IHRvIHBlcmZvcm0gdGhlIG9wcG9zaXRlIHRyYW5zZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGludmVydFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIGQxID0gdGhpcy5kO1xuXHRcdHZhciB0eDEgPSB0aGlzLnR4O1xuXHRcdHZhciBuID0gYTEqZDEtYjEqYzE7XG5cblx0XHR0aGlzLmEgPSBkMS9uO1xuXHRcdHRoaXMuYiA9IC1iMS9uO1xuXHRcdHRoaXMuYyA9IC1jMS9uO1xuXHRcdHRoaXMuZCA9IGExL247XG5cdFx0dGhpcy50eCA9IChjMSp0aGlzLnR5LWQxKnR4MSkvbjtcblx0XHR0aGlzLnR5ID0gLShhMSp0aGlzLnR5LWIxKnR4MSkvbjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXRyaXggaXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGlzSWRlbnRpdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmlzSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50eCA9PT0gMCAmJiB0aGlzLnR5ID09PSAwICYmIHRoaXMuYSA9PT0gMSAmJiB0aGlzLmIgPT09IDAgJiYgdGhpcy5jID09PSAwICYmIHRoaXMuZCA9PT0gMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBtYXRyaXggaXMgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtYXRyaXggKGFsbCBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGVxdWFsKS5cblx0ICogQG1ldGhvZCBlcXVhbHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmVxdWFscyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnR4ID09PSBtYXRyaXgudHggJiYgdGhpcy50eSA9PT0gbWF0cml4LnR5ICYmIHRoaXMuYSA9PT0gbWF0cml4LmEgJiYgdGhpcy5iID09PSBtYXRyaXguYiAmJiB0aGlzLmMgPT09IG1hdHJpeC5jICYmIHRoaXMuZCA9PT0gbWF0cml4LmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgYSBwb2ludCBhY2NvcmRpbmcgdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBtZXRob2QgdHJhbnNmb3JtUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgcG9pbnQgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIGdlbmVyaWMgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcblx0XHRwdCA9IHB0fHx7fTtcblx0XHRwdC54ID0geCp0aGlzLmEreSp0aGlzLmMrdGhpcy50eDtcblx0XHRwdC55ID0geCp0aGlzLmIreSp0aGlzLmQrdGhpcy50eTtcblx0XHRyZXR1cm4gcHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKS4gTm90ZSB0aGF0IHRoZXNlIHZhbHVlc1xuXHQgKiBtYXkgbm90IG1hdGNoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB5b3UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWF0cml4LCB0aG91Z2ggdGhleSB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgdmlzdWFsXG5cdCAqIHJlc3VsdHMuXG5cdCAqIEBtZXRob2QgZGVjb21wb3NlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgdG8uIElmIG51bGwsIHRoZW4gYSBuZXcgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCwgb3IgYSBuZXcgZ2VuZXJpYyBvYmplY3Qgd2l0aCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgYXBwbGllZC5cblx0Ki9cblx0cC5kZWNvbXBvc2UgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGJlIGFibGUgdG8gc29sdmUgZm9yIHdoZXRoZXIgdGhlIG1hdHJpeCBjYW4gYmUgZGVjb21wb3NlZCBpbnRvIG9ubHkgc2NhbGUvcm90YXRpb24gZXZlbiB3aGVuIHNjYWxlIGlzIG5lZ2F0aXZlXG5cdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHRhcmdldCA9IHt9OyB9XG5cdFx0dGFyZ2V0LnggPSB0aGlzLnR4O1xuXHRcdHRhcmdldC55ID0gdGhpcy50eTtcblx0XHR0YXJnZXQuc2NhbGVYID0gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYik7XG5cdFx0dGFyZ2V0LnNjYWxlWSA9IE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpO1xuXG5cdFx0dmFyIHNrZXdYID0gTWF0aC5hdGFuMigtdGhpcy5jLCB0aGlzLmQpO1xuXHRcdHZhciBza2V3WSA9IE1hdGguYXRhbjIodGhpcy5iLCB0aGlzLmEpO1xuXG5cdFx0dmFyIGRlbHRhID0gTWF0aC5hYnMoMS1za2V3WC9za2V3WSk7XG5cdFx0aWYgKGRlbHRhIDwgMC4wMDAwMSkgeyAvLyBlZmZlY3RpdmVseSBpZGVudGljYWwsIGNhbiB1c2Ugcm90YXRpb246XG5cdFx0XHR0YXJnZXQucm90YXRpb24gPSBza2V3WS9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0aWYgKHRoaXMuYSA8IDAgJiYgdGhpcy5kID49IDApIHtcblx0XHRcdFx0dGFyZ2V0LnJvdGF0aW9uICs9ICh0YXJnZXQucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0LnNrZXdYID0gdGFyZ2V0LnNrZXdZID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LnNrZXdYID0gc2tld1gvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRhcmdldC5za2V3WSA9IHNrZXdZL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggVGhlIG1hdHJpeCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TWF0cml4MkR9IGEgY2xvbmUgb2YgdGhlIE1hdHJpeDJEIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy50eCwgdGhpcy50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltNYXRyaXgyRCAoYT1cIit0aGlzLmErXCIgYj1cIit0aGlzLmIrXCIgYz1cIit0aGlzLmMrXCIgZD1cIit0aGlzLmQrXCIgdHg9XCIrdGhpcy50eCtcIiB0eT1cIit0aGlzLnR5K1wiKV1cIjtcblx0fTtcblxuXHQvLyB0aGlzIGhhcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXIgdGhlIGNsYXNzIGlzIGRlZmluZWQ6XG5cdE1hdHJpeDJELmlkZW50aXR5ID0gbmV3IE1hdHJpeDJEKCk7XG5cblxuXHRjcmVhdGVqcy5NYXRyaXgyRCA9IE1hdHJpeDJEO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERpc3BsYXlQcm9wcy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVXNlZCBmb3IgY2FsY3VsYXRpbmcgYW5kIGVuY2Fwc3VsYXRpbmcgZGlzcGxheSByZWxhdGVkIHByb3BlcnRpZXMuXG5cdCAqIEBjbGFzcyBEaXNwbGF5UHJvcHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2aXNpYmxlPXRydWVdIFZpc2libGUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGE9MV0gQWxwaGEgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2hhZG93PW51bGxdIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9zaXRlT3BlcmF0aW9uPW51bGxdIEEgY29tcG9zaXRlT3BlcmF0aW9uIHZhbHVlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF0cml4XSBBIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gRGVmYXVsdHMgdG8gYSBuZXcgaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBEaXNwbGF5UHJvcHModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgYWxwaGEgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgc2hhZG93IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHNoYWRvd1xuXHRcdCAqIEB0eXBlIFNoYWRvd1xuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBjb21wb3NpdGVPcGVyYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBZb3UgY2FuIGZpbmQgYSBsaXN0IG9mIHZhbGlkIGNvbXBvc2l0ZSBvcGVyYXRpb25zIGF0OlxuXHRcdCAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmdcIj5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmc8L2E+XG5cdFx0ICogQHByb3BlcnR5IGNvbXBvc2l0ZU9wZXJhdGlvblxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIGZvciB2aXNpYmxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHZpc2libGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdFx0ICogQHR5cGUgTWF0cml4MkRcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBEaXNwbGF5UHJvcHMucHJvdG90eXBlO1xuXG4vLyBpbml0aWFsaXphdGlvbjpcblx0LyoqXG5cdCAqIFJlaW5pdGlhbGl6ZXMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTFdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHZpc2libGUgPT0gbnVsbCA/IHRydWUgOiAhIXZpc2libGU7XG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhID09IG51bGwgPyAxIDogYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXggfHwgKHRoaXMubWF0cml4JiZ0aGlzLm1hdHJpeC5pZGVudGl0eSgpKSB8fCBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgY2hpbGQncyBwcm9wZXJ0aWVzIGl0cyBwYXJlbnQncy5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIGRlc2lyZWQgdmlzaWJsZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgZGVzaXJlZCBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93IGRlc2lyZWQgc2hhZG93IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gZGVzaXJlZCBjb21wb3NpdGUgb3BlcmF0aW9uIHZhbHVlXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIGEgTWF0cml4MkQgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHNoYWRvdyB8fCB0aGlzLnNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbiB8fCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LmFwcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgcGFyZW50J3MgcHJvcGVydGllcyB0byBhIGNoaWxkJ3MuXG5cdCAqIEZvciBleGFtcGxlLCB0byBnZXQgdGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBjaGlsZCwgeW91IGNvdWxkIHVzZTpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIHByb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHQgKiBcdGRvIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyBwcm9wcyBpbiB0dXJuOlxuXHQgKiBcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbiwgby5nZXRNYXRyaXgoKSk7XG5cdCAqIFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICogXHRcblx0ICogQG1ldGhvZCBwcmVwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5wcmVwZW5kID0gZnVuY3Rpb24odmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLmFscGhhICo9IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5zaGFkb3cgfHwgc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gfHwgY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB2aXNpYmxlO1xuXHRcdG1hdHJpeCYmdGhpcy5tYXRyaXgucHJlcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIGFuZCBpdHMgbWF0cml4IHRvIGRlZmF1bHQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFx0dGhpcy5zaGFkb3cgPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS4gQ2xvbmVzIHRoZSBhc3NvY2lhdGVkIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBEaXNwbGF5UHJvcHModGhpcy5hbHBoYSwgdGhpcy5zaGFkb3csIHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uLCB0aGlzLnZpc2libGUsIHRoaXMubWF0cml4LmNsb25lKCkpO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cblx0Y3JlYXRlanMuRGlzcGxheVByb3BzID0gRGlzcGxheVByb3BzO1xufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFBvaW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHBvaW50IG9uIGEgMiBkaW1lbnNpb25hbCB4IC8geSBjb29yZGluYXRlIHN5c3RlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBcblx0ICogICAgICB2YXIgcG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoMCwgMTAwKTtcblx0ICogXG5cdCAqIEBjbGFzcyBQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0IFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSk7XG5cdCBcdFxuXHQgXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFBvaW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHBvaW50IHRvIHRoaXMgcG9pbnQuXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIHBvaW50LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1BvaW50fSBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQb2ludCAoeD1cIit0aGlzLngrXCIgeT1cIit0aGlzLnkrXCIpXVwiO1xuXHR9O1xuXHRcblx0XG5cdGNyZWF0ZWpzLlBvaW50ID0gUG9pbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVjdGFuZ2xlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHJlY3RhbmdsZSBhcyBkZWZpbmVkIGJ5IHRoZSBwb2ludHMgKHgsIHkpIGFuZCAoeCt3aWR0aCwgeStoZWlnaHQpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogQGNsYXNzIFJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogV2lkdGguXG5cdFx0ICogQHByb3BlcnR5IHdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBIZWlnaHQuXG5cdFx0ICogQHByb3BlcnR5IGhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy54ID0geHx8MDtcblx0XHR0aGlzLnkgPSB5fHwwO1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aHx8MDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKiBcblx0ICogRXh0ZW5kcyB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzIHRvIGluY2x1ZGUgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgZXh0ZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5leHRlbmQgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0d2lkdGggPSB3aWR0aHx8MDtcblx0XHRoZWlnaHQgPSBoZWlnaHR8fDA7XG5cdFx0aWYgKHgrd2lkdGggPiB0aGlzLngrdGhpcy53aWR0aCkgeyB0aGlzLndpZHRoID0geCt3aWR0aC10aGlzLng7IH1cblx0XHRpZiAoeStoZWlnaHQgPiB0aGlzLnkrdGhpcy5oZWlnaHQpIHsgdGhpcy5oZWlnaHQgPSB5K2hlaWdodC10aGlzLnk7IH1cblx0XHRpZiAoeCA8IHRoaXMueCkgeyB0aGlzLndpZHRoICs9IHRoaXMueC14OyB0aGlzLnggPSB4OyB9XG5cdFx0aWYgKHkgPCB0aGlzLnkpIHsgdGhpcy5oZWlnaHQgKz0gdGhpcy55LXk7IHRoaXMueSA9IHk7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKiBcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIHBhZGRpbmcgdG8gdGhlIHJlY3RhbmdsZSdzIGJvdW5kcy5cblx0ICogQG1ldGhvZCBwYWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucGFkID0gZnVuY3Rpb24odG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0KSB7XG5cdFx0dGhpcy54IC09IGxlZnQ7XG5cdFx0dGhpcy55IC09IHRvcDtcblx0XHR0aGlzLndpZHRoICs9IGxlZnQrcmlnaHQ7XG5cdFx0dGhpcy5oZWlnaHQgKz0gdG9wK2JvdHRvbTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSB0byB0aGlzIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIHJlY3RhbmdsZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGVuY2xvc2VzIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvbnRhaW5zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cblx0Ki9cblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gKHggPj0gdGhpcy54ICYmIHgrd2lkdGggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeStoZWlnaHQgPD0gdGhpcy55K3RoaXMuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggY29udGFpbnMgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIHVuaW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGEgdW5pb24gd2l0aC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgdW5pb24uXG5cdCovXG5cdHAudW5pb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5leHRlbmQocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIHRoZSBpbnRlcnNlY3Rpb24gKG92ZXJsYXApIG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSxcblx0ICogb3IgbnVsbCBpZiB0aGV5IGRvIG5vdCBpbnRlcnNlY3QuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0aW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGFuIGludGVyc2VjdGlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBpbnRlcnNlY3Rpb24gb3IgbnVsbC5cblx0Ki9cblx0cC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MStyZWN0LndpZHRoLCB5MiA9IHkxK3JlY3QuaGVpZ2h0O1xuXHRcdGlmICh0aGlzLnggPiB4MSkgeyB4MSA9IHRoaXMueDsgfVxuXHRcdGlmICh0aGlzLnkgPiB5MSkgeyB5MSA9IHRoaXMueTsgfVxuXHRcdGlmICh0aGlzLnggKyB0aGlzLndpZHRoIDwgeDIpIHsgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoOyB9XG5cdFx0aWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgeTIpIHsgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxuXHRcdHJldHVybiAoeDIgPD0geDEgfHwgeTIgPD0geTEpID8gbnVsbCA6IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4Mi14MSwgeTIteTEpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgaW50ZXJzZWN0cyAoaGFzIGFueSBvdmVybGFwKSB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGludGVyc2VjdHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdC5cblx0Ki9cblx0cC5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiAocmVjdC54IDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHRoaXMueCA8PSByZWN0LngrcmVjdC53aWR0aCAmJiByZWN0LnkgPD0gdGhpcy55K3RoaXMuaGVpZ2h0ICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGFyZSBlcXVhbCBvciBsZXNzIHRoYW4gMC5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBlbXB0eS5cblx0Ki9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUmVjdGFuZ2xlICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIiB3aWR0aD1cIit0aGlzLndpZHRoK1wiIGhlaWdodD1cIit0aGlzLmhlaWdodCtcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJ1dHRvbkhlbHBlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBCdXR0b25IZWxwZXIgaXMgYSBoZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGludGVyYWN0aXZlIGJ1dHRvbnMgZnJvbSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXBcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcy4gVGhpcyBjbGFzcyB3aWxsIGludGVyY2VwdCBtb3VzZSBldmVudHMgZnJvbSBhbiBvYmplY3QsIGFuZFxuXHQgKiBhdXRvbWF0aWNhbGx5IGNhbGwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogdG8gdGhlIHJlc3BlY3RpdmUgYW5pbWF0aW9uIGxhYmVscywgYWRkIGEgcG9pbnRlciBjdXJzb3IsIGFuZCBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIGEgaGl0IHN0YXRlIGZyYW1lLlxuXHQgKlxuXHQgKiBUaGUgQnV0dG9uSGVscGVyIGluc3RhbmNlIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIHN0YWdlLCBidXQgYSByZWZlcmVuY2Ugc2hvdWxkIGJlIG1haW50YWluZWQgdG8gcHJldmVudFxuXHQgKiBnYXJiYWdlIGNvbGxlY3Rpb24uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgb3ZlciBzdGF0ZXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGhlbHBlciA9IG5ldyBjcmVhdGVqcy5CdXR0b25IZWxwZXIobXlJbnN0YW5jZSwgXCJvdXRcIiwgXCJvdmVyXCIsIFwiZG93blwiLCBmYWxzZSwgbXlJbnN0YW5jZSwgXCJoaXRcIik7XG5cdCAqICAgICAgbXlJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIENsaWNrIEhhcHBlbmVkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIEJ1dHRvbkhlbHBlclxuXHQgKiBAcGFyYW0ge1Nwcml0ZXxNb3ZpZUNsaXB9IHRhcmdldCBUaGUgaW5zdGFuY2UgdG8gbWFuYWdlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW291dExhYmVsPVwib3V0XCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciByb2xscyBvdXQgb2YgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyTGFiZWw9XCJvdmVyXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciByb2xscyBvdmVyIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZG93bkxhYmVsPVwiZG93blwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwbGF5PWZhbHNlXSBJZiB0aGUgaGVscGVyIHNob3VsZCBjYWxsIFwiZ290b0FuZFBsYXlcIiBvciBcImdvdG9BbmRTdG9wXCIgb24gdGhlIGJ1dHRvbiB3aGVuIGNoYW5naW5nXG5cdCAqIHN0YXRlcy5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBbaGl0QXJlYV0gQW4gb3B0aW9uYWwgaXRlbSB0byB1c2UgYXMgdGhlIGhpdCBzdGF0ZSBmb3IgdGhlIGJ1dHRvbi4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCxcblx0ICogdGhlbiB0aGUgYnV0dG9uJ3MgdmlzaWJsZSBzdGF0ZXMgd2lsbCBiZSB1c2VkIGluc3RlYWQuIE5vdGUgdGhhdCB0aGUgc2FtZSBpbnN0YW5jZSBhcyB0aGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBjYW4gYmVcblx0ICogdXNlZCBmb3IgdGhlIGhpdFN0YXRlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2hpdExhYmVsXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIG9uIHRoZSBoaXRBcmVhIGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgaGl0QXJlYSBib3VuZHMuIElmIHRoaXMgaXNcblx0ICogbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgaGl0QXJlYSB3aWxsIGJlIHVzZWQuICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCdXR0b25IZWxwZXIodGFyZ2V0LCBvdXRMYWJlbCwgb3ZlckxhYmVsLCBkb3duTGFiZWwsIHBsYXksIGhpdEFyZWEsIGhpdExhYmVsKSB7XG5cdFx0aWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgeyByZXR1cm47IH1cblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGFyZ2V0IGZvciB0aGlzIGJ1dHRvbiBoZWxwZXIuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE1vdmllQ2xpcCB8IFNwcml0ZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBtb3VzZXMgb3V0IG9mIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwib3ZlclwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdmVyTGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdmVyTGFiZWwgPSBvdmVyTGFiZWwgPT0gbnVsbCA/IFwib3ZlclwiIDogb3ZlckxhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdmVyIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwib3V0XCIuXG5cdFx0ICogQHByb3BlcnR5IG91dExhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3V0TGFiZWwgPSBvdXRMYWJlbCA9PSBudWxsID8gXCJvdXRcIiA6IG91dExhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIHByZXNzZXMgb24gdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJkb3duXCIuXG5cdFx0ICogQHByb3BlcnR5IGRvd25MYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmRvd25MYWJlbCA9IGRvd25MYWJlbCA9PSBudWxsID8gXCJkb3duXCIgOiBkb3duTGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZW4gQnV0dG9uSGVscGVyIHdpbGwgY2FsbCBnb3RvQW5kUGxheSwgaWYgZmFsc2UsIGl0IHdpbGwgdXNlIGdvdG9BbmRTdG9wLiBEZWZhdWx0IGlzIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwbGF5XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMucGxheSA9IHBsYXk7XG5cdFx0XG5cdFx0XG5cdC8vICBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2lzUHJlc3NlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2lzUHJlc3NlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2lzT3ZlclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2lzT3ZlciA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2VuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0XG5cdC8vIHNldHVwOlxuXHRcdHRhcmdldC5tb3VzZUNoaWxkcmVuID0gZmFsc2U7IC8vIHByZXZlbnRzIGlzc3VlcyB3aGVuIGNoaWxkcmVuIGFyZSByZW1vdmVkIGZyb20gdGhlIGRpc3BsYXkgbGlzdCB3aGVuIHN0YXRlIGNoYW5nZXMuXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLmhhbmRsZUV2ZW50KHt9KTtcblx0XHRpZiAoaGl0QXJlYSkge1xuXHRcdFx0aWYgKGhpdExhYmVsKSB7XG5cdFx0XHRcdGhpdEFyZWEuYWN0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0aGl0QXJlYS5nb3RvQW5kU3RvcCYmaGl0QXJlYS5nb3RvQW5kU3RvcChoaXRMYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuaGl0QXJlYSA9IGhpdEFyZWE7XG5cdFx0fVxuXHR9XG5cdHZhciBwID0gQnV0dG9uSGVscGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25IZWxwZXIvZW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEVuYWJsZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0aWYgKHZhbHVlID09IHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzLnRhcmdldDtcblx0XHR0aGlzLl9lbmFibGVkID0gdmFsdWU7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRvLmN1cnNvciA9IFwicG9pbnRlclwiO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9yZXNldCkgeyBvLl9fcmVzZXQgPSBvLl9yZXNldDsgby5fcmVzZXQgPSB0aGlzLl9yZXNldDt9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8uY3Vyc29yID0gbnVsbDtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJvbGxvdmVyXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG91dFwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByZXNzdXBcIiwgdGhpcyk7XG5cdFx0XHRpZiAoby5fX3Jlc2V0KSB7IG8uX3Jlc2V0ID0gby5fX3Jlc2V0OyBkZWxldGUoby5fX3Jlc2V0KTsgfVxuXHRcdH1cblx0fTtcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uSGVscGVyL2VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRFbmFibGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRFbmFibGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJ1dHRvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSB0YXJnZXQuXG5cdCAqIEBwcm9wZXJ0eSBlbmFibGVkXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0ZW5hYmxlZDogeyBnZXQ6IHAuZ2V0RW5hYmxlZCwgc2V0OiBwLnNldEVuYWJsZWQgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQnV0dG9uSGVscGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dCBUaGUgbW91c2UgZXZlbnQgdG8gaGFuZGxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBsYWJlbCwgdCA9IHRoaXMudGFyZ2V0LCB0eXBlID0gZXZ0LnR5cGU7XG5cdFx0aWYgKHR5cGUgPT0gXCJtb3VzZWRvd25cIikge1xuXHRcdFx0dGhpcy5faXNQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdGxhYmVsID0gdGhpcy5kb3duTGFiZWw7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09IFwicHJlc3N1cFwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNPdmVyID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInJvbGxvdmVyXCIpIHtcblx0XHRcdHRoaXMuX2lzT3ZlciA9IHRydWU7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzUHJlc3NlZCA/IHRoaXMuZG93bkxhYmVsIDogdGhpcy5vdmVyTGFiZWw7XG5cdFx0fSBlbHNlIHsgLy8gcm9sbG91dCBhbmQgZGVmYXVsdFxuXHRcdFx0dGhpcy5faXNPdmVyID0gZmFsc2U7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzUHJlc3NlZCA/IHRoaXMub3ZlckxhYmVsIDogdGhpcy5vdXRMYWJlbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMucGxheSkge1xuXHRcdFx0dC5nb3RvQW5kUGxheSYmdC5nb3RvQW5kUGxheShsYWJlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQuZ290b0FuZFN0b3AmJnQuZ290b0FuZFN0b3AobGFiZWwpO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmplY3RlZCBpbnRvIHRhcmdldC4gUHJlc2VydmVzIHRoZSBwYXVzZWQgc3RhdGUgdGhyb3VnaCBhIHJlc2V0LlxuXHQgKiBAbWV0aG9kIF9yZXNldFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBleHBsb3JlIGJldHRlciB3YXlzIHRvIGhhbmRsZSB0aGlzIGlzc3VlLiBUaGlzIGlzIGhhY2t5ICYgZGlzcnVwdHMgb2JqZWN0IHNpZ25hdHVyZXMuXG5cdFx0dmFyIHAgPSB0aGlzLnBhdXNlZDtcblx0XHR0aGlzLl9fcmVzZXQoKTtcblx0XHR0aGlzLnBhdXNlZCA9IHA7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5CdXR0b25IZWxwZXIgPSBCdXR0b25IZWxwZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU2hhZG93LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gZGVmaW5lIGEgc2hhZG93IHRvIGFwcGx5IHRvIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB2aWEgaXRzIDxjb2RlPnNoYWRvdzwvY29kZT4gcHJvcGVydHkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUltYWdlLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjMDAwMDAwXCIsIDUsIDUsIDEwKTtcblx0ICpcblx0ICogQGNsYXNzIFNoYWRvd1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIFRoZSB5IG9mZnNldCBvZiB0aGUgc2hhZG93IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJsdXIgVGhlIHNpemUgb2YgdGhlIGJsdXJyaW5nIGVmZmVjdC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTaGFkb3coY29sb3IsIG9mZnNldFgsIG9mZnNldFksIGJsdXIpIHtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqIFxuXHRcdCAqIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb2xvclxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3J8fFwiYmxhY2tcIjtcblx0XG5cdFx0LyoqIFRoZSB4IG9mZnNldCBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0WCA9IG9mZnNldFh8fDA7XG5cdFxuXHRcdC8qKiBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFkgPSBvZmZzZXRZfHwwO1xuXHRcblx0XHQvKiogVGhlIGJsdXIgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgYmx1clxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmJsdXIgPSBibHVyfHwwO1xuXHR9XG5cdHZhciBwID0gU2hhZG93LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQW4gaWRlbnRpdHkgc2hhZG93IG9iamVjdCAoYWxsIHByb3BlcnRpZXMgYXJlIHNldCB0byAwKS5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEB0eXBlIFNoYWRvd1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRTaGFkb3cuaWRlbnRpdHkgPSBuZXcgU2hhZG93KFwidHJhbnNwYXJlbnRcIiwgMCwgMCwgMCk7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU2hhZG93XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U2hhZG93fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IFNoYWRvdyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGFkb3codGhpcy5jb2xvciwgdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIHRoaXMuYmx1cik7XG5cdH07XG5cdFxuXG5cdGNyZWF0ZWpzLlNoYWRvdyA9IFNoYWRvdztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggYSBzcHJpdGUgc2hlZXQuIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseVxuXHQgKiBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgbGFyZ2VyIGltYWdlIChvciBpbWFnZXMpLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgZWlnaHQgMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuXG5cdCAqXG5cdCAqIFRoZSBkYXRhIHBhc3NlZCB0byB0aGUgU3ByaXRlU2hlZXQgY29uc3RydWN0b3IgZGVmaW5lczpcblx0ICogPG9sPlxuXHQgKiBcdDxsaT4gVGhlIHNvdXJjZSBpbWFnZSBvciBpbWFnZXMgdG8gdXNlLjwvbGk+XG5cdCAqIFx0PGxpPiBUaGUgcG9zaXRpb25zIG9mIGluZGl2aWR1YWwgaW1hZ2UgZnJhbWVzLjwvbGk+XG5cdCAqIFx0PGxpPiBTZXF1ZW5jZXMgb2YgZnJhbWVzIHRoYXQgZm9ybSBuYW1lZCBhbmltYXRpb25zLiBPcHRpb25hbC48L2xpPlxuXHQgKiBcdDxsaT4gVGhlIHRhcmdldCBwbGF5YmFjayBmcmFtZXJhdGUuIE9wdGlvbmFsLjwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqIDxoMz5TcHJpdGVTaGVldCBGb3JtYXQ8L2gzPlxuXHQgKiBTcHJpdGVTaGVldHMgYXJlIGFuIG9iamVjdCB3aXRoIHR3byByZXF1aXJlZCBwcm9wZXJ0aWVzIChgaW1hZ2VzYCBhbmQgYGZyYW1lc2ApLCBhbmQgdHdvIG9wdGlvbmFsIHByb3BlcnRpZXNcblx0ICogKGBmcmFtZXJhdGVgIGFuZCBgYW5pbWF0aW9uc2ApLiBUaGlzIG1ha2VzIHRoZW0gZWFzeSB0byBkZWZpbmUgaW4gamF2YXNjcmlwdCBjb2RlLCBvciBpbiBKU09OLlxuXHQgKlxuXHQgKiA8aDQ+aW1hZ2VzPC9oND5cblx0ICogQW4gYXJyYXkgb2Ygc291cmNlIGltYWdlcy4gSW1hZ2VzIGNhbiBiZSBlaXRoZXIgYW4gSFRNbGltYWdlXG5cdCAqIGluc3RhbmNlLCBvciBhIHVyaSB0byBhbiBpbWFnZS4gVGhlIGZvcm1lciBpcyByZWNvbW1lbmRlZCB0byBjb250cm9sIHByZWxvYWRpbmcuXG5cdCAqXG5cdCAqIFx0aW1hZ2VzOiBbaW1hZ2UxLCBcInBhdGgvdG8vaW1hZ2UyLnBuZ1wiXSxcblx0ICpcblx0ICogPGg0PmZyYW1lczwvaDQ+XG5cdCAqIERlZmluZXMgdGhlIGluZGl2aWR1YWwgZnJhbWVzLiBUaGVyZSBhcmUgdHdvIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBmcmFtZSBkYXRhOlxuXHQgKiBXaGVuIGFsbCBvZiB0aGUgZnJhbWVzIGFyZSB0aGUgc2FtZSBzaXplIChpbiBhIGdyaWQpLCB1c2UgYW4gb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGByZWdYYCwgYHJlZ1lgLFxuXHQgKiBhbmQgYGNvdW50YCBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiA8dWw+XG5cdCAqICA8bGk+YHdpZHRoYCAmIGBoZWlnaHRgIGFyZSByZXF1aXJlZCBhbmQgc3BlY2lmeSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZnJhbWVzPC9saT5cblx0ICogIDxsaT5gcmVnWGAgJiBgcmVnWWAgaW5kaWNhdGUgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvciBcIm9yaWdpblwiIG9mIHRoZSBmcmFtZXM8L2xpPlxuXHQgKiAgPGxpPmBzcGFjaW5nYCBpbmRpY2F0ZSB0aGUgc3BhY2luZyBiZXR3ZWVuIGZyYW1lczwvbGk+XG5cdCAqICA8bGk+YG1hcmdpbmAgc3BlY2lmeSB0aGUgbWFyZ2luIGFyb3VuZCB0aGUgaW1hZ2Uocyk8L2xpPlxuXHQgKiAgPGxpPmBjb3VudGAgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcHJpdGVzaGVldDsgaWYgb21pdHRlZCwgdGhpcyB3aWxsXG5cdCAqICBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2VzIGFuZCB0aGUgZnJhbWVzLiBGcmFtZXMgd2lsbCBiZSBhc3NpZ25lZFxuXHQgKiAgaW5kZXhlcyBiYXNlZCBvbiB0aGVpciBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGltYWdlcyAobGVmdCB0byByaWdodCwgdG9wIHRvIGJvdHRvbSkuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogIFx0ZnJhbWVzOiB7d2lkdGg6NjQsIGhlaWdodDo2NCwgY291bnQ6MjAsIHJlZ1g6IDMyLCByZWdZOjY0LCBzcGFjaW5nOjAsIG1hcmdpbjowfVxuXHQgKlxuXHQgKiBJZiB0aGUgZnJhbWVzIGFyZSBvZiBkaWZmZXJlbnQgc2l6ZXMsIHVzZSBhbiBhcnJheSBvZiBmcmFtZSBkZWZpbml0aW9ucy4gRWFjaCBkZWZpbml0aW9uIGlzIGl0c2VsZiBhbiBhcnJheVxuXHQgKiB3aXRoIDQgcmVxdWlyZWQgYW5kIDMgb3B0aW9uYWwgZW50cmllcywgaW4gdGhlIG9yZGVyOlxuXHQgKlxuXHQgKiA8dWw+XG5cdCAqICA8bGk+VGhlIGZpcnN0IGZvdXIsIGB4YCwgYHlgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgYXJlIHJlcXVpcmVkIGFuZCBkZWZpbmUgdGhlIGZyYW1lIHJlY3RhbmdsZS48L2xpPlxuXHQgKiAgPGxpPlRoZSBmaWZ0aCwgYGltYWdlSW5kZXhgLCBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgaW1hZ2UgKGRlZmF1bHRzIHRvIDApPC9saT5cblx0ICogIDxsaT5UaGUgbGFzdCB0d28sIGByZWdYYCBhbmQgYHJlZ1lgIHNwZWNpZnkgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvZiB0aGUgZnJhbWU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBcdGZyYW1lczogW1xuXHQgKiBcdFx0Ly8geCwgeSwgd2lkdGgsIGhlaWdodCwgaW1hZ2VJbmRleCosIHJlZ1gqLCByZWdZKlxuXHQgKiBcdFx0WzY0LCAwLCA5NiwgNjRdLFxuXHQgKiBcdFx0WzAsIDAsIDY0LCA2NCwgMSwgMzIsIDMyXVxuXHQgKiBcdFx0Ly8gZXRjLlxuXHQgKiBcdF1cblx0ICpcblx0ICogPGg0PmFuaW1hdGlvbnM8L2g0PlxuXHQgKiBPcHRpb25hbC4gQW4gb2JqZWN0IGRlZmluaW5nIHNlcXVlbmNlcyBvZiBmcmFtZXMgdG8gcGxheSBhcyBuYW1lZCBhbmltYXRpb25zLiBFYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGFuXG5cdCAqIGFuaW1hdGlvbiBvZiB0aGUgc2FtZSBuYW1lLiBFYWNoIGFuaW1hdGlvbiBtdXN0IHNwZWNpZnkgdGhlIGZyYW1lcyB0byBwbGF5LCBhbmQgbWF5XG5cdCAqIGFsc28gaW5jbHVkZSBhIHJlbGF0aXZlIHBsYXliYWNrIGBzcGVlZGAgKGV4LiAyIHdvdWxkIHBsYXliYWNrIGF0IGRvdWJsZSBzcGVlZCwgMC41IGF0IGhhbGYpLCBhbmRcblx0ICogdGhlIG5hbWUgb2YgdGhlIGBuZXh0YCBhbmltYXRpb24gdG8gc2VxdWVuY2UgdG8gYWZ0ZXIgaXQgY29tcGxldGVzLlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdGhyZWUgZm9ybWF0cyBzdXBwb3J0ZWQgZm9yIGRlZmluaW5nIHRoZSBmcmFtZXMgaW4gYW4gYW5pbWF0aW9uLCB3aGljaCBjYW4gYmUgbWl4ZWQgYW5kIG1hdGNoZWQgYXMgYXBwcm9wcmlhdGU6XG5cdCAqIDxvbD5cblx0ICogXHQ8bGk+Zm9yIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiwgeW91IGNhbiBzaW1wbHkgc3BlY2lmeSB0aGUgZnJhbWUgaW5kZXhcblx0ICpcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0c2l0OiA3XG5cdCAqIFx0XHR9XG5cdCAqXG5cdCAqIDwvbGk+XG5cdCAqIDxsaT5cblx0ICogICAgICBmb3IgYW4gYW5pbWF0aW9uIG9mIGNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gYXJyYXkgd2l0aCB0d28gcmVxdWlyZWQsIGFuZCB0d28gb3B0aW9uYWwgZW50cmllc1xuXHQgKiBcdFx0aW4gdGhlIG9yZGVyOiBgc3RhcnRgLCBgZW5kYCwgYG5leHRgLCBhbmQgYHNwZWVkYC4gVGhpcyB3aWxsIHBsYXkgdGhlIGZyYW1lcyBmcm9tIHN0YXJ0IHRvIGVuZCBpbmNsdXNpdmUuXG5cdCAqXG5cdCAqIFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdC8vIHN0YXJ0LCBlbmQsIG5leHQqLCBzcGVlZCpcblx0ICogXHRcdFx0cnVuOiBbMCwgOF0sXG5cdCAqIFx0XHRcdGp1bXA6IFs5LCAxMiwgXCJydW5cIiwgMl1cblx0ICogXHRcdH1cblx0ICpcblx0ICogIDwvbGk+XG5cdCAqICA8bGk+XG5cdCAqICAgICBmb3Igbm9uLWNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gb2JqZWN0IHdpdGggYSBgZnJhbWVzYCBwcm9wZXJ0eSBkZWZpbmluZyBhbiBhcnJheSBvZiBmcmFtZVxuXHQgKiAgICAgaW5kZXhlcyB0byBwbGF5IGluIG9yZGVyLiBUaGUgb2JqZWN0IGNhbiBhbHNvIHNwZWNpZnkgYG5leHRgIGFuZCBgc3BlZWRgIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdHdhbGs6IHtcblx0ICogXHRcdFx0XHRmcmFtZXM6IFsxLDIsMywzLDIsMV1cblx0ICogXHRcdFx0fSxcblx0ICogXHRcdFx0c2hvb3Q6IHtcblx0ICogXHRcdFx0XHRmcmFtZXM6IFsxLDQsNSw2XSxcblx0ICogXHRcdFx0XHRuZXh0OiBcIndhbGtcIixcblx0ICogXHRcdFx0XHRzcGVlZDogMC41XG5cdCAqIFx0XHRcdH1cblx0ICogXHRcdH1cblx0ICpcblx0ICogIDwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gdGhlIGBzcGVlZGAgcHJvcGVydHkgd2FzIGFkZGVkIGluIEVhc2VsSlMgMC43LjAuIEVhcmxpZXIgdmVyc2lvbnMgaGFkIGEgYGZyZXF1ZW5jeWBcblx0ICogcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggd2FzIHRoZSBpbnZlcnNlIG9mIGBzcGVlZGAuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIFwiNFwiIHdvdWxkIGJlIDEvNCBub3JtYWwgc3BlZWQgaW5cblx0ICogZWFybGllciB2ZXJzaW9ucywgYnV0IGlzIDR4IG5vcm1hbCBzcGVlZCBpbiBFYXNlbEpTIDAuNy4wKy5cblx0ICpcblx0ICogPGg0PmZyYW1lcmF0ZTwvaDQ+XG5cdCAqIE9wdGlvbmFsLiBJbmRpY2F0ZXMgdGhlIGRlZmF1bHQgZnJhbWVyYXRlIHRvIHBsYXkgdGhpcyBzcHJpdGVzaGVldCBhdCBpbiBmcmFtZXMgcGVyIHNlY29uZC4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICpcblx0ICogXHRcdGZyYW1lcmF0ZTogMjBcblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBTcHJpdGUgZnJhbWVyYXRlIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzdGFnZSB1cGRhdGUgbWV0aG9kIGlzIHByb3ZpZGVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBcdFx0Y3JlYXRlanMuVGlja2VyLm9uKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICpcdFx0XHRzdGFnZS51cGRhdGUoZXZlbnQpO1xuXHQgKlx0XHR9XG5cdCAqXG5cdCAqIDxoMz5FeGFtcGxlPC9oMz5cblx0ICogVG8gZGVmaW5lIGEgc2ltcGxlIHNwcml0ZSBzaGVldCwgd2l0aCBhIHNpbmdsZSBpbWFnZSBcInNwcml0ZXMuanBnXCIgYXJyYW5nZWQgaW4gYSByZWd1bGFyIDUweDUwIGdyaWQgd2l0aCB0aHJlZVxuXHQgKiBhbmltYXRpb25zOiBcInN0YW5kXCIgc2hvd2luZyB0aGUgZmlyc3QgZnJhbWUsIFwicnVuXCIgbG9vcGluZyBmcmFtZSAxLTUgaW5jbHVzaXZlLCBhbmQgXCJqdW1wXCIgcGxheWluZyBmcmFtZSA2LTggYW5kXG5cdCAqIHNlcXVlbmNpbmcgYmFjayB0byBydW4uXG5cdCAqXG5cdCAqIFx0XHR2YXIgZGF0YSA9IHtcblx0ICogXHRcdFx0aW1hZ2VzOiBbXCJzcHJpdGVzLmpwZ1wiXSxcblx0ICogXHRcdFx0ZnJhbWVzOiB7d2lkdGg6NTAsIGhlaWdodDo1MH0sXG5cdCAqIFx0XHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0XHRzdGFuZDowLFxuXHQgKiBcdFx0XHRcdHJ1bjpbMSw1XSxcblx0ICogXHRcdFx0XHRqdW1wOls2LDgsXCJydW5cIl1cblx0ICogXHRcdFx0fVxuXHQgKiBcdFx0fTtcblx0ICogXHRcdHZhciBzcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHRcdHZhciBhbmltYXRpb24gPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0LCBcInJ1blwiKTtcblx0ICpcblx0ICogPGgzPkdlbmVyYXRpbmcgU3ByaXRlU2hlZXQgSW1hZ2VzPC9oMz5cblx0ICogU3ByaXRlc2hlZXRzIGNhbiBiZSBjcmVhdGVkIG1hbnVhbGx5IGJ5IGNvbWJpbmluZyBpbWFnZXMgaW4gUGhvdG9TaG9wLCBhbmQgc3BlY2lmeWluZyB0aGUgZnJhbWUgc2l6ZSBvclxuXHQgKiBjb29yZGluYXRlcyBtYW51YWxseSwgaG93ZXZlciB0aGVyZSBhcmUgYSBudW1iZXIgb2YgdG9vbHMgdGhhdCBmYWNpbGl0YXRlIHRoaXMuXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5FeHBvcnRpbmcgU3ByaXRlU2hlZXRzIG9yIEhUTUw1IGNvbnRlbnQgZnJvbSBGbGFzaCBQcm8gc3VwcG9ydHMgdGhlIEVhc2VsSlMgU3ByaXRlU2hlZXQgZm9ybWF0LjwvbGk+XG5cdCAqICAgICA8bGk+VGhlIHBvcHVsYXIgPGEgaHJlZj1cImh0dHBzOi8vd3d3LmNvZGVhbmR3ZWIuY29tL3RleHR1cmVwYWNrZXIvZWFzZWxqc1wiIHRhcmdldD1cIl9ibGFua1wiPlRleHR1cmUgUGFja2VyPC9hPiBoYXNcblx0ICogICAgIEVhc2VsSlMgc3VwcG9ydC5cblx0ICogICAgIDxsaT5TV0YgYW5pbWF0aW9ucyBpbiBGbGFzaCBjYW4gYmUgZXhwb3J0ZWQgdG8gU3ByaXRlU2hlZXRzIHVzaW5nIDxhIGhyZWY9XCJodHRwOi8vY3JlYXRlanMuY29tL3pvZVwiIHRhcmdldD1cIl9ibGFua1wiPjwvYT48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8aDM+Q3Jvc3MgT3JpZ2luIElzc3VlczwvaDM+XG5cdCAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gSW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoXG5cdCAqIHVzaW5nOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+YSBtb3VzZTwvbGk+XG5cdCAqICAgICA8bGk+bWV0aG9kcyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5GaWx0ZXJzIChzZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319KTwvbGk+XG5cdCAqICAgICA8bGk+Y2FjaGluZyAoc2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0pPC9saT5cblx0ICogPC91bD5cblx0ICogWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZyBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IG9uIHlvdXIgaW1hZ2VzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gRWFzZWxKUywgb3Jcblx0ICogc2V0dGluZyB0aGUgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBvbiBQcmVsb2FkSlMnIExvYWRRdWV1ZSBvciBMb2FkSXRlbXMuXG5cdCAqXG5cdCAqIFx0XHR2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblx0ICogXHRcdGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO1xuXHQgKiBcdFx0aW1nLnNyYyA9IFwiaHR0cDovL3NlcnZlci13aXRoLUNPUlMtc3VwcG9ydC5jb20vcGF0aC90by9pbWFnZS5qcGdcIjtcblx0ICpcblx0ICogSWYgeW91IHBhc3Mgc3RyaW5nIHBhdGhzIHRvIFNwcml0ZVNoZWV0cywgdGhleSB3aWxsIG5vdCB3b3JrIGNyb3NzLW9yaWdpbi4gVGhlIHNlcnZlciB0aGF0IHN0b3JlcyB0aGUgaW1hZ2UgbXVzdFxuXHQgKiBzdXBwb3J0IGNyb3NzLW9yaWdpbiByZXF1ZXN0cywgb3IgdGhpcyB3aWxsIG5vdCB3b3JrLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgY2hlY2sgb3V0XG5cdCAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0FjY2Vzc19jb250cm9sX0NPUlNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5DT1JTIG92ZXJ2aWV3IG9uIE1ETjwvYT4uXG5cdCAqXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciBhbGwgaW1hZ2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wbGV0ZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jb21wbGV0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGZyYW1lcmF0ZSB0byB1c2UgYnkgZGVmYXVsdCBmb3IgU3ByaXRlIGluc3RhbmNlcyB1c2luZyB0aGUgU3ByaXRlU2hlZXQuIFNlZSB0aGUgU3ByaXRlIGNsYXNzXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblxuXG5cdFx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb25zID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ltYWdlc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbWFnZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9kYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZENvdW50XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9sb2FkQ291bnQgPSAwO1xuXG5cdFx0Ly8gb25seSB1c2VkIGZvciBzaW1wbGUgZnJhbWUgZGVmczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lSGVpZ2h0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZUhlaWdodCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lV2lkdGhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lV2lkdGggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9udW1GcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX251bUZyYW1lcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlZ1hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlZ1ggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9yZWdZXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWdZID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3BhY2luZ1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fc3BhY2luZyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21hcmdpblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbWFyZ2luID0gMDtcblxuXHRcdC8vIHNldHVwOlxuXHRcdHRoaXMuX3BhcnNlRGF0YShkYXRhKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYWxsIGltYWdlcyBhcmUgbG9hZGVkLiAgTm90ZSB0aGF0IHRoaXMgb25seSBmaXJlcyBpZiB0aGUgaW1hZ2VzXG5cdCAqIHdlcmUgbm90IGZ1bGx5IGxvYWRlZCB3aGVuIHRoZSBzcHJpdGUgc2hlZXQgd2FzIGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNoZWNrIHRoZSBjb21wbGV0ZSBwcm9wZXJ0eVxuXHQgKiB0byBwcmlvciB0byBhZGRpbmcgYSBsaXN0ZW5lci4gRXguXG5cdCAqXG5cdCAqIFx0dmFyIHNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KGRhdGEpO1xuXHQgKiBcdGlmICghc2hlZXQuY29tcGxldGUpIHtcblx0ICogXHRcdC8vIG5vdCBwcmVsb2FkZWQsIGxpc3RlbiBmb3IgdGhlIGNvbXBsZXRlIGV2ZW50OlxuXHQgKiBcdFx0c2hlZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBsZXRlXCIsIGhhbmRsZXIpO1xuXHQgKiBcdH1cblx0ICpcblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gZ2V0RnJhbWUgaXMgY2FsbGVkIHdpdGggYSB2YWxpZCBmcmFtZSBpbmRleC4gVGhpcyBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIHVzZSBieSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hlbiBkb2luZyBvbi1kZW1hbmQgcmVuZGVyaW5nLlxuXHQgKiBAZXZlbnQgZ2V0ZnJhbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZyYW1lIFRoZSBmcmFtZSBvYmplY3QgdGhhdCBnZXRGcmFtZSB3aWxsIHJldHVybi5cblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBpbWFnZSBlbmNvdW50ZXJzIGFuIGVycm9yLiBBIFNwcml0ZVNoZWV0IHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQgZm9yIGVhY2ggaW1hZ2UgdGhhdFxuXHQgKiBlbmNvdW50ZXJzIGFuIGVycm9yLCBhbmQgd2lsbCBzdGlsbCBkaXNwYXRjaCBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9uY2UgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgcHJvY2Vzc2luZywgZXZlbiBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cblx0ICogQGV2ZW50IGVycm9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdGhhdCBmYWlsZWQgdG8gbG9hZC5cblx0ICogQHNpbmNlIDAuOC4yXG5cdCAqL1xuXG5cbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2FuaW1hdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25zXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmltYXRpb25zLnNsaWNlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBhbmltYXRpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoaXMgc3ByaXRlIHNoZWV0IGFzIHN0cmluZ3MuXG5cdCAqIEBwcm9wZXJ0eSBhbmltYXRpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRhbmltYXRpb25zOiB7IGdldDogcC5nZXRBbmltYXRpb25zIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIHNwZWNpZmllZCBhbmltYXRpb24sIG9yIGluIHRoZSB3aG9sZSBzcHJpdGVcblx0ICogc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLiBSZXR1cm5zIDAgaWYgdGhlIHNwcml0ZXNoZWV0IHJlbGllcyBvbiBjYWxjdWxhdGVkIGZyYW1lIGNvdW50cywgYW5kXG5cdCAqIHRoZSBpbWFnZXMgaGF2ZSBub3QgYmVlbiBmdWxseSBsb2FkZWQuXG5cdCAqIEBtZXRob2QgZ2V0TnVtRnJhbWVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQgYSBmcmFtZSBjb3VudCBmb3IuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvbiwgb3IgaW4gdGhlIGVudGlyZSBzcHJpdGUgc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLlxuXHQgKi9cblx0cC5nZXROdW1GcmFtZXMgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRpZiAoYW5pbWF0aW9uID09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcmFtZXMgPyB0aGlzLl9mcmFtZXMubGVuZ3RoIDogdGhpcy5fbnVtRnJhbWVzIHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5fZGF0YVthbmltYXRpb25dO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm4gMDsgfVxuXHRcdFx0ZWxzZSB7IHJldHVybiBkYXRhLmZyYW1lcy5sZW5ndGg7IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zOjxVTD5cblx0ICogXHQ8bGk+ZnJhbWVzOiBhbiBhcnJheSBvZiB0aGUgZnJhbWUgaWRzIGluIHRoZSBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5zcGVlZDogdGhlIHBsYXliYWNrIHNwZWVkIGZvciB0aGlzIGFuaW1hdGlvbjwvbGk+XG5cdCAqIFx0PGxpPm5hbWU6IHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5uZXh0OiB0aGUgZGVmYXVsdCBhbmltYXRpb24gdG8gcGxheSBuZXh0LiBJZiB0aGUgYW5pbWF0aW9uIGxvb3BzLCB0aGUgbmFtZSBhbmQgbmV4dCBwcm9wZXJ0eSB3aWxsIGJlIHRoZVxuXHQgKiBcdHNhbWUuPC9saT5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gYSBnZW5lcmljIG9iamVjdCB3aXRoIGZyYW1lcywgc3BlZWQsIG5hbWUsIGFuZCBuZXh0IHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGltYWdlIGFuZCBzb3VyY2UgcmVjdCBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGhhczo8VUw+XG5cdCAqIFx0PGxpPmFuIGltYWdlIHByb3BlcnR5IGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGltYWdlIG9iamVjdCBpbiB3aGljaCB0aGUgZnJhbWUgaXMgZm91bmQ8L2xpPlxuXHQgKiBcdDxsaT5hIHJlY3QgcHJvcGVydHkgY29udGFpbmluZyBhIFJlY3RhbmdsZSBpbnN0YW5jZSB3aGljaCBkZWZpbmVzIHRoZSBib3VuZGFyaWVzIGZvciB0aGUgZnJhbWUgd2l0aGluIHRoYXRcblx0ICogXHRpbWFnZS48L2xpPlxuXHQgKiBcdDxsaT4gQSByZWdYIGFuZCByZWdZIHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlZ1gvWSB2YWx1ZXMgZm9yIHRoZSBmcmFtZS5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRGcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBpbWFnZSBhbmQgcmVjdCBwcm9wZXJ0aWVzLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LlxuXHQgKiovXG5cdHAuZ2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZUluZGV4KSB7XG5cdFx0dmFyIGZyYW1lO1xuXHRcdGlmICh0aGlzLl9mcmFtZXMgJiYgKGZyYW1lPXRoaXMuX2ZyYW1lc1tmcmFtZUluZGV4XSkpIHsgcmV0dXJuIGZyYW1lOyB9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lIHJlbGF0aXZlXG5cdCAqIHRvIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCBhIHJlZ1ggb2YgNTAgYW5kIGEgcmVnWSBvZiA0MCB3b3VsZCByZXR1cm46XG5cdCAqXG5cdCAqIFx0W3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF1cblx0ICpcblx0ICogQG1ldGhvZCBnZXRGcmFtZUJvdW5kc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3JlY3RhbmdsZV0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgdG8gY29weSB0aGUgdmFsdWVzIGludG8uIEJ5IGRlZmF1bHQgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZS4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGltYWdlIGlzIG5vdCBmdWxseSBsb2FkZWQuXG5cdCAqKi9cblx0cC5nZXRGcmFtZUJvdW5kcyA9IGZ1bmN0aW9uKGZyYW1lSW5kZXgsIHJlY3RhbmdsZSkge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoZnJhbWVJbmRleCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gKHJlY3RhbmdsZXx8bmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5zZXRWYWx1ZXMoLWZyYW1lLnJlZ1gsIC1mcmFtZS5yZWdZLCBmcmFtZS5yZWN0LndpZHRoLCBmcmFtZS5yZWN0LmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlU2hlZXRdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuIEEgU3ByaXRlU2hlZXQgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBTcHJpdGUgaW5zdGFuY2VzIHdpdGhvdXQgY2xvbmluZyBpdC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3BhcnNlRGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgU3ByaXRlU2hlZXQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3BhcnNlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR2YXIgaSxsLG8sYTtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBkYXRhLmZyYW1lcmF0ZXx8MDtcblxuXHRcdC8vIHBhcnNlIGltYWdlczpcblx0XHRpZiAoZGF0YS5pbWFnZXMgJiYgKGw9ZGF0YS5pbWFnZXMubGVuZ3RoKSA+IDApIHtcblx0XHRcdGEgPSB0aGlzLl9pbWFnZXMgPSBbXTtcblx0XHRcdGZvciAoaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW1nID0gZGF0YS5pbWFnZXNbaV07XG5cdFx0XHRcdGlmICh0eXBlb2YgaW1nID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR2YXIgc3JjID0gaW1nO1xuXHRcdFx0XHRcdGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHRcdFx0aW1nLnNyYyA9IHNyYztcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnB1c2goaW1nKTtcblx0XHRcdFx0aWYgKCFpbWcuZ2V0Q29udGV4dCAmJiAhaW1nLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRcdHRoaXMuX2xvYWRDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuY29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHQoZnVuY3Rpb24obywgc3JjKSB7IGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHsgby5faGFuZGxlSW1hZ2VMb2FkKHNyYyk7IH0gfSkodGhpcywgc3JjKTtcblx0XHRcdFx0XHQoZnVuY3Rpb24obywgc3JjKSB7IGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IG8uX2hhbmRsZUltYWdlRXJyb3Ioc3JjKTsgfSB9KSh0aGlzLCBzcmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgZnJhbWVzOlxuXHRcdGlmIChkYXRhLmZyYW1lcyA9PSBudWxsKSB7IC8vIG5vdGhpbmdcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5mcmFtZXMpKSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XHRcdGEgPSBkYXRhLmZyYW1lcztcblx0XHRcdGZvciAoaT0wLGw9YS5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHR2YXIgYXJyID0gYVtpXTtcblx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe2ltYWdlOnRoaXMuX2ltYWdlc1thcnJbNF0/YXJyWzRdOjBdLCByZWN0Om5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoYXJyWzBdLGFyclsxXSxhcnJbMl0sYXJyWzNdKSwgcmVnWDphcnJbNV18fDAsIHJlZ1k6YXJyWzZdfHwwIH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvID0gZGF0YS5mcmFtZXM7XG5cdFx0XHR0aGlzLl9mcmFtZVdpZHRoID0gby53aWR0aDtcblx0XHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gby5oZWlnaHQ7XG5cdFx0XHR0aGlzLl9yZWdYID0gby5yZWdYfHwwO1xuXHRcdFx0dGhpcy5fcmVnWSA9IG8ucmVnWXx8MDtcblx0XHRcdHRoaXMuX3NwYWNpbmcgPSBvLnNwYWNpbmd8fDA7XG5cdFx0XHR0aGlzLl9tYXJnaW4gPSBvLm1hcmdpbnx8MDtcblx0XHRcdHRoaXMuX251bUZyYW1lcyA9IG8uY291bnQ7XG5cdFx0XHRpZiAodGhpcy5fbG9hZENvdW50ID09IDApIHsgdGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7IH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZSBhbmltYXRpb25zOlxuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRpZiAoKG89ZGF0YS5hbmltYXRpb25zKSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XHR2YXIgbmFtZTtcblx0XHRcdGZvciAobmFtZSBpbiBvKSB7XG5cdFx0XHRcdHZhciBhbmltID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdHZhciBvYmogPSBvW25hbWVdO1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcIm51bWJlclwiKSB7IC8vIHNpbmdsZSBmcmFtZVxuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtvYmpdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgeyAvLyBzaW1wbGVcblx0XHRcdFx0XHRpZiAob2JqLmxlbmd0aCA9PSAxKSB7IGFuaW0uZnJhbWVzID0gW29ialswXV07IH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGFuaW0uc3BlZWQgPSBvYmpbM107XG5cdFx0XHRcdFx0XHRhbmltLm5leHQgPSBvYmpbMl07XG5cdFx0XHRcdFx0XHRhID0gYW5pbS5mcmFtZXMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAoaT1vYmpbMF07aTw9b2JqWzFdO2krKykge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgeyAvLyBjb21wbGV4XG5cdFx0XHRcdFx0YW5pbS5zcGVlZCA9IG9iai5zcGVlZDtcblx0XHRcdFx0XHRhbmltLm5leHQgPSBvYmoubmV4dDtcblx0XHRcdFx0XHR2YXIgZnJhbWVzID0gb2JqLmZyYW1lcztcblx0XHRcdFx0XHRhID0gYW5pbS5mcmFtZXMgPSAodHlwZW9mIGZyYW1lcyA9PSBcIm51bWJlclwiKSA/IFtmcmFtZXNdIDogZnJhbWVzLnNsaWNlKDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IHRydWUgfHwgYW5pbS5uZXh0ID09PSB1bmRlZmluZWQpIHsgYW5pbS5uZXh0ID0gbmFtZTsgfSAvLyBsb29wXG5cdFx0XHRcdGlmIChhbmltLm5leHQgPT09IGZhbHNlIHx8IChhLmxlbmd0aCA8IDIgJiYgYW5pbS5uZXh0ID09IG5hbWUpKSB7IGFuaW0ubmV4dCA9IG51bGw7IH0gLy8gc3RvcFxuXHRcdFx0XHRpZiAoIWFuaW0uc3BlZWQpIHsgYW5pbS5zcGVlZCA9IDE7IH1cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9ucy5wdXNoKG5hbWUpO1xuXHRcdFx0XHR0aGlzLl9kYXRhW25hbWVdID0gYW5pbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUltYWdlTG9hZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5faGFuZGxlSW1hZ2VMb2FkID0gZnVuY3Rpb24oc3JjKSB7XG5cdFx0aWYgKC0tdGhpcy5fbG9hZENvdW50ID09IDApIHtcblx0XHRcdHRoaXMuX2NhbGN1bGF0ZUZyYW1lcygpO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUltYWdlRXJyb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlSW1hZ2VFcnJvciA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgZXJyb3JFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImVycm9yXCIpO1xuXHRcdGVycm9yRXZlbnQuc3JjID0gc3JjO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcblxuXHRcdC8vIENvbXBsZXRlIGlzIHN0aWxsIGRpc3BhdGNoZWQuXG5cdFx0aWYgKC0tdGhpcy5fbG9hZENvdW50ID09IDApIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2FsY3VsYXRlRnJhbWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jYWxjdWxhdGVGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZnJhbWVzIHx8IHRoaXMuX2ZyYW1lV2lkdGggPT0gMCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXG5cdFx0dmFyIG1heEZyYW1lcyA9IHRoaXMuX251bUZyYW1lcyB8fCAxMDAwMDA7IC8vIGlmIHdlIGdvIG92ZXIgdGhpcywgc29tZXRoaW5nIGlzIHdyb25nLlxuXHRcdHZhciBmcmFtZUNvdW50ID0gMCwgZnJhbWVXaWR0aCA9IHRoaXMuX2ZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0ID0gdGhpcy5fZnJhbWVIZWlnaHQ7XG5cdFx0dmFyIHNwYWNpbmcgPSB0aGlzLl9zcGFjaW5nLCBtYXJnaW4gPSB0aGlzLl9tYXJnaW47XG5cdFx0XG5cdFx0aW1nTG9vcDpcblx0XHRmb3IgKHZhciBpPTAsIGltZ3M9dGhpcy5faW1hZ2VzOyBpPGltZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbWcgPSBpbWdzW2ldLCBpbWdXID0gaW1nLndpZHRoLCBpbWdIID0gaW1nLmhlaWdodDtcblxuXHRcdFx0dmFyIHkgPSBtYXJnaW47XG5cdFx0XHR3aGlsZSAoeSA8PSBpbWdILW1hcmdpbi1mcmFtZUhlaWdodCkge1xuXHRcdFx0XHR2YXIgeCA9IG1hcmdpbjtcblx0XHRcdFx0d2hpbGUgKHggPD0gaW1nVy1tYXJnaW4tZnJhbWVXaWR0aCkge1xuXHRcdFx0XHRcdGlmIChmcmFtZUNvdW50ID49IG1heEZyYW1lcykgeyBicmVhayBpbWdMb29wOyB9XG5cdFx0XHRcdFx0ZnJhbWVDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aW1hZ2U6IGltZyxcblx0XHRcdFx0XHRcdFx0cmVjdDogbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LCB5LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCksXG5cdFx0XHRcdFx0XHRcdHJlZ1g6IHRoaXMuX3JlZ1gsXG5cdFx0XHRcdFx0XHRcdHJlZ1k6IHRoaXMuX3JlZ1lcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHggKz0gZnJhbWVXaWR0aCtzcGFjaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHkgKz0gZnJhbWVIZWlnaHQrc3BhY2luZztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gZnJhbWVDb3VudDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0ID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gR3JhcGhpY3MuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgR3JhcGhpY3MgY2xhc3MgZXhwb3NlcyBhbiBlYXN5IHRvIHVzZSBBUEkgZm9yIGdlbmVyYXRpbmcgdmVjdG9yIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBkcmF3aW5nIHRoZW0gdG8gYVxuXHQgKiBzcGVjaWZpZWQgY29udGV4dC4gTm90ZSB0aGF0IHlvdSBjYW4gdXNlIEdyYXBoaWNzIHdpdGhvdXQgYW55IGRlcGVuZGVuY3kgb24gdGhlIEVhc2VsSlMgZnJhbWV3b3JrIGJ5IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBkaXJlY3RseSwgb3IgaXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIGRyYXcgdmVjdG9yIGdyYXBoaWNzIHdpdGhpbiB0aGVcblx0ICogY29udGV4dCBvZiBhbiBFYXNlbEpTIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogVGhlcmUgYXJlIHR3byBhcHByb2FjaGVzIHRvIHdvcmtpbmcgd2l0aCBHcmFwaGljcyBvYmplY3Q6IGNhbGxpbmcgbWV0aG9kcyBvbiBhIEdyYXBoaWNzIGluc3RhbmNlICh0aGUgXCJHcmFwaGljcyBBUElcIiksIG9yXG5cdCAqIGluc3RhbnRpYXRpbmcgR3JhcGhpY3MgY29tbWFuZCBvYmplY3RzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgZ3JhcGhpY3MgcXVldWUgdmlhIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogVGhlIGZvcm1lciBhYnN0cmFjdHMgdGhlIGxhdHRlciwgc2ltcGxpZnlpbmcgYmVnaW5uaW5nIGFuZCBlbmRpbmcgcGF0aHMsIGZpbGxzLCBhbmQgc3Ryb2tlcy5cblx0ICpcblx0ICogICAgICB2YXIgZyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHQgKiAgICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG5cdCAqICAgICAgZy5iZWdpblN0cm9rZShcIiMwMDAwMDBcIik7XG5cdCAqICAgICAgZy5iZWdpbkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgZy5kcmF3Q2lyY2xlKDAsMCwzMCk7XG5cdCAqXG5cdCAqIEFsbCBkcmF3aW5nIG1ldGhvZHMgaW4gR3JhcGhpY3MgcmV0dXJuIHRoZSBHcmFwaGljcyBpbnN0YW5jZSwgc28gdGhleSBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gRm9yIGV4YW1wbGUsXG5cdCAqIHRoZSBmb2xsb3dpbmcgbGluZSBvZiBjb2RlIHdvdWxkIGdlbmVyYXRlIHRoZSBpbnN0cnVjdGlvbnMgdG8gZHJhdyBhIHJlY3RhbmdsZSB3aXRoIGEgcmVkIHN0cm9rZSBhbmQgYmx1ZSBmaWxsOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5TdHJva2UoXCJyZWRcIikuYmVnaW5GaWxsKFwiYmx1ZVwiKS5kcmF3UmVjdCgyMCwgMjAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBFYWNoIGdyYXBoaWNzIEFQSSBjYWxsIGdlbmVyYXRlcyBhIGNvbW1hbmQgb2JqZWN0IChzZWUgYmVsb3cpLiBUaGUgbGFzdCBjb21tYW5kIHRvIGJlIGNyZWF0ZWQgY2FuIGJlIGFjY2Vzc2VkIHZpYVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jb21tYW5kOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OlxuXHQgKlxuXHQgKiAgICAgIHZhciBmaWxsQ29tbWFuZCA9IG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmNvbW1hbmQ7XG5cdCAqICAgICAgLy8gLi4uIGxhdGVyLCB1cGRhdGUgdGhlIGZpbGwgc3R5bGUvY29sb3I6XG5cdCAqICAgICAgZmlsbENvbW1hbmQuc3R5bGUgPSBcImJsdWVcIjtcblx0ICogICAgICAvLyBvciBjaGFuZ2UgaXQgdG8gYSBiaXRtYXAgZmlsbDpcblx0ICogICAgICBmaWxsQ29tbWFuZC5iaXRtYXAobXlJbWFnZSk7XG5cdCAqXG5cdCAqIEZvciBtb3JlIGRpcmVjdCBjb250cm9sIG9mIHJlbmRlcmluZywgeW91IGNhbiBpbnN0YW50aWF0ZSBhbmQgYXBwZW5kIGNvbW1hbmQgb2JqZWN0cyB0byB0aGUgZ3JhcGhpY3MgcXVldWUgZGlyZWN0bHkuIEluIHRoaXMgY2FzZSwgeW91XG5cdCAqIG5lZWQgdG8gbWFuYWdlIHBhdGggY3JlYXRpb24gbWFudWFsbHksIGFuZCBlbnN1cmUgdGhhdCBmaWxsL3N0cm9rZSBpcyBhcHBsaWVkIHRvIGEgZGVmaW5lZCBwYXRoOlxuXHQgKlxuXHQgKiAgICAgIC8vIHN0YXJ0IGEgbmV3IHBhdGguIEdyYXBoaWNzLmJlZ2luQ21kIGlzIGEgcmV1c2FibGUgQmVnaW5QYXRoIGluc3RhbmNlOlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGNyZWF0ZWpzLkdyYXBoaWNzLmJlZ2luQ21kKTtcblx0ICogICAgICAvLyB3ZSBuZWVkIHRvIGRlZmluZSB0aGUgcGF0aCBiZWZvcmUgYXBwbHlpbmcgdGhlIGZpbGw6XG5cdCAqICAgICAgdmFyIGNpcmNsZSA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcy5DaXJjbGUoMCwwLDMwKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjaXJjbGUpO1xuXHQgKiAgICAgIC8vIGZpbGwgdGhlIHBhdGggd2UganVzdCBkZWZpbmVkOlxuXHQgKiAgICAgIHZhciBmaWxsID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoZmlsbCk7XG5cdCAqXG5cdCAqIFRoZXNlIGFwcHJvYWNoZXMgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIGZvciBleGFtcGxlIHRvIGluc2VydCBhIGN1c3RvbSBjb21tYW5kOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIHZhciBjdXN0b21Db21tYW5kID0gbmV3IEN1c3RvbVNwaXJhbENvbW1hbmQoZXRjKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjdXN0b21Db21tYW5kKTtcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luRmlsbChcImJsdWVcIik7XG5cdCAqICAgICAgbXlHcmFwaGljcy5kcmF3Q2lyY2xlKDAsIDAsIDMwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvIG9uIGNyZWF0aW5nIGN1c3RvbSBjb21tYW5kcy5cblx0ICpcblx0ICogPGg0PlRpbnkgQVBJPC9oND5cblx0ICogVGhlIEdyYXBoaWNzIGNsYXNzIGFsc28gaW5jbHVkZXMgYSBcInRpbnkgQVBJXCIsIHdoaWNoIGlzIG9uZSBvciB0d28tbGV0dGVyIG1ldGhvZHMgdGhhdCBhcmUgc2hvcnRjdXRzIGZvciBhbGwgb2YgdGhlXG5cdCAqIEdyYXBoaWNzIG1ldGhvZHMuIFRoZXNlIG1ldGhvZHMgYXJlIGdyZWF0IGZvciBjcmVhdGluZyBjb21wYWN0IGluc3RydWN0aW9ucywgYW5kIGlzIHVzZWQgYnkgdGhlIFRvb2xraXQgZm9yIENyZWF0ZUpTXG5cdCAqIHRvIGdlbmVyYXRlIHJlYWRhYmxlIGNvZGUuIEFsbCB0aW55IG1ldGhvZHMgYXJlIG1hcmtlZCBhcyBwcm90ZWN0ZWQsIHNvIHlvdSBjYW4gdmlldyB0aGVtIGJ5IGVuYWJsaW5nIHByb3RlY3RlZFxuXHQgKiBkZXNjcmlwdGlvbnMgaW4gdGhlIGRvY3MuXG5cdCAqXG5cdCAqIDx0YWJsZT5cblx0ICogICAgIDx0cj48dGQ+PGI+VGlueTwvYj48L3RkPjx0ZD48Yj5NZXRob2Q8L2I+PC90ZD48dGQ+PGI+VGlueTwvYj48L3RkPjx0ZD48Yj5NZXRob2Q8L2I+PC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5tdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmx0PC90ZD4gPHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2xpbmVUb1wifX17ey9jcm9zc0xpbmt9fTwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+YS9hdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1wifX17ey9jcm9zc0xpbmt9fSAvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1RvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YnQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZXppZXJDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IChhbHNvIGN1cnZlVG8pPC90ZD5cblx0ICogICAgIDx0ZD5yPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmNwPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xvc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2NsZWFyXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmxmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5yZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5lZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2VuZEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5zcyAvIHNkPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gLyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VEYXNoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+czwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bHM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+YnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmVzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZW5kU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+ZHI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJyPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnJjPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdENvbXBsZXhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5kYzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5kZTwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdFbGxpcHNlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZHA8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UG9seVN0YXJcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5wPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZGVjb2RlUGF0aFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqIDwvdGFibGU+XG5cdCAqXG5cdCAqIEhlcmUgaXMgdGhlIGFib3ZlIGV4YW1wbGUsIHVzaW5nIHRoZSB0aW55IEFQSSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MucyhcInJlZFwiKS5mKFwiYmx1ZVwiKS5yKDIwLCAyMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBHcmFwaGljc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBHcmFwaGljcygpIHtcblxuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgY29tbWFuZCB0aGF0IHdhcyBjcmVhdGVkIG9yIGFwcGVuZGVkLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIHJldGFpbiBhIHJlZmVyZW5jZVxuXHRcdCAqIHRvIGEgRmlsbCBjb21tYW5kIGluIG9yZGVyIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgY29sb3IgbGF0ZXIgYnkgdXNpbmc6XG5cdFx0ICpcblx0XHQgKiBcdFx0dmFyIG15RmlsbCA9IG15R3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmNvbW1hbmQ7XG5cdFx0ICogXHRcdC8vIHVwZGF0ZSBjb2xvciBsYXRlcjpcblx0XHQgKiBcdFx0bXlGaWxsLnN0eWxlID0gXCJ5ZWxsb3dcIjtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21tYW5kXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tbWFuZCA9IG51bGw7XG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VTdHlsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlU3R5bGV9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlRGFzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlRGFzaH1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRTdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlSWdub3JlU2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtGaWxsfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWxsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gaW5kZXggdGhhdCB3YXMgY29tbWl0dGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY29tbWl0SW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiovXG5cdFx0dGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVW5jb21taXR0ZWQgaW5zdHJ1Y3Rpb25zLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aXZlSW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGluZGljYXRlcyB0aGF0IHRoZXJlIGhhdmUgYmVlbiBjaGFuZ2VzIHRvIHRoZSBhY3RpdmVJbnN0cnVjdGlvbiBsaXN0IHNpbmNlIHRoZSBsYXN0IHVwZGF0ZUluc3RydWN0aW9ucyBjYWxsLlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGlydHlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IHRvIGRyYXcgZnJvbSBpZiBhIHN0b3JlIG9wZXJhdGlvbiBoYXMgaGFwcGVuZWQuXG5cdFx0ICogQHByb3BlcnR5IF9zdG9yZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblxuXHQvLyBzZXR1cDpcblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblx0dmFyIHAgPSBHcmFwaGljcy5wcm90b3R5cGU7XG5cdHZhciBHID0gR3JhcGhpY3M7IC8vIHNob3J0Y3V0XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDUwLCAxMDAsIDE1MCwgMC41KTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSg1MCwxMDAsMTUwLDAuNSlcIlxuXHQgKlxuXHQgKiBJdCBhbHNvIHN1cHBvcnRzIHBhc3NpbmcgYSBzaW5nbGUgaGV4IGNvbG9yIHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbSwgYW5kIGFuIG9wdGlvbmFsIGFscGhhIHZhbHVlIGFzIHRoZSBzZWNvbmRcblx0ICogcGFyYW0uIEZvciBleGFtcGxlLFxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigweEZGMDBGRiwgMC4yKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSgyNTUsMCwyNTUsMC4yKVwiXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0UkdCXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgUkdCIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJyZ2JhKDI1NSwyNTUsMjU1LDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJyZ2IoMjU1LDI1NSwyNTUpXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0UkdCID0gZnVuY3Rpb24ociwgZywgYiwgYWxwaGEpIHtcblx0XHRpZiAociAhPSBudWxsICYmIGIgPT0gbnVsbCkge1xuXHRcdFx0YWxwaGEgPSBnO1xuXHRcdFx0YiA9IHImMHhGRjtcblx0XHRcdGcgPSByPj44JjB4RkY7XG5cdFx0XHRyID0gcj4+MTYmMHhGRjtcblx0XHR9XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcInJnYihcIityK1wiLFwiK2crXCIsXCIrYitcIilcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwicmdiYShcIityK1wiLFwiK2crXCIsXCIrYitcIixcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdCBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLFxuXHQgKiBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRIU0woMTUwLCAxMDAsIDcwKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwiaHNsKDE1MCwxMDAsNzApXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRIU0xcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlIFRoZSBodWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMzYwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiBUaGUgc2F0dXJhdGlvbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaWdodG5lc3MgVGhlIGxpZ2h0bmVzcyBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIFRoZSBhbHBoYSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciB3aGVyZSAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKiovXG5cdEdyYXBoaWNzLmdldEhTTCA9IGZ1bmN0aW9uKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJoc2woXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcImhzbGEoXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUsXCIrYWxwaGErXCIpXCI7XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQSByZXVzYWJsZSBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9CZWdpblBhdGhcIn19e3svY3Jvc3NMaW5rfX0gdG8gYXZvaWRcblx0ICogdW5uZWNlc3NhcnkgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IGJlZ2luQ21kXG5cdCAqIEB0eXBlIHtHcmFwaGljcy5CZWdpblBhdGh9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHQgLy8gZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuXHQvKipcblx0ICogTWFwIG9mIEJhc2U2NCBjaGFyYWN0ZXJzIHRvIHZhbHVlcy4gVXNlZCBieSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgQkFTRV82NFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge09iamVjdH1cblx0ICoqL1xuXHRHcmFwaGljcy5CQVNFXzY0ID0ge1wiQVwiOjAsXCJCXCI6MSxcIkNcIjoyLFwiRFwiOjMsXCJFXCI6NCxcIkZcIjo1LFwiR1wiOjYsXCJIXCI6NyxcIklcIjo4LFwiSlwiOjksXCJLXCI6MTAsXCJMXCI6MTEsXCJNXCI6MTIsXCJOXCI6MTMsXCJPXCI6MTQsXCJQXCI6MTUsXCJRXCI6MTYsXCJSXCI6MTcsXCJTXCI6MTgsXCJUXCI6MTksXCJVXCI6MjAsXCJWXCI6MjEsXCJXXCI6MjIsXCJYXCI6MjMsXCJZXCI6MjQsXCJaXCI6MjUsXCJhXCI6MjYsXCJiXCI6MjcsXCJjXCI6MjgsXCJkXCI6MjksXCJlXCI6MzAsXCJmXCI6MzEsXCJnXCI6MzIsXCJoXCI6MzMsXCJpXCI6MzQsXCJqXCI6MzUsXCJrXCI6MzYsXCJsXCI6MzcsXCJtXCI6MzgsXCJuXCI6MzksXCJvXCI6NDAsXCJwXCI6NDEsXCJxXCI6NDIsXCJyXCI6NDMsXCJzXCI6NDQsXCJ0XCI6NDUsXCJ1XCI6NDYsXCJ2XCI6NDcsXCJ3XCI6NDgsXCJ4XCI6NDksXCJ5XCI6NTAsXCJ6XCI6NTEsXCIwXCI6NTIsXCIxXCI6NTMsXCIyXCI6NTQsXCIzXCI6NTUsXCI0XCI6NTYsXCI1XCI6NTcsXCI2XCI6NTgsXCI3XCI6NTksXCI4XCI6NjAsXCI5XCI6NjEsXCIrXCI6NjIsXCIvXCI6NjN9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgY2FwcyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJidXR0XCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcInNxdWFyZVwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGNhcHMgdG8gXCJzcXVhcmVcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9DQVBTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUCA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcblxuXHQvKipcblx0ICogTWFwcyBudW1lcmljIHZhbHVlcyBmb3IgdGhlIGpvaW50cyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJtaXRlclwiLCAxIHRvIFwicm91bmRcIiwgYW5kIDIgdG8gXCJiZXZlbFwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGpvaW50cyB0byBcImJldmVsXCI6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zcygxNiwgMCwgMik7XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVFJPS0VfSk9JTlRTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2N0eFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0R3JhcGhpY3MuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9pbnN0cnVjdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnN0cnVjdGlvbnNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBncmFwaGljcyBpbnN0cnVjdGlvbnMgYXJyYXkuIEVhY2ggZW50cnkgaXMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCAoZXguIEdyYXBoaWNzLkZpbGwsIEdyYXBoaWNzLlJlY3QpXG5cdCAqIE1vZGlmeWluZyB0aGUgcmV0dXJuZWQgYXJyYXkgZGlyZWN0bHkgaXMgbm90IHJlY29tbWVuZGVkLCBhbmQgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICpcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIGludHJvc3BlY3Rpb24gb2YgdGhlIGluc3RydWN0aW9ucyAoZXguIGZvciBncmFwaGljcyBleHBvcnQpLlxuXHQgKiBAcHJvcGVydHkgaW5zdHJ1Y3Rpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRpbnN0cnVjdGlvbnM6IHsgZ2V0OiBwLmdldEluc3RydWN0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiovXG5cdHAuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggfHwgdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE9wdGlvbmFsIGRhdGEgdGhhdCBpcyBwYXNzZWQgdG8gZ3JhcGhpY3MgY29tbWFuZCBleGVjIG1ldGhvZHMuIFdoZW4gY2FsbGVkIGZyb20gYSBTaGFwZSBpbnN0YW5jZSwgdGhlIHNoYXBlIHBhc3NlcyBpdHNlbGYgYXMgdGhlIGRhdGEgcGFyYW1ldGVyLiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbSBncmFwaGljIGNvbW1hbmRzIHRvIGluc2VydCBjb250ZXh0dWFsIGRhdGEuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBkYXRhKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGZvciAodmFyIGk9dGhpcy5fc3RvcmVJbmRleCwgbD1pbnN0ci5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpbnN0cltpXS5leGVjKGN0eCwgZGF0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBvbmx5IHRoZSBwYXRoIGRlc2NyaWJlZCBmb3IgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSwgc2tpcHBpbmcgYW55IG5vbi1wYXRoIGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGZpbGwgYW5kXG5cdCAqIHN0cm9rZSBkZXNjcmlwdGlvbnMuIFVzZWQgZm9yIDxjb2RlPkRpc3BsYXlPYmplY3QubWFzazwvY29kZT4gdG8gZHJhdyB0aGUgY2xpcHBpbmcgcGF0aCwgZm9yIGV4YW1wbGUuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3QXNQYXRoXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqKi9cblx0cC5kcmF3QXNQYXRoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyLCBpbnN0cnMgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3Rycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgY29tbWFuZCBpcyBhbHdheXMgYSBiZWdpblBhdGggY29tbWFuZC5cblx0XHRcdGlmICgoaW5zdHIgPSBpbnN0cnNbaV0pLnBhdGggIT09IGZhbHNlKSB7IGluc3RyLmV4ZWMoY3R4KTsgfVxuXHRcdH1cblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1hcCBkaXJlY3RseSB0byBjb250ZXh0IDJEIGNhbGxzOlxuXHQvKipcblx0ICogTW92ZXMgdGhlIGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gQSB0aW55IEFQSSBtZXRob2QgXCJtdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIG1vdmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Nb3ZlVG8oeCx5KSwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgd2hpY2ggYmVjb21lIHRoZSBuZXcgY3VycmVudCBkcmF3aW5nXG5cdCAqIHBvaW50LiBOb3RlIHRoYXQgeW91ICptdXN0KiBjYWxsIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgdGhlIGZpcnN0IGBsaW5lVG8oKWAuXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibHRcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcGxleC1zaGFwZXMtKHBhdGhzKVwiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdCAqIEBtZXRob2QgbGluZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkxpbmVUbyh4LHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYW4gYXJjIHdpdGggdGhlIHNwZWNpZmllZCBjb250cm9sIHBvaW50cyBhbmQgcmFkaXVzLiAgRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjdG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyBkZWZpbmVkIGJ5IHRoZSByYWRpdXMsIHN0YXJ0QW5nbGUgYW5kIGVuZEFuZ2xlIGFyZ3VtZW50cywgY2VudGVyZWQgYXQgdGhlIHBvc2l0aW9uICh4LCB5KS4gRm9yXG5cdCAqIGV4YW1wbGUsIHRvIGRyYXcgYSBmdWxsIGNpcmNsZSB3aXRoIGEgcmFkaXVzIG9mIDIwIGNlbnRlcmVkIGF0ICgxMDAsIDEwMCk6XG5cdCAqXG5cdCAqICAgICAgYXJjKDEwMCwgMTAwLCAyMCwgMCwgTWF0aC5QSSoyKTtcblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjXCI+d2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImFcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBhcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcXVhZHJhdGljIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnQgKGNweCwgY3B5KS4gRm9yIGRldGFpbGVkXG5cdCAqIGluZm9ybWF0aW9uLCByZWFkIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcXVhZHJhdGljY3VydmV0b1wiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwicXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGNweCwgY3B5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBiZXppZXIgY3VydmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvICh4LCB5KSB1c2luZyB0aGUgY29udHJvbCBwb2ludHMgKGNwMXgsIGNwMXkpIGFuZCAoY3AyeCxcblx0ICogY3AyeSkuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWJlemllcmN1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImJ0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmV6aWVyQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmVjdGFuZ2xlIGF0ICh4LCB5KSB3aXRoIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodCB1c2luZyB0aGUgY3VycmVudCBmaWxsIGFuZC9vciBzdHJva2UuXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXJlY3RcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInJcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCByZWN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJlY3QoeCwgeSwgdywgaCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCwgZWZmZWN0aXZlbHkgZHJhd2luZyBhIGxpbmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvIHRoZSBmaXJzdCBkcmF3aW5nIHBvaW50IHNwZWNpZmllZFxuXHQgKiBzaW5jZSB0aGUgZmlsbCBvciBzdHJva2Ugd2FzIGxhc3Qgc2V0LiBBIHRpbnkgQVBJIG1ldGhvZCBcImNwXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgY2xvc2VQYXRoXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA/IHRoaXMuYXBwZW5kKG5ldyBHLkNsb3NlUGF0aCgpKSA6IHRoaXM7XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHMgdGhhdCByb3VnaGx5IG1hcCB0byBGbGFzaCBncmFwaGljcyBBUElzOlxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucywgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIEFueSBsaW5lIGFuZCBmaWxsIHN0eWxlcyB3aWxsIG5lZWRcblx0ICogdG8gYmUgcmVkZWZpbmVkIHRvIGRyYXcgc2hhcGVzIGZvbGxvd2luZyBhIGNsZWFyIGNhbGwuIEEgdGlueSBBUEkgbWV0aG9kIFwiY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsZWFyXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2UgPSB0aGlzLl9maWxsID0gdGhpcy5fc3Ryb2tlRGFzaCA9IHRoaXMuX29sZFN0cm9rZURhc2ggPSBudWxsO1xuXHRcdHRoaXMuX2RpcnR5ID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgZmlsbCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5GaWxsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5GaWxsID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChjb2xvciA/IG5ldyBHLkZpbGwoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBmaWxsIGRlZmluZWQgYnkgdGhlIGxpbmUgKHgwLCB5MCkgdG8gKHgxLCB5MSkuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yXG5cdCAqIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgYmxhY2sgdG8gd2hpdGUgdmVydGljYWwgZ3JhZGllbnQgcmFuZ2luZyBmcm9tIDIwcHggdG8gMTIwcHgsIGFuZCBkcmF3cyBhXG5cdCAqIHNxdWFyZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5saW5lYXJHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcmFkaWFsIGdyYWRpZW50IGZpbGwuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIGNpcmNsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKS5kcmF3Q2lyY2xlKDEwMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicmZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblJhZGlhbEdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcImJmXCIgYWxzb1xuXHQgKiBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5CaXRtYXBGaWxsXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwRmlsbCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKG51bGwsbWF0cml4KS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBmaWxsLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luRmlsbChudWxsKTwvY29kZT4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZWZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBlbmRGaWxsXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRGaWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5GaWxsKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN0cm9rZSBzdHlsZS4gTGlrZSBhbGwgZHJhd2luZyBtZXRob2RzLCB0aGlzIGNhbiBiZSBjaGFpbmVkLCBzbyB5b3UgY2FuIGRlZmluZVxuXHQgKiB0aGUgc3Ryb2tlIHN0eWxlIGFuZCBjb2xvciBpbiBhIHNpbmdsZSBsaW5lIG9mIGNvZGUgbGlrZSBzbzpcblx0ICpcblx0ICogXHRteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDgsXCJyb3VuZFwiKS5iZWdpblN0cm9rZShcIiNGMDBcIik7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwic3NcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VTdHlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuY29tbWFuZCA9IG5ldyBHLlN0cm9rZVN0eWxlKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSk7XG5cblx0XHQvLyBpZ25vcmVTY2FsZSBsaXZlcyBvbiBTdHJva2UsIG5vdCBTdHJva2VTdHlsZSwgc28gd2UgZG8gYSBsaXR0bGUgdHJpY2tlcnk6XG5cdFx0aWYgKHRoaXMuX3N0cm9rZSkgeyB0aGlzLl9zdHJva2UuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTsgfVxuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBvciBjbGVhcnMgdGhlIHN0cm9rZSBkYXNoIHBhdHRlcm4uXG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VEYXNoKFsyMCwgMTBdLCAwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgYHNkYCBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VEYXNoXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIGBbMjAsMTBdYCB3b3VsZCBjcmVhdGUgYSBwYXR0ZXJuIG9mIDIwIHBpeGVsIGxpbmVzIHdpdGggMTAgcGl4ZWwgZ2FwcyBiZXR3ZWVuIHRoZW0uXG5cdCAqIFBhc3NpbmcgbnVsbCBvciBhbiBlbXB0eSBhcnJheSB3aWxsIGNsZWFyIHRoZSBleGlzdGluZyBzdHJva2UgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnNldFN0cm9rZURhc2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VEYXNoKHNlZ21lbnRzLCBvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBzdHJva2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwic1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luU3Ryb2tlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpblN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShjb2xvciA/IG5ldyBHLlN0cm9rZShjb2xvcikgOiBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgbGluZWFyIGdyYWRpZW50IHN0cm9rZSBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKS5cblx0ICogICAgICAgICAgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZShbXCIjMDAwXCIsXCIjRkZGXCJdLCBbMCwgMV0sIDAsIDIwLCAwLCAxMjApLmRyYXdSZWN0KDIwLCAyMCwgMTIwLCAxMjApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImxzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBzdHJva2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIHJlY3RhbmdsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApXG5cdCAqICAgICAgICAgIC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MClcblx0ICogICAgICAgICAgLmRyYXdSZWN0KDUwLCA5MCwgMTUwLCAxMTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLCB0aGVuIGRyYXcgdGhlIHNlY29uZCBjb2xvclxuXHQgKiB0byAxMDAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBOb3RlIHRoYXQgdW5saWtlIGJpdG1hcCBmaWxscyxcblx0ICogc3Ryb2tlcyBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgYSBtYXRyaXggcGFyYW1ldGVyIGR1ZSB0byBsaW1pdGF0aW9ucyBpbiB0aGUgY2FudmFzIEFQSS4gQSB0aW55IEFQSSBtZXRob2QgXCJic1wiXG5cdCAqIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwU3Ryb2tlXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwU3Ryb2tlID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHQvLyBOT1RFOiBtYXRyaXggaXMgbm90IHN1cHBvcnRlZCBmb3Igc3Ryb2tlIGJlY2F1c2UgdHJhbnNmb3JtcyBvbiBzdHJva2VzIGFsc28gYWZmZWN0IHRoZSBkcmF3biBzdHJva2Ugd2lkdGguXG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBzdHJva2UuIEZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gPGNvZGU+YmVnaW5TdHJva2UobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kU3Ryb2tlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRTdHJva2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWdpblN0cm9rZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+Y3VydmVUbygpPC9jb2RlPiBtZXRob2QgdG8gdGhlIGZ1bmN0aW9uYWxseSBzaW1pbGFyIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHF1YWRyYXRpY0N1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jdXJ2ZVRvID0gcC5xdWFkcmF0aWNDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+ZHJhd1JlY3QoKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBkcmF3UmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UmVjdCA9IHAucmVjdDtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGFsbCBjb3JuZXJzIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIENvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdENvbXBsZXgoeCwgeSwgdywgaCwgcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGRpZmZlcmVudCBjb3JuZXIgcmFkaWkuIFN1cHBvcnRzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb3JuZXIgcmFkaWkuIEEgdGlueSBBUElcblx0ICogbWV0aG9kIFwicmNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Um91bmRSZWN0Q29tcGxleFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMIFRvcCBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUiBUb3AgcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSIEJvdHRvbSByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkwgQm90dG9tIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdSb3VuZFJlY3RDb21wbGV4ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYXQgKHgsIHkpLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqXHQgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICpcdCAgICBnLmJlZ2luU3Ryb2tlKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigwLDAsMCkpO1xuXHQgKlx0ICAgIGcuYmVnaW5GaWxsKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigyNTUsMCwwKSk7XG5cdCAqXHQgICAgZy5kcmF3Q2lyY2xlKDAsMCwzKTtcblx0ICpcblx0ICpcdCAgICB2YXIgcyA9IG5ldyBjcmVhdGVqcy5TaGFwZShnKTtcblx0ICpcdFx0cy54ID0gMTAwO1xuXHQgKlx0XHRzLnkgPSAxMDA7XG5cdCAqXG5cdCAqXHQgICAgc3RhZ2UuYWRkQ2hpbGQocyk7XG5cdCAqXHQgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZGNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Q2lyY2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5DaXJjbGUoeCwgeSwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGVsbGlwc2UgKG92YWwpIHdpdGggYSBzcGVjaWZpZWQgd2lkdGggKHcpIGFuZCBoZWlnaHQgKGgpLiBTaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGV4Y2VwdCB0aGUgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgZGlmZmVyZW50LiBBIHRpbnkgQVBJIG1ldGhvZCBcImRlXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0VsbGlwc2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGxlZnQgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRvcCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gdGhlIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIGhlaWdodCAoaG9yaXpvbnRhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSBob3Jpem9udGFsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpc1xuXHQgKiBudW1iZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSB3aWR0aCAodmVydGljYWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgdmVydGljYWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzIG51bWJlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5FbGxpcHNlKHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBzdGFyIGlmIHBvaW50U2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgb3IgYSByZWd1bGFyIHBvbHlnb24gaWYgcG9pbnRTaXplIGlzIDAgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxuXHQgKiBwb2ludHMuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgd2lsbCBkcmF3IGEgZmFtaWxpYXIgNSBwb2ludGVkIHN0YXIgc2hhcGUgY2VudGVyZWQgYXQgMTAwLCAxMDAgYW5kIHdpdGggYVxuXHQgKiByYWRpdXMgb2YgNTA6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCIjRkYwXCIpLmRyYXdQb2x5U3RhcigxMDAsIDEwMCwgNTAsIDUsIDAuNiwgLTkwKTtcblx0ICogICAgICAvLyBOb3RlOiAtOTAgbWFrZXMgdGhlIGZpcnN0IHBvaW50IHZlcnRpY2FsXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZHBcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogQG1ldGhvZCBkcmF3UG9seVN0YXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXMgVGhlIG51bWJlciBvZiBwb2ludHMgb24gdGhlIHN0YXIgb3Igc2lkZXMgb24gdGhlIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemUgVGhlIGRlcHRoIG9yIFwicG9pbnR5LW5lc3NcIiBvZiB0aGUgc3RhciBwb2ludHMuIEEgcG9pbnRTaXplIG9mIDAgd2lsbCBkcmF3IGEgcmVndWxhclxuXHQgKiBwb2x5Z29uIChubyBwb2ludHMpLCBhIHBvaW50U2l6ZSBvZiAxIHdpbGwgZHJhdyBub3RoaW5nIGJlY2F1c2UgdGhlIHBvaW50cyBhcmUgaW5maW5pdGVseSBwb2ludHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IC8gY29ybmVyLiBGb3IgZXhhbXBsZSBhIHZhbHVlIG9mIDAgd2lsbCBkcmF3IHRoZSBmaXJzdCBwb2ludFxuXHQgKiBkaXJlY3RseSB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbnRlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdQb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUG9seVN0YXIoeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkpO1xuXHR9O1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdC8qKlxuXHQgKiBSZW1vdmVkIGluIGZhdm91ciBvZiB1c2luZyBjdXN0b20gY29tbWFuZCBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluamVjdFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCB0byB0aGUgZ3JhcGhpY3MgcXVldWUuIENvbW1hbmQgb2JqZWN0cyBleHBvc2UgYW4gXCJleGVjXCIgbWV0aG9kXG5cdCAqIHRoYXQgYWNjZXB0cyB0d28gcGFyYW1ldGVyczogdGhlIENvbnRleHQyRCB0byBvcGVyYXRlIG9uLCBhbmQgYW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0IHBhc3NlZCBpbnRvXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uIFRoZSBsYXR0ZXIgd2lsbCB1c3VhbGx5IGJlIHRoZSBTaGFwZSBpbnN0YW5jZSB0aGF0IGNhbGxlZCBkcmF3LlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgYnkgR3JhcGhpY3MgbWV0aG9kcywgc3VjaCBhcyBkcmF3Q2lyY2xlLCBidXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSB0byBpbnNlcnRcblx0ICogYnVpbHQtaW4gb3IgY3VzdG9tIGdyYXBoaWNzIGNvbW1hbmRzLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogXHRcdC8vIGF0dGFjaCBkYXRhIHRvIG91ciBzaGFwZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIGRyYXc6XG5cdCAqIFx0XHRteVNoYXBlLmNvbG9yID0gXCJyZWRcIjtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIENpcmNsZSBjb21tYW5kIG9iamVjdDpcblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKG5ldyBjcmVhdGVqcy5HcmFwaGljcy5DaXJjbGUoNTAsIDUwLCAzMCkpO1xuXHQgKlxuXHQgKiBcdFx0Ly8gYXBwZW5kIGEgY3VzdG9tIGNvbW1hbmQgb2JqZWN0IHdpdGggYW4gZXhlYyBtZXRob2QgdGhhdCBzZXRzIHRoZSBmaWxsIHN0eWxlXG5cdCAqIFx0XHQvLyBiYXNlZCBvbiB0aGUgc2hhcGUncyBkYXRhLCBhbmQgdGhlbiBmaWxscyB0aGUgY2lyY2xlLlxuXHQgKiBcdFx0bXlTaGFwZS5ncmFwaGljcy5hcHBlbmQoe2V4ZWM6ZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuXHQgKiBcdFx0XHRjdHguZmlsbFN0eWxlID0gc2hhcGUuY29sb3I7XG5cdCAqIFx0XHRcdGN0eC5maWxsKCk7XG5cdCAqIFx0XHR9fSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb21tYW5kIEEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgZXhwb3NpbmcgYW4gXCJleGVjXCIgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFuIFRoZSBjbGVhbiBwYXJhbSBpcyBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gQSB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGEgY29tbWFuZCBkb2VzIG5vdCBnZW5lcmF0ZSBhIHBhdGggdGhhdCBzaG91bGQgYmUgc3Ryb2tlZCBvciBmaWxsZWQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbihjb21tYW5kLCBjbGVhbikge1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5wdXNoKGNvbW1hbmQpO1xuXHRcdHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG5cdFx0aWYgKCFjbGVhbikgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhIGNvbXBhY3QgZW5jb2RlZCBwYXRoIHN0cmluZyBpbnRvIGEgc2VyaWVzIG9mIGRyYXcgaW5zdHJ1Y3Rpb25zLlxuXHQgKiBUaGlzIGZvcm1hdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4gcmVhZGFibGUsIGFuZCBpcyBtZWFudCBmb3IgdXNlIGJ5IGF1dGhvcmluZyB0b29scy5cblx0ICogVGhlIGZvcm1hdCB1c2VzIGEgYmFzZTY0IGNoYXJhY3RlciBzZXQsIHdpdGggZWFjaCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nIDYgYml0cywgdG8gZGVmaW5lIGEgc2VyaWVzIG9mIGRyYXdcblx0ICogY29tbWFuZHMuXG5cdCAqXG5cdCAqIEVhY2ggY29tbWFuZCBpcyBjb21wcmlzZWQgb2YgYSBzaW5nbGUgXCJoZWFkZXJcIiBjaGFyYWN0ZXIgZm9sbG93ZWQgYnkgYSB2YXJpYWJsZSBudW1iZXIgb2YgYWx0ZXJuYXRpbmcgeCBhbmQgeVxuXHQgKiBwb3NpdGlvbiB2YWx1ZXMuIFJlYWRpbmcgdGhlIGhlYWRlciBiaXRzIGZyb20gbGVmdCB0byByaWdodCAobW9zdCB0byBsZWFzdCBzaWduaWZpY2FudCk6IGJpdHMgMSB0byAzIHNwZWNpZnkgdGhlXG5cdCAqIHR5cGUgb2Ygb3BlcmF0aW9uICgwLW1vdmVUbywgMS1saW5lVG8sIDItcXVhZHJhdGljQ3VydmVUbywgMy1iZXppZXJDdXJ2ZVRvLCA0LWNsb3NlUGF0aCwgNS03IHVudXNlZCkuIEJpdCA0XG5cdCAqIGluZGljYXRlcyB3aGV0aGVyIHBvc2l0aW9uIHZhbHVlcyB1c2UgMTIgYml0cyAoMiBjaGFyYWN0ZXJzKSBvciAxOCBiaXRzICgzIGNoYXJhY3RlcnMpLCB3aXRoIGEgb25lIGluZGljYXRpbmcgdGhlXG5cdCAqIGxhdHRlci4gQml0cyA1IGFuZCA2IGFyZSBjdXJyZW50bHkgdW51c2VkLlxuXHQgKlxuXHQgKiBGb2xsb3dpbmcgdGhlIGhlYWRlciBpcyBhIHNlcmllcyBvZiAwIChjbG9zZVBhdGgpLCAyIChtb3ZlVG8sIGxpbmVUbyksIDQgKHF1YWRyYXRpY0N1cnZlVG8pLCBvciA2IChiZXppZXJDdXJ2ZVRvKVxuXHQgKiBwYXJhbWV0ZXJzLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZSBhbHRlcm5hdGluZyB4L3kgcG9zaXRpb25zIHJlcHJlc2VudGVkIGJ5IDIgb3IgMyBjaGFyYWN0ZXJzIChhcyBpbmRpY2F0ZWQgYnkgdGhlXG5cdCAqIDR0aCBiaXQgaW4gdGhlIGNvbW1hbmQgY2hhcikuIFRoZXNlIGNoYXJhY3RlcnMgY29uc2lzdCBvZiBhIDEgYml0IHNpZ24gKDEgaXMgbmVnYXRpdmUsIDAgaXMgcG9zaXRpdmUpLCBmb2xsb3dlZFxuXHQgKiBieSBhbiAxMSAoMiBjaGFyKSBvciAxNyAoMyBjaGFyKSBiaXQgaW50ZWdlciB2YWx1ZS4gQWxsIHBvc2l0aW9uIHZhbHVlcyBhcmUgaW4gdGVudGhzIG9mIGEgcGl4ZWwuIEV4Y2VwdCBpbiB0aGVcblx0ICogY2FzZSBvZiBtb3ZlIG9wZXJhdGlvbnMgd2hpY2ggYXJlIGFic29sdXRlLCB0aGlzIHZhbHVlIGlzIGEgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgeCBvciB5IHBvc2l0aW9uIChhc1xuXHQgKiBhcHByb3ByaWF0ZSkuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwiQTNjQUFNQXU0QUFBXCIgcmVwcmVzZW50cyBhIGxpbmUgc3RhcnRpbmcgYXQgLTE1MCwwIGFuZCBlbmRpbmcgYXQgMTUwLDAuXG5cdCAqIDxiciAvPkEgLSBiaXRzIDAwMDAwMC4gRmlyc3QgMyBiaXRzICgwMDApIGluZGljYXRlIGEgbW92ZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMCkgaW5kaWNhdGVzIDIgY2hhcnMgcGVyXG5cdCAqIHBhcmFtZXRlci5cblx0ICogPGJyIC8+bjAgLSAxMTAxMTEwMTExMDAuIEFic29sdXRlIHggcG9zaXRpb24gb2YgLTE1MC4wcHguIEZpcnN0IGJpdCBpbmRpY2F0ZXMgYSBuZWdhdGl2ZSB2YWx1ZSwgcmVtYWluaW5nIGJpdHNcblx0ICogaW5kaWNhdGUgMTUwMCB0ZW50aHMgb2YgYSBwaXhlbC5cblx0ICogPGJyIC8+QUEgLSAwMDAwMDAwMDAwMDAuIEFic29sdXRlIHkgcG9zaXRpb24gb2YgMC5cblx0ICogPGJyIC8+SSAtIDAwMTEwMC4gRmlyc3QgMyBiaXRzICgwMDEpIGluZGljYXRlIGEgbGluZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMSkgaW5kaWNhdGVzIDMgY2hhcnMgcGVyIHBhcmFtZXRlci5cblx0ICogPGJyIC8+QXU0IC0gMDAwMDAwMTAxMTEwMTExMDAwLiBBbiB4IGRlbHRhIG9mIDMwMC4wcHgsIHdoaWNoIGlzIGFkZGVkIHRvIHRoZSBwcmV2aW91cyB4IHZhbHVlIG9mIC0xNTAuMHB4IHRvXG5cdCAqIHByb3ZpZGUgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgKzE1MC4wcHguXG5cdCAqIDxiciAvPkFBQSAtIDAwMDAwMDAwMDAwMDAwMDAwMC4gQSB5IGRlbHRhIHZhbHVlIG9mIDAuXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRlY29kZVBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZGVjb2RlUGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBpbnN0cnVjdGlvbnMgPSBbdGhpcy5tb3ZlVG8sIHRoaXMubGluZVRvLCB0aGlzLnF1YWRyYXRpY0N1cnZlVG8sIHRoaXMuYmV6aWVyQ3VydmVUbywgdGhpcy5jbG9zZVBhdGhdO1xuXHRcdHZhciBwYXJhbUNvdW50ID0gWzIsIDIsIDQsIDYsIDBdO1xuXHRcdHZhciBpPTAsIGw9c3RyLmxlbmd0aDtcblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0dmFyIHg9MCwgeT0wO1xuXHRcdHZhciBiYXNlNjQgPSBHcmFwaGljcy5CQVNFXzY0O1xuXG5cdFx0d2hpbGUgKGk8bCkge1xuXHRcdFx0dmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0dmFyIG4gPSBiYXNlNjRbY107XG5cdFx0XHR2YXIgZmkgPSBuPj4zOyAvLyBoaWdoZXN0IG9yZGVyIGJpdHMgMS0zIGNvZGUgZm9yIG9wZXJhdGlvbi5cblx0XHRcdHZhciBmID0gaW5zdHJ1Y3Rpb25zW2ZpXTtcblx0XHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIGluc3RydWN0aW9uICYgdGhhdCB0aGUgdW51c2VkIGJpdHMgYXJlIGVtcHR5OlxuXHRcdFx0aWYgKCFmIHx8IChuJjMpKSB7IHRocm93KFwiYmFkIHBhdGggZGF0YSAoQFwiK2krXCIpOiBcIitjKTsgfVxuXHRcdFx0dmFyIHBsID0gcGFyYW1Db3VudFtmaV07XG5cdFx0XHRpZiAoIWZpKSB7IHg9eT0wOyB9IC8vIG1vdmUgb3BlcmF0aW9ucyByZXNldCB0aGUgcG9zaXRpb24uXG5cdFx0XHRwYXJhbXMubGVuZ3RoID0gMDtcblx0XHRcdGkrKztcblx0XHRcdHZhciBjaGFyQ291bnQgPSAobj4+MiYxKSsyOyAgLy8gNHRoIGhlYWRlciBiaXQgaW5kaWNhdGVzIG51bWJlciBzaXplIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0XHRcdGZvciAodmFyIHA9MDsgcDxwbDsgcCsrKSB7XG5cdFx0XHRcdHZhciBudW0gPSBiYXNlNjRbc3RyLmNoYXJBdChpKV07XG5cdFx0XHRcdHZhciBzaWduID0gKG51bT4+NSkgPyAtMSA6IDE7XG5cdFx0XHRcdG51bSA9ICgobnVtJjMxKTw8Nil8KGJhc2U2NFtzdHIuY2hhckF0KGkrMSldKTtcblx0XHRcdFx0aWYgKGNoYXJDb3VudCA9PSAzKSB7IG51bSA9IChudW08PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzIpXSk7IH1cblx0XHRcdFx0bnVtID0gc2lnbipudW0vMTA7XG5cdFx0XHRcdGlmIChwJTIpIHsgeCA9IChudW0gKz0geCk7IH1cblx0XHRcdFx0ZWxzZSB7IHkgPSAobnVtICs9IHkpOyB9XG5cdFx0XHRcdHBhcmFtc1twXSA9IG51bTtcblx0XHRcdFx0aSArPSBjaGFyQ291bnQ7XG5cdFx0XHR9XG5cdFx0XHRmLmFwcGx5KHRoaXMscGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhbGwgZ3JhcGhpY3MgY29tbWFuZHMgc28gdGhleSB3b24ndCBiZSBleGVjdXRlZCBpbiBmdXR1cmUgZHJhd3MuIENhbGxpbmcgc3RvcmUoKSBhIHNlY29uZCB0aW1lIGFkZHMgdG9cblx0ICogdGhlIGV4aXN0aW5nIHN0b3JlLiBUaGlzIGFsc28gYWZmZWN0cyBgZHJhd0FzUGF0aCgpYC5cblx0ICpcblx0ICogVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGFyZSBjcmVhdGluZyB2ZWN0b3IgZ3JhcGhpY3MgaW4gYW4gaXRlcmF0aXZlIG1hbm5lciAoZXguIGdlbmVyYXRpdmUgYXJ0KSwgc29cblx0ICogdGhhdCBvbmx5IG5ldyBncmFwaGljcyBuZWVkIHRvIGJlIGRyYXduICh3aGljaCBjYW4gcHJvdmlkZSBodWdlIHBlcmZvcm1hbmNlIGJlbmVmaXRzKSwgYnV0IHlvdSB3aXNoIHRvIHJldGFpbiBhbGxcblx0ICogb2YgdGhlIHZlY3RvciBpbnN0cnVjdGlvbnMgZm9yIGxhdGVyIHVzZSAoZXguIHNjYWxpbmcsIG1vZGlmeWluZywgb3IgZXhwb3J0aW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGNhbGxpbmcgc3RvcmUoKSB3aWxsIGZvcmNlIHRoZSBhY3RpdmUgcGF0aCAoaWYgYW55KSB0byBiZSBlbmRlZCBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIGNoYW5naW5nXG5cdCAqIHRoZSBmaWxsIG9yIHN0cm9rZS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGEgYXBwbGljYXRpb24gd2hlcmUgdGhlIHVzZXIgZHJhd3MgbGluZXMgd2l0aCB0aGUgbW91c2UuIEFzIGVhY2ggbGluZSBzZWdtZW50IChvciBjb2xsZWN0aW9uIG9mXG5cdCAqIHNlZ21lbnRzKSBhcmUgYWRkZWQgdG8gYSBTaGFwZSwgaXQgY2FuIGJlIHJhc3Rlcml6ZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHRoZW4gc3RvcmVkLCBzbyB0aGF0IGl0IGNhbiBiZSByZWRyYXduIGF0IGEgZGlmZmVyZW50IHNjYWxlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlc2l6ZWQsIG9yIGV4cG9ydGVkIHRvIFNWRy5cblx0ICpcblx0ICogXHQvLyBzZXQgdXAgY2FjaGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxzY2FsZSk7XG5cdCAqXG5cdCAqIFx0Ly8gd2hlbiB0aGUgdXNlciBkcmFncywgZHJhdyBhIG5ldyBsaW5lOlxuXHQgKiBcdG15U2hhcGUuZ3JhcGhpY3MubW92ZVRvKG9sZFgsb2xkWSkubGluZVRvKG5ld1gsbmV3WSk7XG5cdCAqIFx0Ly8gdGhlbiBkcmF3IGl0IGludG8gdGhlIGV4aXN0aW5nIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUudXBkYXRlQ2FjaGUoXCJzb3VyY2Utb3ZlclwiKTtcblx0ICogXHQvLyBzdG9yZSB0aGUgbmV3IGxpbmUsIHNvIGl0IGlzbid0IHJlZHJhd24gbmV4dCB0aW1lOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogXHQvLyB0aGVuLCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgY2FuIHJlLXJlbmRlciBhdCBhIGRpZmZlcmVudCBzY2FsZTpcblx0ICogXHQvLyBmaXJzdCwgdW5zdG9yZSBhbGwgb3VyIGxpbmVzOlxuXHQgKiBcdG15U2hhcGUudW5zdG9yZSgpO1xuXHQgKiBcdC8vIHRoZW4gY2FjaGUgdXNpbmcgdGhlIG5ldyBzY2FsZTpcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCw1MDAsNTAwLG5ld1NjYWxlKTtcblx0ICogXHQvLyBmaW5hbGx5LCBzdG9yZSB0aGUgZXhpc3RpbmcgY29tbWFuZHMgYWdhaW46XG5cdCAqIFx0bXlTaGFwZS5zdG9yZSgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3JlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gdGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVW5zdG9yZXMgYW55IGdyYXBoaWNzIGNvbW1hbmRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHN0b3JlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zdG9yZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBzbyB0aGF0IHRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiBzdWJzZXF1ZW50IGRyYXcgY2FsbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgdW5zdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAudW5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBHcmFwaGljcyBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBpbmRpdmlkdWFsIGNvbW1hbmQgb2JqZWN0cyBhcmUgbm90IGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBHcmFwaGljcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSBuZXcgR3JhcGhpY3MoKTtcblx0XHRvLmNvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG5cdFx0by5fc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xuXHRcdG8uX3N0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0by5fc3Ryb2tlRGFzaCA9IHRoaXMuX3N0cm9rZURhc2g7XG5cdFx0by5fc3Ryb2tlSWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHRvLl9maWxsID0gdGhpcy5fZmlsbDtcblx0XHRvLl9pbnN0cnVjdGlvbnMgPSB0aGlzLl9pbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9jb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXHRcdG8uX2FjdGl2ZUluc3RydWN0aW9ucyA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5zbGljZSgpO1xuXHRcdG8uX2RpcnR5ID0gdGhpcy5fZGlydHk7XG5cdFx0by5fc3RvcmVJbmRleCA9IHRoaXMuX3N0b3JlSW5kZXg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltHcmFwaGljc11cIjtcblx0fTtcblxuXG4vLyB0aW55IEFQSTpcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIG1vdmVUby5cblx0ICogQG1ldGhvZCBtdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5tdCA9IHAubW92ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBsaW5lVG8uXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHQgPSBwLmxpbmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjVG8uXG5cdCAqIEBtZXRob2QgYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYXQgPSBwLmFyY1RvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZXppZXJDdXJ2ZVRvLlxuXHQgKiBAbWV0aG9kIGJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJ0ID0gcC5iZXppZXJDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBxdWFkcmF0aWNDdXJ2ZVRvIC8gY3VydmVUby5cblx0ICogQG1ldGhvZCBxdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5xdCA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjLlxuXHQgKiBAbWV0aG9kIGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmEgPSBwLmFyYztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcmVjdC5cblx0ICogQG1ldGhvZCByXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuciA9IHAucmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gY2xvc2VQYXRoLlxuXHQgKiBAbWV0aG9kIGNwXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNwID0gcC5jbG9zZVBhdGg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsZWFyLlxuXHQgKiBAbWV0aG9kIGNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYyA9IHAuY2xlYXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luRmlsbC5cblx0ICogQG1ldGhvZCBmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5mID0gcC5iZWdpbkZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIGxmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxmID0gcC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwuXG5cdCAqIEBtZXRob2QgcmZcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucmYgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcEZpbGwuXG5cdCAqIEBtZXRob2QgYmZcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlcGV0aXRpb24gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mIFwicmVwZWF0XCIsXG5cdCAqIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLiBOb3RlIHRoYXQgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IFwicmVwZWF0LXhcIiBvclxuXHQgKiBcInJlcGVhdC15XCIgKGxhdGVzdCB0ZXN0cyB3ZXJlIGluIEZGIDIwLjApLCBhbmQgd2lsbCBkZWZhdWx0IHRvIFwicmVwZWF0XCIuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gU3BlY2lmaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZvciB0aGUgYml0bWFwIGZpbGwuIFRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5iZiA9IHAuYmVnaW5CaXRtYXBGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRGaWxsLlxuXHQgKiBAbWV0aG9kIGVmXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVmID0gcC5lbmRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VTdHlsZS5cblx0ICogQG1ldGhvZCBzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNzID0gcC5zZXRTdHJva2VTdHlsZTtcblx0XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VEYXNoLlxuXHQgKiBAbWV0aG9kIHNkXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIFsyMCwxMF0gd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciBhbnkgZXhpc3RpbmcgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuc2QgPSBwLnNldFN0cm9rZURhc2g7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcIiNGRjAwMDBcIiwgXCJyZWRcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIHN0cm9rZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucyA9IHAuYmVnaW5TdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgbHNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHMgPSBwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgcnNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnMgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luQml0bWFwU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGJzXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYnMgPSBwLmJlZ2luQml0bWFwU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRTdHJva2UuXG5cdCAqIEBtZXRob2QgZXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZXMgPSBwLmVuZFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JlY3QuXG5cdCAqIEBtZXRob2QgZHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kciA9IHAuZHJhd1JlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3QuXG5cdCAqIEBtZXRob2QgcnJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yciA9IHAuZHJhd1JvdW5kUmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JvdW5kUmVjdENvbXBsZXguXG5cdCAqIEBtZXRob2QgcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJjID0gcC5kcmF3Um91bmRSZWN0Q29tcGxleDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd0NpcmNsZS5cblx0ICogQG1ldGhvZCBkY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZGMgPSBwLmRyYXdDaXJjbGU7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdFbGxpcHNlLlxuXHQgKiBAbWV0aG9kIGRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRlID0gcC5kcmF3RWxsaXBzZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1BvbHlTdGFyLlxuXHQgKiBAbWV0aG9kIGRwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRwID0gcC5kcmF3UG9seVN0YXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRlY29kZVBhdGguXG5cdCAqIEBtZXRob2QgcFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBwYXRoIHN0cmluZyB0byBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnAgPSBwLmRlY29kZVBhdGg7XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlSW5zdHJ1Y3Rpb25zXG5cdCAqIEBwYXJhbSBjb21taXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uKGNvbW1pdCkge1xuXHRcdHZhciBpbnN0ciA9IHRoaXMuX2luc3RydWN0aW9ucywgYWN0aXZlID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLCBjb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXG5cdFx0aWYgKHRoaXMuX2RpcnR5ICYmIGFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdGluc3RyLmxlbmd0aCA9IGNvbW1pdEluZGV4OyAvLyByZW1vdmUgb2xkLCB1bmNvbW1pdHRlZCBjb21tYW5kc1xuXHRcdFx0aW5zdHIucHVzaChHcmFwaGljcy5iZWdpbkNtZCk7XG5cblx0XHRcdHZhciBsID0gYWN0aXZlLmxlbmd0aCwgbGwgPSBpbnN0ci5sZW5ndGg7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBsbCtsO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBpbnN0cltpK2xsXSA9IGFjdGl2ZVtpXTsgfVxuXG5cdFx0XHRpZiAodGhpcy5fZmlsbCkgeyBpbnN0ci5wdXNoKHRoaXMuX2ZpbGwpOyB9XG5cdFx0XHRpZiAodGhpcy5fc3Ryb2tlKSB7XG5cdFx0XHRcdC8vIGRvZXNuJ3QgbmVlZCB0byBiZSByZS1hcHBsaWVkIGlmIGl0IGhhc24ndCBjaGFuZ2VkLlxuXHRcdFx0XHRpZiAodGhpcy5fc3Ryb2tlRGFzaCAhPT0gdGhpcy5fb2xkU3Ryb2tlRGFzaCkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlRGFzaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZVN0eWxlICE9PSB0aGlzLl9vbGRTdHJva2VTdHlsZSkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2VTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChjb21taXQpIHtcblx0XHRcdGFjdGl2ZS5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy5fY29tbWl0SW5kZXggPSBpbnN0ci5sZW5ndGg7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRGaWxsXG5cdCAqIEBwYXJhbSBmaWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRGaWxsID0gZnVuY3Rpb24oZmlsbCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLmNvbW1hbmQgPSB0aGlzLl9maWxsID0gZmlsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0U3Ryb2tlXG5cdCAqIEBwYXJhbSBzdHJva2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3NldFN0cm9rZSA9IGZ1bmN0aW9uKHN0cm9rZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHRpZiAodGhpcy5jb21tYW5kID0gdGhpcy5fc3Ryb2tlID0gc3Ryb2tlKSB7XG5cdFx0XHRzdHJva2UuaWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIENvbW1hbmQgT2JqZWN0czpcblx0LyoqXG5cdCAqIEBuYW1lc3BhY2UgR3JhcGhpY3Ncblx0ICovXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2xpbmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIExpbmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubGluZVRvKHRoaXMueCx0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgTW92ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuTW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEFyY1RvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDFcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4MlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeTJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQXJjVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG5cdFx0dGhpcy54MSA9IHgxOyB0aGlzLnkxID0geTE7XG5cdFx0dGhpcy54MiA9IHgyOyB0aGlzLnkyID0geTI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmNUbyh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnJhZGl1cyk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbnRpY2xvY2t3aXNlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHN0YXJ0QW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGVuZEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBhbnRpY2xvY2t3aXNlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5BcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlOyB0aGlzLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG5cdFx0dGhpcy5hbnRpY2xvY2t3aXNlID0gISFhbnRpY2xvY2t3aXNlO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmFudGljbG9ja3dpc2UpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFF1YWRyYXRpY0N1cnZlVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHRoaXMuY3B4ID0gY3B4OyB0aGlzLmNweSA9IGNweTtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucXVhZHJhdGljQ3VydmVUbyh0aGlzLmNweCwgdGhpcy5jcHksIHRoaXMueCwgdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZXppZXJDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZXppZXJDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHR0aGlzLmNwMXggPSBjcDF4OyB0aGlzLmNwMXkgPSBjcDF5O1xuXHRcdHRoaXMuY3AyeCA9IGNwMng7IHRoaXMuY3AyeSA9IGNwMnk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlemllckN1cnZlVG8odGhpcy5jcDF4LCB0aGlzLmNwMXksIHRoaXMuY3AyeCwgdGhpcy5jcDJ5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUmVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2Nsb3NlUGF0aFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQ2xvc2VQYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQ2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5jbG9zZVBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gYmVnaW4gYSBuZXcgcGF0aC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZWdpblBhdGhcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5CZWdpblBhdGggPSBmdW5jdGlvbigpIHtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlZ2luUGF0aCgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luRmlsbFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRmlsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLkZpbGwgPSBmdW5jdGlvbihzdHlsZSwgbWF0cml4KSB7XG5cdFx0dGhpcy5zdHlsZSA9IHN0eWxlO1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguZmlsbFN0eWxlID0gdGhpcy5zdHlsZTtcblx0XHR2YXIgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0aWYgKG10eCkgeyBjdHguc2F2ZSgpOyBjdHgudHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7IH1cblx0XHRjdHguZmlsbCgpO1xuXHRcdGlmIChtdHgpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJGaWxsL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgbGluZWFyR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9Y29sb3JzLmxlbmd0aDsgaTxsOyBpKyspIHsgby5hZGRDb2xvclN0b3AocmF0aW9zW2ldLCBjb2xvcnNbaV0pOyB9XG5cdFx0by5wcm9wcyA9IHtjb2xvcnM6Y29sb3JzLCByYXRpb3M6cmF0aW9zLCB4MDp4MCwgeTA6eTAsIHgxOngxLCB5MTp5MSwgdHlwZTpcImxpbmVhclwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByYWRpYWwgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gIEdyYXBoaWNzLl9jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeDAsIHkwLCByMCwgeDEsIHkxLCByMSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCByMDpyMCwgeDE6eDEsIHkxOnkxLCByMTpyMSwgdHlwZTpcInJhZGlhbFwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSAgTXVzdCBiZSBsb2FkZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBiaXRtYXAgZmlsbCwgb3IgdGhlIGZpbGwgd2lsbCBiZSBlbXB0eS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uXSBPbmUgb2Y6IHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15LCBvciBuby1yZXBlYXQuXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSBHcmFwaGljcy5fY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsIHJlcGV0aXRpb24gfHwgXCJcIik7XG5cdFx0XHRvLnByb3BzID0ge2ltYWdlOiBpbWFnZSwgcmVwZXRpdGlvbjogcmVwZXRpdGlvbiwgdHlwZTogXCJiaXRtYXBcIn07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVNjYWxlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIHN0cm9rZVN0eWxlLlxuXHQgKiBAcHJvcGVydHkgc3R5bGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGlnbm9yZVNjYWxlXG5cdCAqIEB0eXBlIEJvb2xlYW5cblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZSA9IGZ1bmN0aW9uKHN0eWxlLCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnN0eWxlKSB7IHJldHVybjsgfVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnNhdmUoKTsgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7IH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBTdHJva2Ugb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IEcuRmlsbC5wcm90b3R5cGUubGluZWFyR3JhZGllbnQ7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgcmFkaWFsR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLnJhZGlhbEdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJpdG1hcCBmaWxsIHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGJpdG1hcFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gRy5GaWxsLnByb3RvdHlwZS5iaXRtYXA7XG5cdHAucGF0aCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2VTdHlsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY2Fwcz1idXR0XVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2pvaW50cz1taXRlcl1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVTY2FsZT1mYWxzZV1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdpZHRoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIE9uZSBvZjogYnV0dCwgcm91bmQsIHNxdWFyZVxuXHQgKiBAcHJvcGVydHkgY2Fwc1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IHJvdW5kLCBiZXZlbCwgbWl0ZXJcblx0ICogQHByb3BlcnR5IGpvaW50c1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWl0ZXJMaW1pdFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZVN0eWxlID0gZnVuY3Rpb24od2lkdGgsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5jYXBzID0gY2Fwcztcblx0XHR0aGlzLmpvaW50cyA9IGpvaW50cztcblx0XHR0aGlzLm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdHRoaXMuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgubGluZVdpZHRoID0gKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiMVwiIDogdGhpcy53aWR0aCk7XG5cdFx0Y3R4LmxpbmVDYXAgPSAodGhpcy5jYXBzID09IG51bGwgPyBcImJ1dHRcIiA6IChpc05hTih0aGlzLmNhcHMpID8gdGhpcy5jYXBzIDogR3JhcGhpY3MuU1RST0tFX0NBUFNfTUFQW3RoaXMuY2Fwc10pKTtcblx0XHRjdHgubGluZUpvaW4gPSAodGhpcy5qb2ludHMgPT0gbnVsbCA/IFwibWl0ZXJcIiA6IChpc05hTih0aGlzLmpvaW50cykgPyB0aGlzLmpvaW50cyA6IEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQW3RoaXMuam9pbnRzXSkpO1xuXHRcdGN0eC5taXRlckxpbWl0ID0gKHRoaXMubWl0ZXJMaW1pdCA9PSBudWxsID8gXCIxMFwiIDogdGhpcy5taXRlckxpbWl0KTtcblx0XHRjdHguaWdub3JlU2NhbGUgPSAodGhpcy5pZ25vcmVTY2FsZSA9PSBudWxsID8gZmFsc2UgOiB0aGlzLmlnbm9yZVNjYWxlKTtcblx0fTtcblx0cC5wYXRoID0gZmFsc2U7XG5cdFxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VEYXNoXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2VEYXNoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzZWdtZW50c1xuXHQgKiBAdHlwZSBBcnJheVxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBvZmZzZXRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlN0cm9rZURhc2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0fHwwO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHsgLy8gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdFx0XHRjdHguc2V0TGluZURhc2godGhpcy5zZWdtZW50c3x8IEcuU3Ryb2tlRGFzaC5FTVBUWV9TRUdNRU5UUyk7IC8vIGluc3RlYWQgb2YgW10gdG8gcmVkdWNlIGNodXJuLlxuXHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5vZmZzZXR8fDA7XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHNlZ21lbnRzIChpZS4gbm8gZGFzaCkuXG5cdCAqIEBwcm9wZXJ0eSBFTVBUWV9TRUdNRU5UU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0Ry5TdHJva2VEYXNoLkVNUFRZX1NFR01FTlRTID0gW107XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JvdW5kUmVjdENvbXBsZXhcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFJvdW5kUmVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNUTFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzVFJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c0JSXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNCTFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUm91bmRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMudyA9IHc7IHRoaXMuaCA9IGg7XG5cdFx0dGhpcy5yYWRpdXNUTCA9IHJhZGl1c1RMOyB0aGlzLnJhZGl1c1RSID0gcmFkaXVzVFI7XG5cdFx0dGhpcy5yYWRpdXNCUiA9IHJhZGl1c0JSOyB0aGlzLnJhZGl1c0JMID0gcmFkaXVzQkw7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIG1heCA9ICh3PGg/dzpoKS8yO1xuXHRcdHZhciBtVEw9MCwgbVRSPTAsIG1CUj0wLCBtQkw9MDtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgdyA9IHRoaXMudywgaCA9IHRoaXMuaDtcblx0XHR2YXIgclRMID0gdGhpcy5yYWRpdXNUTCwgclRSID0gdGhpcy5yYWRpdXNUUiwgckJSID0gdGhpcy5yYWRpdXNCUiwgckJMID0gdGhpcy5yYWRpdXNCTDtcblxuXHRcdGlmIChyVEwgPCAwKSB7IHJUTCAqPSAobVRMPS0xKTsgfVxuXHRcdGlmIChyVEwgPiBtYXgpIHsgclRMID0gbWF4OyB9XG5cdFx0aWYgKHJUUiA8IDApIHsgclRSICo9IChtVFI9LTEpOyB9XG5cdFx0aWYgKHJUUiA+IG1heCkgeyByVFIgPSBtYXg7IH1cblx0XHRpZiAockJSIDwgMCkgeyByQlIgKj0gKG1CUj0tMSk7IH1cblx0XHRpZiAockJSID4gbWF4KSB7IHJCUiA9IG1heDsgfVxuXHRcdGlmIChyQkwgPCAwKSB7IHJCTCAqPSAobUJMPS0xKTsgfVxuXHRcdGlmIChyQkwgPiBtYXgpIHsgckJMID0gbWF4OyB9XG5cblx0XHRjdHgubW92ZVRvKHgrdy1yVFIsIHkpO1xuXHRcdGN0eC5hcmNUbyh4K3crclRSKm1UUiwgeS1yVFIqbVRSLCB4K3csIHkrclRSLCByVFIpO1xuXHRcdGN0eC5saW5lVG8oeCt3LCB5K2gtckJSKTtcblx0XHRjdHguYXJjVG8oeCt3K3JCUiptQlIsIHkraCtyQlIqbUJSLCB4K3ctckJSLCB5K2gsIHJCUik7XG5cdFx0Y3R4LmxpbmVUbyh4K3JCTCwgeStoKTtcblx0XHRjdHguYXJjVG8oeC1yQkwqbUJMLCB5K2grckJMKm1CTCwgeCwgeStoLXJCTCwgckJMKTtcblx0XHRjdHgubGluZVRvKHgsIHkrclRMKTtcblx0XHRjdHguYXJjVG8oeC1yVEwqbVRMLCB5LXJUTCptVEwsIHgrclRMLCB5LCByVEwpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0fTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBDaXJjbGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQ2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkqMik7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0VsbGlwc2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEVsbGlwc2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5FbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHR2YXIgdyA9IHRoaXMudywgaCA9IHRoaXMuaDtcblxuXHRcdHZhciBrID0gMC41NTIyODQ4O1xuXHRcdHZhciBveCA9ICh3IC8gMikgKiBrO1xuXHRcdHZhciBveSA9IChoIC8gMikgKiBrO1xuXHRcdHZhciB4ZSA9IHggKyB3O1xuXHRcdHZhciB5ZSA9IHkgKyBoO1xuXHRcdHZhciB4bSA9IHggKyB3IC8gMjtcblx0XHR2YXIgeW0gPSB5ICsgaCAvIDI7XG5cblx0XHRjdHgubW92ZVRvKHgsIHltKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4LCB5bS1veSwgeG0tb3gsIHksIHhtLCB5KTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4bStveCwgeSwgeGUsIHltLW95LCB4ZSwgeW0pO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bStveSwgeG0rb3gsIHllLCB4bSwgeWUpO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhtLW94LCB5ZSwgeCwgeW0rb3ksIHgsIHltKTtcblx0fTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3UG9seVN0YXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFBvbHlTdGFyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzaWRlc1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcG9pbnRTaXplXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBhbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuUG9seVN0YXIgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnNpZGVzID0gc2lkZXM7XG5cdFx0dGhpcy5wb2ludFNpemUgPSBwb2ludFNpemU7XG5cdFx0dGhpcy5hbmdsZSA9IGFuZ2xlO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0XHR2YXIgYW5nbGUgPSAodGhpcy5hbmdsZXx8MCkvMTgwKk1hdGguUEk7XG5cdFx0dmFyIHNpZGVzID0gdGhpcy5zaWRlcztcblx0XHR2YXIgcHMgPSAxLSh0aGlzLnBvaW50U2l6ZXx8MCk7XG5cdFx0dmFyIGEgPSBNYXRoLlBJL3NpZGVzO1xuXG5cdFx0Y3R4Lm1vdmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cyk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHNpZGVzOyBpKyspIHtcblx0XHRcdGFuZ2xlICs9IGE7XG5cdFx0XHRpZiAocHMgIT0gMSkge1xuXHRcdFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cypwcywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKnBzKTtcblx0XHRcdH1cblx0XHRcdGFuZ2xlICs9IGE7XG5cdFx0XHRjdHgubGluZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0XHR9XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9O1xuXG5cdC8vIGRvY2NlZCBhYm92ZS5cblx0R3JhcGhpY3MuYmVnaW5DbWQgPSBuZXcgRy5CZWdpblBhdGgoKTsgLy8gc28gd2UgZG9uJ3QgaGF2ZSB0byBpbnN0YW50aWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMuXG5cblxuXHRjcmVhdGVqcy5HcmFwaGljcyA9IEdyYXBoaWNzO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERpc3BsYXlPYmplY3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5T2JqZWN0IGlzIGFuIGFic3RyYWN0IGNsYXNzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS4gSW5zdGVhZCBjb25zdHJ1Y3Qgc3ViY2xhc3NlcyBzdWNoIGFzXG5cdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBkaXNwbGF5IGNsYXNzZXMgaW4gdGhlIEVhc2VsSlMgbGlicmFyeS4gSXQgZGVmaW5lcyB0aGUgY29yZSBwcm9wZXJ0aWVzIGFuZFxuXHQgKiBtZXRob2RzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBkaXNwbGF5IG9iamVjdHMsIHN1Y2ggYXMgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllcyAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGV0YyksXG5cdCAqIGNhY2hpbmcsIGFuZCBtb3VzZSBoYW5kbGVycy5cblx0ICogQGNsYXNzIERpc3BsYXlPYmplY3Rcblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIERpc3BsYXlPYmplY3QoKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFscGhhICh0cmFuc3BhcmVuY3kpIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgY2FjaGUgaXMgYWN0aXZlLCB0aGlzIHJldHVybnMgdGhlIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgY2FjaGVDYW52YXNcblx0XHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmNhY2hlQ2FudmFzID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBJRCBudW1iZXIgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNhY2hlIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICogZGV0ZXJtaW5lIGlmIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCBzaW5jZSBhIHByZXZpb3VzIGNoZWNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWNoZUlEXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5jYWNoZUlEID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIElEIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBNYWtlcyBkaXNwbGF5IG9iamVjdHMgZWFzaWVyIGZvciBzb21lIHVzZXMuXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqKi9cblx0XHR0aGlzLmlkID0gY3JlYXRlanMuVUlELmdldCgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoaXMgb2JqZWN0IHdoZW4gcnVubmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGZvciBjaGlsZHJlblxuXHRcdCAqIG9mIGEge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IHdpbGwgY2F1c2UgZXZlbnRzIG9uIHRoZSBDb250YWluZXIgdG8gbm90IGZpcmUgd2hlbiB0aGF0IGNoaWxkIGlzXG5cdFx0ICogY2xpY2tlZC4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAgZG9lcyBub3QgcHJldmVudCB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZyb20gcmV0dXJuaW5nIHRoZSBjaGlsZC5cblx0XHQgKlxuXHRcdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSW4gRWFzZWxKUyAwLjcuMCwgdGhlIG1vdXNlRW5hYmxlZCBwcm9wZXJ0eSB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IHdpdGggbmVzdGVkIENvbnRhaW5lcnMuIFBsZWFzZVxuXHRcdCAqIGNoZWNrIG91dCB0aGUgbGF0ZXN0IE5FWFQgdmVyc2lvbiBpbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL0Vhc2VsSlMvdHJlZS9tYXN0ZXIvbGliXCI+R2l0SHViPC9hPiBmb3IgYW4gdXBkYXRlZCB2ZXJzaW9uIHdpdGggdGhpcyBpc3N1ZSByZXNvbHZlZC4gVGhlIGZpeCB3aWxsIGJlXG5cdFx0ICogcHJvdmlkZWQgaW4gdGhlIG5leHQgcmVsZWFzZSBvZiBFYXNlbEpTLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUVuYWJsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VFbmFibGVkID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgcnVuIG9uIHRoaXMgZGlzcGxheSBvYmplY3QgKG9yIGl0cyBjaGlsZHJlbikuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cblx0XHQgKiBJbiBhZGRpdGlvbiB0byBwcmV2ZW50aW5nIHRoZSBcInRpY2tcIiBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQsIGl0IHdpbGwgYWxzbyBwcmV2ZW50IHRpY2sgcmVsYXRlZCB1cGRhdGVzXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja0VuYWJsZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LiBJbmNsdWRlZCBpbiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RvU3RyaW5nXCJ9fXt7L2Nyb3NzTGlua319IC4gVXNlZnVsIGZvclxuXHRcdCAqIGRlYnVnZ2luZy5cblx0XHQgKiBAcHJvcGVydHkgbmFtZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0aGF0XG5cdFx0ICogY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3IgbnVsbCBpZiBpdCBoYXMgbm90IGJlZW4gYWRkZWRcblx0XHQgKiB0byBvbmUuXG5cdFx0ICogQHByb3BlcnR5IHBhcmVudFxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEB0eXBlIHtDb250YWluZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZVxuXHRcdCAqIGFyb3VuZCBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHJlZ1ggYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvcmVnWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB0byA1MC5cblx0XHQgKiBAcHJvcGVydHkgcmVnWFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZ1ggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgeSBvZmZzZXQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QncyByZWdpc3RyYXRpb24gcG9pbnQuIEZvciBleGFtcGxlLCB0byBtYWtlIGEgMTAweDEwMHB4IEJpdG1hcCByb3RhdGUgYXJvdW5kXG5cdFx0ICogaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1g6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHJlZ1kgdG8gNTAuXG5cdFx0ICogQHByb3BlcnR5IHJlZ1lcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5yZWdZID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJvdGF0aW9uIGluIGRlZ3JlZXMgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHJvdGF0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWCB0byAyIHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxuXHRcdCAqIG9iamVjdCB0byB0d2ljZSBpdHMgbm9taW5hbCB3aWR0aC4gVG8gaG9yaXpvbnRhbGx5IGZsaXAgYW4gb2JqZWN0LCBzZXQgdGhlIHNjYWxlIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZVggPSAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVkgdG8gMC41IHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxuXHRcdCAqIG9iamVjdCB0byBoYWxmIGl0cyBub21pbmFsIGhlaWdodC4gVG8gdmVydGljYWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cblx0XHQgKiBAcHJvcGVydHkgc2NhbGVZXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2NhbGVZID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBza2V3WFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnNrZXdYID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgdmVydGljYWxseS5cblx0XHQgKiBAcHJvcGVydHkgc2tld1lcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5za2V3WSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgc2hhZG93IG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHNoYWRvdyB0byByZW5kZXIgb24gdGhpcyBkaXNwbGF5IG9iamVjdC4gU2V0IHRvIGBudWxsYCB0byByZW1vdmUgYSBzaGFkb3cuIElmXG5cdFx0ICogbnVsbCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci5cblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XG5cdFx0ICogQHR5cGUge1NoYWRvd31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2hhZG93ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBkaXNwbGF5IG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhbmQgaW5jbHVkZWQgd2hlbiBydW5uaW5nIHRoZSBTdGFnZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHggKGhvcml6b250YWwpIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCwgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnggPSAwO1xuXHRcblx0XHQvKiogVGhlIHkgKHZlcnRpY2FsKSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy55ID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBzZXQsIGRlZmluZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LCBvdmVycmlkaW5nIGFsbCBvdGhlciB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzXG5cdFx0ICogKHgsIHksIHJvdGF0aW9uLCBzY2FsZSwgc2tldykuXG5cdFx0ICogQHByb3BlcnR5IHRyYW5zZm9ybU1hdHJpeFxuXHRcdCAqIEB0eXBlIHtNYXRyaXgyRH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgY29tcG9zaXRlIG9wZXJhdGlvbiBpbmRpY2F0ZXMgaG93IHRoZSBwaXhlbHMgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCB0aGUgZWxlbWVudHNcblx0XHQgKiBiZWhpbmQgaXQuIElmIGBudWxsYCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XG5cdFx0ICogd2hhdHdnIHNwZWMgb24gY29tcG9zaXRpbmc8L2E+LlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIGRyYXduIHRvIGEgd2hvbGUgcGl4ZWwgd2hlblxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL3NuYXBUb1BpeGVsRW5hYmxlZFwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlLiBUbyBlbmFibGUvZGlzYWJsZSBzbmFwcGluZyBvbiB3aG9sZVxuXHRcdCAqIGNhdGVnb3JpZXMgb2YgZGlzcGxheSBvYmplY3RzLCBzZXQgdGhpcyB2YWx1ZSBvbiB0aGUgcHJvdG90eXBlIChFeC4gVGV4dC5wcm90b3R5cGUuc25hcFRvUGl4ZWwgPSB0cnVlKS5cblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMuc25hcFRvUGl4ZWwgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBGaWx0ZXIgb2JqZWN0cyB0byBhcHBseSB0byB0aGlzIGRpc3BsYXkgb2JqZWN0LiBGaWx0ZXJzIGFyZSBvbmx5IGFwcGxpZWQgLyB1cGRhdGVkIHdoZW4ge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBvciB7eyNjcm9zc0xpbmsgXCJ1cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgb25seSBhcHBseSB0byB0aGUgYXJlYSB0aGF0IGlzXG5cdFx0ICogY2FjaGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBmaWx0ZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5maWx0ZXJzID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNoYXBlIGluc3RhbmNlIHRoYXQgZGVmaW5lcyBhIHZlY3RvciBtYXNrIChjbGlwcGluZyBwYXRoKSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gIFRoZSBzaGFwZSdzIHRyYW5zZm9ybWF0aW9uXG5cdFx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudCBjb29yZGluYXRlcyAoYXMgaWYgaXQgd2VyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXNrXG5cdFx0ICogQHR5cGUge1NoYXBlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1hc2sgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgZGlzcGxheSBvYmplY3QgdGhhdCB3aWxsIGJlIHRlc3RlZCB3aGVuIGNoZWNraW5nIG1vdXNlIGludGVyYWN0aW9ucyBvciB0ZXN0aW5nIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBUaGUgaGl0IGFyZWEgd2lsbCBoYXZlIGl0cyB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlIChhcyB0aG91Z2hcblx0XHQgKiB0aGUgaGl0IHRlc3Qgb2JqZWN0IHdlcmUgYSBjaGlsZCBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IGFuZCByZWxhdGl2ZSB0byBpdHMgcmVnWC9ZKS4gVGhlIGhpdEFyZWEgd2lsbCBiZSB0ZXN0ZWRcblx0XHQgKiB1c2luZyBvbmx5IGl0cyBvd24gYGFscGhhYCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBhbHBoYSB2YWx1ZSBvbiB0aGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0LCBvciB0aGUgdGFyZ2V0J3Ncblx0XHQgKiBhbmNlc3RvcnMgKHBhcmVudHMpLlxuXHRcdCAqIFxuXHRcdCAqIElmIHNldCBvbiBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwgY2hpbGRyZW4gb2YgdGhlIENvbnRhaW5lciB3aWxsIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50cy5cblx0XHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8gc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319IHRvIGZhbHNlLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGhpdEFyZWEgaXMgTk9UIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBgaGl0VGVzdCgpYCBtZXRob2QsIG5vciBpcyBpdCBzdXBwb3J0ZWQgZm9yIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBoaXRBcmVhXG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaGl0QXJlYSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBDU1MgY3Vyc29yIChleC4gXCJwb2ludGVyXCIsIFwiaGVscFwiLCBcInRleHRcIiwgZXRjKSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhpcyBkaXNwbGF5XG5cdFx0ICogb2JqZWN0LiBZb3UgbXVzdCBlbmFibGUgbW91c2VvdmVyIGV2ZW50cyB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0b1xuXHRcdCAqIHVzZSB0aGlzIHByb3BlcnR5LiBTZXR0aW5nIGEgbm9uLW51bGwgY3Vyc29yIG9uIGEgQ29udGFpbmVyIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnNvciBzZXQgb24gaXRzIGRlc2NlbmRhbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJzb3Jcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmN1cnNvciA9IG51bGw7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FjaGVPZmZzZXRYXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRZID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZpbHRlck9mZnNldFhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZpbHRlck9mZnNldFggPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZmlsdGVyT2Zmc2V0WVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZVNjYWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTElEXG5cdFx0KiBAcHJvdGVjdGVkXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCovXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMSUQgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCogQHByb3BlcnR5IF9jYWNoZURhdGFVUkxcblx0XHQqIEBwcm90ZWN0ZWRcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCBudWxsXG5cdFx0Ki9cblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3Byb3BzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVjdGFuZ2xlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWN0YW5nbGUgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYm91bmRzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKERpc3BsYXlPYmplY3QsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBMaXN0aW5nIG9mIG1vdXNlIGV2ZW50IG5hbWVzLiBVc2VkIGluIF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwcm9wZXJ0eSBfTU9VU0VfRVZFTlRTXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTID0gW1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZWRvd25cIixcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIixcInByZXNzbW92ZVwiLFwicHJlc3N1cFwiLFwicm9sbG91dFwiLFwicm9sbG92ZXJcIl07XG5cblx0LyoqXG5cdCAqIFN1cHByZXNzZXMgZXJyb3JzIGdlbmVyYXRlZCB3aGVuIHVzaW5nIGZlYXR1cmVzIGxpa2UgaGl0VGVzdCwgbW91c2UgZXZlbnRzLCBhbmQge3sjY3Jvc3NMaW5rIFwiZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2l0aCBjcm9zcyBkb21haW4gY29udGVudC5cblx0ICogQHByb3BlcnR5IHN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHREaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMgPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3NuYXBUb1BpeGVsRW5hYmxlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkID0gZmFsc2U7IC8vIHN0YWdlLnNuYXBUb1BpeGVsRW5hYmxlZCBpcyB0ZW1wb3JhcmlseSBjb3BpZWQgaGVyZSBkdXJpbmcgYSBkcmF3IHRvIHByb3ZpZGUgZ2xvYmFsIGFjY2Vzcy5cblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9oaXRUZXN0Q2FudmFzXG5cdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaGl0VGVzdENvbnRleHRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyAvLyBwcmV2ZW50IGVycm9ycyBvbiBsb2FkIGluIGJyb3dzZXJzIHdpdGhvdXQgY2FudmFzLlxuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHREaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q2FudmFzID0gY2FudmFzO1xuXHRcdERpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX25leHRDYWNoZUlEXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdERpc3BsYXlPYmplY3QuX25leHRDYWNoZUlEID0gMTtcblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWRvd25cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBhbmQgdGhlbiByZWxlYXNlcyBpdCB3aGlsZSBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IGNsaWNrXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZSBjbGlja3MgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb3ZlciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgZGJsY2xpY2tcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXG5cdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS4gU2VlIGFsc28ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlb3ZlclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyBcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZW91dFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fSwgd2l0aCB0aGUgZm9sbG93aW5nXG5cdCAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhcyBhblxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cblx0ICogXG5cdCAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXG5cdCAqIHNoYXBlQSBhbmQgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIuIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9uXG5cdCAqIG15Q29udGFpbmVyLCB0d28gZXZlbnRzIHdvdWxkIGJlIHJlY2VpdmVkLCBlYWNoIHRhcmdldGluZyBhIGNoaWxkIGVsZW1lbnQ6PE9MPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxuXHQgKiA8L09MPlxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG92ZXJcIiBpbnN0ZWFkLCBvbmx5IGEgc2luZ2xlIGV2ZW50IGlzIHJlY2VpdmVkIHdoZW4gdGhlIG1vdXNlIGZpcnN0IGVudGVyc1xuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXG5cdCAqIFxuXHQgKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCByb2xsb3ZlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcblx0ICogZGlmZmVyZW5jZXM6IGl0IGRvZXMgbm90IGJ1YmJsZSwgYW5kIGl0IGNvbnNpZGVycyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIGFzIGFuXG5cdCAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxuXHQgKiBcblx0ICogRm9yIGV4YW1wbGUsIG15Q29udGFpbmVyIGNvbnRhaW5zIHR3byBvdmVybGFwcGluZyBjaGlsZHJlbjogc2hhcGVBIGFuZCBzaGFwZUIuIFRoZSB1c2VyIG1vdmVzIHRoZWlyIG1vdXNlIG92ZXJcblx0ICogc2hhcGVBLCB0aGVuIGRpcmVjdGx5IG9uIHRvIHNoYXBlQiwgdGhlbiBvZmYgYm90aC4gV2l0aCBhIGxpc3RlbmVyIGZvciB7eyNjcm9zc0xpbmsgXCJtb3VzZW91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvbiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGxlYXZlcyBzaGFwZUEgKHRhcmdldD1zaGFwZUEpPC9MST5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGxlYXZlcyBzaGFwZUIgKHRhcmdldD1zaGFwZUIpPC9MST5cblx0ICogPC9PTD5cblx0ICogSG93ZXZlciwgd2l0aCBhIGxpc3RlbmVyIGZvciBcInJvbGxvdXRcIiBpbnN0ZWFkLCBvbmx5IGEgc2luZ2xlIGV2ZW50IGlzIHJlY2VpdmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlc1xuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXG5cdCAqIFxuXHQgKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCByb2xsb3V0XG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogQWZ0ZXIgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlZG93bjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvY2N1cnMgb24gYSBkaXNwbGF5IG9iamVjdCwgYSBwcmVzc21vdmVcblx0ICogZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHVudGlsIHRoZSBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmVcblx0ICogdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhciBvcGVyYXRpb25zLlxuXHQgKiBAZXZlbnQgcHJlc3Ntb3ZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogQWZ0ZXIgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlZG93bjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvY2N1cnMgb24gYSBkaXNwbGF5IG9iamVjdCwgYSBwcmVzc3VwIGV2ZW50XG5cdCAqIHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHRoYXQgb2JqZWN0IHdoZW4gdGhhdCBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhclxuXHQgKiBvcGVyYXRpb25zLlxuXHQgKiBAZXZlbnQgcHJlc3N1cFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQgY29udGFpbmVyLlxuXHQgKiBAZXZlbnQgYWRkZWRcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgY29udGFpbmVyLlxuXHQgKiBAZXZlbnQgcmVtb3ZlZFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBvbiBlYWNoIGRpc3BsYXkgb2JqZWN0IG9uIGEgc3RhZ2Ugd2hlbmV2ZXIgdGhlIHN0YWdlIHVwZGF0ZXMuIFRoaXMgb2NjdXJzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGVcblx0ICogcmVuZGVyaW5nIChkcmF3KSBwYXNzLiBXaGVuIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsIGZpcnN0IGFsbCBkaXNwbGF5IG9iamVjdHMgb25cblx0ICogdGhlIHN0YWdlIGRpc3BhdGNoIHRoZSB0aWNrIGV2ZW50LCB0aGVuIGFsbCBvZiB0aGUgZGlzcGxheSBvYmplY3RzIGFyZSBkcmF3biB0byBzdGFnZS4gQ2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXG5cdCAqIHt7I2Nyb3NzTGluayBcInRpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZGlzcGF0Y2hlZCBpbiBvcmRlciBvZiB0aGVpciBkZXB0aCBwcmlvciB0byB0aGUgZXZlbnQgYmVpbmdcblx0ICogZGlzcGF0Y2hlZCBvbiB0aGVpciBwYXJlbnQuXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIEFuIGFycmF5IGNvbnRhaW5pbmcgYW55IGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBTdGFnZS51cGRhdGUoKSBtZXRob2QuIEZvclxuXHQgKiAgICAgIGV4YW1wbGUgaWYgeW91IGNhbGxlZCBzdGFnZS51cGRhdGUoXCJoZWxsb1wiKSwgdGhlbiB0aGUgcGFyYW1zIHdvdWxkIGJlIFtcImhlbGxvXCJdLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc3RhZ2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRTdGFnZVxuXHQgKiBAcmV0dXJuIHtTdGFnZX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldFN0YWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdXNlcyBkeW5hbWljIGFjY2VzcyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXM7XG5cdFx0dmFyIG8gPSB0aGlzLCBfU3RhZ2UgPSBjcmVhdGVqc1tcIlN0YWdlXCJdO1xuXHRcdHdoaWxlIChvLnBhcmVudCkgeyBvID0gby5wYXJlbnQ7IH1cblx0XHRpZiAobyBpbnN0YW5jZW9mIF9TdGFnZSkgeyByZXR1cm4gbzsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBTdGFnZSBpbnN0YW5jZSB0aGF0IHRoaXMgZGlzcGxheSBvYmplY3Qgd2lsbCBiZSByZW5kZXJlZCBvbiwgb3IgbnVsbCBpZiBpdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gb25lLlxuXHQgKiBAcHJvcGVydHkgc3RhZ2Vcblx0ICogQHR5cGUge1N0YWdlfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdHN0YWdlOiB7IGdldDogcC5nZXRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxuXHQgKiB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2sgaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xuXHRcdGlmIChpZ25vcmVDYWNoZSB8fCAhY2FjaGVDYW52YXMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZTtcblx0XHRjdHguZHJhd0ltYWdlKGNhY2hlQ2FudmFzLCB0aGlzLl9jYWNoZU9mZnNldFgrdGhpcy5fZmlsdGVyT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZK3RoaXMuX2ZpbHRlck9mZnNldFksIGNhY2hlQ2FudmFzLndpZHRoL3NjYWxlLCBjYWNoZUNhbnZhcy5oZWlnaHQvc2NhbGUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHRyYW5zZm9ybWF0aW9uLCBhbHBoYSwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLCBjbGlwcGluZyBwYXRoIChtYXNrKSwgYW5kIHNoYWRvd1xuXHQgKiB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBwcmlvciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgdXBkYXRlQ29udGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgdG8gdXBkYXRlLlxuXHQgKiovXG5cdHAudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBvPXRoaXMsIG1hc2s9by5tYXNrLCBtdHg9IG8uX3Byb3BzLm1hdHJpeDtcblx0XHRcblx0XHRpZiAobWFzayAmJiBtYXNrLmdyYXBoaWNzICYmICFtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkge1xuXHRcdFx0bWFzay5nZXRNYXRyaXgobXR4KTtcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG5cdFx0XHRcblx0XHRcdG1hc2suZ3JhcGhpY3MuZHJhd0FzUGF0aChjdHgpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRcdFxuXHRcdFx0bXR4LmludmVydCgpO1xuXHRcdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5nZXRNYXRyaXgobXR4KTtcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xuXHRcdGlmIChEaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgJiYgby5zbmFwVG9QaXhlbCkge1xuXHRcdFx0dHggPSB0eCArICh0eCA8IDAgPyAtMC41IDogMC41KSB8IDA7XG5cdFx0XHR0eSA9IHR5ICsgKHR5IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcblx0XHR9XG5cdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIHR4LCB0eSk7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhICo9IG8uYWxwaGE7XG5cdFx0aWYgKG8uY29tcG9zaXRlT3BlcmF0aW9uKSB7IGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvLmNvbXBvc2l0ZU9wZXJhdGlvbjsgfVxuXHRcdGlmIChvLnNoYWRvdykgeyB0aGlzLl9hcHBseVNoYWRvdyhjdHgsIG8uc2hhZG93KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byBhIG5ldyBjYW52YXMsIHdoaWNoIGlzIHRoZW4gdXNlZCBmb3Igc3Vic2VxdWVudCBkcmF3cy4gRm9yIGNvbXBsZXggY29udGVudFxuXHQgKiB0aGF0IGRvZXMgbm90IGNoYW5nZSBmcmVxdWVudGx5IChleC4gYSBDb250YWluZXIgd2l0aCBtYW55IGNoaWxkcmVuIHRoYXQgZG8gbm90IG1vdmUsIG9yIGEgY29tcGxleCB2ZWN0b3IgU2hhcGUpLFxuXHQgKiB0aGlzIGNhbiBwcm92aWRlIGZvciBtdWNoIGZhc3RlciByZW5kZXJpbmcgYmVjYXVzZSB0aGUgY29udGVudCBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLXJlbmRlcmVkIGVhY2ggdGljay4gVGhlXG5cdCAqIGNhY2hlZCBkaXNwbGF5IG9iamVjdCBjYW4gYmUgbW92ZWQsIHJvdGF0ZWQsIGZhZGVkLCBldGMgZnJlZWx5LCBob3dldmVyIGlmIGl0cyBjb250ZW50IGNoYW5nZXMsIHlvdSBtdXN0XG5cdCAqIG1hbnVhbGx5IHVwZGF0ZSB0aGUgY2FjaGUgYnkgY2FsbGluZyA8Y29kZT51cGRhdGVDYWNoZSgpPC9jb2RlPiBvciA8Y29kZT5jYWNoZSgpPC9jb2RlPiBhZ2Fpbi4gWW91IG11c3Qgc3BlY2lmeVxuXHQgKiB0aGUgY2FjaGUgYXJlYSB2aWEgdGhlIHgsIHksIHcsIGFuZCBoIHBhcmFtZXRlcnMuIFRoaXMgZGVmaW5lcyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgY2FjaGVkXG5cdCAqIHVzaW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBGb3IgZXhhbXBsZSBpZiB5b3UgZGVmaW5lZCBhIFNoYXBlIHRoYXQgZHJldyBhIGNpcmNsZSBhdCAwLCAwIHdpdGggYSByYWRpdXMgb2YgMjU6XG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcblx0ICogICAgICBteVNoYXBlLmNhY2hlKC0yNSwgLTI1LCA1MCwgNTApO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZmlsdGVycyBuZWVkIHRvIGJlIGRlZmluZWQgPGVtPmJlZm9yZTwvZW0+IHRoZSBjYWNoZSBpcyBhcHBsaWVkLiBDaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gU29tZSBmaWx0ZXJzIChleC4gQmx1ckZpbHRlcikgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBzY2FsZSBwYXJhbS5cblx0ICogXG5cdCAqIFVzdWFsbHksIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBoYXZlIHRoZSBkaW1lbnNpb25zIHdpZHRoKnNjYWxlIGJ5IGhlaWdodCpzY2FsZSwgaG93ZXZlciBzb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKVxuXHQgKiB3aWxsIGFkZCBwYWRkaW5nIHRvIHRoZSBjYW52YXMgZGltZW5zaW9ucy5cblx0ICpcblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9yaWdpbiBmb3IgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNhY2hlIHJlZ2lvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gVGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjYWNoZSB3aWxsIGJlIGNyZWF0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgY2FjaGUgYSB2ZWN0b3Igc2hhcGUgdXNpbmdcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCwxMDAsMTAwLDIpIHRoZW4gdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGJlIDIwMHgyMDAgcHguIFRoaXMgbGV0cyB5b3Ugc2NhbGUgYW5kIHJvdGF0ZVxuXHQgKiBcdGNhY2hlZCBlbGVtZW50cyB3aXRoIGdyZWF0ZXIgZmlkZWxpdHkuIERlZmF1bHQgaXMgMS5cblx0ICoqL1xuXHRwLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcblx0XHQvLyBkcmF3IHRvIGNhbnZhcy5cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyB0aGlzLmNhY2hlQ2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cblx0XHR0aGlzLl9jYWNoZVdpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRYID0geDtcblx0XHR0aGlzLl9jYWNoZU9mZnNldFkgPSB5O1xuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSBzY2FsZTtcblx0XHR0aGlzLnVwZGF0ZUNhY2hlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IHRvIGl0cyBjYWNoZS4gQ2FsbGluZyB1cGRhdGVDYWNoZSB3aXRob3V0IGFuIGFjdGl2ZSBjYWNoZSB3aWxsIHRocm93IGFuIGVycm9yLlxuXHQgKiBJZiBjb21wb3NpdGVPcGVyYXRpb24gaXMgbnVsbCB0aGUgY3VycmVudCBjYWNoZSB3aWxsIGJlIGNsZWFyZWQgcHJpb3IgdG8gZHJhd2luZy4gT3RoZXJ3aXNlIHRoZSBkaXNwbGF5IG9iamVjdFxuXHQgKiB3aWxsIGJlIGRyYXduIG92ZXIgdGhlIGV4aXN0aW5nIGNhY2hlIHVzaW5nIHRoZSBzcGVjaWZpZWQgY29tcG9zaXRlT3BlcmF0aW9uLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIENsZWFyIHRoZSBjdXJyZW50IGdyYXBoaWNzIG9mIGEgY2FjaGVkIHNoYXBlLCBkcmF3IHNvbWUgbmV3IGluc3RydWN0aW9ucywgYW5kIHRoZW4gdXBkYXRlIHRoZSBjYWNoZS4gVGhlIG5ldyBsaW5lXG5cdCAqIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIHRoZSBvbGQgb25lLlxuXHQgKlxuXHQgKiAgICAgIC8vIE5vdCBzaG93bjogQ3JlYXRpbmcgdGhlIHNoYXBlLCBhbmQgY2FjaGluZyBpdC5cblx0ICogICAgICBzaGFwZUluc3RhbmNlLmNsZWFyKCk7XG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS5zZXRTdHJva2VTdHlsZSgzKS5iZWdpblN0cm9rZShcIiNmZjAwMDBcIikubW92ZVRvKDEwMCwgMTAwKS5saW5lVG8oMjAwLDIwMCk7XG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS51cGRhdGVDYWNoZSgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gVGhlIGNvbXBvc2l0ZU9wZXJhdGlvbiB0byB1c2UsIG9yIG51bGwgdG8gY2xlYXIgdGhlIGNhY2hlIGFuZCByZWRyYXcgaXQuXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNjb21wb3NpdGluZ1wiPlxuXHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXG5cdCAqKi9cblx0cC51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXHRcdHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XG5cdFx0aWYgKCFjYWNoZUNhbnZhcykgeyB0aHJvdyBcImNhY2hlKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVwZGF0ZUNhY2hlKClcIjsgfVxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGUsIG9mZlggPSB0aGlzLl9jYWNoZU9mZnNldFgqc2NhbGUsIG9mZlkgPSB0aGlzLl9jYWNoZU9mZnNldFkqc2NhbGU7XG5cdFx0dmFyIHcgPSB0aGlzLl9jYWNoZVdpZHRoLCBoID0gdGhpcy5fY2FjaGVIZWlnaHQsIGN0eCA9IGNhY2hlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRcblx0XHR2YXIgZkJvdW5kcyA9IHRoaXMuX2dldEZpbHRlckJvdW5kcygpO1xuXHRcdG9mZlggKz0gKHRoaXMuX2ZpbHRlck9mZnNldFggPSBmQm91bmRzLngpO1xuXHRcdG9mZlkgKz0gKHRoaXMuX2ZpbHRlck9mZnNldFkgPSBmQm91bmRzLnkpO1xuXHRcdFxuXHRcdHcgPSBNYXRoLmNlaWwodypzY2FsZSkgKyBmQm91bmRzLndpZHRoO1xuXHRcdGggPSBNYXRoLmNlaWwoaCpzY2FsZSkgKyBmQm91bmRzLmhlaWdodDtcblx0XHRpZiAodyAhPSBjYWNoZUNhbnZhcy53aWR0aCB8fCBoICE9IGNhY2hlQ2FudmFzLmhlaWdodCkge1xuXHRcdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBwcmVzZXJ2ZSB0aGUgY29udGVudCBpZiB0aGVyZSBpcyBhIGNvbXBvc2l0ZU9wZXJhdGlvbi5cblx0XHRcdGNhY2hlQ2FudmFzLndpZHRoID0gdztcblx0XHRcdGNhY2hlQ2FudmFzLmhlaWdodCA9IGg7XG5cdFx0fSBlbHNlIGlmICghY29tcG9zaXRlT3BlcmF0aW9uKSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHcrMSwgaCsxKTtcblx0XHR9XG5cdFx0XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGUsIDAsIDAsIHNjYWxlLCAtb2ZmWCwgLW9mZlkpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIHRydWUpO1xuXHRcdC8vIFRPRE86IGZpbHRlcnMgYW5kIGNhY2hlIHNjYWxlIGRvbid0IHBsYXkgd2VsbCB0b2dldGhlciBhdCBwcmVzZW50LlxuXHRcdHRoaXMuX2FwcGx5RmlsdGVycygpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5jYWNoZUlEID0gRGlzcGxheU9iamVjdC5fbmV4dENhY2hlSUQrKztcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBjdXJyZW50IGNhY2hlLiBTZWUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XG5cdFx0dGhpcy5jYWNoZUlEID0gdGhpcy5fY2FjaGVPZmZzZXRYID0gdGhpcy5fY2FjaGVPZmZzZXRZID0gdGhpcy5fZmlsdGVyT2Zmc2V0WCA9IHRoaXMuX2ZpbHRlck9mZnNldFkgPSAwO1xuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIFVSTCBmb3IgdGhlIGNhY2hlLCBvciBudWxsIGlmIHRoaXMgZGlzcGxheSBvYmplY3QgaXMgbm90IGNhY2hlZC5cblx0ICogVXNlcyBjYWNoZUlEIHRvIGVuc3VyZSBhIG5ldyBkYXRhIFVSTCBpcyBub3QgZ2VuZXJhdGVkIGlmIHRoZSBjYWNoZSBoYXMgbm90IGNoYW5nZWQuXG5cdCAqIEBtZXRob2QgZ2V0Q2FjaGVEYXRhVVJMXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGltYWdlIGRhdGEgdXJsIGZvciB0aGUgY2FjaGUuXG5cdCAqKi9cblx0cC5nZXRDYWNoZURhdGFVUkwgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRpZiAodGhpcy5jYWNoZUlEICE9IHRoaXMuX2NhY2hlRGF0YVVSTElEKSB7IHRoaXMuX2NhY2hlRGF0YVVSTCA9IHRoaXMuY2FjaGVDYW52YXMudG9EYXRhVVJMKCk7IH1cblx0XHRyZXR1cm4gdGhpcy5fY2FjaGVEYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuXHQgKiB0byB0aGUgZ2xvYmFsIChzdGFnZSkgY29vcmRpbmF0ZSBzcGFjZS4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCB0byBwb3NpdGlvbiBhbiBIVE1MIGxhYmVsXG5cdCAqIG92ZXIgYSBzcGVjaWZpYyBwb2ludCBvbiBhIG5lc3RlZCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlcyBvbiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XG5cdCAqICAgICAgZGlzcGxheU9iamVjdC55ID0gMjAwO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHQgKiAgICAgIHZhciBwb2ludCA9IGRpc3BsYXlPYmplY3QubG9jYWxUb0dsb2JhbCgxMDAsIDEwMCk7XG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PTQwMCwgeT0zMDBcblx0ICpcblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuXHQgKiBvbiB0aGUgc3RhZ2UuXG5cdCAqKi9cblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fcHJvcHMubWF0cml4KS50cmFuc2Zvcm1Qb2ludCh4LHksIHB0fHxuZXcgY3JlYXRlanMuUG9pbnQoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGdsb2JhbCAoc3RhZ2UpIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlXG5cdCAqIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0LiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZVxuXHQgKiB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGRpc3BsYXkgb2JqZWN0LiBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XG5cdCAqICAgICAgZGlzcGxheU9iamVjdC55ID0gMjAwO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHQgKiAgICAgIHZhciBwb2ludCA9IGRpc3BsYXlPYmplY3QuZ2xvYmFsVG9Mb2NhbCgxMDAsIDEwMCk7XG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PS0yMDAsIHk9LTEwMFxuXHQgKlxuXHQgKiBAbWV0aG9kIGdsb2JhbFRvTG9jYWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGVcblx0ICogZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKiovXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkuaW52ZXJ0KCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgdG8gdGhlIGNvb3JkaW5hdGVcblx0ICogc3BhY2Ugb2YgdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZVxuXHQgKiB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGZvbGxvd2luZyBjb2RlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqICAgICAgdmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xuXHQgKiAgICAgIHB0ID0gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwocHQueCwgcHQueSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBvbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCB0byB3aGljaCB0aGUgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZC5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXG5cdCAqIEByZXR1cm4ge1BvaW50fSBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uXG5cdCAqIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKiovXG5cdHAubG9jYWxUb0xvY2FsID0gZnVuY3Rpb24oeCwgeSwgdGFyZ2V0LCBwdCkge1xuXHRcdHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHksIHB0KTtcblx0XHRyZXR1cm4gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwocHQueCwgcHQueSwgcHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gcXVpY2tseSBzZXQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIG9uIHRoZSBkaXNwbGF5IG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLlxuXHQgKiBPbWl0dGVkIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IHZhbHVlIHNldC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3Quc2V0VHJhbnNmb3JtKDEwMCwgMTAwLCAyLCAyKTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFRoZSBob3Jpem9udGFsIHRyYW5zbGF0aW9uICh4IHBvc2l0aW9uKSBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFRoZSB2ZXJ0aWNhbCB0cmFuc2xhdGlvbiAoeSBwb3NpdGlvbikgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVYPTFdIFRoZSBob3Jpem9udGFsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWT0xXSB0aGUgdmVydGljYWwgc2NhbGUsIGFzIGEgcGVyY2VudGFnZSBvZiAxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcm90YXRpb249MF0gVGhlIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1g9MF0gVGhlIGhvcml6b250YWwgc2tldyBmYWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtza2V3WT0wXSBUaGUgdmVydGljYWwgc2tldyBmYWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdYPTBdIFRoZSBob3Jpem9udGFsIHJlZ2lzdHJhdGlvbiBwb2ludCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdZPTBdIFRoZSB2ZXJ0aWNhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBjb21tYW5kcy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0dGhpcy54ID0geCB8fCAwO1xuXHRcdHRoaXMueSA9IHkgfHwgMDtcblx0XHR0aGlzLnNjYWxlWCA9IHNjYWxlWCA9PSBudWxsID8gMSA6IHNjYWxlWDtcblx0XHR0aGlzLnNjYWxlWSA9IHNjYWxlWSA9PSBudWxsID8gMSA6IHNjYWxlWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gfHwgMDtcblx0XHR0aGlzLnNrZXdYID0gc2tld1ggfHwgMDtcblx0XHR0aGlzLnNrZXdZID0gc2tld1kgfHwgMDtcblx0XHR0aGlzLnJlZ1ggPSByZWdYIHx8IDA7XG5cdFx0dGhpcy5yZWdZID0gcmVnWSB8fCAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXRyaXggYmFzZWQgb24gdGhpcyBvYmplY3QncyBjdXJyZW50IHRyYW5zZm9ybS5cblx0ICogQG1ldGhvZCBnZXRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBBIE1hdHJpeDJEIG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy4gSWYgbnVsbCwgYSBuZXdcblx0ICogTWF0cml4IG9iamVjdCBpcyByZXR1cm5lZC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IEEgbWF0cml4IHJlcHJlc2VudGluZyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgdHJhbnNmb3JtLlxuXHQgKiovXG5cdHAuZ2V0TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSBtYXRyaXgmJm1hdHJpeC5pZGVudGl0eSgpIHx8IG5ldyBjcmVhdGVqcy5NYXRyaXgyRCgpO1xuXHRcdHJldHVybiBvLnRyYW5zZm9ybU1hdHJpeCA/ICBtdHguY29weShvLnRyYW5zZm9ybU1hdHJpeCkgOiBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBNYXRyaXgyRCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm0gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXG5cdCAqIHBhcmVudCBDb250YWluZXJzIHVwIHRvIHRoZSBoaWdoZXN0IGxldmVsIGFuY2VzdG9yICh1c3VhbGx5IHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSkuIFRoaXMgY2FuXG5cdCAqIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHBvc2l0aW9ucyBiZXR3ZWVuIGNvb3JkaW5hdGUgc3BhY2VzLCBzdWNoIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0Q29uY2F0ZW5hdGVkTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIEEge3sjY3Jvc3NMaW5rIFwiTWF0cml4MkRcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxuXHQgKiBJZiBudWxsLCBhIG5ldyBNYXRyaXgyRCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGUgY29tYmluZWQgbWF0cml4LlxuXHQgKiovXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSB0aGlzLmdldE1hdHJpeChtYXRyaXgpO1xuXHRcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0XHRcdG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXR4O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIERpc3BsYXlQcm9wcyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgb2YgdGhlICBvYmplY3QgYW5kIGFsbCBvZiBpdHNcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHNcblx0ICogQHBhcmFtIHtEaXNwbGF5UHJvcHN9IFtwcm9wc10gQSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5UHJvcHNcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxuXHQgKiBJZiBudWxsLCBhIG5ldyBEaXNwbGF5UHJvcHMgb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdHByb3BzID0gcHJvcHMgPyBwcm9wcy5pZGVudGl0eSgpIDogbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gby5nZXRNYXRyaXgocHJvcHMubWF0cml4KTsgXG5cdFx0ZG8ge1xuXHRcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbik7XG5cdFx0XHRcblx0XHRcdC8vIHdlIGRvIHRoaXMgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0aGUgbWF0cml4IGJlaW5nIHVzZWQgZm9yIGJvdGggb3BlcmF0aW9ucyB3aGVuIG8uX3Byb3BzLm1hdHJpeCBpcyBwYXNzZWQgaW4gYXMgdGhlIHByb3BzIHBhcmFtLlxuXHRcdFx0Ly8gdGhpcyBjb3VsZCBiZSBzaW1wbGlmaWVkIChpZS4ganVzdCBkb25lIGFzIHBhcnQgb2YgdGhlIHByZXBlbmQgYWJvdmUpIGlmIHdlIHN3aXRjaGVkIHRvIHVzaW5nIGEgcG9vbC5cblx0XHRcdGlmIChvICE9IHRoaXMpIHsgbXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7IH1cblx0XHR9IHdoaWxlIChvID0gby5wYXJlbnQpO1xuXHRcdHJldHVybiBwcm9wcztcblx0fTtcblxuXHQvKipcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIHBvaW50IGluIDxlbT5sb2NhbDwvZW0+IGNvb3JkaW5hdGVzIChpZS4gZHJhd3MgYSBwaXhlbFxuXHQgKiB3aXRoIGFscGhhID4gMCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uKS4gVGhpcyBpZ25vcmVzIHRoZSBhbHBoYSwgc2hhZG93LCBoaXRBcmVhLCBtYXNrLCBhbmQgY29tcG9zaXRlT3BlcmF0aW9uXG5cdCAqIG9mIHRoZSBkaXNwbGF5IG9iamVjdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIG15U2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwicmVkXCIpLmRyYXdSZWN0KDEwMCwgMTAwLCAyMCwgNTApO1xuXHQgKlxuXHQgKiBcdFx0Y29uc29sZS5sb2cobXlTaGFwZS5oaXRUZXN0KDEwLDEwKTsgLy8gZmFsc2Vcblx0ICogXHRcdGNvbnNvbGUubG9nKG15U2hhcGUuaGl0VGVzdCgxMTAsIDI1KTsgLy8gdHJ1ZVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdG8gdXNlIFN0YWdlIGNvb3JkaW5hdGVzIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlWDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSksIHRoZXkgbXVzdFxuXHQgKiBmaXJzdCBiZSBjb252ZXJ0ZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXM6XG5cdCAqXG5cdCAqICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vkb3duXCIsIGhhbmRsZU1vdXNlRG93bik7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG5cdCAqICAgICAgXHR2YXIgcCA9IG15U2hhcGUuZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSk7XG5cdCAqICAgICAgICAgIHZhciBoaXQgPSBteVNoYXBlLmhpdFRlc3QocC54LCBwLnkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogU2hhcGUtdG8tc2hhcGUgY29sbGlzaW9uIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEVhc2VsSlMuXG5cdCAqXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QgaW50ZXJzZWN0IHRoZSBzcGVjaWZpZWRcblx0ICogbG9jYWwgUG9pbnQuXG5cdCovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR2YXIgY3R4ID0gRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteCwgLXkpO1xuXHRcdHRoaXMuZHJhdyhjdHgpO1xuXG5cdFx0dmFyIGhpdCA9IHRoaXMuX3Rlc3RIaXQoY3R4KTtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cdFx0cmV0dXJuIGhpdDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbXlHcmFwaGljcyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLCAwLCAyNSk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gc3RhZ2UuYWRkQ2hpbGQobmV3IGNyZWF0ZWpzLlNoYXBlKCkpLnNldCh7Z3JhcGhpY3M6bXlHcmFwaGljcywgeDoxMDAsIHk6MTAwLCBhbHBoYTowLjV9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdCdzIGJvdW5kcyBpbiBpdHMgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gKGllLiB3aXRoIG5vIHRyYW5zZm9ybWF0aW9uKS5cblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGUuXG5cdCAqIFxuXHQgKiBOb3QgYWxsIGRpc3BsYXkgb2JqZWN0cyBjYW4gY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSkuIEZvciB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIHVzZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxuXHQgKiBib3VuZHMuXG5cdCAqIFxuXHQgKiA8dGFibGU+XG5cdCAqIFx0PHRyPjx0ZD48Yj5BbGw8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRBbGwgZGlzcGxheSBvYmplY3RzIHN1cHBvcnQgc2V0dGluZyBib3VuZHMgbWFudWFsbHkgdXNpbmcgc2V0Qm91bmRzKCkuIExpa2V3aXNlLCBkaXNwbGF5IG9iamVjdHMgdGhhdFxuXHQgKiBcdFx0aGF2ZSBiZWVuIGNhY2hlZCB1c2luZyBjYWNoZSgpIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlaXIgY2FjaGUuIE1hbnVhbCBhbmQgY2FjaGUgYm91bmRzIHdpbGwgb3ZlcnJpZGVcblx0ICogXHRcdHRoZSBhdXRvbWF0aWMgY2FsY3VsYXRpb25zIGxpc3RlZCBiZWxvdy5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXA8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBzb3VyY2VSZWN0IChpZiBzcGVjaWZpZWQpIG9yIGltYWdlLCBleHRlbmRpbmcgZnJvbSAoeD0wLHk9MCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+U3ByaXRlPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBNYXkgaGF2ZSBub24temVybyB4L3kgaWYgYSBmcmFtZSByZWdpc3RyYXRpb24gcG9pbnQgd2FzIHNwZWNpZmllZFxuXHQgKiBcdFx0aW4gdGhlIHNwcml0ZXNoZWV0IGRhdGEuIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2dldEZyYW1lQm91bmRzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+Q29udGFpbmVyPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYWdncmVnYXRlIChjb21iaW5lZCkgYm91bmRzIG9mIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBhIG5vbi1udWxsIHZhbHVlIGZyb20gZ2V0Qm91bmRzKCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+U2hhcGU8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHREb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhdXRvbWF0aWMgYm91bmRzIGNhbGN1bGF0aW9ucy4gVXNlIHNldEJvdW5kcygpIHRvIG1hbnVhbGx5IGRlZmluZSBib3VuZHMuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+VGV4dDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgYXBwcm94aW1hdGUgYm91bmRzLiBIb3Jpem9udGFsIHZhbHVlcyAoeC93aWR0aCkgYXJlIHF1aXRlIGFjY3VyYXRlLCBidXQgdmVydGljYWwgdmFsdWVzICh5L2hlaWdodCkgYXJlXG5cdCAqIFx0XHRub3QsIGVzcGVjaWFsbHkgd2hlbiB1c2luZyB0ZXh0QmFzZWxpbmUgdmFsdWVzIG90aGVyIHRoYW4gXCJ0b3BcIi5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXBUZXh0PC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyBhcHByb3hpbWF0ZSBib3VuZHMuIFZhbHVlcyB3aWxsIGJlIG1vcmUgYWNjdXJhdGUgaWYgc3ByaXRlc2hlZXQgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50cyBhcmUgY2xvc2Vcblx0ICogXHRcdHRvICh4PTAseT0wKS5cblx0ICogXHQ8L3RkPjwvdHI+XG5cdCogPC90YWJsZT5cblx0ICogXG5cdCAqIEJvdW5kcyBjYW4gYmUgZXhwZW5zaXZlIHRvIGNhbGN1bGF0ZSBmb3Igc29tZSBvYmplY3RzIChleC4gdGV4dCwgb3IgY29udGFpbmVycyB3aXRoIG1hbnkgY2hpbGRyZW4pLCBhbmRcblx0ICogYXJlIHJlY2FsY3VsYXRlZCBlYWNoIHRpbWUgeW91IGNhbGwgZ2V0Qm91bmRzKCkuIFlvdSBjYW4gcHJldmVudCByZWNhbGN1bGF0aW9uIG9uIHN0YXRpYyBvYmplY3RzIGJ5IHNldHRpbmcgdGhlXG5cdCAqIGJvdW5kcyBleHBsaWNpdGx5OlxuXHQgKiBcblx0ICogXHR2YXIgYm91bmRzID0gb2JqLmdldEJvdW5kcygpO1xuXHQgKiBcdG9iai5zZXRCb3VuZHMoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXHQgKiBcdC8vIGdldEJvdW5kcyB3aWxsIG5vdyB1c2UgdGhlIHNldCB2YWx1ZXMsIGluc3RlYWQgb2YgcmVjYWxjdWxhdGluZ1xuXHQgKiBcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cblx0ICogXG5cdCAqIFx0dmFyIG15Qm91bmRzID0gb2JqLmdldEJvdW5kcygpLmNsb25lKCk7XG5cdCAqIFx0Ly8gT1I6XG5cdCAqIFx0bXlSZWN0LmNvcHkob2JqLmdldEJvdW5kcygpKTtcblx0ICogXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzXG5cdCAqIG9iamVjdC5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9ib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5jb3B5KHRoaXMuX2JvdW5kcyk7IH1cblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xuXHRcdGlmIChjYWNoZUNhbnZhcykge1xuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZTtcblx0XHRcdHJldHVybiB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKHRoaXMuX2NhY2hlT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIHBhcmVudCdzIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCkuXG5cdCAqIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCBib3VuZHMgb2YgdGhlIGNhY2hlLlxuXHQgKiBcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXJcblx0ICogYm91bmRzLlxuXHQgKiBcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cblx0ICogXG5cdCAqIENvbnRhaW5lciBpbnN0YW5jZXMgY2FsY3VsYXRlIGFnZ3JlZ2F0ZSBib3VuZHMgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBib3VuZHMgdmlhIGdldEJvdW5kcy5cblx0ICogQG1ldGhvZCBnZXRUcmFuc2Zvcm1lZEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgYm91bmRzLCBvciBudWxsIGlmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgdGhpcyBvYmplY3QuXG5cdCAqKi9cblx0cC5nZXRUcmFuc2Zvcm1lZEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBbGxvd3MgeW91IHRvIG1hbnVhbGx5IHNwZWNpZnkgdGhlIGJvdW5kcyBvZiBhbiBvYmplY3QgdGhhdCBlaXRoZXIgY2Fubm90IGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUgJlxuXHQgKiBUZXh0KSBmb3IgZnV0dXJlIHJlZmVyZW5jZSwgb3Igc28gdGhlIG9iamVjdCBjYW4gYmUgaW5jbHVkZWQgaW4gQ29udGFpbmVyIGJvdW5kcy4gTWFudWFsbHkgc2V0IGJvdW5kcyB3aWxsIGFsd2F5c1xuXHQgKiBvdmVycmlkZSBjYWxjdWxhdGVkIGJvdW5kcy5cblx0ICogXG5cdCAqIFRoZSBib3VuZHMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiB0aGUgb2JqZWN0J3MgbG9jYWwgKHVudHJhbnNmb3JtZWQpIGNvb3JkaW5hdGVzLiBGb3IgZXhhbXBsZSwgYSBTaGFwZSBpbnN0YW5jZVxuXHQgKiB3aXRoIGEgMjVweCByYWRpdXMgY2lyY2xlIGNlbnRlcmVkIGF0IDAsMCB3b3VsZCBoYXZlIGJvdW5kcyBvZiAoLTI1LCAtMjUsIDUwLCA1MCkuXG5cdCAqIEBtZXRob2Qgc2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IG9yaWdpbiBvZiB0aGUgYm91bmRzLiBQYXNzIG51bGwgdG8gcmVtb3ZlIHRoZSBtYW51YWwgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBvcmlnaW4gb2YgdGhlIGJvdW5kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cblx0ICoqL1xuXHRwLnNldEJvdW5kcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoeCA9PSBudWxsKSB7IHRoaXMuX2JvdW5kcyA9IHg7IH1cblx0XHR0aGlzLl9ib3VuZHMgPSAodGhpcy5fYm91bmRzIHx8IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogcmV2ZXJ0ZWQgdG8gdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLiBDYWNoZXMgYXJlIG5vdCBtYWludGFpbmVkIGFjcm9zcyBjbG9uZXMsIGFuZCBzb21lIGVsZW1lbnRzXG5cdCAqIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlIChtYXNrcywgaW5kaXZpZHVhbCBmaWx0ZXIgaW5zdGFuY2VzLCBoaXQgYXJlYSlcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3QgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBEaXNwbGF5T2JqZWN0KCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRGlzcGxheU9iamVjdCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0Ly8gc2VwYXJhdGVkIHNvIGl0IGNhbiBiZSB1c2VkIG1vcmUgZWFzaWx5IGluIHN1YmNsYXNzZXM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gbyBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBmcm9tIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3Rcblx0ICogaW5zdGFuY2UgY29waWVkIGludG8uXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0by5hbHBoYSA9IHRoaXMuYWxwaGE7XG5cdFx0by5tb3VzZUVuYWJsZWQgPSB0aGlzLm1vdXNlRW5hYmxlZDtcblx0XHRvLnRpY2tFbmFibGVkID0gdGhpcy50aWNrRW5hYmxlZDtcblx0XHRvLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0by5yZWdYID0gdGhpcy5yZWdYO1xuXHRcdG8ucmVnWSA9IHRoaXMucmVnWTtcblx0XHRvLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcblx0XHRvLnNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuXHRcdG8uc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cdFx0by5zaGFkb3cgPSB0aGlzLnNoYWRvdztcblx0XHRvLnNrZXdYID0gdGhpcy5za2V3WDtcblx0XHRvLnNrZXdZID0gdGhpcy5za2V3WTtcblx0XHRvLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cdFx0by54ICA9IHRoaXMueDtcblx0XHRvLnkgPSB0aGlzLnk7XG5cdFx0by5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRvLnNuYXBUb1BpeGVsID0gdGhpcy5zbmFwVG9QaXhlbDtcblx0XHRvLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnM9PW51bGw/bnVsbDp0aGlzLmZpbHRlcnMuc2xpY2UoMCk7XG5cdFx0by5tYXNrID0gdGhpcy5tYXNrO1xuXHRcdG8uaGl0QXJlYSA9IHRoaXMuaGl0QXJlYTtcblx0XHRvLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xuXHRcdG8uX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwbHlTaGFkb3dcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3dcblx0ICoqL1xuXHRwLl9hcHBseVNoYWRvdyA9IGZ1bmN0aW9uKGN0eCwgc2hhZG93KSB7XG5cdFx0c2hhZG93ID0gc2hhZG93IHx8IFNoYWRvdy5pZGVudGl0eTtcblx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WDtcblx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZO1xuXHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0Ly8gYmVjYXVzZSB0aWNrIGNhbiBiZSByZWFsbHkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBjaGVjayBmb3IgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIGRpc3BhdGNoRXZlbnQuXG5cdFx0dmFyIGxzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmIChscyAmJiBsc1tcInRpY2tcIl0pIHtcblx0XHRcdC8vIHJlc2V0ICYgcmV1c2UgdGhlIGV2ZW50IG9iamVjdCB0byBhdm9pZCBjb25zdHJ1Y3Rpb24gLyBHQyBjb3N0czpcblx0XHRcdGV2dE9iai50YXJnZXQgPSBudWxsO1xuXHRcdFx0ZXZ0T2JqLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGV2dE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnRPYmopO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGVzdEhpdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLl90ZXN0SGl0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBoaXQgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbM10gPiAxO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghRGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB7XG5cdFx0XHRcdHRocm93IFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGR1ZSB0byBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gcmVhZGluZyBjYW52YXMgcGl4ZWwgZGF0YSB3aXRoIGxvY2FsIG9yIGNyb3NzLWRvbWFpbiBpbWFnZXMuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoaXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PSAwIHx8ICF0aGlzLmNhY2hlQ2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcblx0XHR2YXIgY3R4ID0gdGhpcy5jYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0dmFyIHcgPSB0aGlzLmNhY2hlQ2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYWNoZUNhbnZhcy5oZWlnaHQ7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0dGhpcy5maWx0ZXJzW2ldLmFwcGx5RmlsdGVyKGN0eCwgMCwgMCwgdywgaCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEZpbHRlckJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRGaWx0ZXJCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIGwsIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMsIGJvdW5kcyA9IHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoMCwwLDAsMCk7XG5cdFx0aWYgKCFmaWx0ZXJzIHx8ICEobD1maWx0ZXJzLmxlbmd0aCkpIHsgcmV0dXJuIGJvdW5kczsgfVxuXHRcdFxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBmID0gdGhpcy5maWx0ZXJzW2ldO1xuXHRcdFx0Zi5nZXRCb3VuZHMmJmYuZ2V0Qm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pe1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHModGhpcy5nZXRCb3VuZHMoKSwgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RyYW5zZm9ybUJvdW5kc1xuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gYm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90cmFuc2Zvcm1Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGJvdW5kczsgfVxuXHRcdHZhciB4ID0gYm91bmRzLngsIHkgPSBib3VuZHMueSwgd2lkdGggPSBib3VuZHMud2lkdGgsIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cdFx0XG5cdFx0aWYgKHggfHwgeSkgeyBtdHguYXBwZW5kVHJhbnNmb3JtKDAsMCwxLDEsMCwwLDAsLXgsLXkpOyB9IC8vIFRPRE86IHNpbXBsaWZ5IHRoaXMuXG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XG5cdFx0XG5cdFx0dmFyIHhfYSA9IHdpZHRoKm10eC5hLCB4X2IgPSB3aWR0aCptdHguYjtcblx0XHR2YXIgeV9jID0gaGVpZ2h0Km10eC5jLCB5X2QgPSBoZWlnaHQqbXR4LmQ7XG5cdFx0dmFyIHR4ID0gbXR4LnR4LCB0eSA9IG10eC50eTtcblx0XHRcblx0XHR2YXIgbWluWCA9IHR4LCBtYXhYID0gdHgsIG1pblkgPSB0eSwgbWF4WSA9IHR5O1xuXG5cdFx0aWYgKCh4ID0geF9hICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuXHRcdGlmICgoeCA9IHhfYSArIHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cblx0XHRpZiAoKHggPSB5X2MgKyB0eCkgPCBtaW5YKSB7IG1pblggPSB4OyB9IGVsc2UgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG5cdFx0XG5cdFx0aWYgKCh5ID0geF9iICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxuXHRcdGlmICgoeSA9IHhfYiArIHlfZCArIHR5KSA8IG1pblkpIHsgbWluWSA9IHk7IH0gZWxzZSBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cblx0XHRpZiAoKHkgPSB5X2QgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XG5cdFx0XG5cdFx0cmV0dXJuIGJvdW5kcy5zZXRWYWx1ZXMobWluWCwgbWluWSwgbWF4WC1taW5YLCBtYXhZLW1pblkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBoYXMgYW55IG1vdXNlIGV2ZW50IGxpc3RlbmVycyBvciBhIGN1cnNvci5cblx0ICogQG1ldGhvZCBfaXNNb3VzZU9wYXF1ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5faGFzTW91c2VFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGV2dHMgPSBEaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFM7XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1ldnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoZXZ0c1tpXSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR9XG5cdFx0cmV0dXJuICEhdGhpcy5jdXJzb3I7XG5cdH07XG5cblx0Y3JlYXRlanMuRGlzcGxheU9iamVjdCA9IGNyZWF0ZWpzLnByb21vdGUoRGlzcGxheU9iamVjdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29udGFpbmVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblxuLy8gY29uc3RydWN0b3I6XG4vKipcbiAqIEEgQ29udGFpbmVyIGlzIGEgbmVzdGFibGUgZGlzcGxheSBsaXN0IHRoYXQgYWxsb3dzIHlvdSB0byB3b3JrIHdpdGggY29tcG91bmQgZGlzcGxheSBlbGVtZW50cy4gRm9yICBleGFtcGxlIHlvdSBjb3VsZFxuICogZ3JvdXAgYXJtLCBsZWcsIHRvcnNvIGFuZCBoZWFkIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdG9nZXRoZXIgaW50byBhIFBlcnNvbiBDb250YWluZXIsIGFuZFxuICogdHJhbnNmb3JtIHRoZW0gYXMgYSBncm91cCwgd2hpbGUgc3RpbGwgYmVpbmcgYWJsZSB0byBtb3ZlIHRoZSBpbmRpdmlkdWFsIHBhcnRzIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIENoaWxkcmVuIG9mXG4gKiBjb250YWluZXJzIGhhdmUgdGhlaXIgPGNvZGU+dHJhbnNmb3JtPC9jb2RlPiBhbmQgPGNvZGU+YWxwaGE8L2NvZGU+IHByb3BlcnRpZXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlaXIgcGFyZW50XG4gKiBDb250YWluZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGEge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gd2l0aCB4PTEwMCBhbmQgYWxwaGE9MC41LCBwbGFjZWQgaW4gYSBDb250YWluZXIgd2l0aCA8Y29kZT54PTUwPC9jb2RlPlxuICogYW5kIDxjb2RlPmFscGhhPTAuNzwvY29kZT4gd2lsbCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGF0IDxjb2RlPng9MTUwPC9jb2RlPiBhbmQgPGNvZGU+YWxwaGE9MC4zNTwvY29kZT4uXG4gKiBDb250YWluZXJzIGhhdmUgc29tZSBvdmVyaGVhZCwgc28geW91IGdlbmVyYWxseSBzaG91bGRuJ3QgY3JlYXRlIGEgQ29udGFpbmVyIHRvIGhvbGQgYSBzaW5nbGUgY2hpbGQuXG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqICAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAqICAgICAgY29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlKTtcbiAqICAgICAgY29udGFpbmVyLnggPSAxMDA7XG4gKlxuICogQGNsYXNzIENvbnRhaW5lclxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiovXG5cdGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIGluIHRoZSBkaXNwbGF5IGxpc3QuIFlvdSBzaG91bGQgdXN1YWxseSB1c2UgdGhlIGNoaWxkIG1hbmFnZW1lbnQgbWV0aG9kcyBzdWNoIGFzXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2FkZENoaWxkXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvcmVtb3ZlQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL3N3YXBDaGlsZHJlblwifX17ey9jcm9zc0xpbmt9fSwgZXRjLCByYXRoZXIgdGhhbiBhY2Nlc3NpbmcgdGhpcyBkaXJlY3RseSwgYnV0IGl0IGlzXG5cdFx0ICogaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdFx0ICogQHByb3BlcnR5IGNoaWxkcmVuXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgYXJlIGluZGVwZW5kZW50bHkgZW5hYmxlZCBmb3IgbW91c2UvcG9pbnRlciBpbnRlcmFjdGlvbi5cblx0XHQgKiBJZiBmYWxzZSwgdGhlIGNoaWxkcmVuIHdpbGwgYmUgYWdncmVnYXRlZCB1bmRlciB0aGUgY29udGFpbmVyIC0gZm9yIGV4YW1wbGUsIGEgY2xpY2sgb24gYSBjaGlsZCBzaGFwZSB3b3VsZFxuXHRcdCAqIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgY29udGFpbmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUNoaWxkcmVuXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgYmUgcHJvcGFnYXRlZCB0byBjaGlsZHJlbiBvZiB0aGlzIENvbnRhaW5lci4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcblx0XHQgKiBvbiBzb21lIGRpc3BsYXkgb2JqZWN0cyAoZXguIFNwcml0ZSAmIE1vdmllQ2xpcCBmcmFtZSBhZHZhbmNpbmcsIERPTUVsZW1lbnQgdmlzaWJpbGl0eSBoYW5kbGluZykuXG5cdFx0ICogQHByb3BlcnR5IHRpY2tDaGlsZHJlblxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja0NoaWxkcmVuID0gdHJ1ZTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb250YWluZXIsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvbnVtQ2hpbGRyZW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXROdW1DaGlsZHJlblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXROdW1DaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoZSBjb250YWluZXIuXG5cdCAqIEBwcm9wZXJ0eSBudW1DaGlsZHJlblxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG51bUNoaWxkcmVuOiB7IGdldDogcC5nZXROdW1DaGlsZHJlbiB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBDb250YWluZXI7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcblx0XHQvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBpc3N1ZXMgd2l0aCBkaXNwbGF5IGxpc3QgY2hhbmdlcyB0aGF0IG9jY3VyIGR1cmluZyBhIGRyYXc6XG5cdFx0dmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXHRcdFx0aWYgKCFjaGlsZC5pc1Zpc2libGUoKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHQvLyBkcmF3IHRoZSBjaGlsZDpcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjaGlsZC51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0XHRjaGlsZC5kcmF3KGN0eCk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UpO1xuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuIGF0IG9uY2U6XG5cdCAqXG5cdCAqIFx0XHRjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UsIHNoYXBlSW5zdGFuY2UsIHRleHRJbnN0YW5jZSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXG5cdCAqKi9cblx0cC5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0aWYgKGNoaWxkID09IG51bGwpIHsgcmV0dXJuIGNoaWxkOyB9XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyB0aGlzLmFkZENoaWxkKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBhcmd1bWVudHNbbC0xXTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgZGlzcGxheSBsaXN0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIGJ1bXBpbmcgY2hpbGRyZW4gYXQgZXF1YWwgb3IgZ3JlYXRlciBpbmRleGVzIHVwIG9uZSwgYW5kXG5cdCAqIHNldHRpbmcgaXRzIHBhcmVudCB0byB0aGlzIENvbnRhaW5lci5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGFkZENoaWxkQXQoY2hpbGQxLCBpbmRleCk7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4sIHN1Y2ggYXM6XG5cdCAqXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGNoaWxkMiwgLi4uLCBpbmRleCk7XG5cdCAqXG5cdCAqIFRoZSBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgbnVtQ2hpbGRyZW4uIEZvciBleGFtcGxlLCB0byBhZGQgbXlTaGFwZSB1bmRlciBvdGhlclNoYXBlIGluIHRoZSBkaXNwbGF5IGxpc3QsXG5cdCAqIHlvdSBjb3VsZCB1c2U6XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLmFkZENoaWxkQXQobXlTaGFwZSwgY29udGFpbmVyLmdldENoaWxkSW5kZXgob3RoZXJTaGFwZSkpO1xuXHQgKlxuXHQgKiBUaGlzIHdvdWxkIGFsc28gYnVtcCBvdGhlclNoYXBlJ3MgaW5kZXggdXAgYnkgb25lLiBGYWlscyBzaWxlbnRseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGFkZCB0aGUgY2hpbGQgYXQuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGxhc3QgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXG5cdCAqKi9cblx0cC5hZGRDaGlsZEF0ID0gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdHZhciBpbmR4ID0gYXJndW1lbnRzW2wtMV07IC8vIGNhbid0IHVzZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmRleCBwYXJhbSBvciBpdCByZXBsYWNlcyBhcmd1bWVudHNbMV1cblx0XHRpZiAoaW5keCA8IDAgfHwgaW5keCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBhcmd1bWVudHNbbC0yXTsgfVxuXHRcdGlmIChsID4gMikge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwtMTsgaSsrKSB7IHRoaXMuYWRkQ2hpbGRBdChhcmd1bWVudHNbaV0sIGluZHgraSk7IH1cblx0XHRcdHJldHVybiBhcmd1bWVudHNbbC0yXTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XG5cdFx0Y2hpbGQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjaGlsZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuIE5vdGUgdGhhdCBpdCBpcyBmYXN0ZXIgdG8gdXNlIHJlbW92ZUNoaWxkQXQoKSBpZiB0aGUgaW5kZXggaXNcblx0ICogYWxyZWFkeSBrbm93bi5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XG5cdCAqXG5cdCAqICAgICAgcmVtb3ZlQ2hpbGQoY2hpbGQxLCBjaGlsZDIsIC4uLik7XG5cdCAqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiovXG5cdHAucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVDaGlsZChhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdChjcmVhdGVqcy5pbmRleE9mKHRoaXMuY2hpbGRyZW4sIGNoaWxkKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggZnJvbSB0aGUgZGlzcGxheSBsaXN0LCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGRBdCgyKTtcblx0ICpcblx0ICogWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcblx0ICpcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoMiwgNywgLi4uKVxuXHQgKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cblx0ICoqL1xuXHRwLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGFbaV0gPSBhcmd1bWVudHNbaV07IH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBiLWE7IH0pO1xuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkQXQoYVtpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH1cblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgtMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2luZGV4XTtcblx0XHRpZiAoY2hpbGQpIHsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxuXHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblx0XHRjaGlsZC5kaXNwYXRjaEV2ZW50KFwicmVtb3ZlZFwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0Y29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsQ2hpbGRyZW5cblx0ICoqL1xuXHRwLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdHdoaWxlIChraWRzLmxlbmd0aCkgeyB0aGlzLnJlbW92ZUNoaWxkQXQoMCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5nZXRDaGlsZEF0KDIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldENoaWxkQXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIGNoaWxkIGF0IHRoZSBpbmRleC5cblx0ICoqL1xuXHRwLmdldENoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cblx0ICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG5cdCAqKi9cblx0cC5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0aWYoa2lkc1tpXS5uYW1lID09IG5hbWUpIHsgcmV0dXJuIGtpZHNbaV07IH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGFuIGFycmF5IHNvcnQgb3BlcmF0aW9uIG9uIHRoZSBjaGlsZCBsaXN0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTogRGlzcGxheSBjaGlsZHJlbiB3aXRoIGEgaGlnaGVyIHkgaW4gZnJvbnQuPC9oND5cblx0ICogXG5cdCAqICAgICAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcblx0ICogICAgICAgICAgaWYgKG9iajEueSA+IG9iajIueSkgeyByZXR1cm4gMTsgfVxuXHQgKiAgICAgICAgICBpZiAob2JqMS55IDwgb2JqMi55KSB7IHJldHVybiAtMTsgfVxuXHQgKiAgICAgICAgICByZXR1cm4gMDtcblx0ICogICAgICB9XG5cdCAqICAgICAgY29udGFpbmVyLnNvcnRDaGlsZHJlbihzb3J0RnVuY3Rpb24pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNvcnRDaGlsZHJlblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0RnVuY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBzb3J0IHRoZSBjaGlsZCBsaXN0LiBTZWUgSmF2YVNjcmlwdCdzIDxjb2RlPkFycmF5LnNvcnQ8L2NvZGU+XG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqKi9cblx0cC5zb3J0Q2hpbGRyZW4gPSBmdW5jdGlvbihzb3J0RnVuY3Rpb24pIHtcblx0XHR0aGlzLmNoaWxkcmVuLnNvcnQoc29ydEZ1bmN0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBpbiB0aGUgZGlzcGxheSBsaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbmRleCA9IGNvbnRhaW5lci5nZXRDaGlsZEluZGV4KGNoaWxkKTtcblx0ICpcblx0ICogQG1ldGhvZCBnZXRDaGlsZEluZGV4XG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJldHVybiB0aGUgaW5kZXggb2YuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIC0xIGlmIHRoZSBjaGlsZCBpcyBub3QgZm91bmQuXG5cdCAqKi9cblx0cC5nZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3dhcHMgdGhlIGNoaWxkcmVuIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlcy4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGluZGV4IGlzIG91dCBvZiByYW5nZS5cblx0ICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5BdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcblx0ICoqL1xuXHRwLnN3YXBDaGlsZHJlbkF0ID0gZnVuY3Rpb24oaW5kZXgxLCBpbmRleDIpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0dmFyIG8xID0ga2lkc1tpbmRleDFdO1xuXHRcdHZhciBvMiA9IGtpZHNbaW5kZXgyXTtcblx0XHRpZiAoIW8xIHx8ICFvMikgeyByZXR1cm47IH1cblx0XHRraWRzW2luZGV4MV0gPSBvMjtcblx0XHRraWRzW2luZGV4Ml0gPSBvMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTd2FwcyB0aGUgc3BlY2lmaWVkIGNoaWxkcmVuJ3MgZGVwdGggaW4gdGhlIGRpc3BsYXkgbGlzdC4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXNcblx0ICogQ29udGFpbmVyLlxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlblxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMlxuXHQgKiovXG5cdHAuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24oY2hpbGQxLCBjaGlsZDIpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XG5cdFx0dmFyIGluZGV4MSxpbmRleDI7XG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0aWYgKGtpZHNbaV0gPT0gY2hpbGQxKSB7IGluZGV4MSA9IGk7IH1cblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkMikgeyBpbmRleDIgPSBpOyB9XG5cdFx0XHRpZiAoaW5kZXgxICE9IG51bGwgJiYgaW5kZXgyICE9IG51bGwpIHsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGk9PWwpIHsgcmV0dXJuOyB9IC8vIFRPRE86IHRocm93IGVycm9yP1xuXHRcdGtpZHNbaW5kZXgxXSA9IGNoaWxkMjtcblx0XHRraWRzW2luZGV4Ml0gPSBjaGlsZDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgZGVwdGggb2YgdGhlIHNwZWNpZmllZCBjaGlsZC4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgY29udGFpbmVyLCBvciB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgXG5cdCAqIEBtZXRob2Qgc2V0Q2hpbGRJbmRleFxuXHQgKiovXG5cdHAuc2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbiwgbD1raWRzLmxlbmd0aDtcblx0XHRpZiAoY2hpbGQucGFyZW50ICE9IHRoaXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IGwpIHsgcmV0dXJuOyB9XG5cdFx0Zm9yICh2YXIgaT0wO2k8bDtpKyspIHtcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkKSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGlmIChpPT1sIHx8IGkgPT0gaW5kZXgpIHsgcmV0dXJuOyB9XG5cdFx0a2lkcy5zcGxpY2UoaSwxKTtcblx0XHRraWRzLnNwbGljZShpbmRleCwwLGNoaWxkKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudCAoY2hpbGQsIGdyYW5kY2hpbGQsIGV0Yylcblx0ICogb2YgdGhpcyBjb250YWluZXIuXG5cdCAqIEBtZXRob2QgY29udGFpbnNcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgRGlzcGxheU9iamVjdCB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudC5cblx0ICoqL1xuXHRwLmNvbnRhaW5zID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZCA9PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUZXN0cyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRlcnNlY3RzIHRoZSBzcGVjaWZpZWQgbG9jYWwgcG9pbnQgKGllLiBkcmF3cyBhIHBpeGVsIHdpdGggYWxwaGEgPiAwIGF0IHRoZVxuXHQgKiBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3cgYW5kIGNvbXBvc2l0ZU9wZXJhdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIGFuZCBhbGxcblx0ICogdHJhbnNmb3JtIHByb3BlcnRpZXMgaW5jbHVkaW5nIHJlZ1gvWS5cblx0ICogQG1ldGhvZCBoaXRUZXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpcyBhIHZpc2libGUgc2VjdGlvbiBvZiBhIERpc3BsYXlPYmplY3QgdGhhdCBvdmVybGFwcyB0aGUgc3BlY2lmaWVkXG5cdCAqIGNvb3JkaW5hdGVzLlxuXHQgKiovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHQvLyBUT0RPOiBvcHRpbWl6ZSB0byB1c2UgdGhlIGZhc3QgY2FjaGUgY2hlY2sgd2hlcmUgcG9zc2libGUuXG5cdFx0cmV0dXJuICh0aGlzLmdldE9iamVjdFVuZGVyUG9pbnQoeCwgeSkgIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzIHRoYXQgYXJlIGluIHRoaXMgY29udGFpbmVyJ3MgZGlzcGxheVxuXHQgKiBsaXN0LiBUaGlzIHJvdXRpbmUgaWdub3JlcyBhbnkgZGlzcGxheSBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZUVuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc2V0IHRvIGBmYWxzZWAuIFRoZSBhcnJheSB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiB2aXN1YWwgZGVwdGgsIHdpdGggdGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IGF0IGluZGV4IDAuXG5cdCAqIFRoaXMgdXNlcyBzaGFwZSBiYXNlZCBoaXQgZGV0ZWN0aW9uLCBhbmQgY2FuIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gdG8gcnVuLCBzbyBpdCBpcyBiZXN0IHRvIHVzZSBpdCBjYXJlZnVsbHkuXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0ZXN0aW5nIGZvciBvYmplY3RzIHVuZGVyIHRoZSBtb3VzZSwgdGVzdCBvbiB0aWNrIChpbnN0ZWFkIG9mIG9uIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vtb3ZlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSxcblx0ICogYW5kIG9ubHkgaWYgdGhlIG1vdXNlJ3MgcG9zaXRpb24gaGFzIGNoYW5nZWQuXG5cdCAqIFxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QnkgZGVmYXVsdCAobW9kZT0wKSB0aGlzIG1ldGhvZCBldmFsdWF0ZXMgYWxsIGRpc3BsYXkgb2JqZWN0cy48L2xpPlxuXHQgKiAgICAgPGxpPkJ5IHNldHRpbmcgdGhlIGBtb2RlYCBwYXJhbWV0ZXIgdG8gYDFgLCB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZUVuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogXHRcdGFuZCB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnRpZXMgd2lsbCBiZSByZXNwZWN0ZWQuPC9saT5cblx0ICogXHQgICA8bGk+U2V0dGluZyB0aGUgYG1vZGVgIHRvIGAyYCBhZGRpdGlvbmFsbHkgZXhjbHVkZXMgZGlzcGxheSBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYWN0aXZlIG1vdXNlIGV2ZW50XG5cdCAqIFx0ICAgXHRsaXN0ZW5lcnMgb3IgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0OmN1cnNvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS4gVGhhdCBpcywgb25seSBvYmplY3RzXG5cdCAqIFx0ICAgXHR0aGF0IHdvdWxkIG5vcm1hbGx5IGludGVyY2VwdCBtb3VzZSBpbnRlcmFjdGlvbiB3aWxsIGJlIGluY2x1ZGVkLiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IGltcHJvdmUgcGVyZm9ybWFuY2Vcblx0ICogXHQgICBcdGluIHNvbWUgY2FzZXMgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC48L2xpPlxuXHQgKiA8L2xpPlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGJvdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9oaXRBcmVhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21hc2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0c1VuZGVyUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kZT0wXSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAwLWFsbCwgMS1yZXNwZWN0IG1vdXNlRW5hYmxlZC9tb3VzZUNoaWxkcmVuLCAyLW9ubHkgbW91c2Ugb3BhcXVlIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSBvZiBEaXNwbGF5T2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuXHQgKiovXG5cdHAuZ2V0T2JqZWN0c1VuZGVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtb2RlKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcblx0XHR0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChwdC54LCBwdC55LCBhcnIsIG1vZGU+MCwgbW9kZT09MSk7XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCByZXR1cm5zIG9ubHkgdGhlIHRvcC1tb3N0IGRpc3BsYXlcblx0ICogb2JqZWN0LiBUaGlzIHJ1bnMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiA8Y29kZT5nZXRPYmplY3RzVW5kZXJQb2ludCgpPC9jb2RlPiwgYnV0IGlzIHN0aWxsIHBvdGVudGlhbGx5IGFuIGV4cGVuc2l2ZVxuXHQgKiBvcGVyYXRpb24uIFNlZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0VW5kZXJQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1vZGUgVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG5cdCAqKi9cblx0cC5nZXRPYmplY3RVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQocHQueCwgcHQueSwgbnVsbCwgbW9kZT4wLCBtb2RlPT0xKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcyhudWxsLCB0cnVlKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldFRyYW5zZm9ybWVkQm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBDb250YWluZXIuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiByZXZlcnRlZCB0byB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSBJZiB0cnVlLCBhbGwgb2YgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LiBJZiBmYWxzZSwgdGhlXG5cdCAqIHByb3BlcnRpZXMgb2YgdGhlIGNvbnRhaW5lciB3aWxsIGJlIGNsb25lZCwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uXG5cdCAqIEByZXR1cm4ge0NvbnRhaW5lcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBDb250YWluZXIgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQ29udGFpbmVyKCkpO1xuXHRcdGlmIChyZWN1cnNpdmUpIHsgdGhpcy5fY2xvbmVDaGlsZHJlbihvKTsgfVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29udGFpbmVyIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHRpZiAodGhpcy50aWNrQ2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGk9dGhpcy5jaGlsZHJlbi5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC50aWNrRW5hYmxlZCAmJiBjaGlsZC5fdGljaykgeyBjaGlsZC5fdGljayhldnRPYmopOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGNsb25lcyBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIsIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHRhcmdldCBjb250YWluZXIuXG5cdCAqIEBtZXRob2QgY2xvbmVDaGlsZHJlblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q29udGFpbmVyfSBvIFRoZSB0YXJnZXQgY29udGFpbmVyLlxuXHQgKiovXG5cdHAuX2Nsb25lQ2hpbGRyZW4gPSBmdW5jdGlvbihvKSB7XG5cdFx0aWYgKG8uY2hpbGRyZW4ubGVuZ3RoKSB7IG8ucmVtb3ZlQWxsQ2hpbGRyZW4oKTsgfVxuXHRcdHZhciBhcnIgPSBvLmNoaWxkcmVuO1xuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjbG9uZSA9IHRoaXMuY2hpbGRyZW5baV0uY2xvbmUodHJ1ZSk7XG5cdFx0XHRjbG9uZS5wYXJlbnQgPSBvO1xuXHRcdFx0YXJyLnB1c2goY2xvbmUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0T2JqZWN0c1VuZGVyUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91c2UgSWYgdHJ1ZSwgaXQgd2lsbCByZXNwZWN0IG1vdXNlIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBtb3VzZUVuYWJsZWQsIG1vdXNlQ2hpbGRyZW4sIGFuZCBhY3RpdmUgbGlzdGVuZXJzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZUxpc3RlbmVyIElmIHRydWUsIHRoZXJlIGlzIGFuIGFjdGl2ZSBtb3VzZSBldmVudCBsaXN0ZW5lciBvbiBhIHBhcmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50RGVwdGggSW5kaWNhdGVzIHRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBzZWFyY2guXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgpIHtcblx0XHRjdXJyZW50RGVwdGggPSBjdXJyZW50RGVwdGggfHwgMDtcblx0XHRpZiAoIWN1cnJlbnREZXB0aCAmJiAhdGhpcy5fdGVzdE1hc2sodGhpcywgeCwgeSkpIHsgcmV0dXJuIG51bGw7IH1cblx0XHR2YXIgbXR4LCBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRhY3RpdmVMaXN0ZW5lciA9IGFjdGl2ZUxpc3RlbmVyIHx8IChtb3VzZSYmdGhpcy5faGFzTW91c2VFdmVudExpc3RlbmVyKCkpO1xuXG5cdFx0Ly8gZHJhdyBjaGlsZHJlbiBvbmUgYXQgYSB0aW1lLCBhbmQgY2hlY2sgaWYgd2UgZ2V0IGEgaGl0OlxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaT1sLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgaGl0QXJlYSA9IGNoaWxkLmhpdEFyZWE7XG5cdFx0XHRpZiAoIWNoaWxkLnZpc2libGUgfHwgKCFoaXRBcmVhICYmICFjaGlsZC5pc1Zpc2libGUoKSkgfHwgKG1vdXNlICYmICFjaGlsZC5tb3VzZUVuYWJsZWQpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgIXRoaXMuX3Rlc3RNYXNrKGNoaWxkLCB4LCB5KSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHQvLyBpZiBhIGNoaWxkIGNvbnRhaW5lciBoYXMgYSBoaXRBcmVhIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGl0cyBoaXRBcmVhLCBzbyB3ZSBjYW4gdHJlYXQgaXQgYXMgYSBub3JtYWwgRE86XG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGNoaWxkLl9nZXRPYmplY3RzVW5kZXJQb2ludCh4LCB5LCBhcnIsIG1vdXNlLCBhY3RpdmVMaXN0ZW5lciwgY3VycmVudERlcHRoKzEpO1xuXHRcdFx0XHRpZiAoIWFyciAmJiByZXN1bHQpIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiByZXN1bHQ7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtb3VzZSAmJiAhYWN0aXZlTGlzdGVuZXIgJiYgIWNoaWxkLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVE9ETzogY2FuIHdlIHBhc3MgZGlzcGxheVByb3BzIGZvcndhcmQsIHRvIGF2b2lkIGhhdmluZyB0byBjYWxjdWxhdGUgdGhpcyBiYWNrd2FyZHMgZXZlcnkgdGltZT8gSXQncyBraW5kIG9mIGEgbWl4ZWQgYmFnLiBXaGVuIHdlJ3JlIG9ubHkgaHVudGluZyBmb3IgRE9zIHdpdGggZXZlbnQgbGlzdGVuZXJzLCBpdCBtYXkgbm90IG1ha2Ugc2Vuc2UuXG5cdFx0XHRcdHZhciBwcm9wcyA9IGNoaWxkLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyhjaGlsZC5fcHJvcHMpO1xuXHRcdFx0XHRtdHggPSBwcm9wcy5tYXRyaXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaGl0QXJlYSkge1xuXHRcdFx0XHRcdG10eC5hcHBlbmRNYXRyaXgoaGl0QXJlYS5nZXRNYXRyaXgoaGl0QXJlYS5fcHJvcHMubWF0cml4KSk7XG5cdFx0XHRcdFx0cHJvcHMuYWxwaGEgPSBoaXRBcmVhLmFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eC14LCBtdHgudHkteSk7XG5cdFx0XHRcdChoaXRBcmVhfHxjaGlsZCkuZHJhdyhjdHgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdFx0XHRpZiAoYXJyKSB7IGFyci5wdXNoKGNoaWxkKTsgfVxuXHRcdFx0XHRlbHNlIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiBjaGlsZDsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90ZXN0TWFza1xuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgeC95IGlzIHdpdGhpbiB0aGUgbWFza2VkIHJlZ2lvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3Rlc3RNYXNrID0gZnVuY3Rpb24odGFyZ2V0LCB4LCB5KSB7XG5cdFx0dmFyIG1hc2sgPSB0YXJnZXQubWFzaztcblx0XHRpZiAoIW1hc2sgfHwgIW1hc2suZ3JhcGhpY3MgfHwgbWFzay5ncmFwaGljcy5pc0VtcHR5KCkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcblx0XHR2YXIgbXR4ID0gdGhpcy5fcHJvcHMubWF0cml4LCBwYXJlbnQgPSB0YXJnZXQucGFyZW50O1xuXHRcdG10eCA9IHBhcmVudCA/IHBhcmVudC5nZXRDb25jYXRlbmF0ZWRNYXRyaXgobXR4KSA6IG10eC5pZGVudGl0eSgpO1xuXHRcdG10eCA9IG1hc2suZ2V0TWF0cml4KG1hc2suX3Byb3BzLm1hdHJpeCkucHJlcGVuZE1hdHJpeChtdHgpO1xuXHRcdFxuXHRcdHZhciBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcblx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcblx0XHRcblx0XHQvLyBkcmF3IHRoZSBtYXNrIGFzIGEgc29saWQgZmlsbDpcblx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcblx0XHRjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRcblx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxuXHRcdFxuXHRcdHZhciBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXg7XG5cdFx0bXR4ID0gaWdub3JlVHJhbnNmb3JtID8gbXR4LmlkZW50aXR5KCkgOiB0aGlzLmdldE1hdHJpeChtdHgpO1xuXHRcdGlmIChtYXRyaXgpIHsgbXR4LnByZXBlbmRNYXRyaXgobWF0cml4KTsgfVxuXHRcdFxuXHRcdHZhciBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgsIHJlY3Q9bnVsbDtcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICEoYm91bmRzID0gY2hpbGQuX2dldEJvdW5kcyhtdHgpKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKHJlY3QpIHsgcmVjdC5leHRlbmQoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpOyB9XG5cdFx0XHRlbHNlIHsgcmVjdCA9IGJvdW5kcy5jbG9uZSgpOyB9XG5cdFx0fVxuXHRcdHJldHVybiByZWN0O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29udGFpbmVyID0gY3JlYXRlanMucHJvbW90ZShDb250YWluZXIsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTdGFnZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgc3RhZ2UgaXMgdGhlIHJvb3QgbGV2ZWwge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGRpc3BsYXkgbGlzdC4gRWFjaCB0aW1lIGl0cyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBpcyBjYWxsZWQsIGl0IHdpbGwgcmVuZGVyIGl0cyBkaXNwbGF5IGxpc3QgdG8gaXRzIHRhcmdldCBjYW52YXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBzdGFnZSwgYWRkcyBhIGNoaWxkIHRvIGl0LCB0aGVuIHVzZXMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IHRvIHVwZGF0ZSB0aGUgY2hpbGRcblx0ICogYW5kIHJlZHJhdyB0aGUgc3RhZ2UgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0VsZW1lbnRJZFwiKTtcblx0ICogICAgICB2YXIgaW1hZ2UgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLnBuZ1wiKTtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChpbWFnZSk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgaW1hZ2UueCArPSAxMDtcblx0ICogICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgU3RhZ2Vcblx0ICogQGV4dGVuZHMgQ29udGFpbmVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgU3RyaW5nIHwgT2JqZWN0fSBjYW52YXMgQSBjYW52YXMgb2JqZWN0IHRoYXQgdGhlIFN0YWdlIHdpbGwgcmVuZGVyIHRvLCBvciB0aGUgc3RyaW5nIGlkXG5cdCAqIG9mIGEgY2FudmFzIG9iamVjdCBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTdGFnZShjYW52YXMpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGFnZSBzaG91bGQgYXV0b21hdGljYWxseSBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIHJlbmRlci4gWW91IGNhbiBzZXQgdGhpcyB0byA8Y29kZT5mYWxzZTwvY29kZT5cblx0XHQgKiB0byBtYW51YWxseSBjb250cm9sIGNsZWFyaW5nIChmb3IgZ2VuZXJhdGl2ZSBhcnQsIG9yIHdoZW4gcG9pbnRpbmcgbXVsdGlwbGUgc3RhZ2VzIGF0IHRoZSBzYW1lIGNhbnZhcyBmb3Jcblx0XHQgKiBleGFtcGxlKS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdFx0ICogICAgICBzdGFnZS5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvQ2xlYXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW52YXMgdGhlIHN0YWdlIHdpbGwgcmVuZGVyIHRvLiBNdWx0aXBsZSBzdGFnZXMgY2FuIHNoYXJlIGEgc2luZ2xlIGNhbnZhcywgYnV0IHlvdSBtdXN0IGRpc2FibGUgYXV0b0NsZWFyIGZvciBhbGwgYnV0IHRoZVxuXHRcdCAqIGZpcnN0IHN0YWdlIHRoYXQgd2lsbCBiZSB0aWNrZWQgKG9yIHRoZXkgd2lsbCBjbGVhciBlYWNoIG90aGVyJ3MgcmVuZGVyKS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHRcdCAqIG5ldyBjYW52YXMgb3IgbW91c2UgZXZlbnRzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdFx0ICogICAgICBteVN0YWdlLmNhbnZhcyA9IGFub3RoZXJDYW52YXM7XG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW52YXNcblx0XHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLmNhbnZhcyA9ICh0eXBlb2YgY2FudmFzID09IFwic3RyaW5nXCIpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSA6IGNhbnZhcztcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZVggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBZIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgYXJlYSBvZiB0aGUgc3RhZ2UgdG8gYWZmZWN0IHdoZW4gY2FsbGluZyB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseVxuXHRcdCAqIHJlLWRyYXcgc3BlY2lmaWMgcmVnaW9ucyBvZiB0aGUgY2FudmFzLiBJZiBudWxsLCB0aGUgd2hvbGUgY2FudmFzIGFyZWEgaXMgZHJhd24uXG5cdFx0ICogQHByb3BlcnR5IGRyYXdSZWN0XG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKi9cblx0XHR0aGlzLmRyYXdSZWN0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzcGxheSBvYmplY3RzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB3aG9sZSBwaXhlbHMuIFlvdSBjYW4gc2V0IHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc25hcFRvUGl4ZWxcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb2Zcblx0XHQgKiBkaXNwbGF5IG9iamVjdHMgdG8gZmFsc2UgdG8gZW5hYmxlL2Rpc2FibGUgdGhpcyBiZWhhdmlvdXIgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMuXG5cdFx0ICogQHByb3BlcnR5IHNuYXBUb1BpeGVsRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlSW5Cb3VuZHNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUluQm91bmRzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRpY2sgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIG9uIGFsbCBkaXNwbGF5IG9iamVjdHMgb24gdGhlIHN0YWdlIHByaW9yIHRvIHJlbmRlcmluZyB0byB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrT25VcGRhdGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tPblVwZGF0ZSA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIG1vdXNlIG1vdmUgZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgdGFyZ2V0IGNhbnZhcy4gU2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiB4L3kvcmF3WC9yYXdZLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZU1vdmVPdXRzaWRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VNb3ZlT3V0c2lkZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHNlbGVjdGlvbiBvZiBvdGhlciBlbGVtZW50cyBpbiB0aGUgaHRtbCBwYWdlIGlmIHRoZSB1c2VyIGNsaWNrcyBhbmQgZHJhZ3MsIG9yIGRvdWJsZSBjbGlja3Mgb24gdGhlIGNhbnZhcy5cblx0XHQgKiBUaGlzIHdvcmtzIGJ5IGNhbGxpbmcgYHByZXZlbnREZWZhdWx0KClgIG9uIGFueSBtb3VzZWRvd24gZXZlbnRzIChvciB0b3VjaCBlcXVpdmFsZW50KSBvcmlnaW5hdGluZyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmV2ZW50U2VsZWN0aW9uXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5wcmV2ZW50U2VsZWN0aW9uID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhpdEFyZWEgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBmb3IgU3RhZ2UuXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0IFxuXHRcdCBcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIG9iamVjdHMgd2l0aCBkYXRhIGZvciBlYWNoIGFjdGl2ZSBwb2ludGVyIGlkLiBFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdCAqIHgsIHksIGV2ZW50LCB0YXJnZXQsIG92ZXJUYXJnZXQsIG92ZXJYLCBvdmVyWSwgaW5Cb3VuZHMsIHBvc0V2dE9iaiAobmF0aXZlIGV2ZW50IHRoYXQgbGFzdCB1cGRhdGVkIHBvc2l0aW9uKVxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9pbnRlckRhdGEgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIGFjdGl2ZSBwb2ludGVycy5cblx0XHQgKiBAcHJvcGVydHkgX3BvaW50ZXJDb3VudFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyQ291bnQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHByaW1hcnkgcG9pbnRlci5cblx0XHQgKiBAcHJvcGVydHkgX3ByaW1hcnlQb2ludGVySURcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbW91c2VPdmVySW50ZXJ2YWxJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0U3RhZ2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgU3RhZ2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBpbml0aWFsaXplOlxuXHRcdHRoaXMuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFN0YWdlLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGNhbnZhcy5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vtb3ZlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb24gdGhlIGNhbnZhcy4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vkb3duXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHRoZSB1c2VyIHByZXNzZXMgc29tZXdoZXJlIG9uIHRoZSBzdGFnZSwgdGhlbiByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGFueXdoZXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGRldGVjdCBpdCAodGhpcyB2YXJpZXMgc2xpZ2h0bHkgYmV0d2VlbiBicm93c2VycykuXG5cdCAqIFlvdSBjYW4gdXNlIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlSW5Cb3VuZHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgc3RhZ2UgYm91bmRzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZXVwXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBmcm9tIHdpdGhpbiB0aGUgY2FudmFzIGFyZWEgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkgdG8gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWxlYXZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbnRvIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkgZnJvbSBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IHRydWUpLlxuXHQgKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VlbnRlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgcHJvcGFnYXRpbmcgdGhlIHRpY2sgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrc3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LiBEb2VzIG5vdCBmaXJlIGlmXG5cdCAqIHRpY2tPblVwZGF0ZSBpcyBmYWxzZS4gUHJlY2VkZXMgdGhlIFwiZHJhd3N0YXJ0XCIgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNhbnZhcyBpcyBjbGVhcmVkIGFuZCB0aGUgZGlzcGxheSBsaXN0IGlzIGRyYXduIHRvIGl0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqIEBldmVudCBkcmF3c3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gdGhlIGNhbnZhcyBhbmQgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc3RvcmVkLlxuXHQgKiBAZXZlbnQgZHJhd2VuZFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cblx0IFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIHRhcmdldCBzdGFnZSB0aGF0IHdpbGwgaGF2ZSBtb3VzZSAvIHRvdWNoIGludGVyYWN0aW9ucyByZWxheWVkIHRvIGl0IGFmdGVyIHRoaXMgc3RhZ2UgaGFuZGxlcyB0aGVtLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmUgbXVsdGlwbGUgbGF5ZXJlZCBjYW52YXNlcyBhbmQgd2FudCB1c2VyIGludGVyYWN0aW9uc1xuXHQgKiBldmVudHMgdG8gcGFzcyB0aHJvdWdoLiBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCByZWxheSBtb3VzZSBldmVudHMgZnJvbSB0b3BTdGFnZSB0byBib3R0b21TdGFnZTpcblx0ICpcblx0ICogICAgICB0b3BTdGFnZS5uZXh0U3RhZ2UgPSBib3R0b21TdGFnZTtcblx0ICpcblx0ICogVG8gZGlzYWJsZSByZWxheWluZywgc2V0IG5leHRTdGFnZSB0byBudWxsLlxuXHQgKiBcblx0ICogTW91c2VPdmVyLCBNb3VzZU91dCwgUm9sbE92ZXIsIGFuZCBSb2xsT3V0IGludGVyYWN0aW9ucyBhcmUgYWxzbyBwYXNzZWQgdGhyb3VnaCB1c2luZyB0aGUgbW91c2Ugb3ZlciBzZXR0aW5nc1xuXHQgKiBvZiB0aGUgdG9wLW1vc3Qgc3RhZ2UsIGJ1dCBhcmUgb25seSBwcm9jZXNzZWQgaWYgdGhlIHRhcmdldCBzdGFnZSBoYXMgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZC5cblx0ICogQ29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyByb2xsIG92ZXIgaW4gcmVsYXkgdGFyZ2V0czo8T0w+XG5cdCAqIDxMST4gVGhlIHRvcC1tb3N0IChmaXJzdCkgc3RhZ2UgbXVzdCBoYXZlIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGVuYWJsZWQgKHZpYSBlbmFibGVNb3VzZU92ZXIpPC9MST5cblx0ICogPExJPiBBbGwgc3RhZ2VzIHRoYXQgd2lzaCB0byBwYXJ0aWNpcGF0ZSBpbiBtb3VzZSBvdmVyIGludGVyYWN0aW9uIG11c3QgZW5hYmxlIHRoZW0gdmlhIGVuYWJsZU1vdXNlT3ZlcjwvTEk+XG5cdCAqIDxMST4gQWxsIHJlbGF5IHRhcmdldHMgd2lsbCBzaGFyZSB0aGUgZnJlcXVlbmN5IHZhbHVlIG9mIHRoZSB0b3AtbW9zdCBzdGFnZTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIFRvIGlsbHVzdHJhdGUsIGluIHRoaXMgZXhhbXBsZSB0aGUgdGFyZ2V0U3RhZ2Ugd291bGQgcHJvY2VzcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBhdCAxMGh6IChkZXNwaXRlIHBhc3Npbmdcblx0ICogMzAgYXMgaXQncyBkZXNpcmVkIGZyZXF1ZW5jeSk6XG5cdCAqIFx0dG9wU3RhZ2UubmV4dFN0YWdlID0gdGFyZ2V0U3RhZ2U7XG5cdCAqIFx0dG9wU3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcblx0ICogXHR0YXJnZXRTdGFnZS5lbmFibGVNb3VzZU92ZXIoMzApO1xuXHQgKiBcblx0ICogSWYgdGhlIHRhcmdldCBzdGFnZSdzIGNhbnZhcyBpcyBjb21wbGV0ZWx5IGNvdmVyZWQgYnkgdGhpcyBzdGFnZSdzIGNhbnZhcywgeW91IG1heSBhbHNvIHdhbnQgdG8gZGlzYWJsZSBpdHNcblx0ICogRE9NIGV2ZW50cyB1c2luZzpcblx0ICogXG5cdCAqXHR0YXJnZXRTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiBcblx0ICogQHByb3BlcnR5IG5leHRTdGFnZVxuXHQgKiBAdHlwZSB7U3RhZ2V9XG5cdCAqKi9cblx0cC5fZ2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXh0U3RhZ2U7XG5cdH07XG5cdHAuX3NldF9uZXh0U3RhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9uZXh0U3RhZ2UpIHsgdGhpcy5fbmV4dFN0YWdlLl9wcmV2U3RhZ2UgPSBudWxsOyB9XG5cdFx0aWYgKHZhbHVlKSB7IHZhbHVlLl9wcmV2U3RhZ2UgPSB0aGlzOyB9XG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gdmFsdWU7XG5cdH07XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG5leHRTdGFnZTogeyBnZXQ6IHAuX2dldF9uZXh0U3RhZ2UsIHNldDogcC5fc2V0X25leHRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEVhY2ggdGltZSB0aGUgdXBkYXRlIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBzdGFnZSB3aWxsIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja09uVXBkYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBmYWxzZSxcblx0ICogYW5kIHRoZW4gcmVuZGVyIHRoZSBkaXNwbGF5IGxpc3QgdG8gdGhlIGNhbnZhcy5cblx0ICpcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gUHJvcHMgb2JqZWN0IHRvIHBhc3MgdG8gYHRpY2soKWAuIFNob3VsZCB1c3VhbGx5IGJlIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudXBkYXRlID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdGlmICh0aGlzLnRpY2tPblVwZGF0ZSkgeyB0aGlzLnRpY2socHJvcHMpOyB9XG5cdFx0aWYgKHRoaXMuZGlzcGF0Y2hFdmVudChcImRyYXdzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkO1xuXHRcdHZhciByID0gdGhpcy5kcmF3UmVjdCwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0aWYgKHRoaXMuYXV0b0NsZWFyKSB7XG5cdFx0XHRpZiAocikgeyBjdHguY2xlYXJSZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7IH1cblx0XHRcdGVsc2UgeyBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTsgfVxuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLmRyYXdSZWN0KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgucmVjdChyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgZmFsc2UpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd2VuZFwiKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9wYWdhdGVzIGEgdGljayBldmVudCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiBJZiBhIHByb3BzIG9iamVjdCBpcyBwYXNzZWQgdG8gYHRpY2soKWAsIHRoZW4gYWxsIG9mIGl0cyBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QgdGhhdCBpc1xuXHQgKiBwcm9wYWdhdGVkIHRvIGxpc3RlbmVycy5cblx0ICpcblx0ICogU29tZSB0aW1lLWJhc2VkIGZlYXR1cmVzIGluIEVhc2VsSlMgKGZvciBleGFtcGxlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWlyZSB0aGF0XG5cdCAqIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0IChvciBlcXVpdmFsZW50IG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkpIGJlXG5cdCAqIHBhc3NlZCBhcyB0aGUgYHByb3BzYCBwYXJhbWV0ZXIgdG8gYHRpY2soKWAuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiBcdFRpY2tlci5vbihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqIFx0ZnVuY3Rpb24gaGFuZGxlVGljayhldnRPYmopIHtcblx0ICogXHRcdC8vIGNsb25lIHRoZSBldmVudCBvYmplY3QgZnJvbSBUaWNrZXIsIGFuZCBhZGQgc29tZSBjdXN0b20gZGF0YSB0byBpdDpcblx0ICogXHRcdHZhciBldnQgPSBldnRPYmouY2xvbmUoKS5zZXQoe2dyZWV0aW5nOlwiaGVsbG9cIiwgbmFtZTpcIndvcmxkXCJ9KTtcblx0ICogXHRcdFxuXHQgKiBcdFx0Ly8gcGFzcyBpdCB0byBzdGFnZS51cGRhdGUoKTpcblx0ICogXHRcdG15U3RhZ2UudXBkYXRlKGV2dCk7IC8vIHN1YnNlcXVlbnRseSBjYWxscyB0aWNrKCkgd2l0aCB0aGUgc2FtZSBwYXJhbVxuXHQgKiBcdH1cblx0ICogXHRcblx0ICogXHQvLyAuLi5cblx0ICogXHRteURpc3BsYXlPYmplY3Qub24oXCJ0aWNrXCIsIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVEaXNwbGF5T2JqZWN0VGljayhldnQpIHtcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5kZWx0YSk7IC8vIHRoZSBkZWx0YSBwcm9wZXJ0eSBmcm9tIHRoZSBUaWNrZXIgdGljayBldmVudCBvYmplY3Rcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5ncmVldGluZywgZXZ0Lm5hbWUpOyAvLyBjdXN0b20gZGF0YTogXCJoZWxsbyB3b3JsZFwiXG5cdCAqIFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuIFNob3VsZCB1c3VhbGx5IGJlIGEgVGlja2VyIGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudGljayA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKCF0aGlzLnRpY2tFbmFibGVkIHx8IHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdHZhciBldnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobikpIHsgZXZ0T2JqW25dID0gcHJvcHNbbl07IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fdGljayhldnRPYmopO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tlbmRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0aGF0IGNhbGxzIHRoZSBTdGFnZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoZW4gYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgcmVjZWl2ZWQuIFRoaXMgYWxsb3dzIHlvdSB0byByZWdpc3RlciBhIFN0YWdlIGluc3RhbmNlIGFzIGEgZXZlbnQgbGlzdGVuZXIgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCB1c2luZzpcblx0ICpcblx0ICogICAgICBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgbXlTdGFnZVwiKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBzdWJzY3JpYmUgdG8gdGlja3MgdXNpbmcgdGhpcyBwYXR0ZXJuLCB0aGVuIHRoZSB0aWNrIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvXG5cdCAqIGRpc3BsYXkgb2JqZWN0IHRpY2sgaGFuZGxlcnMsIGluc3RlYWQgb2YgPGNvZGU+ZGVsdGE8L2NvZGU+IGFuZCA8Y29kZT5wYXVzZWQ8L2NvZGU+IHBhcmFtZXRlcnMuXG5cdCAqIEBwcm9wZXJ0eSBoYW5kbGVFdmVudFxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHRpZiAoZXZ0LnR5cGUgPT0gXCJ0aWNrXCIpIHsgdGhpcy51cGRhdGUoZXZ0KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRhcmdldCBjYW52YXMuIFVzZWZ1bCBpZiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9hdXRvQ2xlYXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGBmYWxzZWAuXG5cdCAqIEBtZXRob2QgY2xlYXJcblx0ICoqL1xuXHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCsxLCB0aGlzLmNhbnZhcy5oZWlnaHQrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIHVybCB0aGF0IGNvbnRhaW5zIGEgQmFzZTY0LWVuY29kZWQgaW1hZ2Ugb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZS4gVGhlIHJldHVybmVkIGRhdGEgdXJsIGNhblxuXHQgKiBiZSBzcGVjaWZpZWQgYXMgdGhlIHNyYyB2YWx1ZSBvZiBhbiBpbWFnZSBlbGVtZW50LlxuXHQgKiBAbWV0aG9kIHRvRGF0YVVSTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gVGhlIGJhY2tncm91bmQgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4gQW55IHZhbGlkIENTUyBjb2xvclxuXHQgKiB2YWx1ZSBpcyBhbGxvd2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9XCJpbWFnZS9wbmdcIl0gVGhlIE1JTUUgdHlwZSBvZiB0aGUgaW1hZ2UgZm9ybWF0IHRvIGJlIGNyZWF0ZS4gVGhlIGRlZmF1bHQgaXMgXCJpbWFnZS9wbmdcIi4gSWYgYW4gdW5rbm93biBNSU1FIHR5cGVcblx0ICogaXMgcGFzc2VkIGluLCBvciBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgTUlNRSB0eXBlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBCYXNlNjQgZW5jb2RlZCBpbWFnZS5cblx0ICoqL1xuXHRwLnRvRGF0YVVSTCA9IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgbWltZVR5cGUpIHtcblx0XHR2YXIgZGF0YSwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdyA9IHRoaXMuY2FudmFzLndpZHRoLCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG5cdFx0aWYgKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0ZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG5cdFx0XHR2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW92ZXJcIjtcblx0XHRcdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZXx8XCJpbWFnZS9wbmdcIik7XG5cblx0XHRpZihiYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIChieSBwYXNzaW5nIGEgZnJlcXVlbmN5IG9mIDApIG1vdXNlIG92ZXIgKHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBhbmQgcm9sbCBvdmVyIGV2ZW50cyAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBmb3IgdGhpcyBzdGFnZSdzIGRpc3BsYXkgbGlzdC4gVGhlc2UgZXZlbnRzIGNhblxuXHQgKiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIHRoZXkgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGV2ZW50cyBjYW4gYmUgY29udHJvbGxlZFxuXHQgKiBpbmRlcGVuZGVudGx5IG9mIG1vdXNlIG1vdmUgZXZlbnRzIHZpYSB0aGUgb3B0aW9uYWwgYGZyZXF1ZW5jeWAgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdCAqICAgICAgc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTsgLy8gMTAgdXBkYXRlcyBwZXIgc2Vjb25kXG5cdCAqXG5cdCAqIEBtZXRob2QgZW5hYmxlTW91c2VPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcXVlbmN5PTIwXSBPcHRpb25hbCBwYXJhbSBzcGVjaWZ5aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBwZXIgc2Vjb25kIHRvIGJyb2FkY2FzdFxuXHQgKiBtb3VzZSBvdmVyL291dCBldmVudHMuIFNldCB0byAwIHRvIGRpc2FibGUgbW91c2Ugb3ZlciBldmVudHMgY29tcGxldGVseS4gTWF4aW11bSBpcyA1MC4gQSBsb3dlciBmcmVxdWVuY3kgaXMgbGVzc1xuXHQgKiByZXNwb25zaXZlLCBidXQgdXNlcyBsZXNzIENQVS5cblx0ICoqL1xuXHRwLmVuYWJsZU1vdXNlT3ZlciA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuXHRcdGlmICh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHRpZiAoZnJlcXVlbmN5ID09IDApIHtcblx0XHRcdFx0dGhpcy5fdGVzdE1vdXNlT3Zlcih0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZyZXF1ZW5jeSA9PSBudWxsKSB7IGZyZXF1ZW5jeSA9IDIwOyB9XG5cdFx0ZWxzZSBpZiAoZnJlcXVlbmN5IDw9IDApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzO1xuXHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpeyBvLl90ZXN0TW91c2VPdmVyKCk7IH0sIDEwMDAvTWF0aC5taW4oNTAsZnJlcXVlbmN5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHN0YWdlIGFkZHMgdG8gRE9NIGVsZW1lbnRzICh3aW5kb3csIGRvY3VtZW50IGFuZCBjYW52YXMpLiBJdCBpcyBnb29kXG5cdCAqIHByYWN0aWNlIHRvIGRpc2FibGUgZXZlbnRzIHdoZW4gZGlzcG9zaW5nIG9mIGEgU3RhZ2UgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgc3RhZ2Ugd2lsbCBjb250aW51ZSB0byByZWNlaXZlXG5cdCAqIGV2ZW50cyBmcm9tIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVET01FdmVudHNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBldmVudHMuIERlZmF1bHQgaXMgdHJ1ZS5cblx0ICoqL1xuXHRwLmVuYWJsZURPTUV2ZW50cyA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdGlmIChlbmFibGUgPT0gbnVsbCkgeyBlbmFibGUgPSB0cnVlOyB9XG5cdFx0dmFyIG4sIG8sIGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnM7XG5cdFx0aWYgKCFlbmFibGUgJiYgbHMpIHtcblx0XHRcdGZvciAobiBpbiBscykge1xuXHRcdFx0XHRvID0gbHNbbl07XG5cdFx0XHRcdG8udC5yZW1vdmVFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlICYmICFscyAmJiB0aGlzLmNhbnZhcykge1xuXHRcdFx0dmFyIHQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdyA6IGRvY3VtZW50O1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHRcdGxzW1wibW91c2V1cFwiXSA9IHt0OnQsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VVcChlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vtb3ZlXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZU1vdmUoZSl9IH07XG5cdFx0XHRsc1tcImRibGNsaWNrXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlRG91YmxlQ2xpY2soZSl9IH07XG5cdFx0XHRsc1tcIm1vdXNlZG93blwiXSA9IHt0OnRoaXMuY2FudmFzLCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlRG93bihlKX0gfTtcblxuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LmFkZEV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFnZSBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlN0YWdlIGNhbm5vdCBiZSBjbG9uZWQuXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3RhZ2UgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRFbGVtZW50UmVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVcblx0ICoqL1xuXHRwLl9nZXRFbGVtZW50UmVjdCA9IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgYm91bmRzO1xuXHRcdHRyeSB7IGJvdW5kcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0gLy8gdGhpcyBjYW4gZmFpbCBvbiBkaXNjb25uZWN0ZWQgRE9NIGVsZW1lbnRzIGluIElFOVxuXHRcdGNhdGNoIChlcnIpIHsgYm91bmRzID0ge3RvcDogZS5vZmZzZXRUb3AsIGxlZnQ6IGUub2Zmc2V0TGVmdCwgd2lkdGg6ZS5vZmZzZXRXaWR0aCwgaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0fTsgfVxuXG5cdFx0dmFyIG9mZlggPSAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50TGVmdCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudExlZnQgfHwgMCk7XG5cdFx0dmFyIG9mZlkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRUb3AgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50VG9wICB8fCAwKTtcblxuXHRcdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZSxudWxsKSA6IGUuY3VycmVudFN0eWxlOyAvLyBJRSA8OSBjb21wYXRpYmlsaXR5LlxuXHRcdHZhciBwYWRMID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdMZWZ0KStwYXJzZUludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblx0XHR2YXIgcGFkVCA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nVG9wKStwYXJzZUludChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuXHRcdHZhciBwYWRSID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdSaWdodCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuXHRcdHZhciBwYWRCID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdCb3R0b20pK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG5cblx0XHQvLyBub3RlOiBpbiBzb21lIGJyb3dzZXJzIGJvdW5kcyBwcm9wZXJ0aWVzIGFyZSByZWFkIG9ubHkuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGJvdW5kcy5sZWZ0K29mZlgrcGFkTCxcblx0XHRcdHJpZ2h0OiBib3VuZHMucmlnaHQrb2ZmWC1wYWRSLFxuXHRcdFx0dG9wOiBib3VuZHMudG9wK29mZlkrcGFkVCxcblx0XHRcdGJvdHRvbTogYm91bmRzLmJvdHRvbStvZmZZLXBhZEJcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFBvaW50ZXJEYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqKi9cblx0cC5fZ2V0UG9pbnRlckRhdGEgPSBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdO1xuXHRcdGlmICghZGF0YSkgeyBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdID0ge3g6MCx5OjB9OyB9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlTW92ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZighZSl7IGUgPSB3aW5kb3cuZXZlbnQ7IH1cblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyTW92ZSgtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cblx0XHR2YXIgaW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTtcblx0XHRpZiAoaW5Cb3VuZHMgfHwgby5pbkJvdW5kcyB8fCB0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdGlmIChpZCA9PT0gLTEgJiYgby5pbkJvdW5kcyA9PSAhaW5Cb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIChpbkJvdW5kcyA/IFwibW91c2VsZWF2ZVwiIDogXCJtb3VzZWVudGVyXCIpLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlbW92ZVwiLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG8udGFyZ2V0LCBcInByZXNzbW92ZVwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgcGFnZVgsIHBhZ2VZLCBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiovXG5cdHAuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuX2dldEVsZW1lbnRSZWN0KHRoaXMuY2FudmFzKTtcblx0XHRwYWdlWCAtPSByZWN0LmxlZnQ7XG5cdFx0cGFnZVkgLT0gcmVjdC50b3A7XG5cblx0XHR2YXIgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXHRcdHBhZ2VYIC89IChyZWN0LnJpZ2h0LXJlY3QubGVmdCkvdztcblx0XHRwYWdlWSAvPSAocmVjdC5ib3R0b20tcmVjdC50b3ApL2g7XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKG8uaW5Cb3VuZHMgPSAocGFnZVggPj0gMCAmJiBwYWdlWSA+PSAwICYmIHBhZ2VYIDw9IHctMSAmJiBwYWdlWSA8PSBoLTEpKSB7XG5cdFx0XHRvLnggPSBwYWdlWDtcblx0XHRcdG8ueSA9IHBhZ2VZO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tb3VzZU1vdmVPdXRzaWRlKSB7XG5cdFx0XHRvLnggPSBwYWdlWCA8IDAgPyAwIDogKHBhZ2VYID4gdy0xID8gdy0xIDogcGFnZVgpO1xuXHRcdFx0by55ID0gcGFnZVkgPCAwID8gMCA6IChwYWdlWSA+IGgtMSA/IGgtMSA6IHBhZ2VZKTtcblx0XHR9XG5cblx0XHRvLnBvc0V2dE9iaiA9IGU7XG5cdFx0by5yYXdYID0gcGFnZVg7XG5cdFx0by5yYXdZID0gcGFnZVk7XG5cblx0XHRpZiAoaWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgaWQgPT09IC0xKSB7XG5cdFx0XHR0aGlzLm1vdXNlWCA9IG8ueDtcblx0XHRcdHRoaXMubW91c2VZID0gby55O1xuXHRcdFx0dGhpcy5tb3VzZUluQm91bmRzID0gby5pbkJvdW5kcztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJVcCgtMSwgZSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uKGlkLCBlLCBjbGVhciwgb3duZXIpIHtcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciB0YXJnZXQ9bnVsbCwgb1RhcmdldCA9IG8udGFyZ2V0O1xuXHRcdGlmICghb3duZXIgJiYgKG9UYXJnZXQgfHwgbmV4dFN0YWdlKSkgeyB0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblx0XHRcblx0XHRpZiAoby5kb3duKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2V1cFwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKHRhcmdldCA9PSBvVGFyZ2V0KSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcImNsaWNrXCIsIHRydWUsIGlkLCBvLCBlKTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcInByZXNzdXBcIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdGlmIChjbGVhcikge1xuXHRcdFx0aWYgKGlkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsOyB9XG5cdFx0XHRkZWxldGUodGhpcy5fcG9pbnRlckRhdGFbaWRdKTtcblx0XHR9IGVsc2UgeyBvLnRhcmdldCA9IG51bGw7IH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCBjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZURvd25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlckRvd24oLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lcikge1xuXHRcdGlmICh0aGlzLnByZXZlbnRTZWxlY3Rpb24pIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0aWYgKHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPT0gbnVsbCB8fCBpZCA9PT0gLTEpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IGlkOyB9IC8vIG1vdXNlIGFsd2F5cyB0YWtlcyBvdmVyLlxuXHRcdFxuXHRcdGlmIChwYWdlWSAhPSBudWxsKSB7IHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTsgfVxuXHRcdHZhciB0YXJnZXQgPSBudWxsLCBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKCFvd25lcikgeyB0YXJnZXQgPSBvLnRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXG5cdFx0aWYgKG8uaW5Cb3VuZHMpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZWRvd25cIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSB0cnVlOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBjbGVhciBJZiB0cnVlLCBjbGVhcnMgdGhlIG1vdXNlb3ZlciAvIHJvbGxvdmVyIChpZS4gbm8gdGFyZ2V0KVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICogQHBhcmFtIHtTdGFnZX0gZXZlbnRUYXJnZXQgVGhlIHN0YWdlIHRoYXQgdGhlIGN1cnNvciBpcyBhY3RpdmVseSBvdmVyLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGVzdE1vdXNlT3ZlciA9IGZ1bmN0aW9uKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlO1xuXHRcdGlmICghdGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Ly8gbm90IGVuYWJsZWQgZm9yIG1vdXNlb3ZlciwgYnV0IHNob3VsZCBzdGlsbCByZWxheSB0aGUgZXZlbnQuXG5cdFx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0Ly8gb25seSB1cGRhdGUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiBUaGlzIHByb3ZpZGVzIGEgbG90IG9mIG9wdGltaXphdGlvbiwgYnV0IGhhcyBzb21lIHRyYWRlLW9mZnMuXG5cdFx0aWYgKCFvIHx8ICghY2xlYXIgJiYgdGhpcy5tb3VzZVggPT0gdGhpcy5fbW91c2VPdmVyWCAmJiB0aGlzLm1vdXNlWSA9PSB0aGlzLl9tb3VzZU92ZXJZICYmIHRoaXMubW91c2VJbkJvdW5kcykpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGUgPSBvLnBvc0V2dE9iajtcblx0XHR2YXIgaXNFdmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0IHx8IGUmJihlLnRhcmdldCA9PSB0aGlzLmNhbnZhcyk7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBjb21tb24gPSAtMSwgY3Vyc29yPVwiXCIsIHQsIGksIGw7XG5cdFx0XG5cdFx0aWYgKCFvd25lciAmJiAoY2xlYXIgfHwgdGhpcy5tb3VzZUluQm91bmRzICYmIGlzRXZlbnRUYXJnZXQpKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludCh0aGlzLm1vdXNlWCwgdGhpcy5tb3VzZVksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWCA9IHRoaXMubW91c2VYO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWSA9IHRoaXMubW91c2VZO1xuXHRcdH1cblxuXHRcdHZhciBvbGRMaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0fHxbXTtcblx0XHR2YXIgb2xkVGFyZ2V0ID0gb2xkTGlzdFtvbGRMaXN0Lmxlbmd0aC0xXTtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldCA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYW5jZXN0b3IgbGlzdCBhbmQgY2hlY2sgZm9yIGN1cnNvcjpcblx0XHR0ID0gdGFyZ2V0O1xuXHRcdHdoaWxlICh0KSB7XG5cdFx0XHRsaXN0LnVuc2hpZnQodCk7XG5cdFx0XHRpZiAoIWN1cnNvcikgeyBjdXJzb3IgPSB0LmN1cnNvcjsgfVxuXHRcdFx0dCA9IHQucGFyZW50O1xuXHRcdH1cblx0XHR0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG5cdFx0aWYgKCFvd25lciAmJiBldmVudFRhcmdldCkgeyBldmVudFRhcmdldC5jYW52YXMuc3R5bGUuY3Vyc29yID0gY3Vyc29yOyB9XG5cblx0XHQvLyBmaW5kIGNvbW1vbiBhbmNlc3Rvcjpcblx0XHRmb3IgKGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RbaV0gIT0gb2xkTGlzdFtpXSkgeyBicmVhazsgfVxuXHRcdFx0Y29tbW9uID0gaTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZFRhcmdldCwgXCJtb3VzZW91dFwiLCB0cnVlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9b2xkTGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZExpc3RbaV0sIFwicm9sbG91dFwiLCBmYWxzZSwgLTEsIG8sIGUsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpPWxpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChsaXN0W2ldLCBcInJvbGxvdmVyXCIsIGZhbHNlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZW92ZXJcIiwgdHJ1ZSwgLTEsIG8sIGUsIG9sZFRhcmdldCk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcywgZXZlbnRUYXJnZXQgfHwgaXNFdmVudFRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRG91YmxlQ2xpY2tcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihlLCBvd25lcikge1xuXHRcdHZhciB0YXJnZXQ9bnVsbCwgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0aWYgKCFvd25lcikge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJkYmxjbGlja1wiLCB0cnVlLCAtMSwgbywgZSk7XG5cdFx0fVxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVEb3VibGVDbGljayhlLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoTW91c2VFdmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gW25hdGl2ZUV2ZW50XVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtyZWxhdGVkVGFyZ2V0XVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoTW91c2VFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgYnViYmxlcywgcG9pbnRlcklkLCBvLCBuYXRpdmVFdmVudCwgcmVsYXRlZFRhcmdldCkge1xuXHRcdC8vIFRPRE86IG1pZ2h0IGJlIHdvcnRoIGVpdGhlciByZXVzaW5nIE1vdXNlRXZlbnQgaW5zdGFuY2VzLCBvciBhZGRpbmcgYSB3aWxsVHJpZ2dlciBtZXRob2QgdG8gYXZvaWQgR0MuXG5cdFx0aWYgKCF0YXJnZXQgfHwgKCFidWJibGVzICYmICF0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkpIHsgcmV0dXJuOyB9XG5cdFx0Lypcblx0XHQvLyBUT0RPOiBhY2NvdW50IGZvciBzdGFnZSB0cmFuc2Zvcm1hdGlvbnM/XG5cdFx0dGhpcy5fbXR4ID0gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fbXR4KS5pbnZlcnQoKTtcblx0XHR2YXIgcHQgPSB0aGlzLl9tdHgudHJhbnNmb3JtUG9pbnQoby54LCBvLnkpO1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgcHQueCwgcHQueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZD09LTEsIG8ucmF3WCwgby5yYXdZKTtcblx0XHQqL1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgby54LCBvLnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQgPT09IC0xLCBvLnJhd1gsIG8ucmF3WSwgcmVsYXRlZFRhcmdldCk7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlN0YWdlID0gY3JlYXRlanMucHJvbW90ZShTdGFnZSwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFxuXHQvKipcblx0ICogQSBCaXRtYXAgcmVwcmVzZW50cyBhbiBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBpbiB0aGUgZGlzcGxheSBsaXN0LiBBIEJpdG1hcCBjYW4gYmUgaW5zdGFudGlhdGVkIHVzaW5nIGFuIGV4aXN0aW5nXG5cdCAqIEhUTUwgZWxlbWVudCwgb3IgYSBzdHJpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgYml0bWFwID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcImltYWdlUGF0aC5qcGdcIik7XG5cdCAqXG5cdCAqIDxzdHJvbmc+Tm90ZXM6PC9zdHJvbmc+XG5cdCAqIDxvbD5cblx0ICogICAgIDxsaT5XaGVuIGEgc3RyaW5nIHBhdGggb3IgaW1hZ2UgdGFnIHRoYXQgaXMgbm90IHlldCBsb2FkZWQgaXMgdXNlZCwgdGhlIHN0YWdlIG1heSBuZWVkIHRvIGJlIHJlZHJhd24gYmVmb3JlIGl0XG5cdCAqICAgICAgd2lsbCBiZSBkaXNwbGF5ZWQuPC9saT5cblx0ICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSBjdXJyZW50bHkgd2lsbCBub3QgcmVzcGVjdCBhbiBhbHBoYSB2YWx1ZSBvdGhlciB0aGFuIDAgb3IgMS4gVG8gZ2V0IGFyb3VuZCB0aGlzLFxuXHQgKiAgICAgdGhlIEJpdG1hcCBjYW4gYmUgY2FjaGVkLjwvbGk+XG5cdCAqICAgICA8bGk+Qml0bWFwcyB3aXRoIGFuIFNWRyBzb3VyY2Ugd2lsbCB0YWludCB0aGUgY2FudmFzIHdpdGggY3Jvc3Mtb3JpZ2luIGRhdGEsIHdoaWNoIHByZXZlbnRzIGludGVyYWN0aXZpdHkuIFRoaXNcblx0ICogICAgIGhhcHBlbnMgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCByZWNlbnQgRmlyZWZveCBidWlsZHMuPC9saT5cblx0ICogICAgIDxsaT5JbWFnZXMgbG9hZGVkIGNyb3NzLW9yaWdpbiB3aWxsIHRocm93IGNyb3NzLW9yaWdpbiBzZWN1cml0eSBlcnJvcnMgd2hlbiBpbnRlcmFjdGVkIHdpdGggdXNpbmcgYSBtb3VzZSwgdXNpbmdcblx0ICogICAgIG1ldGhvZHMgc3VjaCBhcyBgZ2V0T2JqZWN0VW5kZXJQb2ludGAsIG9yIHVzaW5nIGZpbHRlcnMsIG9yIGNhY2hpbmcuIFlvdSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5IHNldHRpbmdcblx0ICogICAgIGBjcm9zc09yaWdpbmAgZmxhZ3Mgb24geW91ciBpbWFnZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBFYXNlbEpTLCBlZzogYGltZy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiO2A8L2xpPlxuXHQgKiA8L29sPlxuXHQgKlxuXHQgKiBAY2xhc3MgQml0bWFwXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IFN0cmluZ30gaW1hZ2VPclVyaSBUaGUgc291cmNlIG9iamVjdCBvciBVUkkgdG8gYW4gaW1hZ2UgdG9cblx0ICogZGlzcGxheS4gVGhpcyBjYW4gYmUgZWl0aGVyIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCwgb3IgYSBzdHJpbmcgVVJJIHRvIGFuIGltYWdlIGZpbGUgdG8gbG9hZCBhbmQgdXNlLlxuXHQgKiBJZiBpdCBpcyBhIFVSSSwgYSBuZXcgSW1hZ2Ugb2JqZWN0IHdpbGwgYmUgY29uc3RydWN0ZWQgYW5kIGFzc2lnbmVkIHRvIHRoZSAuaW1hZ2UgcHJvcGVydHkuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQml0bWFwKGltYWdlT3JVcmkpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGltYWdlIHRvIHJlbmRlci4gVGhpcyBjYW4gYmUgYW4gSW1hZ2UsIGEgQ2FudmFzLCBvciBhIFZpZGVvLiBOb3QgYWxsIGJyb3dzZXJzIChlc3BlY2lhbGx5XG5cdFx0ICogbW9iaWxlIGJyb3dzZXJzKSBzdXBwb3J0IGRyYXdpbmcgdmlkZW8gdG8gYSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IGltYWdlXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudFxuXHRcdCAqKi9cblx0XHRpZiAodHlwZW9mIGltYWdlT3JVcmkgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHR0aGlzLmltYWdlLnNyYyA9IGltYWdlT3JVcmk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW1hZ2UgPSBpbWFnZU9yVXJpO1xuXHRcdH1cblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIGFuIGFyZWEgb2YgdGhlIHNvdXJjZSBpbWFnZSB0byBkcmF3LiBJZiBvbWl0dGVkLCB0aGUgd2hvbGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cblx0XHQgKiBOb3RlIHRoYXQgdmlkZW8gc291cmNlcyBtdXN0IGhhdmUgYSB3aWR0aCAvIGhlaWdodCBzZXQgdG8gd29yayBjb3JyZWN0bHkgd2l0aCBgc291cmNlUmVjdGAuXG5cdFx0ICogQHByb3BlcnR5IHNvdXJjZVJlY3Rcblx0XHQgKiBAdHlwZSBSZWN0YW5nbGVcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2VSZWN0ID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaXRtYXAsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXHRcblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBCaXRtYXA7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IChpbWFnZSAmJiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSB8fCAhdGhpcy5pbWFnZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHZhciBpbWcgPSB0aGlzLmltYWdlLCByZWN0ID0gdGhpcy5zb3VyY2VSZWN0O1xuXHRcdGlmIChyZWN0KSB7XG5cdFx0XHQvLyBzb21lIGJyb3dzZXJzIGNob2tlIG9uIG91dCBvZiBib3VuZCB2YWx1ZXMsIHNvIHdlJ2xsIGZpeCB0aGVtOlxuXHRcdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MSArIHJlY3Qud2lkdGgsIHkyID0geTEgKyByZWN0LmhlaWdodCwgeCA9IDAsIHkgPSAwLCB3ID0gaW1nLndpZHRoLCBoID0gaW1nLmhlaWdodDtcblx0XHRcdGlmICh4MSA8IDApIHsgeCAtPSB4MTsgeDEgPSAwOyB9XG5cdFx0XHRpZiAoeDIgPiB3KSB7IHgyID0gdzsgfVxuXHRcdFx0aWYgKHkxIDwgMCkgeyB5IC09IHkxOyB5MSA9IDA7IH1cblx0XHRcdGlmICh5MiA+IGgpIHsgeTIgPSBoOyB9XG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgeDEsIHkxLCB4Mi14MSwgeTIteTEsIHgsIHksIHgyLXgxLCB5Mi15MSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvL05vdGUsIHRoZSBkb2Mgc2VjdGlvbnMgYmVsb3cgZG9jdW1lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCBBUElzIChmcm9tIERpc3BsYXlPYmplY3QpICBmcm9tXG5cdC8vQml0bWFwLiBUaGlzIGlzIHdoeSB0aGV5IGhhdmUgbm8gbWV0aG9kIGltcGxlbWVudGF0aW9ucy5cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlLCBvID0gdGhpcy5zb3VyY2VSZWN0IHx8IGltYWdlO1xuXHRcdHZhciBoYXNDb250ZW50ID0gKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gaGFzQ29udGVudCA/IHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoMCwgMCwgby53aWR0aCwgby5oZWlnaHQpIDogbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEJpdG1hcCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtCaXRtYXB9IGEgY2xvbmUgb2YgdGhlIEJpdG1hcCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSBuZXcgQml0bWFwKHRoaXMuaW1hZ2UpO1xuXHRcdGlmICh0aGlzLnNvdXJjZVJlY3QpIHsgby5zb3VyY2VSZWN0ID0gdGhpcy5zb3VyY2VSZWN0LmNsb25lKCk7IH1cblx0XHR0aGlzLl9jbG9uZVByb3BzKG8pO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCaXRtYXAgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXHRcblx0Y3JlYXRlanMuQml0bWFwID0gY3JlYXRlanMucHJvbW90ZShCaXRtYXAsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBhIGZyYW1lIG9yIHNlcXVlbmNlIG9mIGZyYW1lcyAoaWUuIGFuIGFuaW1hdGlvbikgZnJvbSBhIFNwcml0ZVNoZWV0IGluc3RhbmNlLiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZlxuXHQgKiBpbWFnZXMgKHVzdWFsbHkgYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIHNpbmdsZSBpbWFnZS4gRm9yIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS4gWW91IGNhbiBkaXNwbGF5IGluZGl2aWR1YWwgZnJhbWVzLFxuXHQgKiBwbGF5IGZyYW1lcyBhcyBhbiBhbmltYXRpb24sIGFuZCBldmVuIHNlcXVlbmNlIGFuaW1hdGlvbnMgdG9nZXRoZXIuXG5cdCAqXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc2V0dGluZyB1cCBmcmFtZXMgYW5kIGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0KTtcblx0ICogICAgICBpbnN0YW5jZS5nb3RvQW5kU3RvcChcImZyYW1lTmFtZVwiKTtcblx0ICpcblx0ICogVW50aWwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsXG5cdCAqIG9ubHkgdGhlIGZpcnN0IGRlZmluZWQgZnJhbWUgZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0IHdpbGwgYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZShzKSwgZnJhbWVcblx0ICogZGltZW5zaW9ucywgYW5kIGZyYW1lIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZnJhbWVPckFuaW1hdGlvbl0gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdG8gcGxheSBpbml0aWFsbHkuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlKHNwcml0ZVNoZWV0LCBmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmcmFtZSBpbmRleCB0aGF0IHdpbGwgYmUgZHJhd24gd2hlbiBkcmF3IGlzIGNhbGxlZC4gTm90ZSB0aGF0IHdpdGggc29tZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGRlZmluaXRpb25zLCB0aGlzIHdpbGwgYWR2YW5jZSBub24tc2VxdWVudGlhbGx5LiBUaGlzIHdpbGwgYWx3YXlzIGJlIGFuIGludGVnZXIgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEFuaW1hdGlvblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGZpbmFsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBhZHZhbmNpbmcgZWFjaCB0aWNrIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlLCB5b3UgY291bGQgY3JlYXRlIGEgc3ByaXRlXG5cdFx0ICogc2hlZXQgb2YgaWNvbnMsIHNldCBwYXVzZWQgdG8gdHJ1ZSwgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIGljb24gYnkgc2V0dGluZyA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZSwgZnJhbWUgZGltZW5zaW9ucywgYW5kIGZyYW1lXG5cdFx0ICogZGF0YS4gU2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIHtTcHJpdGVTaGVldH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggd2l0aGluIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uIFdoZW4gcGxheWluZyBub3JtYWxseSwgdGhpcyB3aWxsIGluY3JlYXNlXG5cdFx0ICogZnJvbSAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgY3VycmVudCBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGNvdWxkIGJlIGEgbm9uLWludGVnZXIgdmFsdWUgaWZcblx0XHQgKiB1c2luZyB0aW1lLWJhc2VkIHBsYXliYWNrIChzZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZVwifX17ey9jcm9zc0xpbmt9fSwgb3IgaWYgdGhlIGFuaW1hdGlvbidzIHNwZWVkIGlzXG5cdFx0ICogbm90IGFuIGludGVnZXIuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25GcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgU3ByaXRlIGluc3RhbmNlcyBhZHZhbmNlIG9uZSBmcmFtZSBwZXIgdGljay4gU3BlY2lmeWluZyBhIGZyYW1lcmF0ZSBmb3IgdGhlIFNwcml0ZSAob3IgaXRzIHJlbGF0ZWRcblx0XHQgKiBTcHJpdGVTaGVldCkgd2lsbCBjYXVzZSBpdCB0byBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRpY2tzIGFzIGFwcHJvcHJpYXRlIHRvIG1haW50YWluIHRoZSB0YXJnZXRcblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgYSBTcHJpdGUgd2l0aCBhIGZyYW1lcmF0ZSBvZiAxMCBpcyBwbGFjZWQgb24gYSBTdGFnZSBiZWluZyB1cGRhdGVkIGF0IDQwZnBzLCB0aGVuIHRoZSBTcHJpdGUgd2lsbFxuXHRcdCAqIGFkdmFuY2Ugcm91Z2hseSBvbmUgZnJhbWUgZXZlcnkgNCB0aWNrcy4gVGhpcyB3aWxsIG5vdCBiZSBleGFjdCwgYmVjYXVzZSB0aGUgdGltZSBiZXR3ZWVuIGVhY2ggdGljayB3aWxsXG5cdFx0ICogdmFyeSBzbGlnaHRseSBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmVhdHVyZSBpcyBkZXBlbmRlbnQgb24gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IChvciBhbiBvYmplY3Qgd2l0aCBhbiBhcHByb3ByaWF0ZSBcImRlbHRhXCIgcHJvcGVydHkpIGJlaW5nXG5cdFx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGFuaW1hdGlvbiBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgZnJhbWUgaW5kZXguXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50RnJhbWVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2tpcHMgdGhlIG5leHQgYXV0byBhZHZhbmNlLiBVc2VkIGJ5IGdvdG9BbmRQbGF5IHRvIGF2b2lkIGltbWVkaWF0ZWx5IGp1bXBpbmcgdG8gdGhlIG5leHQgZnJhbWVcblx0XHQgKiBAcHJvcGVydHkgX3NraXBBZHZhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKGZyYW1lT3JBbmltYXRpb24gIT0gbnVsbCkgeyB0aGlzLmdvdG9BbmRQbGF5KGZyYW1lT3JBbmltYXRpb24pOyB9XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IFNwcml0ZTsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQyBzcHJpdGVzaGVldCBleHBvcnQuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFuIGFuaW1hdGlvbiByZWFjaGVzIGl0cyBlbmRzLlxuXHQgKiBAZXZlbnQgYW5pbWF0aW9uZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IGp1c3QgZW5kZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXh0IFRoZSBuYW1lIG9mIHRoZSBuZXh0IGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGxheWVkLCBvciBudWxsLiBUaGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgbmFtZSBpZiB0aGUgYW5pbWF0aW9uIGlzIGxvb3BpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBhbnkgdGltZSB0aGUgY3VycmVudCBmcmFtZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSBkdWUgdG8gYXV0b21hdGljIGFkdmFuY2VtZW50IG9uIGEgdGljayxcblx0ICogb3IgY2FsbGluZyBnb3RvQW5kUGxheSgpIG9yIGdvdG9BbmRTdG9wKCkuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR2YXIgbyA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0RnJhbWUodGhpcy5fY3VycmVudEZyYW1lfDApO1xuXHRcdGlmICghbykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgcmVjdCA9IG8ucmVjdDtcblx0XHRpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkgeyBjdHguZHJhd0ltYWdlKG8uaW1hZ2UsIHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgLW8ucmVnWCwgLW8ucmVnWSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Ly9Ob3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSAgZnJvbVxuXHQvL0JpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogUGxheSAodW5wYXVzZSkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGF1c2VkIGlmIGVpdGhlciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvc3RvcFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLiBTaW5nbGUgZnJhbWUgYW5pbWF0aW9ucyB3aWxsIHJlbWFpblxuXHQgKiB1bmNoYW5nZWQuXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiovXG5cdHAucGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWluZyBhIHJ1bm5pbmcgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGxheWluZyBpZiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgY2FsbGVkLiBOb3RlIHRoYXQgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCByZXN1bWUgcGxheWJhY2suXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiovXG5cdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UgYW5kIHBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIG5hbWUsIG5hbWVkIGZyYW1lLCBvciBmcmFtZSBudW1iZXIuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG9cblx0ICogYW5kIGJlZ2luIHBsYXlpbmcuXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byB0cnVlIGFuZCBzZWVrcyB0byB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBzdG9wLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBwbGF5aGVhZC4gVGhpcyBvY2N1cnMgYXV0b21hdGljYWxseSBlYWNoIHRpY2sgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIFt0aW1lXSB7TnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gYWR2YW5jZSBieS4gT25seSBhcHBsaWNhYmxlIGlmIGZyYW1lcmF0ZSBpcyBzZXQgb24gdGhlIFNwcml0ZVxuXHQgKiBvciBpdHMgU3ByaXRlU2hlZXQuXG5cdCAqIEBtZXRob2QgYWR2YW5jZVxuXHQqL1xuXHRwLmFkdmFuY2UgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIGZwcyA9IHRoaXMuZnJhbWVyYXRlIHx8IHRoaXMuc3ByaXRlU2hlZXQuZnJhbWVyYXRlO1xuXHRcdHZhciB0ID0gKGZwcyAmJiB0aW1lICE9IG51bGwpID8gdGltZS8oMTAwMC9mcHMpIDogMTtcblx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSh0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUgcmVsYXRpdmUgdG9cblx0ICogdGhlIG9yaWdpbi4gRm9yIGV4YW1wbGUsIGEgOTAgeCA3MCBmcmFtZSB3aXRoIDxjb2RlPnJlZ1g9NTA8L2NvZGU+IGFuZCA8Y29kZT5yZWdZPTQwPC9jb2RlPiB3b3VsZCByZXR1cm4gYVxuXHQgKiByZWN0YW5nbGUgd2l0aCBbeD0tNTAsIHk9LTQwLCB3aWR0aD05MCwgaGVpZ2h0PTcwXS4gVGhpcyBpZ25vcmVzIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG5cdCAqXG5cdCAqIEFsc28gc2VlIHRoZSBTcHJpdGVTaGVldCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHlcblx0ICogbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogc2hvdWxkIHRoaXMgbm9ybWFsaXplRnJhbWU/XG5cdFx0cmV0dXJuIHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKSB8fCB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lQm91bmRzKHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLl9yZWN0YW5nbGUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFNwcml0ZSBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBzYW1lIFNwcml0ZVNoZWV0IGlzIHNoYXJlZCBiZXR3ZWVuIGNsb25lZFxuXHQgKiBpbnN0YW5jZXMuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U3ByaXRlfSBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBTcHJpdGUodGhpcy5zcHJpdGVTaGVldCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtTcHJpdGV9IG9cblx0ICogQHJldHVybiB7U3ByaXRlfSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLmN1cnJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcblx0XHRvLnBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbkZyYW1lID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWU7XG5cdFx0by5mcmFtZXJhdGUgPSB0aGlzLmZyYW1lcmF0ZTtcblx0XHRcblx0XHRvLl9hbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0by5fY3VycmVudEZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdG8uX3NraXBBZHZhbmNlID0gdGhpcy5fc2tpcEFkdmFuY2U7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIDxjb2RlPmN1cnJlbnRGcmFtZTwvY29kZT4gaWYgcGF1c2VkIGlzIG5vdCB0cnVlLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRpY2tzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdGlmICghdGhpcy5wYXVzZWQpIHtcblx0XHRcdGlmICghdGhpcy5fc2tpcEFkdmFuY2UpIHsgdGhpcy5hZHZhbmNlKGV2dE9iaiYmZXZ0T2JqLmRlbHRhKTsgfVxuXHRcdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgY3VycmVudCBmcmFtZSwgYWR2YW5jaW5nIGFuaW1hdGlvbnMgYW5kIGRpc3BhdGNoaW5nIGNhbGxiYWNrcyBhcyBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9ub3JtYWxpemVGcmFtZVxuXHQgKiovXG5cdHAuX25vcm1hbGl6ZUZyYW1lID0gZnVuY3Rpb24oZnJhbWVEZWx0YSkge1xuXHRcdGZyYW1lRGVsdGEgPSBmcmFtZURlbHRhIHx8IDA7XG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbjtcblx0XHR2YXIgcGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdHZhciBsO1xuXHRcdFxuXHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdHZhciBzcGVlZCA9IGFuaW1hdGlvbi5zcGVlZCB8fCAxO1xuXHRcdFx0dmFyIGFuaW1GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0bCA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoO1xuXHRcdFx0aWYgKGFuaW1GcmFtZSArIGZyYW1lRGVsdGEgKiBzcGVlZCA+PSBsKSB7XG5cdFx0XHRcdHZhciBuZXh0ID0gYW5pbWF0aW9uLm5leHQ7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXNwYXRjaEFuaW1hdGlvbkVuZChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGwgLSAxKSkge1xuXHRcdFx0XHRcdC8vIHNvbWV0aGluZyBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW55IG1vcmUgY2hhbmdlcyBoZXJlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0Ly8gc2VxdWVuY2UuIEF1dG9tYXRpY2FsbHkgY2FsbHMgX25vcm1hbGl6ZUZyYW1lIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBmcmFtZXMuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2dvdG8obmV4dCwgZnJhbWVEZWx0YSAtIChsIC0gYW5pbUZyYW1lKSAvIHNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBlbmQuXG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGFuaW1GcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YW5pbUZyYW1lICs9IGZyYW1lRGVsdGEgKiBzcGVlZDtcblx0XHRcdH1cblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gYW5pbUZyYW1lO1xuXHRcdFx0dGhpcy5fY3VycmVudEZyYW1lID0gYW5pbWF0aW9uLmZyYW1lc1thbmltRnJhbWUgfCAwXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFtZSA9ICh0aGlzLl9jdXJyZW50RnJhbWUgKz0gZnJhbWVEZWx0YSk7XG5cdFx0XHRsID0gdGhpcy5zcHJpdGVTaGVldC5nZXROdW1GcmFtZXMoKTtcblx0XHRcdGlmIChmcmFtZSA+PSBsICYmIGwgPiAwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBsb29wZWQuXG5cdFx0XHRcdFx0aWYgKCh0aGlzLl9jdXJyZW50RnJhbWUgLT0gbCkgPj0gbCkgeyByZXR1cm4gdGhpcy5fbm9ybWFsaXplRnJhbWUoKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lIHwgMDtcblx0XHRpZiAodGhpcy5jdXJyZW50RnJhbWUgIT0gZnJhbWUpIHtcblx0XHRcdHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBcImFuaW1hdGlvbmVuZFwiIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYSBoYW5kbGVyIGNoYW5nZWQgdGhlIGFuaW1hdGlvbiAoZXguIGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLilcblx0ICogQHByb3BlcnR5IF9kaXNwYXRjaEFuaW1hdGlvbkVuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hBbmltYXRpb25FbmQgPSBmdW5jdGlvbihhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGVuZCkge1xuXHRcdHZhciBuYW1lID0gYW5pbWF0aW9uID8gYW5pbWF0aW9uLm5hbWUgOiBudWxsO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIikpIHtcblx0XHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJhbmltYXRpb25lbmRcIik7XG5cdFx0XHRldnQubmFtZSA9IG5hbWU7XG5cdFx0XHRldnQubmV4dCA9IG5leHQ7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHR9XG5cdFx0Ly8gZGlkIHRoZSBhbmltYXRpb24gZ2V0IGNoYW5nZWQgaW4gdGhlIGV2ZW50IHN0YWNrPzpcblx0XHR2YXIgY2hhbmdlZCA9ICh0aGlzLl9hbmltYXRpb24gIT0gYW5pbWF0aW9uIHx8IHRoaXMuX2N1cnJlbnRGcmFtZSAhPSBmcmFtZSk7XG5cdFx0Ly8gaWYgdGhlIGFuaW1hdGlvbiBoYXNuJ3QgY2hhbmdlZCwgYnV0IHRoZSBzcHJpdGUgd2FzIHBhdXNlZCwgdGhlbiB3ZSB3YW50IHRvIHN0aWNrIHRvIHRoZSBsYXN0IGZyYW1lOlxuXHRcdGlmICghY2hhbmdlZCAmJiAhcGF1c2VkICYmIHRoaXMucGF1c2VkKSB7IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gZW5kOyBjaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgcGxheWhlYWQgdG8gdGhlIHNwZWNpZmllZCBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uLlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbZnJhbWVdIFRoZSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdvIHRvLiBEZWZhdWx0cyB0byAwLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ290byA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24sIGZyYW1lKSB7XG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLnNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihmcmFtZU9yQW5pbWF0aW9uKTtcblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbiA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKGZyYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZSA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU2hhcGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBIFNoYXBlIGFsbG93cyB5b3UgdG8gZGlzcGxheSB2ZWN0b3IgYXJ0IGluIHRoZSBkaXNwbGF5IGxpc3QuIEl0IGNvbXBvc2l0ZXMgYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0YW5jZSB3aGljaCBleHBvc2VzIGFsbCBvZiB0aGUgdmVjdG9yIGRyYXdpbmcgbWV0aG9kcy4gVGhlIEdyYXBoaWNzIGluc3RhbmNlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBTaGFwZVxuXHQgKiBpbnN0YW5jZXMgdG8gZGlzcGxheSB0aGUgc2FtZSB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aCBkaWZmZXJlbnQgcG9zaXRpb25zIG9yIHRyYW5zZm9ybXMuXG5cdCAqXG5cdCAqIElmIHRoZSB2ZWN0b3IgYXJ0IHdpbGwgbm90XG5cdCAqIGNoYW5nZSBiZXR3ZWVuIGRyYXdzLCB5b3UgbWF5IHdhbnQgdG8gdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byByZWR1Y2UgdGhlXG5cdCAqIHJlbmRlcmluZyBjb3N0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKGdyYXBoaWNzKTtcblx0ICpcblx0ICogICAgICAvL0FsdGVybmF0aXZlbHkgdXNlIGNhbiBhbHNvIHVzZSB0aGUgZ3JhcGhpY3MgcHJvcGVydHkgb2YgdGhlIFNoYXBlIGNsYXNzIHRvIHJlbmRlcmVyIHRoZSBzYW1lIGFzIGFib3ZlLlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgU2hhcGVcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtHcmFwaGljc30gZ3JhcGhpY3MgT3B0aW9uYWwuIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LiBJZiBudWxsLCBhIG5ldyBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhcGUoZ3JhcGhpY3MpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IGdyYXBoaWNzXG5cdFx0ICogQHR5cGUgR3JhcGhpY3Ncblx0XHQgKiovXG5cdFx0dGhpcy5ncmFwaGljcyA9IGdyYXBoaWNzID8gZ3JhcGhpY3MgOiBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTaGFwZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuZ3JhcGhpY3MgJiYgIXRoaXMuZ3JhcGhpY3MuaXNFbXB0eSgpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFNoYXBlIGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLiBSZXR1cm5zIHRydWUgaWZcblx0ICogdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogPGk+Tk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLjwvaT5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuZ3JhcGhpY3MuZHJhdyhjdHgsIHRoaXMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFwZS4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlIHJldmVydGVkIHRvXG5cdCAqIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2l2ZSBJZiB0cnVlLCB0aGlzIFNoYXBlJ3Mge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2Ugd2lsbCBhbHNvIGJlXG5cdCAqIGNsb25lZC4gSWYgZmFsc2UsIHRoZSBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIHNoYXJlZCB3aXRoIHRoZSBuZXcgU2hhcGUuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBnID0gKHJlY3Vyc2l2ZSAmJiB0aGlzLmdyYXBoaWNzKSA/IHRoaXMuZ3JhcGhpY3MuY2xvbmUoKSA6IHRoaXMuZ3JhcGhpY3M7XG5cdFx0cmV0dXJuICB0aGlzLl9jbG9uZVByb3BzKG5ldyBTaGFwZShnKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTaGFwZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU2hhcGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNoYXBlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXkgb25lIG9yIG1vcmUgbGluZXMgb2YgZHluYW1pYyB0ZXh0IChub3QgdXNlciBlZGl0YWJsZSkgaW4gdGhlIGRpc3BsYXkgbGlzdC4gTGluZSB3cmFwcGluZyBzdXBwb3J0ICh1c2luZyB0aGVcblx0ICogbGluZVdpZHRoKSBpcyB2ZXJ5IGJhc2ljLCB3cmFwcGluZyBvbiBzcGFjZXMgYW5kIHRhYnMgb25seS4gTm90ZSB0aGF0IGFzIGFuIGFsdGVybmF0aXZlIHRvIFRleHQsIHlvdSBjYW4gcG9zaXRpb24gSFRNTFxuXHQgKiB0ZXh0IGFib3ZlIG9yIGJlbG93IHRoZSBjYW52YXMgcmVsYXRpdmUgdG8gaXRlbXMgaW4gdGhlIGRpc3BsYXkgbGlzdCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCwgb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiRE9NRWxlbWVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGI+UGxlYXNlIG5vdGUgdGhhdCBUZXh0IGRvZXMgbm90IHN1cHBvcnQgSFRNTCB0ZXh0LCBhbmQgY2FuIG9ubHkgZGlzcGxheSBvbmUgZm9udCBzdHlsZSBhdCBhIHRpbWUuPC9iPiBUbyB1c2Vcblx0ICogbXVsdGlwbGUgZm9udCBzdHlsZXMsIHlvdSB3aWxsIG5lZWQgdG8gY3JlYXRlIG11bHRpcGxlIHRleHQgaW5zdGFuY2VzLCBhbmQgcG9zaXRpb24gdGhlbSBtYW51YWxseS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQoXCJIZWxsbyBXb3JsZFwiLCBcIjIwcHggQXJpYWxcIiwgXCIjZmY3NzAwXCIpO1xuXHQgKiAgICAgIHRleHQueCA9IDEwMDtcblx0ICogICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuXHQgKlxuXHQgKiBDcmVhdGVKUyBUZXh0IHN1cHBvcnRzIHdlYiBmb250cyAodGhlIHNhbWUgcnVsZXMgYXMgQ2FudmFzKS4gVGhlIGZvbnQgbXVzdCBiZSBsb2FkZWQgYW5kIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlclxuXHQgKiBiZWZvcmUgaXQgY2FuIGJlIGRpc3BsYXllZC5cblx0ICpcblx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBUZXh0IGNhbiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIGNhY2hlIGluc3RhbmNlcyB3aGVyZSBwb3NzaWJsZS4gQmUgYXdhcmUgdGhhdCBub3QgYWxsXG5cdCAqIGJyb3dzZXJzIHdpbGwgcmVuZGVyIFRleHQgZXhhY3RseSB0aGUgc2FtZS5cblx0ICogQGNsYXNzIFRleHRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0XSBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRdIFRoZSBmb250IHN0eWxlIHRvIHVzZS4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGZvbnQgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcImJvbGRcblx0ICogMzZweCBBcmlhbFwiKS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcl0gVGhlIGNvbG9yIHRvIGRyYXcgdGhlIHRleHQgaW4uIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBjb2xvciBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguXG5cdCAqIFwiI0YwMFwiLCBcInJlZFwiLCBvciBcIiNGRjAwMDBcIikuXG5cdCAqKi9cblx0ZnVuY3Rpb24gVGV4dCh0ZXh0LCBmb250LCBjb2xvcikge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmb250IHN0eWxlIHRvIHVzZS4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGZvbnQgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcImJvbGQgMzZweCBBcmlhbFwiKS5cblx0XHQgKiBAcHJvcGVydHkgZm9udFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLmZvbnQgPSBmb250O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY29sb3IgdG8gZHJhdyB0aGUgdGV4dCBpbi4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGNvbG9yIGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCIjRjAwXCIpLiBEZWZhdWx0IGlzIFwiIzAwMFwiLlxuXHRcdCAqIEl0IHdpbGwgYWxzbyBhY2NlcHQgdmFsaWQgY2FudmFzIGZpbGxTdHlsZSB2YWx1ZXMuXG5cdFx0ICogQHByb3BlcnR5IGNvbG9yXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnQuIEFueSBvZiBcInN0YXJ0XCIsIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIGFuZCBcImNlbnRlclwiLiBGb3IgZGV0YWlsZWRcblx0XHQgKiBpbmZvcm1hdGlvbiB2aWV3IHRoZVxuXHRcdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi4gRGVmYXVsdCBpcyBcImxlZnRcIi5cblx0XHQgKiBAcHJvcGVydHkgdGV4dEFsaWduXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgcG9pbnQgb24gdGhlIGZvbnQuIEFueSBvZiBcInRvcFwiLCBcImhhbmdpbmdcIiwgXCJtaWRkbGVcIiwgXCJhbHBoYWJldGljXCIsIFwiaWRlb2dyYXBoaWNcIiwgb3Jcblx0XHQgKiBcImJvdHRvbVwiLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gdmlldyB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LiBEZWZhdWx0IGlzIFwidG9wXCIuXG5cdFx0ICogQHByb3BlcnR5IHRleHRCYXNlbGluZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCovXG5cdFx0dGhpcy50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB3aWR0aCB0byBkcmF3IHRoZSB0ZXh0LiBJZiBtYXhXaWR0aCBpcyBzcGVjaWZpZWQgKG5vdCBudWxsKSwgdGhlIHRleHQgd2lsbCBiZSBjb25kZW5zZWQgb3Jcblx0XHQgKiBzaHJ1bmsgdG8gbWFrZSBpdCBmaXQgaW4gdGhpcyB3aWR0aC4gRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIHZpZXcgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXhXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGdyZWF0ZXIgdGhhbiAwLCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduIGFzIGEgc3Ryb2tlIChvdXRsaW5lKSBvZiB0aGUgc3BlY2lmaWVkIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdXRsaW5lXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3V0bGluZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbGluZSBoZWlnaHQgKHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gYmFzZWxpbmVzKSBmb3IgbXVsdGktbGluZSB0ZXh0LiBJZiBudWxsIG9yIDAsXG5cdFx0ICogdGhlIHZhbHVlIG9mIGdldE1lYXN1cmVkTGluZUhlaWdodCBpcyB1c2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lSGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbWF4aW11bSB3aWR0aCBmb3IgYSBsaW5lIG9mIHRleHQgYmVmb3JlIGl0IGlzIHdyYXBwZWQgdG8gbXVsdGlwbGUgbGluZXMuIElmIG51bGwsXG5cdFx0ICogdGhlIHRleHQgd2lsbCBub3QgYmUgd3JhcHBlZC5cblx0XHQgKiBAcHJvcGVydHkgbGluZVdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZVdpZHRoID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0LCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXHRcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ29udGV4dFxuXHQgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7IFRleHQuX3dvcmtpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7IH1cblx0XG5cdFxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB4IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEFsaWduIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkgSF9PRkZTRVRTXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUZXh0LkhfT0ZGU0VUUyA9IHtzdGFydDogMCwgbGVmdDogMCwgY2VudGVyOiAtMC41LCBlbmQ6IC0xLCByaWdodDogLTF9O1xuXHRcblx0LyoqXG5cdCAqIExvb2t1cCB0YWJsZSBmb3IgdGhlIHJhdGlvIHRvIG9mZnNldCBib3VuZHMgeSBjYWxjdWxhdGlvbnMgYmFzZWQgb24gdGhlIHRleHRCYXNlbGluZSBwcm9wZXJ0eS5cblx0ICogQHByb3BlcnR5IEhfT0ZGU0VUU1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGV4dC5WX09GRlNFVFMgPSB7dG9wOiAwLCBoYW5naW5nOiAtMC4wMSwgbWlkZGxlOiAtMC40LCBhbHBoYWJldGljOiAtMC44LCBpZGVvZ3JhcGhpYzogLTAuODUsIGJvdHRvbTogLTF9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMudGV4dCAhPSBudWxsICYmIHRoaXMudGV4dCAhPT0gXCJcIik7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBUZXh0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dmFyIGNvbCA9IHRoaXMuY29sb3IgfHwgXCIjMDAwXCI7XG5cdFx0aWYgKHRoaXMub3V0bGluZSkgeyBjdHguc3Ryb2tlU3R5bGUgPSBjb2w7IGN0eC5saW5lV2lkdGggPSB0aGlzLm91dGxpbmUqMTsgfVxuXHRcdGVsc2UgeyBjdHguZmlsbFN0eWxlID0gY29sOyB9XG5cdFx0XG5cdFx0dGhpcy5fZHJhd1RleHQodGhpcy5fcHJlcENvbnRleHQoY3R4KSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1lYXN1cmVkLCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSB0ZXh0IHdpdGhvdXQgd3JhcHBpbmcuIFVzZSBnZXRCb3VuZHMgZm9yIGEgbW9yZSByb2J1c3QgdmFsdWUuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRXaWR0aFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtZWFzdXJlZCwgdW50cmFuc2Zvcm1lZCB3aWR0aCBvZiB0aGUgdGV4dC5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkV2lkdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aCh0aGlzLnRleHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IG9mIHRoZSB0ZXh0LCBpZ25vcmluZyB0aGUgbGluZUhlaWdodCBwcm9wZXJ0eS4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgbWVhc3VyZWRcblx0ICogd2lkdGggb2YgYSBcIk1cIiBjaGFyYWN0ZXIgbXVsdGlwbGllZCBieSAxLjIsIHdoaWNoIHByb3ZpZGVzIGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IGZvciBtb3N0IGZvbnRzLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkTGluZUhlaWdodFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGxpbmUgaGVpZ2h0IG9mIHRoZSB0ZXh0LCBpZ25vcmluZyB0aGUgbGluZUhlaWdodCBwcm9wZXJ0eS4gVGhpcyBpc1xuXHQgKiBiYXNlZCBvbiB0aGUgbWVhc3VyZWQgd2lkdGggb2YgYSBcIk1cIiBjaGFyYWN0ZXIgbXVsdGlwbGllZCBieSAxLjIsIHdoaWNoIGFwcHJveGltYXRlcyBlbSBmb3IgbW9zdCBmb250cy5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkTGluZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRNZWFzdXJlZFdpZHRoKFwiTVwiKSoxLjI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBtdWx0aS1saW5lIHRleHQgYnkgbXVsdGlwbHlpbmcgdGhlIG51bWJlciBvZiBsaW5lcyBhZ2FpbnN0IGVpdGhlciB0aGVcblx0ICogPGNvZGU+bGluZUhlaWdodDwvY29kZT4gKGlmIHNwZWNpZmllZCkgb3Ige3sjY3Jvc3NMaW5rIFwiVGV4dC9nZXRNZWFzdXJlZExpbmVIZWlnaHRcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdFxuXHQgKiB0aGlzIG9wZXJhdGlvbiByZXF1aXJlcyB0aGUgdGV4dCBmbG93aW5nIGxvZ2ljIHRvIHJ1biwgd2hpY2ggaGFzIGFuIGFzc29jaWF0ZWQgQ1BVIGNvc3QuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRIZWlnaHRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIHRoZSB1bnRyYW5zZm9ybWVkIG11bHRpLWxpbmUgdGV4dC5cblx0ICoqL1xuXHRwLmdldE1lYXN1cmVkSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwse30pLmhlaWdodDtcblx0fTtcblxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChyZWN0KSB7IHJldHVybiByZWN0OyB9XG5cdFx0aWYgKHRoaXMudGV4dCA9PSBudWxsIHx8IHRoaXMudGV4dCA9PT0gXCJcIikgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHZhciBvID0gdGhpcy5fZHJhd1RleHQobnVsbCwge30pO1xuXHRcdHZhciB3ID0gKHRoaXMubWF4V2lkdGggJiYgdGhpcy5tYXhXaWR0aCA8IG8ud2lkdGgpID8gdGhpcy5tYXhXaWR0aCA6IG8ud2lkdGg7XG5cdFx0dmFyIHggPSB3ICogVGV4dC5IX09GRlNFVFNbdGhpcy50ZXh0QWxpZ258fFwibGVmdFwiXTtcblx0XHR2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodHx8dGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHR2YXIgeSA9IGxpbmVIZWlnaHQgKiBUZXh0LlZfT0ZGU0VUU1t0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIl07XG5cdFx0cmV0dXJuIHRoaXMuX3JlY3RhbmdsZS5zZXRWYWx1ZXMoeCwgeSwgdywgby5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgYW5kIGxpbmVzIHByb3BlcnRpZXMuIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSB0aGUgdmlzdWFsIHdpZHRoIGFuZCBoZWlnaHRcblx0ICogb2YgdGhlIGRyYXduIHRleHQuIFRoZSBsaW5lcyBwcm9wZXJ0eSBjb250YWlucyBhbiBhcnJheSBvZiBzdHJpbmdzLCBvbmUgZm9yXG5cdCAqIGVhY2ggbGluZSBvZiB0ZXh0IHRoYXQgd2lsbCBiZSBkcmF3biwgYWNjb3VudGluZyBmb3IgbGluZSBicmVha3MgYW5kIHdyYXBwaW5nLiBUaGVzZSBzdHJpbmdzIGhhdmUgdHJhaWxpbmdcblx0ICogd2hpdGVzcGFjZSByZW1vdmVkLlxuXHQgKiBAbWV0aG9kIGdldE1ldHJpY3Ncblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldE1ldHJpY3MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IHtsaW5lczpbXX07XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0IHx8IHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0by52T2Zmc2V0ID0gby5saW5lSGVpZ2h0ICogVGV4dC5WX09GRlNFVFNbdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCJdO1xuXHRcdHJldHVybiB0aGlzLl9kcmF3VGV4dChudWxsLCBvLCBvLmxpbmVzKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBUZXh0IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1RleHR9IGEgY2xvbmUgb2YgdGhlIFRleHQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBUZXh0KHRoaXMudGV4dCwgdGhpcy5mb250LCB0aGlzLmNvbG9yKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUZXh0ICh0ZXh0PVwiKyAgKHRoaXMudGV4dC5sZW5ndGggPiAyMCA/IHRoaXMudGV4dC5zdWJzdHIoMCwgMTcpK1wiLi4uXCIgOiB0aGlzLnRleHQpICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge1RleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtUZXh0fSBvXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX2Nsb25lUHJvcHMobyk7XG5cdFx0by50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcblx0XHRvLnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuXHRcdG8ubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoO1xuXHRcdG8ub3V0bGluZSA9IHRoaXMub3V0bGluZTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG5cdFx0by5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0V29ya2luZ0NvbnRleHRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wcmVwQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5mb250ID0gdGhpcy5mb250fHxcIjEwcHggc2Fucy1zZXJpZlwiO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbnx8XCJsZWZ0XCI7XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9IHRoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiO1xuXHRcdHJldHVybiBjdHg7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIG11bHRpbGluZSB0ZXh0LlxuXHQgKiBAbWV0aG9kIF9kcmF3VGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2RyYXdUZXh0ID0gZnVuY3Rpb24oY3R4LCBvLCBsaW5lcykge1xuXHRcdHZhciBwYWludCA9ICEhY3R4O1xuXHRcdGlmICghcGFpbnQpIHtcblx0XHRcdGN0eCA9IFRleHQuX3dvcmtpbmdDb250ZXh0O1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX3ByZXBDb250ZXh0KGN0eCk7XG5cdFx0fVxuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0fHx0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdFxuXHRcdHZhciBtYXhXID0gMCwgY291bnQgPSAwO1xuXHRcdHZhciBoYXJkTGluZXMgPSBTdHJpbmcodGhpcy50ZXh0KS5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWhhcmRMaW5lcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RyID0gaGFyZExpbmVzW2ldO1xuXHRcdFx0dmFyIHcgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5saW5lV2lkdGggIT0gbnVsbCAmJiAodyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoKSA+IHRoaXMubGluZVdpZHRoKSB7XG5cdFx0XHRcdC8vIHRleHQgd3JhcHBpbmc6XG5cdFx0XHRcdHZhciB3b3JkcyA9IHN0ci5zcGxpdCgvKFxccykvKTtcblx0XHRcdFx0c3RyID0gd29yZHNbMF07XG5cdFx0XHRcdHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIGo9MSwgamw9d29yZHMubGVuZ3RoOyBqPGpsOyBqKz0yKSB7XG5cdFx0XHRcdFx0Ly8gTGluZSBuZWVkcyB0byB3cmFwOlxuXHRcdFx0XHRcdHZhciB3b3JkVyA9IGN0eC5tZWFzdXJlVGV4dCh3b3Jkc1tqXSArIHdvcmRzW2orMV0pLndpZHRoO1xuXHRcdFx0XHRcdGlmICh3ICsgd29yZFcgPiB0aGlzLmxpbmVXaWR0aCkge1xuXHRcdFx0XHRcdFx0aWYgKHBhaW50KSB7IHRoaXMuX2RyYXdUZXh0TGluZShjdHgsIHN0ciwgY291bnQqbGluZUhlaWdodCk7IH1cblx0XHRcdFx0XHRcdGlmIChsaW5lcykgeyBsaW5lcy5wdXNoKHN0cik7IH1cblx0XHRcdFx0XHRcdGlmICh3ID4gbWF4VykgeyBtYXhXID0gdzsgfVxuXHRcdFx0XHRcdFx0c3RyID0gd29yZHNbaisxXTtcblx0XHRcdFx0XHRcdHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0ciArPSB3b3Jkc1tqXSArIHdvcmRzW2orMV07XG5cdFx0XHRcdFx0XHR3ICs9IHdvcmRXO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuXHRcdFx0aWYgKGxpbmVzKSB7IGxpbmVzLnB1c2goc3RyKTsgfVxuXHRcdFx0aWYgKG8gJiYgdyA9PSBudWxsKSB7IHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDsgfVxuXHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG5cdFx0XHRjb3VudCsrO1xuXHRcdH1cblx0XHRcblx0XHRpZiAobykge1xuXHRcdFx0by53aWR0aCA9IG1heFc7XG5cdFx0XHRvLmhlaWdodCA9IGNvdW50KmxpbmVIZWlnaHQ7XG5cdFx0fVxuXHRcdGlmICghcGFpbnQpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kcmF3VGV4dExpbmVcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZHJhd1RleHRMaW5lID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB5KSB7XG5cdFx0Ly8gQ2hyb21lIDE3IHdpbGwgZmFpbCB0byBkcmF3IHRoZSB0ZXh0IGlmIHRoZSBsYXN0IHBhcmFtIGlzIGluY2x1ZGVkIGJ1dCBudWxsLCBzbyB3ZSBmZWVkIGl0IGEgbGFyZ2UgdmFsdWUgaW5zdGVhZDpcblx0XHRpZiAodGhpcy5vdXRsaW5lKSB7IGN0eC5zdHJva2VUZXh0KHRleHQsIDAsIHksIHRoaXMubWF4V2lkdGh8fDB4RkZGRik7IH1cblx0XHRlbHNlIHsgY3R4LmZpbGxUZXh0KHRleHQsIDAsIHksIHRoaXMubWF4V2lkdGh8fDB4RkZGRik7IH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0TWVhc3VyZWRXaWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0TWVhc3VyZWRXaWR0aCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR2YXIgY3R4ID0gVGV4dC5fd29ya2luZ0NvbnRleHQ7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgdyA9IHRoaXMuX3ByZXBDb250ZXh0KGN0eCkubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdztcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRleHQgPSBjcmVhdGVqcy5wcm9tb3RlKFRleHQsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCaXRtYXBUZXh0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlzIHRleHQgdXNpbmcgYml0bWFwIGdseXBocyBkZWZpbmVkIGluIGEgc3ByaXRlIHNoZWV0LiBNdWx0aS1saW5lIHRleHQgaXMgc3VwcG9ydGVkXG5cdCAqIHVzaW5nIG5ldyBsaW5lIGNoYXJhY3RlcnMsIGJ1dCBhdXRvbWF0aWMgd3JhcHBpbmcgaXMgbm90IHN1cHBvcnRlZC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiQml0bWFwVGV4dC9zcHJpdGVTaGVldDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBnbHlwaHMuXG5cdCAqIFxuXHQgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz4gQml0bWFwVGV4dCBleHRlbmRzIENvbnRhaW5lciwgYnV0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIG9uZS5cblx0ICogQXMgc3VjaCwgbWV0aG9kcyBsaWtlIGFkZENoaWxkIGFuZCByZW1vdmVDaGlsZCBhcmUgZGlzYWJsZWQuXG5cdCAqIEBjbGFzcyBCaXRtYXBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0PVwiXCJdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IFtzcHJpdGVTaGVldD1udWxsXSBUaGUgc3ByaXRlc2hlZXQgdGhhdCBkZWZpbmVzIHRoZSBjaGFyYWN0ZXIgZ2x5cGhzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXBUZXh0KHRleHQsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgZ2x5cGhzIGZvciB0aGlzIGJpdG1hcCB0ZXh0LiBFYWNoIGdseXBoL2NoYXJhY3RlclxuXHRcdCAqIHNob3VsZCBoYXZlIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQgbmFtZWQgdGhlIHNhbWUgYXNcblx0XHQgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uIGRlZmluaXRpb246XG5cdFx0ICpcblx0XHQgKiBcdFx0XCJBXCI6IHtmcmFtZXM6IFswXX1cblx0XHQgKlxuXHRcdCAqIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIGZyYW1lIGF0IGluZGV4IDAgb2YgdGhlIHNwcml0ZXNoZWV0IHNob3VsZCBiZSBkcmF3biBmb3IgdGhlIFwiQVwiIGNoYXJhY3Rlci4gVGhlIHNob3J0IGZvcm1cblx0XHQgKiBpcyBhbHNvIGFjY2VwdGFibGU6XG5cdFx0ICogXG5cdFx0ICogXHRcdFwiQVwiOiAwXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHRleHQgaXMgbm90IGZvdW5kIGluIHRoZSBzcHJpdGUgc2hlZXQsIGl0IHdpbGwgYWxzb1xuXHRcdCAqIHRyeSB0byB1c2UgdGhlIGFsdGVybmF0ZSBjYXNlICh1cHBlciBvciBsb3dlcikuXG5cdFx0ICpcblx0XHQgKiBTZWUgU3ByaXRlU2hlZXQgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVmaW5pbmcgc3ByaXRlIHNoZWV0IGRhdGEuXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUgU3ByaXRlU2hlZXRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIGxpbmUgaGVpZ2h0IGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIGhlaWdodCBvZiB0aGUgXCIxXCIsIFwiVFwiLCBvciBcIkxcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3BhY2luZyAoaW4gcGl4ZWxzKSB3aWxsIGJlIGFkZGVkIGFmdGVyIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBvdXRwdXQuXG5cdFx0ICogQHByb3BlcnR5IGxldHRlclNwYWNpbmdcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHRoZW4gZW1wdHkgcGl4ZWxzIGVxdWFsIHRvXG5cdFx0ICogc3BhY2VXaWR0aCB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSB2YWx1ZSBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSB3aWR0aCBvZiB0aGUgXCIxXCIsIFwibFwiLCBcIkVcIiwgb3IgXCJBXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IHNwYWNlV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3BhY2VXaWR0aCA9IDA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0IFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRQcm9wc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSB7dGV4dDowLHNwcml0ZVNoZWV0OjAsbGluZUhlaWdodDowLGxldHRlclNwYWNpbmc6MCxzcGFjZVdpZHRoOjB9O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcFRleHQsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEJpdG1hcFRleHQgdXNlcyBTcHJpdGUgaW5zdGFuY2VzIHRvIGRyYXcgdGV4dC4gVG8gcmVkdWNlIHRoZSBjcmVhdGlvbiBhbmQgZGVzdHJ1Y3Rpb24gb2YgaW5zdGFuY2VzIChhbmQgdGh1cyBnYXJiYWdlIGNvbGxlY3Rpb24pLCBpdCBtYWludGFpbnNcblx0ICogYW4gaW50ZXJuYWwgb2JqZWN0IHBvb2wgb2Ygc3ByaXRlIGluc3RhbmNlcyB0byByZXVzZS4gSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBjYXVzZSBtb3JlIHNwcml0ZXMgdG8gYmVcblx0ICogcmV0YWluZWQsIHNsaWdodGx5IGluY3JlYXNpbmcgbWVtb3J5IHVzZSwgYnV0IHJlZHVjaW5nIGluc3RhbnRpYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBtYXhQb29sU2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICoqL1xuXHRCaXRtYXBUZXh0Lm1heFBvb2xTaXplID0gMTAwO1xuXHRcblx0LyoqXG5cdCAqIFNwcml0ZSBvYmplY3QgcG9vbC5cblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRCaXRtYXBUZXh0Ll9zcHJpdGVQb29sID0gW107XG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fdXBkYXRlVGV4dCgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0cmV0dXJuIHRoaXMuQ29udGFpbmVyX2dldEJvdW5kcygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5zcHJpdGVTaGVldCAmJiB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlICYmIHRoaXMudGV4dCk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPT0gMCAmJiB0aGlzLnNjYWxlWSAhPT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblx0XG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQml0bWFwVGV4dCh0aGlzLnRleHQsIHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxuXHQgKiovXG5cdHAuYWRkQ2hpbGQgPSBwLmFkZENoaWxkQXQgPSBwLnJlbW92ZUNoaWxkID0gcC5yZW1vdmVDaGlsZEF0ID0gcC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuIFx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtCaXRtYXBUZXh0fSBvXG5cdCAqIEByZXR1cm4ge0JpdG1hcFRleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5Db250YWluZXJfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGV0dGVyU3BhY2luZyA9IHRoaXMubGV0dGVyU3BhY2luZztcblx0XHRvLnNwYWNlV2lkdGggPSB0aGlzLnNwYWNlV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lSW5kZXggPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGMsIG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oY2hhcmFjdGVyKTtcblx0XHRpZiAoIW8pIHtcblx0XHRcdChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSkpIHx8IChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSkpIHx8IChjPW51bGwpO1xuXHRcdFx0aWYgKGMpIHsgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjKTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbyAmJiBvLmZyYW1lc1swXTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IG51bGwgPyBpbmRleCA6IHNwcml0ZVNoZWV0LmdldEZyYW1lKGluZGV4KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRMaW5lSGVpZ2h0XG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldExpbmVIZWlnaHQgPSBmdW5jdGlvbihzcykge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKFwiMVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIlRcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJMXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3QuaGVpZ2h0IDogMTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNwYWNlV2lkdGhcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0U3BhY2VXaWR0aCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwibFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImVcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJhXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3Qud2lkdGggOiAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHg9MCwgeT0wLCBvPXRoaXMuX29sZFByb3BzLCBjaGFuZ2U9ZmFsc2UsIHNwYWNlVz10aGlzLnNwYWNlV2lkdGgsIGxpbmVIPXRoaXMubGluZUhlaWdodCwgc3M9dGhpcy5zcHJpdGVTaGVldDtcblx0XHR2YXIgcG9vbD1CaXRtYXBUZXh0Ll9zcHJpdGVQb29sLCBraWRzPXRoaXMuY2hpbGRyZW4sIGNoaWxkSW5kZXg9MCwgbnVtS2lkcz1raWRzLmxlbmd0aCwgc3ByaXRlO1xuXHRcdFxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKG9bbl0gIT0gdGhpc1tuXSkge1xuXHRcdFx0XHRvW25dID0gdGhpc1tuXTtcblx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjaGFuZ2UpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGhhc1NwYWNlID0gISF0aGlzLl9nZXRGcmFtZShcIiBcIiwgc3MpO1xuXHRcdGlmICghaGFzU3BhY2UgJiYgIXNwYWNlVykgeyBzcGFjZVcgPSB0aGlzLl9nZXRTcGFjZVdpZHRoKHNzKTsgfVxuXHRcdGlmICghbGluZUgpIHsgbGluZUggPSB0aGlzLl9nZXRMaW5lSGVpZ2h0KHNzKTsgfVxuXHRcdFxuXHRcdGZvcih2YXIgaT0wLCBsPXRoaXMudGV4dC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0LmNoYXJBdChpKTtcblx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gXCIgXCIgJiYgIWhhc1NwYWNlKSB7XG5cdFx0XHRcdHggKz0gc3BhY2VXO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyPT1cIlxcblwiIHx8IGNoYXJhY3Rlcj09XCJcXHJcIikge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyPT1cIlxcclwiICYmIHRoaXMudGV4dC5jaGFyQXQoaSsxKSA9PSBcIlxcblwiKSB7IGkrKzsgfSAvLyBjcmxmXG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0XHR5ICs9IGxpbmVIO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNzKTtcblx0XHRcdGlmIChpbmRleCA9PSBudWxsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdGlmIChjaGlsZEluZGV4IDwgbnVtS2lkcykge1xuXHRcdFx0XHRzcHJpdGUgPSBraWRzW2NoaWxkSW5kZXhdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2lkcy5wdXNoKHNwcml0ZSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBjcmVhdGVqcy5TcHJpdGUoKSk7XG5cdFx0XHRcdHNwcml0ZS5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRudW1LaWRzKys7XG5cdFx0XHR9XG5cdFx0XHRzcHJpdGUuc3ByaXRlU2hlZXQgPSBzcztcblx0XHRcdHNwcml0ZS5nb3RvQW5kU3RvcChpbmRleCk7XG5cdFx0XHRzcHJpdGUueCA9IHg7XG5cdFx0XHRzcHJpdGUueSA9IHk7XG5cdFx0XHRjaGlsZEluZGV4Kys7XG5cdFx0XHRcblx0XHRcdHggKz0gc3ByaXRlLmdldEJvdW5kcygpLndpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdH1cblx0XHR3aGlsZSAobnVtS2lkcyA+IGNoaWxkSW5kZXgpIHtcblx0XHRcdCAvLyBmYXN0ZXIgdGhhbiByZW1vdmVDaGlsZC5cblx0XHRcdHBvb2wucHVzaChzcHJpdGUgPSBraWRzLnBvcCgpKTtcblx0XHRcdHNwcml0ZS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0bnVtS2lkcy0tO1xuXHRcdH1cblx0XHRpZiAocG9vbC5sZW5ndGggPiBCaXRtYXBUZXh0Lm1heFBvb2xTaXplKSB7IHBvb2wubGVuZ3RoID0gQml0bWFwVGV4dC5tYXhQb29sU2l6ZTsgfVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuQml0bWFwVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwVGV4dCwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW92aWVDbGlwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCBjbGFzcyBhc3NvY2lhdGVzIGEgVHdlZW5KUyBUaW1lbGluZSB3aXRoIGFuIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319LiBJdCBhbGxvd3Ncblx0ICogeW91IHRvIGNyZWF0ZSBvYmplY3RzIHdoaWNoIGVuY2Fwc3VsYXRlIHRpbWVsaW5lIGFuaW1hdGlvbnMsIHN0YXRlIGNoYW5nZXMsIGFuZCBzeW5jaGVkIGFjdGlvbnMuIER1ZSB0byB0aGVcblx0ICogY29tcGxleGl0aWVzIGluaGVyZW50IGluIGNvcnJlY3RseSBzZXR0aW5nIHVwIGEgTW92aWVDbGlwLCBpdCBpcyBsYXJnZWx5IGludGVuZGVkIGZvciB0b29sIG91dHB1dCBhbmQgaXMgbm90IGluY2x1ZGVkXG5cdCAqIGluIHRoZSBtYWluIEVhc2VsSlMgbGlicmFyeS5cblx0ICpcblx0ICogQ3VycmVudGx5IE1vdmllQ2xpcCBvbmx5IHdvcmtzIHByb3Blcmx5IGlmIGl0IGlzIHRpY2sgYmFzZWQgKGFzIG9wcG9zZWQgdG8gdGltZSBiYXNlZCkgdGhvdWdoIHNvbWUgY29uY2Vzc2lvbnMgaGF2ZVxuXHQgKiBiZWVuIG1hZGUgdG8gc3VwcG9ydCB0aW1lLWJhc2VkIHRpbWVsaW5lcyBpbiB0aGUgZnV0dXJlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBhbmltYXRlcyB0d28gc2hhcGVzIGJhY2sgYW5kIGZvcnRoLiBUaGUgZ3JleSBzaGFwZSBzdGFydHMgb24gdGhlIGxlZnQsIGJ1dCB3ZSBqdW1wIHRvIGEgbWlkLXBvaW50IGluXG5cdCAqIHRoZSBhbmltYXRpb24gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc1wiKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgc3RhZ2UpO1xuXHQgKlxuXHQgKiAgICAgIHZhciBtYyA9IG5ldyBjcmVhdGVqcy5Nb3ZpZUNsaXAobnVsbCwgMCwgdHJ1ZSwge3N0YXJ0OjIwfSk7XG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQobWMpO1xuXHQgKlxuXHQgKiAgICAgIHZhciBjaGlsZDEgPSBuZXcgY3JlYXRlanMuU2hhcGUoXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiM5OTk5OTlcIilcblx0ICogICAgICAgICAgICAgIC5kcmF3Q2lyY2xlKDMwLDMwLDMwKSk7XG5cdCAqICAgICAgdmFyIGNoaWxkMiA9IG5ldyBjcmVhdGVqcy5TaGFwZShcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiIzVhOWNmYlwiKVxuXHQgKiAgICAgICAgICAgICAgLmRyYXdDaXJjbGUoMzAsMzAsMzApKTtcblx0ICpcblx0ICogICAgICBtYy50aW1lbGluZS5hZGRUd2Vlbihcblx0ICogICAgICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KGNoaWxkMSlcblx0ICogICAgICAgICAgICAgIC50byh7eDowfSkudG8oe3g6NjB9LCA1MCkudG8oe3g6MH0sIDUwKSk7XG5cdCAqICAgICAgbWMudGltZWxpbmUuYWRkVHdlZW4oXG5cdCAqICAgICAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldChjaGlsZDIpXG5cdCAqICAgICAgICAgICAgICAudG8oe3g6NjB9KS50byh7eDowfSwgNTApLnRvKHt4OjYwfSwgNTApKTtcblx0ICpcblx0ICogICAgICBtYy5nb3RvQW5kUGxheShcInN0YXJ0XCIpO1xuXHQgKlxuXHQgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgPGNvZGU+dHdlZW4udG8oKTwvY29kZT4gdG8gYW5pbWF0ZSBhbmQgc2V0IHByb3BlcnRpZXMgKHVzZSBubyBkdXJhdGlvbiB0byBoYXZlIGl0IHNldFxuXHQgKiBpbW1lZGlhdGVseSksIGFuZCB0aGUgPGNvZGU+dHdlZW4ud2FpdCgpPC9jb2RlPiBtZXRob2QgdG8gY3JlYXRlIGRlbGF5cyBiZXR3ZWVuIGFuaW1hdGlvbnMuIE5vdGUgdGhhdCB1c2luZyB0aGVcblx0ICogPGNvZGU+dHdlZW4uc2V0KCk8L2NvZGU+IG1ldGhvZCB0byBhZmZlY3QgcHJvcGVydGllcyB3aWxsIGxpa2VseSBub3QgcHJvdmlkZSB0aGUgZGVzaXJlZCByZXN1bHQuXG5cdCAqXG5cdCAqIEBjbGFzcyBNb3ZpZUNsaXBcblx0ICogQG1haW4gTW92aWVDbGlwXG5cdCAqIEBleHRlbmRzIENvbnRhaW5lclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttb2RlPWluZGVwZW5kZW50XSBJbml0aWFsIHZhbHVlIGZvciB0aGUgbW9kZSBwcm9wZXJ0eS4gT25lIG9mIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9JTkRFUEVOREVOVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL1NJTkdMRV9GUkFNRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgb3Ige3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL1NZTkNIRUQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9JTkRFUEVOREVOVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFBvc2l0aW9uPTBdIEluaXRpYWwgdmFsdWUgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvc3RhcnRQb3NpdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9vcD10cnVlXSBJbml0aWFsIHZhbHVlIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkuIFRoZSBkZWZhdWx0IGlzIGB0cnVlYC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtsYWJlbHM9bnVsbF0gQSBoYXNoIG9mIGxhYmVscyB0byBwYXNzIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvdGltZWxpbmU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW92aWVDbGlwLiBMYWJlbHMgb25seSBuZWVkIHRvIGJlIHBhc3NlZCBpZiB0aGV5IG5lZWQgdG8gYmUgdXNlZC5cblx0ICoqL1xuXHRmdW5jdGlvbiBNb3ZpZUNsaXAobW9kZSwgc3RhcnRQb3NpdGlvbiwgbG9vcCwgbGFiZWxzKSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHQhTW92aWVDbGlwLmluaXRlZCYmTW92aWVDbGlwLmluaXQoKTsgLy8gc3RhdGljIGluaXRcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ29udHJvbHMgaG93IHRoaXMgTW92aWVDbGlwIGFkdmFuY2VzIGl0cyB0aW1lLiBNdXN0IGJlIG9uZSBvZiAwIChJTkRFUEVOREVOVCksIDEgKFNJTkdMRV9GUkFNRSksIG9yIDIgKFNZTkNIRUQpLlxuXHRcdCAqIFNlZSBlYWNoIGNvbnN0YW50IGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBiZWhhdmlvdXIuXG5cdFx0ICogQHByb3BlcnR5IG1vZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubW9kZSA9IG1vZGV8fE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoYXQgdGhlIGZpcnN0IGZyYW1lIHRvIHBsYXkgaW4gdGhpcyBtb3ZpZWNsaXAsIG9yIHRoZSBvbmx5IGZyYW1lIHRvIGRpc3BsYXkgaWYgbW9kZSBpcyBTSU5HTEVfRlJBTUUuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIE1vdmllQ2xpcCBzaG91bGQgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBpdHMgdGltZWxpbmUuXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IGxvb3A7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBtb3ZpZWNsaXAuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBUd2VlbkpTIFRpbWVsaW5lIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW92aWVDbGlwLiBUaGlzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBNb3ZpZUNsaXBcblx0XHQgKiBpbnN0YW5jZSBpcyBpbml0aWFsaXplZC4gQW5pbWF0aW9ucyBhcmUgY3JlYXRlZCBieSBhZGRpbmcgPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiPlR3ZWVuSlM8L2E+IFR3ZWVuXG5cdFx0ICogaW5zdGFuY2VzIHRvIHRoZSB0aW1lbGluZS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MH0pLnRvKHt4OjEwMH0sIDMwKTtcblx0XHQgKiAgICAgIHZhciBtYyA9IG5ldyBjcmVhdGVqcy5Nb3ZpZUNsaXAoKTtcblx0XHQgKiAgICAgIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKHR3ZWVuKTtcblx0XHQgKlxuXHRcdCAqIEVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSB0aW1lbGluZSBieSB0b2dnbGluZyBhbiBcIl9vZmZcIiBwcm9wZXJ0eVxuXHRcdCAqIHVzaW5nIHRoZSA8Y29kZT50d2Vlbkluc3RhbmNlLnRvKCk8L2NvZGU+IG1ldGhvZC4gTm90ZSB0aGF0IHVzaW5nIDxjb2RlPlR3ZWVuLnNldDwvY29kZT4gaXMgbm90IHJlY29tbWVuZGVkIHRvXG5cdFx0ICogY3JlYXRlIE1vdmllQ2xpcCBhbmltYXRpb25zLiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgd2lsbCB0b2dnbGUgdGhlIHRhcmdldCBvZmYgb24gZnJhbWUgMCwgYW5kIHRoZW4gYmFjayBvbiBmb3Jcblx0XHQgKiBmcmFtZSAxLiBZb3UgY2FuIHVzZSB0aGUgXCJ2aXNpYmxlXCIgcHJvcGVydHkgdG8gYWNoaWV2ZSB0aGUgc2FtZSBlZmZlY3QuXG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHtfb2ZmOmZhbHNlfSlcblx0XHQgKiAgICAgICAgICAud2FpdCgxKS50byh7X29mZjp0cnVlfSlcblx0XHQgKiAgICAgICAgICAud2FpdCgxKS50byh7X29mZjpmYWxzZX0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHRpbWVsaW5lXG5cdFx0ICogQHR5cGUgVGltZWxpbmVcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50aW1lbGluZSA9IG5ldyBjcmVhdGVqcy5UaW1lbGluZShudWxsLCBsYWJlbHMsIHtwYXVzZWQ6dHJ1ZSwgcG9zaXRpb246c3RhcnRQb3NpdGlvbiwgdXNlVGlja3M6dHJ1ZX0pO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgTW92aWVDbGlwJ3MgcG9zaXRpb24gd2lsbCBub3QgYWR2YW5jZSB3aGVuIHRpY2tlZC5cblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgYWN0aW9ucyBpbiB0aGlzIE1vdmllQ2xpcCdzIHR3ZWVucyB3aWxsIGJlIHJ1biB3aGVuIHRoZSBwbGF5aGVhZCBhZHZhbmNlcy5cblx0XHQgKiBAcHJvcGVydHkgYWN0aW9uc0VuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYWN0aW9uc0VuYWJsZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgTW92aWVDbGlwIHdpbGwgYXV0b21hdGljYWxseSBiZSByZXNldCB0byBpdHMgZmlyc3QgZnJhbWUgd2hlbmV2ZXIgdGhlIHRpbWVsaW5lIGFkZHNcblx0XHQgKiBpdCBiYWNrIG9udG8gdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gTW92aWVDbGlwIGluc3RhbmNlcyB3aXRoIG1vZGU9SU5ERVBFTkRFTlQuXG5cdFx0ICogPGJyPjxicj5cblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZCBhIGNoYXJhY3RlciBhbmltYXRpb24gd2l0aCBhIFwiYm9keVwiIGNoaWxkIE1vdmllQ2xpcCBpbnN0YW5jZVxuXHRcdCAqIHdpdGggZGlmZmVyZW50IGNvc3R1bWVzIG9uIGVhY2ggZnJhbWUsIHlvdSBjb3VsZCBzZXQgYm9keS5hdXRvUmVzZXQgPSBmYWxzZSwgc28gdGhhdFxuXHRcdCAqIHlvdSBjYW4gbWFudWFsbHkgY2hhbmdlIHRoZSBmcmFtZSBpdCBpcyBvbiwgd2l0aG91dCB3b3JyeWluZyB0aGF0IGl0IHdpbGwgYmUgcmVzZXRcblx0XHQgKiBhdXRvbWF0aWNhbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvUmVzZXRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMuYXV0b1Jlc2V0ID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBib3VuZHMgZm9yIGVhY2ggZnJhbWUgaW4gdGhlIE1vdmllQ2xpcC4gVGhpcyBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIHRvb2wgb3V0cHV0LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZUJvdW5kc1xuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZnJhbWVCb3VuZHMgPSB0aGlzLmZyYW1lQm91bmRzfHxudWxsOyAvLyBUT0RPOiBEZXByZWNhdGVkLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgc3VwcG9ydCBvZiBGbGFzaENDXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCBNb3ZpZUNsaXAgaW5zdGFuY2VzIGFkdmFuY2Ugb25lIGZyYW1lIHBlciB0aWNrLiBTcGVjaWZ5aW5nIGEgZnJhbWVyYXRlIGZvciB0aGUgTW92aWVDbGlwXG5cdFx0ICogd2lsbCBjYXVzZSBpdCB0byBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRpY2tzIGFzIGFwcHJvcHJpYXRlIHRvIG1haW50YWluIHRoZSB0YXJnZXRcblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgYSBNb3ZpZUNsaXAgd2l0aCBhIGZyYW1lcmF0ZSBvZiAxMCBpcyBwbGFjZWQgb24gYSBTdGFnZSBiZWluZyB1cGRhdGVkIGF0IDQwZnBzLCB0aGVuIHRoZSBNb3ZpZUNsaXAgd2lsbFxuXHRcdCAqIGFkdmFuY2Ugcm91Z2hseSBvbmUgZnJhbWUgZXZlcnkgNCB0aWNrcy4gVGhpcyB3aWxsIG5vdCBiZSBleGFjdCwgYmVjYXVzZSB0aGUgdGltZSBiZXR3ZWVuIGVhY2ggdGljayB3aWxsXG5cdFx0ICogdmFyeSBzbGlnaHRseSBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmVhdHVyZSBpcyBkZXBlbmRlbnQgb24gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IChvciBhbiBvYmplY3Qgd2l0aCBhbiBhcHByb3ByaWF0ZSBcImRlbHRhXCIgcHJvcGVydHkpIGJlaW5nXG5cdFx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zeW5jaE9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N5bmNoT2Zmc2V0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTsgLy8gVE9ETzogZXZhbHVhdGUgdXNpbmcgYSAuX3Jlc2V0IEJvb2xlYW4gcHJvcCBpbnN0ZWFkIG9mIC0xLlxuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aW1lIHJlbWFpbmluZyBmcm9tIHRoZSBwcmV2aW91cyB0aWNrLCBvbmx5IGFwcGxpY2FibGUgd2hlbiAuZnJhbWVyYXRlIGlzIHNldC5cblx0XHQgKiBAcHJvcGVydHkgX3Rcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3QgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGFyZSBhY3RpdmVseSBiZWluZyBtYW5hZ2VkIGJ5IHRoZSBNb3ZpZUNsaXAuXG5cdFx0ICogQHByb3BlcnR5IF9tYW5hZ2VkXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5hZ2VkID0ge307XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW92aWVDbGlwLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIFRoZSBNb3ZpZUNsaXAgd2lsbCBhZHZhbmNlIGluZGVwZW5kZW50bHkgb2YgaXRzIHBhcmVudCwgZXZlbiBpZiBpdHMgcGFyZW50IGlzIHBhdXNlZC5cblx0ICogVGhpcyBpcyB0aGUgZGVmYXVsdCBtb2RlLlxuXHQgKiBAcHJvcGVydHkgSU5ERVBFTkRFTlRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQGRlZmF1bHQgXCJpbmRlcGVuZGVudFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdE1vdmllQ2xpcC5JTkRFUEVOREVOVCA9IFwiaW5kZXBlbmRlbnRcIjtcblxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCB3aWxsIG9ubHkgZGlzcGxheSBhIHNpbmdsZSBmcmFtZSAoYXMgZGV0ZXJtaW5lZCBieSB0aGUgc3RhcnRQb3NpdGlvbiBwcm9wZXJ0eSkuXG5cdCAqIEBwcm9wZXJ0eSBTSU5HTEVfRlJBTUVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQGRlZmF1bHQgXCJzaW5nbGVcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNb3ZpZUNsaXAuU0lOR0xFX0ZSQU1FID0gXCJzaW5nbGVcIjtcblxuXHQvKipcblx0ICogVGhlIE1vdmllQ2xpcCB3aWxsIGJlIGFkdmFuY2VkIG9ubHkgd2hlbiBpdHMgcGFyZW50IGFkdmFuY2VzIGFuZCB3aWxsIGJlIHN5bmNoZWQgdG8gdGhlIHBvc2l0aW9uIG9mXG5cdCAqIHRoZSBwYXJlbnQgTW92aWVDbGlwLlxuXHQgKiBAcHJvcGVydHkgU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAZGVmYXVsdCBcInN5bmNoZWRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNb3ZpZUNsaXAuU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXHRcblx0XG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0TW92aWVDbGlwLmluaXRlZCA9IGZhbHNlO1xuXHRcblx0XG4vLyBzdGF0aWMgbWV0aG9kczpcblx0TW92aWVDbGlwLmluaXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoTW92aWVDbGlwLmluaXRlZCkgeyByZXR1cm47IH1cblx0XHQvLyBwbHVnaW5zIGludHJvZHVjZSBzb21lIG92ZXJoZWFkIHRvIFR3ZWVuLCBzbyB3ZSBvbmx5IGluc3RhbGwgdGhpcyBpZiBhbiBNQyBpcyBpbnN0YW50aWF0ZWQuXG5cdFx0TW92aWVDbGlwUGx1Z2luLmluc3RhbGwoKTtcblx0XHRNb3ZpZUNsaXAuaW5pdGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2xhYmVsczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldExhYmVsc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmdldExhYmVscygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2N1cnJlbnRMYWJlbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRDdXJyZW50TGFiZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmdldEN1cnJlbnRMYWJlbCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RHVyYXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVsaW5lLmR1cmF0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gKGFrYSBmcmFtZSkgcHJvcGVydGllcywgc29ydGVkIGJ5IHBvc2l0aW9uLlxuXHQgKiBTaG9ydGN1dCB0byBUd2VlbkpTOiBUaW1lbGluZS5nZXRMYWJlbHMoKTtcblx0ICogQHByb3BlcnR5IGxhYmVsc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgb24gb3IgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjdXJyZW50IGZyYW1lLiBTZWUgVHdlZW5KUzogVGltZWxpbmUuZ2V0Q3VycmVudExhYmVsKClcblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBjdXJyZW50TGFiZWxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBvZiB0aGlzIE1vdmllQ2xpcCBpbiBzZWNvbmRzIG9yIHRpY2tzLiBJZGVudGljYWwgdG8ge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCBwcm92aWRlZCBmb3IgRmxhc2ggQVBJIGNvbXBhdGliaWxpdHkuXG5cdCAqIEBwcm9wZXJ0eSB0b3RhbEZyYW1lc1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoaXMgTW92aWVDbGlwIGluIHNlY29uZHMgb3IgdGlja3MuXG5cdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGxhYmVsczogeyBnZXQ6IHAuZ2V0TGFiZWxzIH0sXG5cdFx0XHRjdXJyZW50TGFiZWw6IHsgZ2V0OiBwLmdldEN1cnJlbnRMYWJlbCB9LFxuXHRcdFx0dG90YWxGcmFtZXM6IHsgZ2V0OiBwLmdldER1cmF0aW9uIH0sXG5cdFx0XHRkdXJhdGlvbjogeyBnZXQ6IHAuZ2V0RHVyYXRpb24gfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IE1vdmllQ2xpcDsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQ1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBjaGlsZHJlbiBhcmUgcGxhY2VkIGluIGRyYXcsIHNvIHdlIGNhbid0IGRldGVybWluZSBpZiB3ZSBoYXZlIGNvbnRlbnQuXG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0Ly8gZHJhdyB0byBjYWNoZSBmaXJzdDpcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UuXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiovXG5cdHAucGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZS5cblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqKi9cblx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgbW92aWUgY2xpcCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsIGFuZCBzZXRzIHBhdXNlZCB0byBmYWxzZS5cblx0ICogQG1ldGhvZCBnb3RvQW5kUGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGdvIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIG1vdmllIGNsaXAgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbCBhbmQgc2V0cyBwYXVzZWQgdG8gdHJ1ZS5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG9yIGZyYW1lIG5hbWUgdG8gZ28gdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHBsYXloZWFkLiBUaGlzIG9jY3VycyBhdXRvbWF0aWNhbGx5IGVhY2ggdGljayBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0gW3RpbWVdIHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byBhZHZhbmNlIGJ5LiBPbmx5IGFwcGxpY2FibGUgaWYgZnJhbWVyYXRlIGlzIHNldC5cblx0ICogQG1ldGhvZCBhZHZhbmNlXG5cdCovXG5cdHAuYWR2YW5jZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHQvLyBUT0RPOiBzaG91bGQgd2Ugd29ycnkgYXQgYWxsIGFib3V0IGNsaXBzIHdobyBjaGFuZ2UgdGhlaXIgb3duIG1vZGVzIHZpYSBmcmFtZSBzY3JpcHRzP1xuXHRcdHZhciBpbmRlcGVuZGVudCA9IE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XHRpZiAodGhpcy5tb2RlICE9IGluZGVwZW5kZW50KSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBvPXRoaXMsIGZwcyA9IG8uZnJhbWVyYXRlO1xuXHRcdHdoaWxlICgobyA9IG8ucGFyZW50KSAmJiBmcHMgPT0gbnVsbCkge1xuXHRcdFx0aWYgKG8ubW9kZSA9PSBpbmRlcGVuZGVudCkgeyBmcHMgPSBvLl9mcmFtZXJhdGU7IH1cblx0XHR9XG5cdFx0dGhpcy5fZnJhbWVyYXRlID0gZnBzO1xuXHRcdFxuXHRcdHZhciB0ID0gKGZwcyAhPSBudWxsICYmIGZwcyAhPSAtMSAmJiB0aW1lICE9IG51bGwpID8gdGltZS8oMTAwMC9mcHMpICsgdGhpcy5fdCA6IDE7XG5cdFx0dmFyIGZyYW1lcyA9IHR8MDtcblx0XHR0aGlzLl90ID0gdC1mcmFtZXM7IC8vIGxlZnRvdmVyIHRpbWVcblx0XHRcblx0XHR3aGlsZSAoIXRoaXMucGF1c2VkICYmIGZyYW1lcy0tKSB7XG5cdFx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAodGhpcy5fcHJldlBvcyA8IDApID8gMCA6IHRoaXMuX3ByZXZQb3NpdGlvbisxO1xuXHRcdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogTW92aWVDbGlwIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciB0aGlzPyBOZWVkIHRvIGNsb25lIHRoZSBUaW1lbGluZSAmIHJldGFyZ2V0IHR3ZWVucyAtIHByZXR0eSBjb21wbGV4LlxuXHRcdHRocm93KFwiTW92aWVDbGlwIGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01vdmllQ2xpcCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdHRoaXMuYWR2YW5jZShldnRPYmomJmV2dE9iai5kZWx0YSk7XG5cdFx0dGhpcy5Db250YWluZXJfX3RpY2soZXZ0T2JqKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBhbmltYXRpb24gbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZ28gdG8uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMudGltZWxpbmUucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgPT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHQvLyBwcmV2ZW50IF91cGRhdGVUaW1lbGluZSBmcm9tIG92ZXJ3cml0aW5nIHRoZSBuZXcgcG9zaXRpb24gYmVjYXVzZSBvZiBhIHJlc2V0OlxuXHRcdGlmICh0aGlzLl9wcmV2UG9zID09IC0xKSB7IHRoaXMuX3ByZXZQb3MgPSBOYU47IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSBwb3M7XG5cdFx0dGhpcy5fdCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9yZXNldFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHAuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXHRcdHRoaXMuX3QgPSB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVUaW1lbGluZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGwgPSB0aGlzLnRpbWVsaW5lO1xuXHRcdHZhciBzeW5jaGVkID0gdGhpcy5tb2RlICE9IE1vdmllQ2xpcC5JTkRFUEVOREVOVDtcblx0XHR0bC5sb29wID0gKHRoaXMubG9vcD09bnVsbCkgPyB0cnVlIDogdGhpcy5sb29wO1xuXHRcdFxuXHRcdHZhciBwb3MgPSBzeW5jaGVkID8gdGhpcy5zdGFydFBvc2l0aW9uICsgKHRoaXMubW9kZT09TW92aWVDbGlwLlNJTkdMRV9GUkFNRT8wOnRoaXMuX3N5bmNoT2Zmc2V0KSA6ICh0aGlzLl9wcmV2UG9zIDwgMCA/IDAgOiB0aGlzLl9wcmV2UG9zaXRpb24pO1xuXHRcdHZhciBtb2RlID0gc3luY2hlZCB8fCAhdGhpcy5hY3Rpb25zRW5hYmxlZCA/IGNyZWF0ZWpzLlR3ZWVuLk5PTkUgOiBudWxsO1xuXHRcdFxuXHRcdC8vIHByZS1hc3NpZ24gY3VycmVudEZyYW1lIHNvIGl0IGlzIGF2YWlsYWJsZSB0byBmcmFtZSBzY3JpcHRzOlxuXHRcdHRoaXMuY3VycmVudEZyYW1lID0gdGwuX2NhbGNQb3NpdGlvbihwb3MpO1xuXHRcdFxuXHRcdC8vIHVwZGF0ZSB0aW1lbGluZSBwb3NpdGlvbiwgaWdub3JpbmcgYWN0aW9ucyBpZiB0aGlzIGlzIGEgZ3JhcGhpYy5cblx0XHR0bC5zZXRQb3NpdGlvbihwb3MsIG1vZGUpO1xuXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gdGwuX3ByZXZQb3NpdGlvbjtcblx0XHRpZiAodGhpcy5fcHJldlBvcyA9PSB0bC5fcHJldlBvcykgeyByZXR1cm47IH1cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMuX3ByZXZQb3MgPSB0bC5fcHJldlBvcztcblxuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbWFuYWdlZCkgeyB0aGlzLl9tYW5hZ2VkW25dID0gMTsgfVxuXG5cdFx0dmFyIHR3ZWVucyA9IHRsLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPXR3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4uX3RhcmdldDtcblx0XHRcdGlmICh0YXJnZXQgPT0gdGhpcyB8fCB0d2Vlbi5wYXNzaXZlKSB7IGNvbnRpbnVlOyB9IC8vIFRPRE86IHRoaXMgYXNzdW1lcyBhY3Rpb25zIHR3ZWVuIGhhcyB0aGlzIGFzIHRoZSB0YXJnZXQuIFZhbGlkP1xuXHRcdFx0dmFyIG9mZnNldCA9IHR3ZWVuLl9zdGVwUG9zaXRpb247XG5cblx0XHRcdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KSB7XG5cdFx0XHRcdC8vIG1vdGlvbiB0d2Vlbi5cblx0XHRcdFx0dGhpcy5fYWRkTWFuYWdlZENoaWxkKHRhcmdldCwgb2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHN0YXRlIHR3ZWVuLlxuXHRcdFx0XHR0aGlzLl9zZXRTdGF0ZSh0YXJnZXQuc3RhdGUsIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGZvciAoaT1raWRzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBpZCA9IGtpZHNbaV0uaWQ7XG5cdFx0XHRpZiAodGhpcy5fbWFuYWdlZFtpZF0gPT0gMSkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkQXQoaSk7XG5cdFx0XHRcdGRlbGV0ZSh0aGlzLl9tYW5hZ2VkW2lkXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRTdGF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdGF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBvZmZzZXQpIHtcblx0XHRpZiAoIXN0YXRlKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGk9c3RhdGUubGVuZ3RoLTE7aT49MDtpLS0pIHtcblx0XHRcdHZhciBvID0gc3RhdGVbaV07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gby50O1xuXHRcdFx0dmFyIHByb3BzID0gby5wO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0YXJnZXRbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdFx0dGhpcy5fYWRkTWFuYWdlZENoaWxkKHRhcmdldCwgb2Zmc2V0KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgdGltZWxpbmUsIGFuZCBzZXRzIGl0IHVwIGFzIGEgbWFuYWdlZCBjaGlsZC5cblx0ICogQG1ldGhvZCBfYWRkTWFuYWdlZENoaWxkXG5cdCAqIEBwYXJhbSB7TW92aWVDbGlwfSBjaGlsZCBUaGUgY2hpbGQgTW92aWVDbGlwIHRvIG1hbmFnZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0cC5fYWRkTWFuYWdlZENoaWxkID0gZnVuY3Rpb24oY2hpbGQsIG9mZnNldCkge1xuXHRcdGlmIChjaGlsZC5fb2ZmKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwwKTtcblxuXHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIE1vdmllQ2xpcCkge1xuXHRcdFx0Y2hpbGQuX3N5bmNoT2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0Ly8gVE9ETzogdGhpcyBkb2VzIG5vdCBwcmVjaXNlbHkgbWF0Y2ggRmxhc2guIEZsYXNoIGxvc2VzIHRyYWNrIG9mIHRoZSBjbGlwIGlmIGl0IGlzIHJlbmFtZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSB0aW1lbGluZSwgd2hpY2ggY2F1c2VzIGl0IHRvIHJlc2V0LlxuXHRcdFx0aWYgKGNoaWxkLm1vZGUgPT0gTW92aWVDbGlwLklOREVQRU5ERU5UICYmIGNoaWxkLmF1dG9SZXNldCAmJiAhdGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0pIHsgY2hpbGQuX3Jlc2V0KCk7IH1cblx0XHR9XG5cdFx0dGhpcy5fbWFuYWdlZFtjaGlsZC5pZF0gPSAyO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm1cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xuXHRcdFx0aWYgKHRoaXMuZnJhbWVCb3VuZHMpIHsgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5mcmFtZUJvdW5kc1t0aGlzLmN1cnJlbnRGcmFtZV0pOyB9XG5cdFx0fVxuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxuXHRcdHJldHVybiB0aGlzLkNvbnRhaW5lcl9fZ2V0Qm91bmRzKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLk1vdmllQ2xpcCA9IGNyZWF0ZWpzLnByb21vdGUoTW92aWVDbGlwLCBcIkNvbnRhaW5lclwiKTtcblxuXG5cbi8vIE1vdmllQ2xpcFBsdWdpbiBmb3IgVHdlZW5KUzpcblx0LyoqXG5cdCAqIFRoaXMgcGx1Z2luIHdvcmtzIHdpdGggPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlR3ZWVuSlM8L2E+IHRvIHByZXZlbnQgdGhlIHN0YXJ0UG9zaXRpb25cblx0ICogcHJvcGVydHkgZnJvbSB0d2VlbmluZy5cblx0ICogQHByaXZhdGVcblx0ICogQGNsYXNzIE1vdmllQ2xpcFBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3ZpZUNsaXBQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3ZpZUNsaXBQbHVnaW4gY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIilcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgcHJpb3JpdHlcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4ucHJpb3JpdHkgPSAxMDA7IC8vIHZlcnkgaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBmaXJzdFxuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluc3RhbGxcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRNb3ZpZUNsaXBQbHVnaW4uaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLmluc3RhbGxQbHVnaW4oTW92aWVDbGlwUGx1Z2luLCBbXCJzdGFydFBvc2l0aW9uXCJdKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJvb2xlYW59IHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLmluaXQgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBzdGVwXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLnN0ZXAgPSBmdW5jdGlvbigpIHtcblx0XHQvLyB1bnVzZWQuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3Bcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFufSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdGFydFZhbHVlc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBlbmRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3YWl0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbmRcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdE1vdmllQ2xpcFBsdWdpbi50d2VlbiA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSwgc3RhcnRWYWx1ZXMsIGVuZFZhbHVlcywgcmF0aW8sIHdhaXQsIGVuZCkge1xuXHRcdGlmICghKHR3ZWVuLnRhcmdldCBpbnN0YW5jZW9mIE1vdmllQ2xpcCkpIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIChyYXRpbyA9PSAxID8gZW5kVmFsdWVzW3Byb3BdIDogc3RhcnRWYWx1ZXNbcHJvcF0pO1xuXHR9O1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdFxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdGljIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fXMuXG5cdCAqIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseSBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGltYWdlIG9uIGEgcmVndWxhciBncmlkLiBGb3Jcblx0ICogZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zc1xuXHQgKiBieSAyIGhpZ2gpLiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldFV0aWxzXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldFV0aWxzKCkge1xuXHRcdHRocm93IFwiU3ByaXRlU2hlZXRVdGlscyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ2FudmFzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ29udGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXHQgKiBAcHJvdGVjdGVkXG5cdCovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzID0gY2FudmFzO1xuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIDxiPlRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIG1ldGhvZCwgYW5kIG1heSBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBpc3N1ZXMuPC9iPjxici8+PGJyLz5cblx0ICogRXh0ZW5kcyB0aGUgZXhpc3Rpbmcgc3ByaXRlIHNoZWV0IGJ5IGZsaXBwaW5nIHRoZSBvcmlnaW5hbCBmcmFtZXMgaG9yaXpvbnRhbGx5LCB2ZXJ0aWNhbGx5LCBvciBib3RoLFxuXHQgKiBhbmQgYWRkaW5nIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiAmIGZyYW1lIGRhdGEuIFRoZSBmbGlwcGVkIGFuaW1hdGlvbnMgd2lsbCBoYXZlIGEgc3VmZml4IGFkZGVkIHRvIHRoZWlyIG5hbWVzXG5cdCAqIChfaCwgX3YsIF9odiBhcyBhcHByb3ByaWF0ZSkuIE1ha2Ugc3VyZSB0aGUgc3ByaXRlIHNoZWV0IGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cblx0ICogPGJyLz48YnIvPlxuXHQgKiBGb3IgZXhhbXBsZTo8YnIvPlxuXHQgKiBTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMobXlTcHJpdGVTaGVldCwgdHJ1ZSwgdHJ1ZSk7XG5cdCAqIFRoZSBhYm92ZSB3b3VsZCBhZGQgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5IEFORCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCB2ZXJ0aWNhbGx5LlxuXHQgKiA8YnIvPjxici8+XG5cdCAqIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gZmxpcCBhbnkgZGlzcGxheSBvYmplY3QgYnkgc2V0dGluZyBpdHMgc2NhbGVYIG9yIHNjYWxlWSB0byBhIG5lZ2F0aXZlIHZhbHVlLiBPbiBzb21lXG5cdCAqIGJyb3dzZXJzIChlc3BlY2lhbGx5IHRob3NlIHdpdGhvdXQgaGFyZHdhcmUgYWNjZWxlcmF0ZWQgY2FudmFzKSB0aGlzIGNhbiByZXN1bHQgaW4gc2xpZ2h0bHkgZGVncmFkZWQgcGVyZm9ybWFuY2UsXG5cdCAqIHdoaWNoIGlzIHdoeSBhZGRGbGlwcGVkRnJhbWVzIGlzIGF2YWlsYWJsZS5cblx0ICogQG1ldGhvZCBhZGRGbGlwcGVkRnJhbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHBhcmFtIHtCb29sZWFufSBob3Jpem9udGFsIElmIHRydWUsIGhvcml6b250YWxseSBmbGlwcGVkIGZyYW1lcyB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZlcnRpY2FsIElmIHRydWUsIHZlcnRpY2FsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBib3RoIElmIHRydWUsIGZyYW1lcyB0aGF0IGFyZSBmbGlwcGVkIGJvdGggaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5IHdpbGwgYmUgYWRkZWQuXG5cdCAqIEBkZXByZWNhdGVkIE1vZGVybiBicm93c2VycyBwZXJmb3JtIGJldHRlciB3aGVuIGZsaXBwaW5nIHZpYSBhIHRyYW5zZm9ybSAoZXguIHNjYWxlWD0tMSkgcmVuZGVyaW5nIHRoaXMgb2Jzb2xldGUuXG5cdCAqKi9cblx0U3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGhvcml6b250YWwsIHZlcnRpY2FsLCBib3RoKSB7XG5cdFx0aWYgKCFob3Jpem9udGFsICYmICF2ZXJ0aWNhbCAmJiAhYm90aCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0aWYgKGhvcml6b250YWwpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsZmFsc2UpOyB9XG5cdFx0aWYgKHZlcnRpY2FsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCxmYWxzZSx0cnVlKTsgfVxuXHRcdGlmIChib3RoKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCx0cnVlLHRydWUpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzaW5nbGUgZnJhbWUgb2YgdGhlIHNwZWNpZmllZCBzcHJpdGUgc2hlZXQgYXMgYSBuZXcgUE5HIGltYWdlLiBBbiBleGFtcGxlIG9mIHdoZW4gdGhpcyBtYXkgYmUgdXNlZnVsIGlzXG5cdCAqIHRvIHVzZSBhIHNwcml0ZXNoZWV0IGZyYW1lIGFzIHRoZSBzb3VyY2UgZm9yIGEgYml0bWFwIGZpbGwuXG5cdCAqXG5cdCAqIDxzdHJvbmc+V0FSTklORzo8L3N0cm9uZz4gSW4gYWxtb3N0IGFsbCBjYXNlcyBpdCBpcyBiZXR0ZXIgdG8gZGlzcGxheSBhIHNpbmdsZSBmcmFtZSB1c2luZyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGNhbGwgdGhhbiBpdCBpcyB0byBzbGljZSBvdXQgYSBmcmFtZSB1c2luZyB0aGlzXG5cdCAqIG1ldGhvZCBhbmQgZGlzcGxheSBpdCB3aXRoIGEgQml0bWFwIGluc3RhbmNlLiBZb3UgY2FuIGFsc28gY3JvcCBhbiBpbWFnZSB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiQml0bWFwL3NvdXJjZVJlY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgb2Yge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUgZXh0cmFjdEZyYW1lIG1ldGhvZCBtYXkgY2F1c2UgY3Jvc3MtZG9tYWluIHdhcm5pbmdzIHNpbmNlIGl0IGFjY2Vzc2VzIHBpeGVscyBkaXJlY3RseSBvbiB0aGUgY2FudmFzLlxuXHQgKiBAbWV0aG9kIGV4dHJhY3RGcmFtZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBleHRyYWN0IGEgZnJhbWUgZnJvbS5cblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdG8gZXh0cmFjdC4gSWYgYW4gYW5pbWF0aW9uXG5cdCAqIG5hbWUgaXMgc3BlY2lmaWVkLCBvbmx5IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkLlxuXHQgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBhIHNpbmdsZSBmcmFtZSBvZiB0aGUgc3BlY2lmaWVkIHNwcml0ZSBzaGVldCBhcyBhIG5ldyBQTkcgaW1hZ2UuXG5cdCovXG5cdFNwcml0ZVNoZWV0VXRpbHMuZXh0cmFjdEZyYW1lID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdGZyYW1lT3JBbmltYXRpb24gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbikuZnJhbWVzWzBdO1xuXHRcdH1cblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0LmdldEZyYW1lKGZyYW1lT3JBbmltYXRpb24pO1xuXHRcdGlmICghZGF0YSkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHZhciByID0gZGF0YS5yZWN0O1xuXHRcdHZhciBjYW52YXMgPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzO1xuXHRcdGNhbnZhcy53aWR0aCA9IHIud2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IHIuaGVpZ2h0O1xuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShkYXRhLmltYWdlLCByLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQsIDAsIDAsIHIud2lkdGgsIHIuaGVpZ2h0KTtcblx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblx0XHRyZXR1cm4gaW1nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHJnYiBjaGFubmVscyBvZiBvbmUgaW1hZ2Ugd2l0aCB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhbm90aGVyLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbWJpbmUgYSBjb21wcmVzc2VkXG5cdCAqIEpQRUcgaW1hZ2UgY29udGFpbmluZyBjb2xvciBkYXRhIHdpdGggYSBQTkczMiBtb25vY2hyb21hdGljIGltYWdlIGNvbnRhaW5pbmcgYWxwaGEgZGF0YS4gV2l0aCBjZXJ0YWluIHR5cGVzIG9mXG5cdCAqIGltYWdlcyAodGhvc2Ugd2l0aCBkZXRhaWwgdGhhdCBsZW5kIGl0c2VsZiB0byBKUEVHIGNvbXByZXNzaW9uKSB0aGlzIGNhbiBwcm92aWRlIHNpZ25pZmljYW50IGZpbGUgc2l6ZSBzYXZpbmdzXG5cdCAqIHZlcnN1cyBhIHNpbmdsZSBSR0JBIFBORzMyLiBUaGlzIG1ldGhvZCBpcyB2ZXJ5IGZhc3QgKGdlbmVyYWxseSBvbiB0aGUgb3JkZXIgb2YgMS0yIG1zIHRvIHJ1bikuXG5cdCAqIEBtZXRob2QgbWVyZ2VBbHBoYVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gcmJnSW1hZ2UgVGhlIGltYWdlIChvciBjYW52YXMpIGNvbnRhaW5pbmcgdGhlIFJHQiBjaGFubmVscyB0byB1c2UuXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gYWxwaGFJbWFnZSBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgY29udGFpbmluZyB0aGUgYWxwaGEgY2hhbm5lbCB0byB1c2UuXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIGNhbnZhcyB3aWxsIGJlIHVzZWQgYW5kIHJldHVybmVkLiBJZiBub3QsIGEgbmV3IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIGNhbnZhcyB3aXRoIHRoZSBjb21iaW5lZCBpbWFnZSBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgc291cmNlIGZvciBCaXRtYXAgb3IgU3ByaXRlU2hlZXQuXG5cdCAqIEBkZXByZWNhdGVkIFRvb2xzIHN1Y2ggYXMgSW1hZ2VBbHBoYSBnZW5lcmFsbHkgcHJvdmlkZSBiZXR0ZXIgcmVzdWx0cy4gVGhpcyB3aWxsIGJlIG1vdmVkIHRvIHNhbmRib3ggaW4gdGhlIGZ1dHVyZS5cblx0Ki9cblx0U3ByaXRlU2hlZXRVdGlscy5tZXJnZUFscGhhID0gZnVuY3Rpb24ocmdiSW1hZ2UsIGFscGhhSW1hZ2UsIGNhbnZhcykge1xuXHRcdGlmICghY2FudmFzKSB7IGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyB9XG5cdFx0Y2FudmFzLndpZHRoID0gTWF0aC5tYXgoYWxwaGFJbWFnZS53aWR0aCwgcmdiSW1hZ2Uud2lkdGgpO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChhbHBoYUltYWdlLmhlaWdodCwgcmdiSW1hZ2UuaGVpZ2h0KTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5kcmF3SW1hZ2UocmdiSW1hZ2UsMCwwKTtcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuXHRcdGN0eC5kcmF3SW1hZ2UoYWxwaGFJbWFnZSwwLDApO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHRTcHJpdGVTaGVldFV0aWxzLl9mbGlwID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGNvdW50LCBoLCB2KSB7XG5cdFx0dmFyIGltZ3MgPSBzcHJpdGVTaGVldC5faW1hZ2VzO1xuXHRcdHZhciBjYW52YXMgPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzO1xuXHRcdHZhciBjdHggPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dDtcblx0XHR2YXIgaWwgPSBpbWdzLmxlbmd0aC9jb3VudDtcblx0XHRmb3IgKHZhciBpPTA7aTxpbDtpKyspIHtcblx0XHRcdHZhciBzcmMgPSBpbWdzW2ldO1xuXHRcdFx0c3JjLl9fdG1wID0gaTsgLy8gYSBiaXQgaGFja3ksIGJ1dCBmYXN0ZXIgdGhhbiBkb2luZyBpbmRleE9mIGJlbG93LlxuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgrMSxjYW52YXMuaGVpZ2h0KzEpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gc3JjLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKGg/LTE6MSwgMCwgMCwgdj8tMToxLCBoP3NyYy53aWR0aDowLCB2P3NyYy5oZWlnaHQ6MCk7XG5cdFx0XHRjdHguZHJhd0ltYWdlKHNyYywwLDApO1xuXHRcdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGEgc3RyYW5nZSBidWcgaW4gU2FmYXJpOlxuXHRcdFx0aW1nLndpZHRoID0gc3JjLndpZHRoO1xuXHRcdFx0aW1nLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG5cdFx0XHRpbWdzLnB1c2goaW1nKTtcblx0XHR9XG5cblx0XHR2YXIgZnJhbWVzID0gc3ByaXRlU2hlZXQuX2ZyYW1lcztcblx0XHR2YXIgZmwgPSBmcmFtZXMubGVuZ3RoL2NvdW50O1xuXHRcdGZvciAoaT0wO2k8Zmw7aSsrKSB7XG5cdFx0XHRzcmMgPSBmcmFtZXNbaV07XG5cdFx0XHR2YXIgcmVjdCA9IHNyYy5yZWN0LmNsb25lKCk7XG5cdFx0XHRpbWcgPSBpbWdzW3NyYy5pbWFnZS5fX3RtcCtpbCpjb3VudF07XG5cblx0XHRcdHZhciBmcmFtZSA9IHtpbWFnZTppbWcscmVjdDpyZWN0LHJlZ1g6c3JjLnJlZ1gscmVnWTpzcmMucmVnWX07XG5cdFx0XHRpZiAoaCkge1xuXHRcdFx0XHRyZWN0LnggPSBpbWcud2lkdGgtcmVjdC54LXJlY3Qud2lkdGg7IC8vIHVwZGF0ZSByZWN0XG5cdFx0XHRcdGZyYW1lLnJlZ1ggPSByZWN0LndpZHRoLXNyYy5yZWdYOyAvLyB1cGRhdGUgcmVnaXN0cmF0aW9uIHBvaW50XG5cdFx0XHR9XG5cdFx0XHRpZiAodikge1xuXHRcdFx0XHRyZWN0LnkgPSBpbWcuaGVpZ2h0LXJlY3QueS1yZWN0LmhlaWdodDsgIC8vIHVwZGF0ZSByZWN0XG5cdFx0XHRcdGZyYW1lLnJlZ1kgPSByZWN0LmhlaWdodC1zcmMucmVnWTsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxuXHRcdFx0fVxuXHRcdFx0ZnJhbWVzLnB1c2goZnJhbWUpO1xuXHRcdH1cblxuXHRcdHZhciBzZnggPSBcIl9cIisoaD9cImhcIjpcIlwiKSsodj9cInZcIjpcIlwiKTtcblx0XHR2YXIgbmFtZXMgPSBzcHJpdGVTaGVldC5fYW5pbWF0aW9ucztcblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0Ll9kYXRhO1xuXHRcdHZhciBhbCA9IG5hbWVzLmxlbmd0aC9jb3VudDtcblx0XHRmb3IgKGk9MDtpPGFsO2krKykge1xuXHRcdFx0dmFyIG5hbWUgPSBuYW1lc1tpXTtcblx0XHRcdHNyYyA9IGRhdGFbbmFtZV07XG5cdFx0XHR2YXIgYW5pbSA9IHtuYW1lOm5hbWUrc2Z4LHNwZWVkOnNyYy5zcGVlZCxuZXh0OnNyYy5uZXh0LGZyYW1lczpbXX07XG5cdFx0XHRpZiAoc3JjLm5leHQpIHsgYW5pbS5uZXh0ICs9IHNmeDsgfVxuXHRcdFx0ZnJhbWVzID0gc3JjLmZyYW1lcztcblx0XHRcdGZvciAodmFyIGo9MCxsPWZyYW1lcy5sZW5ndGg7ajxsO2orKykge1xuXHRcdFx0XHRhbmltLmZyYW1lcy5wdXNoKGZyYW1lc1tqXStmbCpjb3VudCk7XG5cdFx0XHR9XG5cdFx0XHRkYXRhW2FuaW0ubmFtZV0gPSBhbmltO1xuXHRcdFx0bmFtZXMucHVzaChhbmltLm5hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0VXRpbHMgPSBTcHJpdGVTaGVldFV0aWxzO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0QnVpbGRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBTcHJpdGVTaGVldEJ1aWxkZXIgYWxsb3dzIHlvdSB0byBnZW5lcmF0ZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXQgcnVuIHRpbWVcblx0ICogZnJvbSBhbnkgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsbG93IHlvdSB0byBtYWludGFpbiB5b3VyIGFzc2V0cyBhcyB2ZWN0b3IgZ3JhcGhpY3MgKGZvciBsb3cgZmlsZSBzaXplKSwgYW5kXG5cdCAqIHJlbmRlciB0aGVtIGF0IHJ1biB0aW1lIGFzIFNwcml0ZVNoZWV0cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiBTcHJpdGVTaGVldHMgY2FuIGJlIGJ1aWx0IGVpdGhlciBzeW5jaHJvbm91c2x5LCBvciBhc3luY2hyb25vdXNseSwgc28gdGhhdCBsYXJnZSBTcHJpdGVTaGVldHMgY2FuIGJlIGdlbmVyYXRlZFxuXHQgKiB3aXRob3V0IGxvY2tpbmcgdGhlIFVJLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFwiaW1hZ2VzXCIgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIFNwcml0ZVNoZWV0IGFyZSBhY3R1YWxseSBjYW52YXMgZWxlbWVudHMsIGFuZCB0aGF0IHRoZXkgd2lsbCBiZVxuXHQgKiBzaXplZCB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyIHVwIHRvIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldEJ1aWxkZXIvbWF4V2lkdGg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL21heEhlaWdodDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0QnVpbGRlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lcmF0ZT0wXSBUaGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9mXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0aGF0IGFyZSBjcmVhdGVkLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRCdWlsZGVyKGZyYW1lcmF0ZSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgaW1hZ2VzIChub3QgaW5kaXZpZHVhbCBmcmFtZXMpIGluIHRoZSBnZW5lcmF0ZWQgU3ByaXRlU2hlZXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvXG5cdFx0ICogdXNlIGEgcG93ZXIgb2YgMiBmb3IgdGhpcyB2YWx1ZSAoZXguIDEwMjQsIDIwNDgsIDQwOTYpLiBJZiB0aGUgZnJhbWVzIGNhbm5vdCBhbGwgZml0IHdpdGhpbiB0aGUgbWF4XG5cdFx0ICogZGltZW5zaW9ucywgdGhlbiBhZGRpdGlvbmFsIGltYWdlcyB3aWxsIGJlIGNyZWF0ZWQgYXMgbmVlZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXhXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQqL1xuXHRcdHRoaXMubWF4V2lkdGggPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSBoZWlnaHQgZm9yIHRoZSBpbWFnZXMgKG5vdCBpbmRpdmlkdWFsIGZyYW1lcykgaW4gdGhlIGdlbmVyYXRlZCBTcHJpdGVTaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG9cblx0XHQgKiB1c2UgYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXhcblx0XHQgKiBkaW1lbnNpb25zLCB0aGVuIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heEhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXhIZWlnaHQgPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgdGhhdCB3YXMgZ2VuZXJhdGVkLiBUaGlzIHdpbGwgYmUgbnVsbCBiZWZvcmUgYSBidWlsZCBpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIFNwcml0ZVNoZWV0XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2NhbGUgdG8gYXBwbHkgd2hlbiBkcmF3aW5nIGFsbCBmcmFtZXMgdG8gdGhlIFNwcml0ZVNoZWV0LiBUaGlzIGlzIG11bHRpcGxpZWQgYWdhaW5zdCBhbnkgc2NhbGUgc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGFkZEZyYW1lIGNhbGwuIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBnZW5lcmF0ZSBhIFNwcml0ZVNoZWV0IGF0IHJ1biB0aW1lIHRoYXQgaXMgdGFpbG9yZWRcblx0XHQgKiB0byB0aGUgYSBzcGVjaWZpYyBkZXZpY2UgcmVzb2x1dGlvbiAoZXguIHRhYmxldCB2cyBtb2JpbGUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCogVGhlIHBhZGRpbmcgdG8gdXNlIGJldHdlZW4gZnJhbWVzLiBUaGlzIGlzIGhlbHBmdWwgdG8gcHJlc2VydmUgYW50aWFsaWFzaW5nIG9uIGRyYXduIHZlY3RvciBjb250ZW50LlxuXHRcdCogQHByb3BlcnR5IHBhZGRpbmdcblx0XHQqIEB0eXBlIE51bWJlclxuXHRcdCogQGRlZmF1bHQgMVxuXHRcdCoqL1xuXHRcdHRoaXMucGFkZGluZyA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbnVtYmVyIGZyb20gMC4wMSB0byAwLjk5IHRoYXQgaW5kaWNhdGVzIHdoYXQgcGVyY2VudGFnZSBvZiB0aW1lIHRoZSBidWlsZGVyIGNhbiB1c2UuIFRoaXMgY2FuIGJlXG5cdFx0ICogdGhvdWdodCBvZiBhcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgcGVyIHNlY29uZCB0aGUgYnVpbGRlciB3aWxsIHVzZS4gRm9yIGV4YW1wbGUsIHdpdGggYSB0aW1lU2xpY2UgdmFsdWUgb2YgMC4zLFxuXHRcdCAqIHRoZSBidWlsZGVyIHdpbGwgcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFwcHJveGltYXRlbHkgMTVtcyBwZXIgYnVpbGQgKDMwJSBvZiBhdmFpbGFibGUgdGltZSwgb3IgMC4zcyBwZXIgc2Vjb25kKS5cblx0XHQgKiBEZWZhdWx0cyB0byAwLjMuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTbGljZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDAuM1xuXHRcdCAqKi9cblx0XHR0aGlzLnRpbWVTbGljZSA9IDAuMztcblx0XG5cdFx0LyoqXG5cdFx0ICogQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhdCBpbmRpY2F0ZXMgdGhlIHByb2dyZXNzIG9mIGEgYnVpbGQsIG9yIC0xIGlmIGEgYnVpbGQgaGFzIG5vdFxuXHRcdCAqIGJlZW4gaW5pdGlhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IC0xO1xuXG5cdFx0LyoqXG5cdFx0ICogQSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdmFsdWUgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBuZXcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgYXJlXG5cdFx0ICogY3JlYXRlZC4gSWYgbm8gZnJhbWVyYXRlIGlzIHNwZWNpZmllZCAob3IgaXQgaXMgMCksIHRoZW4gU3ByaXRlU2hlZXRzIHdpbGwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IGZyYW1lcmF0ZSB8fCAwO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9kYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX25leHRGcmFtZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9uZXh0RnJhbWVJbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90aW1lcklEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl90aW1lcklEID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fc2NhbGUgPSAxO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0QnVpbGRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlMgPSBcImZyYW1lIGRpbWVuc2lvbnMgZXhjZWVkIG1heCBzcHJpdGVzaGVldCBkaW1lbnNpb25zXCI7XG5cdFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORyA9IFwiYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmdcIjtcblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGEgYnVpbGQgY29tcGxldGVzLlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhc3luY2hyb25vdXMgYnVpbGQgaGFzIHByb2dyZXNzLlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgKDAtMSkuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgYSBmcmFtZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUgZnJhbWUgd2lsbCBub3QgYmUgZHJhd24gdW50aWwgeW91XG5cdCAqIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL2J1aWxkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gVGhlIG9wdGlvbmFsIHNldHVwIHBhcmFtcyBhbGxvdyB5b3UgdG8gaGF2ZVxuXHQgKiBhIGZ1bmN0aW9uIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRyYXcgb2NjdXJzLiBGb3IgZXhhbXBsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGFkZCBhIHNpbmdsZSBzb3VyY2UgbXVsdGlwbGVcblx0ICogdGltZXMsIGJ1dCBtYW5pcHVsYXRlIGl0IG9yIGl0cyBjaGlsZHJlbiB0byBjaGFuZ2UgaXQgdG8gZ2VuZXJhdGUgZGlmZmVyZW50IGZyYW1lcy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBzb3VyY2UncyB0cmFuc2Zvcm1hdGlvbnMgKHgsIHksIHNjYWxlLCByb3RhdGUsIGFscGhhKSB3aWxsIGJlIGlnbm9yZWQsIGV4Y2VwdCBmb3IgcmVnWC9ZLiBUbyBhcHBseVxuXHQgKiB0cmFuc2Zvcm1zIHRvIGEgc291cmNlIG9iamVjdCBhbmQgaGF2ZSB0aGVtIGNhcHR1cmVkIGluIHRoZSBTcHJpdGVTaGVldCwgc2ltcGx5IHBsYWNlIGl0IGludG8gYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHBhc3MgaW4gdGhlIENvbnRhaW5lciBhcyB0aGUgc291cmNlLlxuXHQgKiBAbWV0aG9kIGFkZEZyYW1lXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gc291cmNlIFRoZSBzb3VyY2Uge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fSAgdG8gZHJhdyBhcyB0aGUgZnJhbWUuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbc291cmNlUmVjdF0gQSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gZGVmaW5pbmcgdGhlIHBvcnRpb24gb2YgdGhlXG5cdCAqIHNvdXJjZSB0byBkcmF3IHRvIHRoZSBmcmFtZS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBsb29rIGZvciBhIGBnZXRCb3VuZHNgIG1ldGhvZCwgYm91bmRzIHByb3BlcnR5LCBvclxuXHQgKiBgbm9taW5hbEJvdW5kc2AgcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3QgZm91bmQsIHRoZSBmcmFtZSB3aWxsIGJlIHNraXBwZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gT3B0aW9uYWwuIFRoZSBzY2FsZSB0byBkcmF3IHRoaXMgZnJhbWUgYXQuIERlZmF1bHQgaXMgMS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyB0aGlzIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOiB0aGUgc291cmNlLCBhbmQgc2V0dXBEYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdGhhdCB3YXMganVzdCBhZGRlZCwgb3IgbnVsbCBpZiBhIHNvdXJjZVJlY3QgY291bGQgbm90IGJlIGRldGVybWluZWQuXG5cdCAqKi9cblx0cC5hZGRGcmFtZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdHJldHVybiB0aGlzLl9mcmFtZXMucHVzaCh7c291cmNlOnNvdXJjZSwgc291cmNlUmVjdDpyZWN0LCBzY2FsZTpzY2FsZSwgZnVuY3Q6c2V0dXBGdW5jdGlvbiwgZGF0YTpzZXR1cERhdGEsIGluZGV4OnRoaXMuX2ZyYW1lcy5sZW5ndGgsIGhlaWdodDpyZWN0LmhlaWdodCpzY2FsZX0pLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY3JlYXRlZCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBhZGRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgZm9yIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lcyBBbiBhcnJheSBvZiBmcmFtZSBpbmRleGVzIHRoYXQgY29tcHJpc2UgdGhlIGFuaW1hdGlvbi4gRXguIFszLDYsNV0gd291bGQgZGVzY3JpYmUgYW4gYW5pbWF0aW9uXG5cdCAqIHRoYXQgcGxheWVkIGZyYW1lIGluZGV4ZXMgMywgNiwgYW5kIDUgaW4gdGhhdCBvcmRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtuZXh0XSBTcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBjb250aW51ZSB0byBhZnRlciB0aGlzIGFuaW1hdGlvbiBlbmRzLiBZb3UgY2FuXG5cdCAqIGFsc28gcGFzcyBmYWxzZSB0byBoYXZlIHRoZSBhbmltYXRpb24gc3RvcCB3aGVuIGl0IGVuZHMuIEJ5IGRlZmF1bHQgaXQgd2lsbCBsb29wIHRvIHRoZSBzdGFydCBvZiB0aGUgc2FtZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIFNwZWNpZmllcyBhIGZyYW1lIGFkdmFuY2Ugc3BlZWQgZm9yIHRoaXMgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAwLjUgd291bGRcblx0ICogY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBhZHZhbmNlIGV2ZXJ5IHNlY29uZCB0aWNrLiBOb3RlIHRoYXQgZWFybGllciB2ZXJzaW9ucyB1c2VkIGBmcmVxdWVuY3lgIGluc3RlYWQsIHdoaWNoIGhhZFxuXHQgKiB0aGUgb3Bwb3NpdGUgZWZmZWN0LlxuXHQgKiovXG5cdHAuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSwgZnJhbWVzLCBuZXh0LCBzcGVlZCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX2FuaW1hdGlvbnNbbmFtZV0gPSB7ZnJhbWVzOmZyYW1lcywgbmV4dDpuZXh0LCBzcGVlZDpzcGVlZH07XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoaXMgd2lsbCB0YWtlIGEge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlLCBhbmQgYWRkIGl0cyBmcmFtZXMgYW5kIGxhYmVscyB0byB0aGlzXG5cdCAqIGJ1aWxkZXIuIExhYmVscyB3aWxsIGJlIGFkZGVkIGFzIGFuIGFuaW1hdGlvbiBydW5uaW5nIGZyb20gdGhlIGxhYmVsIGluZGV4IHRvIHRoZSBuZXh0IGxhYmVsLiBGb3IgZXhhbXBsZSwgaWZcblx0ICogdGhlcmUgaXMgYSBsYWJlbCBuYW1lZCBcImZvb1wiIGF0IGZyYW1lIDAgYW5kIGEgbGFiZWwgbmFtZWQgXCJiYXJcIiBhdCBmcmFtZSAxMCwgaW4gYSBNb3ZpZUNsaXAgd2l0aCAxNSBmcmFtZXMsIGl0XG5cdCAqIHdpbGwgYWRkIGFuIGFuaW1hdGlvbiBuYW1lZCBcImZvb1wiIHRoYXQgcnVucyBmcm9tIGZyYW1lIGluZGV4IDAgdG8gOSwgYW5kIGFuIGFuaW1hdGlvbiBuYW1lZCBcImJhclwiIHRoYXQgcnVucyBmcm9tXG5cdCAqIGZyYW1lIGluZGV4IDEwIHRvIDE0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZnVsbCBNb3ZpZUNsaXAgd2l0aCB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvYWN0aW9uc0VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc2V0IHRvIGBmYWxzZWAsIGVuZGluZyBvbiB0aGUgbGFzdCBmcmFtZS5cblx0ICogQG1ldGhvZCBhZGRNb3ZpZUNsaXBcblx0ICogQHBhcmFtIHtNb3ZpZUNsaXB9IHNvdXJjZSBUaGUgc291cmNlIE1vdmllQ2xpcCBpbnN0YW5jZSB0byBhZGQgdG8gdGhlIFNwcml0ZVNoZWV0LlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3NvdXJjZVJlY3RdIEEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGRlZmluaW5nIHRoZSBwb3J0aW9uIG9mIHRoZSBzb3VyY2UgdG9cblx0ICogZHJhdyB0byB0aGUgZnJhbWUuIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgbG9vayBmb3IgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QsIGBmcmFtZUJvdW5kc2AgQXJyYXksIGBib3VuZHNgIHByb3BlcnR5LCBvciBgbm9taW5hbEJvdW5kc2AgcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3Rcblx0ICogZm91bmQsIHRoZSBNb3ZpZUNsaXAgd2lsbCBiZSBza2lwcGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSB0byBkcmF3IHRoZSBtb3ZpZSBjbGlwIGF0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIGVhY2ggZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkXG5cdCAqIHdpdGggdGhyZWUgcGFyYW1ldGVyczogdGhlIHNvdXJjZSwgc2V0dXBEYXRhLCBhbmQgdGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGFiZWxGdW5jdGlvbl0gVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggTW92aWVDbGlwIGxhYmVsIHRoYXQgaXMgYWRkZWQgd2l0aCBmb3VyXG5cdCAqIHBhcmFtZXRlcnM6IHRoZSBsYWJlbCBuYW1lLCB0aGUgc291cmNlIE1vdmllQ2xpcCBpbnN0YW5jZSwgdGhlIHN0YXJ0aW5nIGZyYW1lIGluZGV4IChpbiB0aGUgbW92aWVjbGlwIHRpbWVsaW5lKVxuXHQgKiBhbmQgdGhlIGVuZCBpbmRleC4gSXQgbXVzdCByZXR1cm4gYSBuZXcgbmFtZSBmb3IgdGhlIGxhYmVsL2FuaW1hdGlvbiwgb3IgYGZhbHNlYCB0byBleGNsdWRlIHRoZSBsYWJlbC5cblx0ICoqL1xuXHRwLmFkZE1vdmllQ2xpcCA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSwgbGFiZWxGdW5jdGlvbikge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0cyA9IHNvdXJjZS5mcmFtZUJvdW5kcztcblx0XHR2YXIgcmVjdCA9IHNvdXJjZVJlY3R8fHNvdXJjZS5ib3VuZHN8fHNvdXJjZS5ub21pbmFsQm91bmRzO1xuXHRcdGlmICghcmVjdCYmc291cmNlLmdldEJvdW5kcykgeyByZWN0ID0gc291cmNlLmdldEJvdW5kcygpOyB9XG5cdFx0aWYgKCFyZWN0ICYmICFyZWN0cykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBsLCBiYXNlRnJhbWVJbmRleCA9IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0dmFyIGR1cmF0aW9uID0gc291cmNlLnRpbWVsaW5lLmR1cmF0aW9uO1xuXHRcdGZvciAoaT0wOyBpPGR1cmF0aW9uOyBpKyspIHtcblx0XHRcdHZhciByID0gKHJlY3RzJiZyZWN0c1tpXSkgPyByZWN0c1tpXSA6IHJlY3Q7XG5cdFx0XHR0aGlzLmFkZEZyYW1lKHNvdXJjZSwgciwgc2NhbGUsIHRoaXMuX3NldHVwTW92aWVDbGlwRnJhbWUsIHtpOmksIGY6c2V0dXBGdW5jdGlvbiwgZDpzZXR1cERhdGF9KTtcblx0XHR9XG5cdFx0dmFyIGxhYmVscyA9IHNvdXJjZS50aW1lbGluZS5fbGFiZWxzO1xuXHRcdHZhciBsYmxzID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiBsYWJlbHMpIHtcblx0XHRcdGxibHMucHVzaCh7aW5kZXg6bGFiZWxzW25dLCBsYWJlbDpufSk7XG5cdFx0fVxuXHRcdGlmIChsYmxzLmxlbmd0aCkge1xuXHRcdFx0bGJscy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLmluZGV4LWIuaW5kZXg7IH0pO1xuXHRcdFx0Zm9yIChpPTAsbD1sYmxzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIGxhYmVsID0gbGJsc1tpXS5sYWJlbDtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gYmFzZUZyYW1lSW5kZXgrbGJsc1tpXS5pbmRleDtcblx0XHRcdFx0dmFyIGVuZCA9IGJhc2VGcmFtZUluZGV4KygoaSA9PSBsLTEpID8gZHVyYXRpb24gOiBsYmxzW2krMV0uaW5kZXgpO1xuXHRcdFx0XHR2YXIgZnJhbWVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGo9c3RhcnQ7IGo8ZW5kOyBqKyspIHsgZnJhbWVzLnB1c2goaik7IH1cblx0XHRcdFx0aWYgKGxhYmVsRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRsYWJlbCA9IGxhYmVsRnVuY3Rpb24obGFiZWwsIHNvdXJjZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdFx0aWYgKCFsYWJlbCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkQW5pbWF0aW9uKGxhYmVsLCBmcmFtZXMsIHRydWUpOyAvLyBmb3Igbm93LCB0aGlzIGxvb3BzIGFsbCBhbmltYXRpb25zLlxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQnVpbGRzIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWVzLlxuXHQgKiBAbWV0aG9kIGJ1aWxkXG5cdCAqIEByZXR1cm4ge1Nwcml0ZVNoZWV0fSBUaGUgY3JlYXRlZCBTcHJpdGVTaGVldCBpbnN0YW5jZSwgb3IgbnVsbCBpZiBhIGJ1aWxkIGlzIGFscmVhZHkgcnVubmluZyBvciBhbiBlcnJvclxuXHQgKiBvY2N1cnJlZC5cblx0ICoqL1xuXHRwLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy5fc3RhcnRCdWlsZCgpO1xuXHRcdHdoaWxlICh0aGlzLl9kcmF3TmV4dCgpKSB7fVxuXHRcdHRoaXMuX2VuZEJ1aWxkKCk7XG5cdFx0cmV0dXJuIHRoaXMuc3ByaXRlU2hlZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGJ1aWxkcyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZyYW1lcy4gSXQgd2lsbFxuXHQgKiBydW4gMjAgdGltZXMgcGVyIHNlY29uZCwgdXNpbmcgYW4gYW1vdW50IG9mIHRpbWUgZGVmaW5lZCBieSBgdGltZVNsaWNlYC4gV2hlbiBpdCBpcyBjb21wbGV0ZSBpdCB3aWxsIGNhbGwgdGhlXG5cdCAqIHNwZWNpZmllZCBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBidWlsZEFzeW5jXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNsaWNlXSBTZXRzIHRoZSB0aW1lU2xpY2UgcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmJ1aWxkQXN5bmMgPSBmdW5jdGlvbih0aW1lU2xpY2UpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLnRpbWVTbGljZSA9IHRpbWVTbGljZTtcblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuX3J1bigpOyB9LCA1MC1NYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgY3VycmVudCBhc3luY2hyb25vdXMgYnVpbGQuXG5cdCAqIEBtZXRob2Qgc3RvcEFzeW5jXG5cdCAqKi9cblx0cC5zdG9wQXN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXJJRCk7XG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0QnVpbGRlciBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0QnVpbGRlciBjYW5ub3QgYmUgY2xvbmVkLlwiKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0QnVpbGRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zdGFydEJ1aWxkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zdGFydEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhZCA9IHRoaXMucGFkZGluZ3x8MDtcblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0dGhpcy5fc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdHZhciBkYXRhRnJhbWVzID0gW107XG5cdFx0dGhpcy5fZGF0YSA9IHtcblx0XHRcdGltYWdlczogW10sXG5cdFx0XHRmcmFtZXM6IGRhdGFGcmFtZXMsXG5cdFx0XHRmcmFtZXJhdGU6IHRoaXMuZnJhbWVyYXRlLFxuXHRcdFx0YW5pbWF0aW9uczogdGhpcy5fYW5pbWF0aW9ucyAvLyBUT0RPOiBzaG91bGQgd2UgXCJjbG9uZVwiIF9hbmltYXRpb25zIGluIGNhc2Ugc29tZW9uZSBhZGRzIG1vcmUgYW5pbWF0aW9ucyBhZnRlciBhIGJ1aWxkP1xuXHRcdH07XG5cblx0XHR2YXIgZnJhbWVzID0gdGhpcy5fZnJhbWVzLnNsaWNlKCk7XG5cdFx0ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiAoYS5oZWlnaHQ8PWIuaGVpZ2h0KSA/IC0xIDogMTsgfSk7XG5cblx0XHRpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGgtMV0uaGVpZ2h0K3BhZCoyID4gdGhpcy5tYXhIZWlnaHQpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0dmFyIHk9MCwgeD0wO1xuXHRcdHZhciBpbWcgPSAwO1xuXHRcdHdoaWxlIChmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuX2ZpbGxSb3coZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCk7XG5cdFx0XHRpZiAoby53ID4geCkgeyB4ID0gby53OyB9XG5cdFx0XHR5ICs9IG8uaDtcblx0XHRcdGlmICghby5oIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gdGhpcy5fZ2V0U2l6ZSh4LHRoaXMubWF4V2lkdGgpO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSh5LHRoaXMubWF4SGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5fZGF0YS5pbWFnZXNbaW1nXSA9IGNhbnZhcztcblx0XHRcdFx0aWYgKCFvLmgpIHtcblx0XHRcdFx0XHR4PXk9MDtcblx0XHRcdFx0XHRpbWcrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cE1vdmllQ2xpcEZyYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9zZXR1cE1vdmllQ2xpcEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG5cdFx0dmFyIGFlID0gc291cmNlLmFjdGlvbnNFbmFibGVkO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNvdXJjZS5nb3RvQW5kU3RvcChkYXRhLmkpO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGFlO1xuXHRcdGRhdGEuZiYmZGF0YS5mKHNvdXJjZSwgZGF0YS5kLCBkYXRhLmkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRTaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9nZXRTaXplID0gZnVuY3Rpb24oc2l6ZSxtYXgpIHtcblx0XHR2YXIgcG93ID0gNDtcblx0XHR3aGlsZSAoTWF0aC5wb3coMiwrK3BvdykgPCBzaXplKXt9XG5cdFx0cmV0dXJuIE1hdGgubWluKG1heCxNYXRoLnBvdygyLHBvdykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9maWxsUm93XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YUZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9maWxsUm93ID0gZnVuY3Rpb24oZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCkge1xuXHRcdHZhciB3ID0gdGhpcy5tYXhXaWR0aDtcblx0XHR2YXIgbWF4SCA9IHRoaXMubWF4SGVpZ2h0O1xuXHRcdHkgKz0gcGFkO1xuXHRcdHZhciBoID0gbWF4SC15O1xuXHRcdHZhciB4ID0gcGFkO1xuXHRcdHZhciBoZWlnaHQgPSAwO1xuXHRcdGZvciAodmFyIGk9ZnJhbWVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcblx0XHRcdHZhciBzYyA9IHRoaXMuX3NjYWxlKmZyYW1lLnNjYWxlO1xuXHRcdFx0dmFyIHJlY3QgPSBmcmFtZS5zb3VyY2VSZWN0O1xuXHRcdFx0dmFyIHNvdXJjZSA9IGZyYW1lLnNvdXJjZTtcblx0XHRcdHZhciByeCA9IE1hdGguZmxvb3Ioc2MqcmVjdC54LXBhZCk7XG5cdFx0XHR2YXIgcnkgPSBNYXRoLmZsb29yKHNjKnJlY3QueS1wYWQpO1xuXHRcdFx0dmFyIHJoID0gTWF0aC5jZWlsKHNjKnJlY3QuaGVpZ2h0K3BhZCoyKTtcblx0XHRcdHZhciBydyA9IE1hdGguY2VpbChzYypyZWN0LndpZHRoK3BhZCoyKTtcblx0XHRcdGlmIChydyA+IHcpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0XHRpZiAocmggPiBoIHx8IHgrcncgPiB3KSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRmcmFtZS5pbWcgPSBpbWc7XG5cdFx0XHRmcmFtZS5yZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LHkscncscmgpO1xuXHRcdFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IHJoO1xuXHRcdFx0ZnJhbWVzLnNwbGljZShpLDEpO1xuXHRcdFx0ZGF0YUZyYW1lc1tmcmFtZS5pbmRleF0gPSBbeCx5LHJ3LHJoLGltZyxNYXRoLnJvdW5kKC1yeCtzYypzb3VyY2UucmVnWC1wYWQpLE1hdGgucm91bmQoLXJ5K3NjKnNvdXJjZS5yZWdZLXBhZCldO1xuXHRcdFx0eCArPSBydztcblx0XHR9XG5cdFx0cmV0dXJuIHt3OngsIGg6aGVpZ2h0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZW5kQnVpbGRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2VuZEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9kYXRhKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XHR0aGlzLnByb2dyZXNzID0gMTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9ydW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTA7XG5cdFx0dmFyIHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpK3RzO1xuXHRcdHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHdoaWxlICh0ID4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSkge1xuXHRcdFx0aWYgKCF0aGlzLl9kcmF3TmV4dCgpKSB7IGNvbXBsZXRlID0gdHJ1ZTsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtdHMpO1xuXHRcdH1cblx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MgPSB0aGlzLl9pbmRleC90aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSkge1xuXHRcdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHRcdFx0ZXZ0LnByb2dyZXNzID0gcDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd05leHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGRyYXcuXG5cdCAqKi9cblx0cC5fZHJhd05leHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5faW5kZXhdO1xuXHRcdHZhciBzYyA9IGZyYW1lLnNjYWxlKnRoaXMuX3NjYWxlO1xuXHRcdHZhciByZWN0ID0gZnJhbWUucmVjdDtcblx0XHR2YXIgc291cmNlUmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2RhdGEuaW1hZ2VzW2ZyYW1lLmltZ107XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0ZnJhbWUuZnVuY3QmJmZyYW1lLmZ1bmN0KGZyYW1lLnNvdXJjZSwgZnJhbWUuZGF0YSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC50cmFuc2xhdGUoTWF0aC5jZWlsKHJlY3QueC1zb3VyY2VSZWN0Lngqc2MpLCBNYXRoLmNlaWwocmVjdC55LXNvdXJjZVJlY3QueSpzYykpO1xuXHRcdGN0eC5zY2FsZShzYyxzYyk7XG5cdFx0ZnJhbWUuc291cmNlLmRyYXcoY3R4KTsgLy8gZGlzcGxheSBvYmplY3Qgd2lsbCBkcmF3IGl0c2VsZi5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiAoKyt0aGlzLl9pbmRleCkgPCB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRCdWlsZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldEJ1aWxkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERPTUVsZW1lbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiA8Yj5UaGlzIGNsYXNzIGlzIHN0aWxsIGV4cGVyaW1lbnRhbCwgYW5kIG1vcmUgYWR2YW5jZWQgdXNlIGlzIGxpa2VseSB0byBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBidWdzLjwvYj5cblx0ICpcblx0ICogQSBET01FbGVtZW50IGFsbG93cyB5b3UgdG8gYXNzb2NpYXRlIGEgSFRNTEVsZW1lbnQgd2l0aCB0aGUgZGlzcGxheSBsaXN0LiBJdCB3aWxsIGJlIHRyYW5zZm9ybWVkXG5cdCAqIHdpdGhpbiB0aGUgRE9NIGFzIHRob3VnaCBpdCBpcyBjaGlsZCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGl0IGlzIGFkZGVkIHRvLiBIb3dldmVyLCBpdCBpc1xuXHQgKiBub3QgcmVuZGVyZWQgdG8gY2FudmFzLCBhbmQgYXMgc3VjaCB3aWxsIHJldGFpbiB3aGF0ZXZlciB6LWluZGV4IGl0IGhhcyByZWxhdGl2ZSB0byB0aGUgY2FudmFzIChpZS4gaXQgd2lsbCBiZVxuXHQgKiBkcmF3biBpbiBmcm9udCBvZiBvciBiZWhpbmQgdGhlIGNhbnZhcykuXG5cdCAqXG5cdCAqIFRoZSBwb3NpdGlvbiBvZiBhIERPTUVsZW1lbnQgaXMgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50IG5vZGUgaW4gdGhlIERPTS4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdFxuXHQgKiB0aGUgRE9NIE9iamVjdCBiZSBhZGRlZCB0byBhIGRpdiB0aGF0IGFsc28gY29udGFpbnMgdGhlIGNhbnZhcyBzbyB0aGF0IHRoZXkgc2hhcmUgdGhlIHNhbWUgcG9zaXRpb25cblx0ICogb24gdGhlIHBhZ2UuXG5cdCAqXG5cdCAqIERPTUVsZW1lbnQgaXMgdXNlZnVsIGZvciBwb3NpdGlvbmluZyBIVE1MIGVsZW1lbnRzIG92ZXIgdG9wIG9mIGNhbnZhcyBjb250ZW50LCBhbmQgZm9yIGVsZW1lbnRzXG5cdCAqIHRoYXQgeW91IHdhbnQgdG8gZGlzcGxheSBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGNhbnZhcy4gRm9yIGV4YW1wbGUsIGEgdG9vbHRpcCB3aXRoIHJpY2ggSFRNTFxuXHQgKiBjb250ZW50LlxuXHQgKlxuXHQgKiA8aDQ+TW91c2UgSW50ZXJhY3Rpb248L2g0PlxuXHQgKlxuXHQgKiBET01FbGVtZW50IGluc3RhbmNlcyBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMsIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZVxuXHQgKiBldmVudHMgb3Igc3VwcG9ydCBtZXRob2RzIGxpa2UgaGl0VGVzdC4gVG8gZ2V0IG1vdXNlIGV2ZW50cyBmcm9tIGEgRE9NRWxlbWVudCwgeW91IG11c3QgaW5zdGVhZCBhZGQgaGFuZGxlcnMgdG9cblx0ICogdGhlIGh0bWxFbGVtZW50IChub3RlLCB0aGlzIGRvZXMgbm90IHN1cHBvcnQgRXZlbnREaXNwYXRjaGVyKVxuXHQgKlxuXHQgKiAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IGNyZWF0ZWpzLkRPTUVsZW1lbnQoaHRtbEVsZW1lbnQpO1xuXHQgKiAgICAgIGRvbUVsZW1lbnQuaHRtbEVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrZWRcIik7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgRE9NRWxlbWVudFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxlbWVudCBBIHJlZmVyZW5jZSBvciBpZCBmb3IgdGhlIERPTSBlbGVtZW50IHRvIG1hbmFnZS5cblx0ICovXG5cdGZ1bmN0aW9uIERPTUVsZW1lbnQoaHRtbEVsZW1lbnQpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRpZiAodHlwZW9mKGh0bWxFbGVtZW50KT09XCJzdHJpbmdcIikgeyBodG1sRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWxFbGVtZW50KTsgfVxuXHRcdHRoaXMubW91c2VFbmFibGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIHN0eWxlID0gaHRtbEVsZW1lbnQuc3R5bGU7XG5cdFx0c3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c3R5bGUudHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtT3JpZ2luID0gc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5Nb3pUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5PVHJhbnNmb3JtT3JpZ2luID0gXCIwJSAwJVwiO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgRE9NIG9iamVjdCB0byBtYW5hZ2UuXG5cdFx0ICogQHByb3BlcnR5IGh0bWxFbGVtZW50XG5cdFx0ICogQHR5cGUgSFRNTEVsZW1lbnRcblx0XHQgKi9cblx0XHR0aGlzLmh0bWxFbGVtZW50ID0gaHRtbEVsZW1lbnQ7XG5cdFxuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkTXR4XG5cdFx0ICogQHR5cGUgTWF0cml4MkRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKERPTUVsZW1lbnQsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5odG1sRWxlbWVudCAhPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHQvLyB0aGlzIHJlbGllcyBvbiB0aGUgX3RpY2sgbWV0aG9kIGJlY2F1c2UgZHJhdyBpc24ndCBjYWxsZWQgaWYgdGhlIHBhcmVudCBpcyBub3QgdmlzaWJsZS5cblx0XHQvLyB0aGUgYWN0dWFsIHVwZGF0ZSBoYXBwZW5zIGluIF9oYW5kbGVEcmF3RW5kXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICovXG5cdHAuY2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcblx0ICovXG5cdHAudW5jYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICovXG5cdHAudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGhpdFRlc3Rcblx0ICovXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgbG9jYWxUb0dsb2JhbFxuXHQgKi9cblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBnbG9iYWxUb0xvY2FsXG5cdCAqL1xuXHRwLmdsb2JhbFRvTG9jYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9Mb2NhbFxuXHQgKi9cblx0cC5sb2NhbFRvTG9jYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBET01FbGVtZW50IGNhbm5vdCBiZSBjbG9uZWQuIFRocm93cyBhbiBlcnJvci5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltET01FbGVtZW50IChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblx0LyoqXG4gICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuXHQgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICogQGV2ZW50IGNsaWNrXG5cdCAqL1xuXG4gICAgIC8qKlxuICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcbiBcdCAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgKiBAZXZlbnQgZGJsQ2xpY2tcblx0ICovXG5cbiAgICAgLyoqXG4gICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcbiBcdCAgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICAqIEBldmVudCBtb3VzZWRvd25cblx0ICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBUaGUgSFRNTEVsZW1lbnQgY2FuIGxpc3RlbiBmb3IgdGhlIG1vdXNlb3ZlciBldmVudCwgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLlxuICAgICAgKiBTaW5jZSBET01FbGVtZW50IGluc3RhbmNlcyBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cbiAgICAgICogQGV2ZW50IG1vdXNlb3ZlclxuXHQgICovXG5cbiAgICAgLyoqXG4gICAgICAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAgKiBAZXZlbnQgdGlja1xuXHQgICovXG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogZnVuY3Rpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHR2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG5cdFx0c3RhZ2UmJnN0YWdlLm9uKFwiZHJhd2VuZFwiLCB0aGlzLl9oYW5kbGVEcmF3RW5kLCB0aGlzLCB0cnVlKTtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX3RpY2soZXZ0T2JqKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVEcmF3RW5kXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVEcmF3RW5kID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIG8gPSB0aGlzLmh0bWxFbGVtZW50O1xuXHRcdGlmICghbykgeyByZXR1cm47IH1cblx0XHR2YXIgc3R5bGUgPSBvLnN0eWxlO1xuXHRcdFxuXHRcdHZhciBwcm9wcyA9IHRoaXMuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzKHRoaXMuX3Byb3BzKSwgbXR4ID0gcHJvcHMubWF0cml4O1xuXHRcdFxuXHRcdHZhciB2aXNpYmlsaXR5ID0gcHJvcHMudmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcblx0XHRpZiAodmlzaWJpbGl0eSAhPSBzdHlsZS52aXNpYmlsaXR5KSB7IHN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5OyB9XG5cdFx0aWYgKCFwcm9wcy52aXNpYmxlKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBvbGRQcm9wcyA9IHRoaXMuX29sZFByb3BzLCBvbGRNdHggPSBvbGRQcm9wcyYmb2xkUHJvcHMubWF0cml4O1xuXHRcdHZhciBuID0gMTAwMDA7IC8vIHByZWNpc2lvblxuXHRcdFxuXHRcdGlmICghb2xkTXR4IHx8ICFvbGRNdHguZXF1YWxzKG10eCkpIHtcblx0XHRcdHZhciBzdHIgPSBcIm1hdHJpeChcIiArIChtdHguYSpufDApL24gK1wiLFwiKyAobXR4LmIqbnwwKS9uICtcIixcIisgKG10eC5jKm58MCkvbiArXCIsXCIrIChtdHguZCpufDApL24gK1wiLFwiKyAobXR4LnR4KzAuNXwwKTtcblx0XHRcdHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLk9UcmFuc2Zvcm0gPSBzdHlsZS5tc1RyYW5zZm9ybSA9IHN0ciArXCIsXCIrIChtdHgudHkrMC41fDApICtcIilcIjtcblx0XHRcdHN0eWxlLk1velRyYW5zZm9ybSA9IHN0ciArXCJweCxcIisgKG10eC50eSswLjV8MCkgK1wicHgpXCI7XG5cdFx0XHRpZiAoIW9sZFByb3BzKSB7IG9sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKHRydWUsIE5hTik7IH1cblx0XHRcdG9sZFByb3BzLm1hdHJpeC5jb3B5KG10eCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChvbGRQcm9wcy5hbHBoYSAhPSBwcm9wcy5hbHBoYSkge1xuXHRcdFx0c3R5bGUub3BhY2l0eSA9IFwiXCIrKHByb3BzLmFscGhhKm58MCkvbjtcblx0XHRcdG9sZFByb3BzLmFscGhhID0gcHJvcHMuYWxwaGE7XG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuRE9NRWxlbWVudCA9IGNyZWF0ZWpzLnByb21vdGUoRE9NRWxlbWVudCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEJhc2UgY2xhc3MgdGhhdCBhbGwgZmlsdGVycyBzaG91bGQgaW5oZXJpdCBmcm9tLiBGaWx0ZXJzIG5lZWQgdG8gYmUgYXBwbGllZCB0byBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB1c2luZ1xuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIElmIGFuIG9iamVjdCBjaGFuZ2VzLCBwbGVhc2UgY2FjaGUgaXQgYWdhaW4sIG9yIHVzZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3VwZGF0ZUNhY2hlXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZpbHRlcnMgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBjYWNoaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbnN0YW5jZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwgMCwgMCwgMSwgMjU1LCAwLCAwKSxcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMTApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBteUluc3RhbmNlLmNhY2hlKDAsMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZWFjaCBmaWx0ZXIgY2FuIGltcGxlbWVudCBhIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCByZXR1cm5zIHRoZVxuXHQgKiBtYXJnaW5zIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGZ1bGx5IGRpc3BsYXkgdGhlIGZpbHRlci4gRm9yIGV4YW1wbGUsIHRoZSB7eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgY2F1c2UgYW4gb2JqZWN0IHRvIGZlYXRoZXIgb3V0d2FyZHMsIHJlc3VsdGluZyBpbiBhIG1hcmdpbiBhcm91bmQgdGhlIHNoYXBlLlxuXHQgKlxuXHQgKiA8aDQ+RWFzZWxKUyBGaWx0ZXJzPC9oND5cblx0ICogRWFzZWxKUyBjb21lcyB3aXRoIGEgbnVtYmVyIG9mIHByZS1idWlsdCBmaWx0ZXJzOlxuXHQgKiA8dWw+PGxpPnt7I2Nyb3NzTGluayBcIkFscGhhTWFwRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IDogTWFwIGEgZ3JleXNjYWxlIGltYWdlIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hc2tGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IE1hcCBhbiBpbWFnZSdzIGFscGhhIGNoYW5uZWwgdG8gdGhlIGFscGhhIGNoYW5uZWwgb2YgYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkJsdXJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IEFwcGx5IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGJsdXIgdG8gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBDb2xvciB0cmFuc2Zvcm0gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBUcmFuc2Zvcm0gYW4gaW1hZ2UgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBjbGFzcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRmlsdGVyKCkge31cblx0dmFyIHAgPSBGaWx0ZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIHBhZGRpbmcgdmFsdWVzIGZvciB0aGlzIGZpbHRlci4gVGhhdCBpcywgaG93IG11Y2ggdGhlIGZpbHRlciB3aWxsIGV4dGVuZCB0aGUgdmlzdWFsIGJvdW5kcyBvZiBhbiBvYmplY3QgaXQgaXMgYXBwbGllZCB0by5cblx0ICogQG1ldGhvZCBnZXRCb3VuZHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0XSBJZiBzcGVjaWZpZWQsIHRoZSBwcm92aWRlZCBSZWN0YW5nbGUgaW5zdGFuY2Ugd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgcGFkZGluZyBhbW91bnRzIGFuZCByZXR1cm5lZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBJZiBhIGByZWN0YCBwYXJhbSB3YXMgcHJvdmlkZWQsIGl0IGlzIHJldHVybmVkLiBJZiBub3QsIGVpdGhlciBhIG5ldyByZWN0YW5nbGUgd2l0aCB0aGUgcGFkZGluZyB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gcGFkZGluZyBpcyByZXF1aXJlZCBmb3IgdGhpcyBmaWx0ZXIuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRhcmdldEN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSkge1xuXHRcdC8vIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGJlY2F1c2UgbW9zdCBmaWx0ZXJzIGFjY2VzcyBwaXhlbCBkYXRhLiBJdCBpcyBvdmVycmlkZGVuIHdoZW4gbm90IG5lZWRlZC5cblx0XHR0YXJnZXRDdHggPSB0YXJnZXRDdHggfHwgY3R4O1xuXHRcdGlmICh0YXJnZXRYID09IG51bGwpIHsgdGFyZ2V0WCA9IHg7IH1cblx0XHRpZiAodGFyZ2V0WSA9PSBudWxsKSB7IHRhcmdldFkgPSB5OyB9XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2FwcGx5RmlsdGVyKGltYWdlRGF0YSkpIHtcblx0XHRcdHRhcmdldEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIEZpbHRlciBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtGaWx0ZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRmlsdGVyIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcigpO1xuXHR9O1xuXHRcbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbWFnZURhdGEgVGFyZ2V0IEltYWdlRGF0YSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfTtcblxuXG5cdGNyZWF0ZWpzLkZpbHRlciA9IEZpbHRlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCbHVyRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGJveCBibHVyIHRvIERpc3BsYXlPYmplY3RzLiBOb3RlIHRoYXQgdGhpcyBmaWx0ZXIgaXMgZmFpcmx5IENQVSBpbnRlbnNpdmUsIHBhcnRpY3VsYXJseSBpZiB0aGUgcXVhbGl0eSBpc1xuXHQgKiBzZXQgaGlnaGVyIHRoYW4gMS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIGFwcGxpZXMgYSA1IHBpeGVsIGJsdXIgdG8gaXQuIEl0IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIHRvIGFjY291bnQgZm9yIHRoZSBzcHJlYWQgdGhhdCB0aGUgYmx1ciBjYXVzZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibHVyRmlsdGVyID0gbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMSk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtibHVyRmlsdGVyXTtcblx0ICogICAgICB2YXIgYm91bmRzID0gYmx1ckZpbHRlci5nZXRCb3VuZHMoKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTArYm91bmRzLngsIC01MCtib3VuZHMueSwgMTAwK2JvdW5kcy53aWR0aCwgMTAwK2JvdW5kcy5oZWlnaHQpO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBCbHVyRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWD0wXSBUaGUgaG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clk9MF0gVGhlIHZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTFdIFRoZSBudW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJsdXJGaWx0ZXIoIGJsdXJYLCBibHVyWSwgcXVhbGl0eSkge1xuXHRcdGlmICggaXNOYU4oYmx1clgpIHx8IGJsdXJYIDwgMCApIGJsdXJYID0gMDtcblx0XHRpZiAoIGlzTmFOKGJsdXJZKSB8fCBibHVyWSA8IDAgKSBibHVyWSA9IDA7XG5cdFx0aWYgKCBpc05hTihxdWFsaXR5KSB8fCBxdWFsaXR5IDwgMSAgKSBxdWFsaXR5ID0gMTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1clhcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clggPSBibHVyWCB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBWZXJ0aWNhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1cllcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clkgPSBibHVyWSB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAxIHdpbGwgcHJvZHVjZSBhIHJvdWdoIGJsdXIuIEEgdmFsdWUgb2YgMiB3aWxsIHByb2R1Y2UgYVxuXHRcdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBxdWFsaXR5XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCbHVyRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIG11bHRpcGx5IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBNVUxfVEFCTEVcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Qmx1ckZpbHRlci5NVUxfVEFCTEUgPSBbMSwgMTcxLCAyMDUsIDI5MywgNTcsIDM3MywgNzksIDEzNywgMjQxLCAyNywgMzkxLCAzNTcsIDQxLCAxOSwgMjgzLCAyNjUsIDQ5NywgNDY5LCA0NDMsIDQyMSwgMjUsIDE5MSwgMzY1LCAzNDksIDMzNSwgMTYxLCAxNTUsIDE0OSwgOSwgMjc4LCAyNjksIDI2MSwgNTA1LCAyNDUsIDQ3NSwgMjMxLCA0NDksIDQzNywgMjEzLCA0MTUsIDQwNSwgMzk1LCAxOTMsIDM3NywgMzY5LCAzNjEsIDM1MywgMzQ1LCAxNjksIDMzMSwgMzI1LCAzMTksIDMxMywgMzA3LCAzMDEsIDM3LCAxNDUsIDI4NSwgMjgxLCA2OSwgMjcxLCAyNjcsIDI2MywgMjU5LCA1MDksIDUwMSwgNDkzLCAyNDMsIDQ3OSwgMTE4LCA0NjUsIDQ1OSwgMTEzLCA0NDYsIDU1LCA0MzUsIDQyOSwgNDIzLCAyMDksIDQxMywgNTEsIDQwMywgMTk5LCAzOTMsIDk3LCAzLCAzNzksIDM3NSwgMzcxLCAzNjcsIDM2MywgMzU5LCAzNTUsIDM1MSwgMzQ3LCA0MywgODUsIDMzNywgMzMzLCAxNjUsIDMyNywgMzIzLCA1LCAzMTcsIDE1NywgMzExLCA3NywgMzA1LCAzMDMsIDc1LCAyOTcsIDI5NCwgNzMsIDI4OSwgMjg3LCA3MSwgMTQxLCAyNzksIDI3NywgMjc1LCA2OCwgMTM1LCA2NywgMTMzLCAzMywgMjYyLCAyNjAsIDEyOSwgNTExLCA1MDcsIDUwMywgNDk5LCA0OTUsIDQ5MSwgNjEsIDEyMSwgNDgxLCA0NzcsIDIzNywgMjM1LCA0NjcsIDIzMiwgMTE1LCA0NTcsIDIyNywgNDUxLCA3LCA0NDUsIDIyMSwgNDM5LCAyMTgsIDQzMywgMjE1LCA0MjcsIDQyNSwgMjExLCA0MTksIDQxNywgMjA3LCA0MTEsIDQwOSwgMjAzLCAyMDIsIDQwMSwgMzk5LCAzOTYsIDE5NywgNDksIDM4OSwgMzg3LCAzODUsIDM4MywgOTUsIDE4OSwgNDcsIDE4NywgOTMsIDE4NSwgMjMsIDE4MywgOTEsIDE4MSwgNDUsIDE3OSwgODksIDE3NywgMTEsIDE3NSwgODcsIDE3MywgMzQ1LCAzNDMsIDM0MSwgMzM5LCAzMzcsIDIxLCAxNjcsIDgzLCAzMzEsIDMyOSwgMzI3LCAxNjMsIDgxLCAzMjMsIDMyMSwgMzE5LCAxNTksIDc5LCAzMTUsIDMxMywgMzksIDE1NSwgMzA5LCAzMDcsIDE1MywgMzA1LCAzMDMsIDE1MSwgNzUsIDI5OSwgMTQ5LCAzNywgMjk1LCAxNDcsIDczLCAyOTEsIDE0NSwgMjg5LCAyODcsIDE0MywgMjg1LCA3MSwgMTQxLCAyODEsIDM1LCAyNzksIDEzOSwgNjksIDI3NSwgMTM3LCAyNzMsIDE3LCAyNzEsIDEzNSwgMjY5LCAyNjcsIDEzMywgMjY1LCAzMywgMjYzLCAxMzEsIDI2MSwgMTMwLCAyNTksIDEyOSwgMjU3LCAxXTtcblxuXHQvKipcblx0ICogQXJyYXkgb2Ygc2hpZnQgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IFNIR19UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLlNIR19UQUJMRSA9IFswLCA5LCAxMCwgMTEsIDksIDEyLCAxMCwgMTEsIDEyLCA5LCAxMywgMTMsIDEwLCA5LCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxMCwgMTMsIDE0LCAxNCwgMTQsIDEzLCAxMywgMTMsIDksIDE0LCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE0LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTIsIDE0LCAxNSwgMTUsIDEzLCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDEzLCAxNiwgMTYsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgOSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDEwLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE0LCAxNSwgMTQsIDE1LCAxMywgMTYsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTQsIDE1LCAxNywgMTcsIDE2LCAxNiwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTEsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE2LCAxNywgMTcsIDE3LCAxNiwgMTQsIDE3LCAxNywgMTcsIDE3LCAxNSwgMTYsIDE0LCAxNiwgMTUsIDE2LCAxMywgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEyLCAxNiwgMTUsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDEzLCAxNiwgMTUsIDE3LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE0LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE1LCAxNiwgMTcsIDE0LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCA5XTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHJlY3QpIHtcblx0XHR2YXIgeCA9IHRoaXMuYmx1clh8MCwgeSA9IHRoaXMuYmx1cll8IDA7XG5cdFx0aWYgKHggPD0gMCAmJiB5IDw9IDApIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgcSA9IE1hdGgucG93KHRoaXMucXVhbGl0eSwgMC4yKTtcblx0XHRyZXR1cm4gKHJlY3QgfHwgbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5wYWQoeCpxKzEseSpxKzEseCpxKzEseSpxKzEpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEJsdXJGaWx0ZXIodGhpcy5ibHVyWCwgdGhpcy5ibHVyWSwgdGhpcy5xdWFsaXR5KTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JsdXJGaWx0ZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXG5cdFx0dmFyIHJhZGl1c1ggPSB0aGlzLmJsdXJYID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1gpIHx8IHJhZGl1c1ggPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHJhZGl1c1kgPSB0aGlzLmJsdXJZID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1kpIHx8IHJhZGl1c1kgPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHJhZGl1c1ggPT0gMCAmJiByYWRpdXNZID09IDApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5xdWFsaXR5O1xuXHRcdGlmIChpc05hTihpdGVyYXRpb25zKSB8fCBpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cdFx0aXRlcmF0aW9ucyB8PSAwO1xuXHRcdGlmIChpdGVyYXRpb25zID4gMykgaXRlcmF0aW9ucyA9IDM7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblxuXHRcdHZhciBweCA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciB4PTAsIHk9MCwgaT0wLCBwPTAsIHlwPTAsIHlpPTAsIHl3PTAsIHI9MCwgZz0wLCBiPTAsIGE9MCwgcHI9MCwgcGc9MCwgcGI9MCwgcGE9MDtcblxuXHRcdHZhciBkaXZ4ID0gKHJhZGl1c1ggKyByYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciBkaXZ5ID0gKHJhZGl1c1kgKyByYWRpdXNZICsgMSkgfCAwO1xuXHRcdHZhciB3ID0gaW1hZ2VEYXRhLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IGltYWdlRGF0YS5oZWlnaHQgfCAwO1xuXG5cdFx0dmFyIHcxID0gKHcgLSAxKSB8IDA7XG5cdFx0dmFyIGgxID0gKGggLSAxKSB8IDA7XG5cdFx0dmFyIHJ4cDEgPSAocmFkaXVzWCArIDEpIHwgMDtcblx0XHR2YXIgcnlwMSA9IChyYWRpdXNZICsgMSkgfCAwO1xuXG5cdFx0dmFyIHNzeCA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdHZhciBzeCA9IHNzeDtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdng7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3ggPSBzeC5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN4Lm4gPSBzc3g7XG5cblx0XHR2YXIgc3N5ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN5ID0gc3N5O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eTsgaSsrIClcblx0XHR7XG5cdFx0XHRzeSA9IHN5Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3kubiA9IHNzeTtcblxuXHRcdHZhciBzaSA9IG51bGw7XG5cblxuXHRcdHZhciBtdHggPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0dmFyIHN0eCA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgbXR5ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXHRcdHZhciBzdHkgPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNZXSB8IDA7XG5cblx0XHR3aGlsZSAoaXRlcmF0aW9ucy0tID4gMCkge1xuXG5cdFx0XHR5dyA9IHlpID0gMDtcblx0XHRcdHZhciBtcyA9IG10eDtcblx0XHRcdHZhciBzcyA9IHN0eDtcblx0XHRcdGZvciAoeSA9IGg7IC0teSA+IC0xOykge1xuXHRcdFx0XHRyID0gcnhwMSAqIChwciA9IHB4Wyh5aSkgfCAwXSk7XG5cdFx0XHRcdGcgPSByeHAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSk7XG5cdFx0XHRcdGIgPSByeHAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSk7XG5cdFx0XHRcdGEgPSByeHAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSk7XG5cblx0XHRcdFx0c3ggPSBzc3g7XG5cblx0XHRcdFx0Zm9yKCBpID0gcnhwMTsgLS1pID4gLTE7IClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN4LnIgPSBwcjtcblx0XHRcdFx0XHRzeC5nID0gcGc7XG5cdFx0XHRcdFx0c3guYiA9IHBiO1xuXHRcdFx0XHRcdHN4LmEgPSBwYTtcblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDwgcnhwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHAgPSAoeWkgKyAoKHcxIDwgaSA/IHcxIDogaSkgPDwgMikpIHwgMDtcblx0XHRcdFx0XHRyICs9ICggc3guciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnICs9ICggc3guZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeC5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN4LmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNpID0gc3N4O1xuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHc7IHgrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRweFt5aSsrXSA9IChyICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChnICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChiICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChhICogbXMpID4+PiBzcztcblxuXHRcdFx0XHRcdHAgPSAoKHl3ICsgKChwID0geCArIHJhZGl1c1ggKyAxKSA8IHcxID8gcCA6IHcxKSkgPDwgMik7XG5cblx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR5dyArPSB3O1xuXHRcdFx0fVxuXG5cdFx0XHRtcyA9IG10eTtcblx0XHRcdHNzID0gc3R5O1xuXHRcdFx0Zm9yICh4ID0gMDsgeCA8IHc7IHgrKykge1xuXHRcdFx0XHR5aSA9ICh4IDw8IDIpIHwgMDtcblxuXHRcdFx0XHRyID0gKHJ5cDEgKiAocHIgPSBweFt5aV0pKSB8IDA7XG5cdFx0XHRcdGcgPSAocnlwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGIgPSAocnlwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGEgPSAocnlwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pKSB8IDA7XG5cblx0XHRcdFx0c3kgPSBzc3k7XG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCByeXAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3kuciA9IHByO1xuXHRcdFx0XHRcdHN5LmcgPSBwZztcblx0XHRcdFx0XHRzeS5iID0gcGI7XG5cdFx0XHRcdFx0c3kuYSA9IHBhO1xuXHRcdFx0XHRcdHN5ID0gc3kubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlwID0gdztcblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDw9IHJhZGl1c1k7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcblxuXHRcdFx0XHRcdHIgKz0gKCBzeS5yID0gcHhbeWldKTtcblx0XHRcdFx0XHRnICs9ICggc3kuZyA9IHB4W3lpKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3kuYiA9IHB4W3lpKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3kuYSA9IHB4W3lpKzNdKTtcblxuXHRcdFx0XHRcdHN5ID0gc3kubjtcblxuXHRcdFx0XHRcdGlmKCBpIDwgaDEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHlwICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eWkgPSB4O1xuXHRcdFx0XHRzaSA9IHNzeTtcblx0XHRcdFx0aWYgKCBpdGVyYXRpb25zID4gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Y3JlYXRlanMuQmx1ckZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQmx1ckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0XG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBncmV5c2NhbGUgYWxwaGEgbWFwIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcblx0ICogYmUgY29waWVkIGZyb20gdGhlIHJlZCBjaGFubmVsIG9mIHRoZSBtYXAsIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC5cblx0ICpcblx0ICogR2VuZXJhbGx5LCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LCBiZWNhdXNlIGl0IGhhcyBtdWNoXG5cdCAqIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSByZWQtPmJsdWUgYm94LCBjYWNoZXMgaXQsIGFuZCB0aGVuIHVzZXMgdGhlIGNhY2hlIGNhbnZhcyBhcyBhbiBhbHBoYSBtYXAgb24gYSAxMDB4MTAwIGltYWdlLlxuXHQgKlxuXHQgKiAgICAgICB2YXIgYm94ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjZmYwMDAwXCIsIFwiIzAwMDBmZlwiXSwgWzAsIDFdLCAwLCAwLCAwLCAxMDApXG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgIHZhciBibXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwicGF0aC90by9pbWFnZS5qcGdcIik7XG5cdCAqICAgICAgIGJtcC5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyKGJveC5jYWNoZUNhbnZhcylcblx0ICogICAgICAgXTtcblx0ICogICAgICAgYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICAgc3RhZ2UuYWRkQ2hpbGQoYm1wKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQWxwaGFNYXBGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGFscGhhTWFwIFRoZSBncmV5c2NhbGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBhbHBoYSB2YWx1ZSBmb3IgdGhlXG5cdCAqIHJlc3VsdC4gVGhpcyBzaG91bGQgYmUgZXhhY3RseSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQWxwaGFNYXBGaWx0ZXIoYWxwaGFNYXApIHtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZSByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWVcblx0XHQgKiBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhTWFwXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhTWFwID0gYWxwaGFNYXA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FscGhhTWFwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5fYWxwaGFNYXAgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFwRGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBVaW50OENsYW1wZWRBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXBEYXRhID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBbHBoYU1hcEZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbyA9IG5ldyBBbHBoYU1hcEZpbHRlcih0aGlzLmFscGhhTWFwKTtcblx0XHRvLl9hbHBoYU1hcCA9IHRoaXMuX2FscGhhTWFwO1xuXHRcdG8uX21hcERhdGEgPSB0aGlzLl9tYXBEYXRhO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0FscGhhTWFwRmlsdGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF0aGlzLl9wcmVwQWxwaGFNYXAoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcblx0XHQvLyBUT0RPOiB1cGRhdGUgdG8gc3VwcG9ydCBzY2VuYXJpb3Mgd2hlcmUgdGhlIHRhcmdldCBoYXMgZGlmZmVyZW50IGRpbWVuc2lvbnMuXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwRGF0YTtcblx0XHRmb3IodmFyIGk9MCwgbD1kYXRhLmxlbmd0aDsgaTxsOyBpICs9IDQpIHsgZGF0YVtpICsgM10gPSBtYXBbaV0gfHwgMDsgfVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wcmVwQWxwaGFNYXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBBbHBoYU1hcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuYWxwaGFNYXApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHRoaXMuYWxwaGFNYXAgPT0gdGhpcy5fYWxwaGFNYXAgJiYgdGhpcy5fbWFwRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX2FscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblx0XHR2YXIgY2FudmFzID0gbWFwO1xuXHRcdHZhciBjdHg7XG5cdFx0aWYgKG1hcCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXMgPyBjcmVhdGVqcy5jcmVhdGVDYW52YXMoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRjYW52YXMud2lkdGggPSBtYXAud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gbWFwLmhlaWdodDtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XHRjdHguZHJhd0ltYWdlKG1hcCwgMCwgMCk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBtYXAud2lkdGgsIG1hcC5oZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vaWYgKCF0aGlzLnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBhY2Nlc3MgbG9jYWwgaW1hZ2UgZGF0YTogXCIgKyBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbWFwRGF0YSA9IGltZ0RhdGEuZGF0YTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hcEZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXNrRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGFscGhhIGZyb20gdGhlIG1hc2sgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdGhlIHRhcmdldCwgc3VjaCB0aGF0IHRoZSBhbHBoYSBjaGFubmVsIG9mIHRoZSByZXN1bHQgd2lsbFxuXHQgKiBiZSBkZXJpdmVkIGZyb20gdGhlIG1hc2ssIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvXG5cdCAqIGFwcGx5IGFuIGFscGhhIG1hc2sgdG8gYSBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbWJpbmUgYSBKUEcgY29tcHJlc3NlZCBSR0IgaW1hZ2Ugd2l0aCBhIFBORzMyXG5cdCAqIGFscGhhIG1hc2ssIHdoaWNoIGNhbiByZXN1bHQgaW4gYSBtdWNoIHNtYWxsZXIgZmlsZSBzaXplIHRoYW4gYSBzaW5nbGUgUE5HMzIgY29udGFpbmluZyBBUkdCLlxuXHQgKlxuXHQgKiA8Yj5JTVBPUlRBTlQgTk9URTogVGhpcyBmaWx0ZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIHRhcmdldEN0eCwgb3IgdGFyZ2V0WC9ZIHBhcmFtZXRlcnMgY29ycmVjdGx5LjwvYj5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSBncmFkaWVudCBib3gsIHRoZW4gY2FjaGVzIGl0IGFuZCB1c2VzIHRoZSBcImNhY2hlQ2FudmFzXCIgYXMgdGhlIGFscGhhIG1hc2sgb24gYSAxMDB4MTAwIGltYWdlLlxuXHQgKlxuXHQgKiAgICAgIHZhciBib3ggPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogICAgICBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMDAwMFwiLCBcInJnYmEoMCwgMCwgMCwgMClcIl0sIFswLCAxXSwgMCwgMCwgMTAwLCAxMDApXG5cdCAqICAgICAgYm94LmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICBib3guY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwicGF0aC90by9pbWFnZS5qcGdcIik7XG5cdCAqICAgICAgYm1wLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5BbHBoYU1hc2tGaWx0ZXIoYm94LmNhY2hlQ2FudmFzKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQWxwaGFNYXNrRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBtYXNrXG5cdCAqKi9cblx0ZnVuY3Rpb24gQWxwaGFNYXNrRmlsdGVyKG1hc2spIHtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBtYXNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXNrXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLm1hc2sgPSBtYXNrO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFscGhhTWFza0ZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgZmlsdGVyIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cblx0ICpcblx0ICogPHN0cm9uZz5JTVBPUlRBTlQgTk9URTogVGhpcyBmaWx0ZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIHRhcmdldEN0eCwgb3IgdGFyZ2V0WC9ZIHBhcmFtZXRlcnNcblx0ICogY29ycmVjdGx5Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJEIGNvbnRleHQgdG8gdXNlIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3RhcmdldEN0eF0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIDJEIGNvbnRleHQgdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgY29udGV4dCBwYXNzZWQgdG8gY3R4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFhdIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSB4IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFldIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSB5IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsdGVyIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cblx0ICoqL1xuXHRwLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q3R4LCB0YXJnZXRYLCB0YXJnZXRZKSB7XG5cdFx0aWYgKCF0aGlzLm1hc2spIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0YXJnZXRDdHggPSB0YXJnZXRDdHggfHwgY3R4O1xuXHRcdGlmICh0YXJnZXRYID09IG51bGwpIHsgdGFyZ2V0WCA9IHg7IH1cblx0XHRpZiAodGFyZ2V0WSA9PSBudWxsKSB7IHRhcmdldFkgPSB5OyB9XG5cblx0XHR0YXJnZXRDdHguc2F2ZSgpO1xuXHRcdGlmIChjdHggIT0gdGFyZ2V0Q3R4KSB7XG5cdFx0XHQvLyBUT0RPOiBzdXBwb3J0IHRhcmdldEN0eCBhbmQgdGFyZ2V0WC9ZXG5cdFx0XHQvLyBjbGVhclJlY3QsIHRoZW4gZHJhdyB0aGUgY3R4IGluP1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRhcmdldEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG5cdFx0dGFyZ2V0Q3R4LmRyYXdJbWFnZSh0aGlzLm1hc2ssIHRhcmdldFgsIHRhcmdldFkpO1xuXHRcdHRhcmdldEN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IEFscGhhTWFza0ZpbHRlcih0aGlzLm1hc2spO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0FscGhhTWFza0ZpbHRlcl1cIjtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkFscGhhTWFza0ZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWxwaGFNYXNrRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvckZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjb2xvciB0cmFuc2Zvcm0gdG8gRGlzcGxheU9iamVjdHMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkIGNpcmNsZSwgYW5kIHRoZW4gdHJhbnNmb3JtcyBpdCB0byBCbHVlLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBtdWx0aXBseWluZyBhbGwgdGhlIGNoYW5uZWxzXG5cdCAqIHRvIDAgKGV4Y2VwdCBhbHBoYSwgd2hpY2ggaXMgc2V0IHRvIDEpLCBhbmQgdGhlbiBhZGRpbmcgMjU1IHRvIHRoZSBibHVlIGNoYW5uZWwuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvckZpbHRlcigwLDAsMCwxLCAwLDAsMjU1LDApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBDb2xvckZpbHRlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSByZWQgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtncmVlbk11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBncmVlbiBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdWVNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgYmx1ZSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGFscGhhIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVkT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSByZWQgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5PZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGdyZWVuIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBibHVlIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYWxwaGEgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JGaWx0ZXIocmVkTXVsdGlwbGllciwgZ3JlZW5NdWx0aXBsaWVyLCBibHVlTXVsdGlwbGllciwgYWxwaGFNdWx0aXBsaWVyLCByZWRPZmZzZXQsIGdyZWVuT2Zmc2V0LCBibHVlT2Zmc2V0LCBhbHBoYU9mZnNldCkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogUmVkIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgcmVkTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZE11bHRpcGxpZXIgPSByZWRNdWx0aXBsaWVyICE9IG51bGwgPyByZWRNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBncmVlbk11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk11bHRpcGxpZXIgPSBncmVlbk11bHRpcGxpZXIgIT0gbnVsbCA/IGdyZWVuTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBibHVlTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVNdWx0aXBsaWVyID0gYmx1ZU11bHRpcGxpZXIgIT0gbnVsbCA/IGJsdWVNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxwaGEgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU11bHRpcGxpZXIgPSBhbHBoYU11bHRpcGxpZXIgIT0gbnVsbCA/IGFscGhhTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWRPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRPZmZzZXQgPSByZWRPZmZzZXQgfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5PZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk9mZnNldCA9IGdyZWVuT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVPZmZzZXQgPSBibHVlT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFPZmZzZXQgPSBhbHBoYU9mZnNldCB8fCAwO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbG9yRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yRmlsdGVyKHRoaXMucmVkTXVsdGlwbGllciwgdGhpcy5ncmVlbk11bHRpcGxpZXIsIHRoaXMuYmx1ZU11bHRpcGxpZXIsIHRoaXMuYWxwaGFNdWx0aXBsaWVyLCB0aGlzLnJlZE9mZnNldCwgdGhpcy5ncmVlbk9mZnNldCwgdGhpcy5ibHVlT2Zmc2V0LCB0aGlzLmFscGhhT2Zmc2V0KTtcblx0fTtcblx0XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBsID0gZGF0YS5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdGRhdGFbaV0gPSBkYXRhW2ldKnRoaXMucmVkTXVsdGlwbGllcit0aGlzLnJlZE9mZnNldDtcblx0XHRcdGRhdGFbaSsxXSA9IGRhdGFbaSsxXSp0aGlzLmdyZWVuTXVsdGlwbGllcit0aGlzLmdyZWVuT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzJdID0gZGF0YVtpKzJdKnRoaXMuYmx1ZU11bHRpcGxpZXIrdGhpcy5ibHVlT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzNdID0gZGF0YVtpKzNdKnRoaXMuYWxwaGFNdWx0aXBsaWVyK3RoaXMuYWxwaGFPZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFzc2VtYmxpbmcgYSBtYXRyaXggZm9yIHVzZSB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTW9zdCBtZXRob2RzIHJldHVybiB0aGUgaW5zdGFuY2UgdG8gZmFjaWxpdGF0ZSBjaGFpbmVkIGNhbGxzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlDb2xvck1hdHJpeC5hZGp1c3RIdWUoMjApLmFkanVzdEJyaWdodG5lc3MoNTApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBhcHBseSBmaWx0ZXJzLCBvciB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIENvbG9yTWF0cml4IHRvIGNoYW5nZSBhIERpc3BsYXlPYmplY3QncyBjb2xvci5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4KGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpIHtcblx0XHR0aGlzLnNldENvbG9yKGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpO1xuXHR9XG5cdHZhciBwID0gQ29sb3JNYXRyaXgucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBkZWx0YSB2YWx1ZXMgZm9yIGNvbnRyYXN0IGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IERFTFRBX0lOREVYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkRFTFRBX0lOREVYID0gW1xuXHRcdDAsICAgIDAuMDEsIDAuMDIsIDAuMDQsIDAuMDUsIDAuMDYsIDAuMDcsIDAuMDgsIDAuMSwgIDAuMTEsXG5cdFx0MC4xMiwgMC4xNCwgMC4xNSwgMC4xNiwgMC4xNywgMC4xOCwgMC4yMCwgMC4yMSwgMC4yMiwgMC4yNCxcblx0XHQwLjI1LCAwLjI3LCAwLjI4LCAwLjMwLCAwLjMyLCAwLjM0LCAwLjM2LCAwLjM4LCAwLjQwLCAwLjQyLFxuXHRcdDAuNDQsIDAuNDYsIDAuNDgsIDAuNSwgIDAuNTMsIDAuNTYsIDAuNTksIDAuNjIsIDAuNjUsIDAuNjgsXG5cdFx0MC43MSwgMC43NCwgMC43NywgMC44MCwgMC44MywgMC44NiwgMC44OSwgMC45MiwgMC45NSwgMC45OCxcblx0XHQxLjAsICAxLjA2LCAxLjEyLCAxLjE4LCAxLjI0LCAxLjMwLCAxLjM2LCAxLjQyLCAxLjQ4LCAxLjU0LFxuXHRcdDEuNjAsIDEuNjYsIDEuNzIsIDEuNzgsIDEuODQsIDEuOTAsIDEuOTYsIDIuMCwgIDIuMTIsIDIuMjUsXG5cdFx0Mi4zNywgMi41MCwgMi42MiwgMi43NSwgMi44NywgMy4wLCAgMy4yLCAgMy40LCAgMy42LCAgMy44LFxuXHRcdDQuMCwgIDQuMywgIDQuNywgIDQuOSwgIDUuMCwgIDUuNSwgIDYuMCwgIDYuNSwgIDYuOCwgIDcuMCxcblx0XHQ3LjMsICA3LjUsICA3LjgsICA4LjAsICA4LjQsICA4LjcsICA5LjAsICA5LjQsICA5LjYsICA5LjgsXG5cdFx0MTAuMFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBJZGVudGl0eSBtYXRyaXggdmFsdWVzLlxuXHQgKiBAcHJvcGVydHkgSURFTlRJVFlfTUFUUklYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCA9IFtcblx0XHQxLDAsMCwwLDAsXG5cdFx0MCwxLDAsMCwwLFxuXHRcdDAsMCwxLDAsMCxcblx0XHQwLDAsMCwxLDAsXG5cdFx0MCwwLDAsMCwxXG5cdF07XG5cblx0LyoqXG5cdCAqIFRoZSBjb25zdGFudCBsZW5ndGggb2YgYSBjb2xvciBtYXRyaXguXG5cdCAqIEBwcm9wZXJ0eSBMRU5HVEhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkxFTkdUSCA9IENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWC5sZW5ndGg7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAuc2V0Q29sb3IgPSBmdW5jdGlvbihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzZXQoKS5hZGp1c3RDb2xvcihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHkgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gYWRqdXN0IGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uIGFuZCBodWUuXG5cdCAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBhZGp1c3RIdWUoaHVlKSwgYWRqdXN0Q29udHJhc3QoY29udHJhc3QpLFxuXHQgKiBhZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpLCBhZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pLCBpbiB0aGF0IG9yZGVyLlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHR0aGlzLmFkanVzdEh1ZShodWUpO1xuXHRcdHRoaXMuYWRqdXN0Q29udHJhc3QoY29udHJhc3QpO1xuXHRcdHRoaXMuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKTtcblx0XHRyZXR1cm4gdGhpcy5hZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHBpeGVsIGNvbG9yIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIHRoZSBpbWFnZSBicmlnaHRlciwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgbWFrZSBpdCBkYXJrZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0QnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0yNTUgJiAyNTUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBSR0IgY2hhbm5lbHMuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RCcmlnaHRuZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMjU1KTtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHQxLDAsMCwwLHZhbHVlLFxuXHRcdFx0MCwxLDAsMCx2YWx1ZSxcblx0XHRcdDAsMCwxLDAsdmFsdWUsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29udHJhc3Qgb2YgcGl4ZWwgY29sb3IuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIGNvbnRyYXN0LCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBkZWNyZWFzZSBjb250cmFzdC5cblx0ICogQG1ldGhvZCBhZGp1c3RDb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb250cmFzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHg7XG5cdFx0aWYgKHZhbHVlPDApIHtcblx0XHRcdHggPSAxMjcrdmFsdWUvMTAwKjEyNztcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHZhbHVlJTE7XG5cdFx0XHRpZiAoeCA9PSAwKSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFt2YWx1ZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKV0qKDEteCkrQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKSsxXSp4OyAvLyB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1vcmUgZ3JhbnVsYXJpdHkuXG5cdFx0XHR9XG5cdFx0XHR4ID0geCoxMjcrMTI3O1xuXHRcdH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHR4LzEyNywwLDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAseC8xMjcsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLHgvMTI3LDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29sb3Igc2F0dXJhdGlvbiBvZiB0aGUgcGl4ZWwuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIHNhdHVyYXRpb24sIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIHNhdHVyYXRpb24gKHRyZW5kIHRvd2FyZHMgZ3JleXNjYWxlKS5cblx0ICogQG1ldGhvZCBhZGp1c3RTYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdFNhdHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxMDApO1xuXHRcdHZhciB4ID0gMSsoKHZhbHVlID4gMCkgPyAzKnZhbHVlLzEwMCA6IHZhbHVlLzEwMCk7XG5cdFx0dmFyIGx1bVIgPSAwLjMwODY7XG5cdFx0dmFyIGx1bUcgPSAwLjYwOTQ7XG5cdFx0dmFyIGx1bUIgPSAwLjA4MjA7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUiooMS14KSt4LGx1bUcqKDEteCksbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCkreCxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSxsdW1CKigxLXgpK3gsMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgaHVlIG9mIHRoZSBwaXhlbCBjb2xvci5cblx0ICogQG1ldGhvZCBhZGp1c3RIdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTgwICYgMTgwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0SHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTgwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgY29zVmFsID0gTWF0aC5jb3ModmFsdWUpO1xuXHRcdHZhciBzaW5WYWwgPSBNYXRoLnNpbih2YWx1ZSk7XG5cdFx0dmFyIGx1bVIgPSAwLjIxMztcblx0XHR2YXIgbHVtRyA9IDAuNzE1O1xuXHRcdHZhciBsdW1CID0gMC4wNzI7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUitjb3NWYWwqKDEtbHVtUikrc2luVmFsKigtbHVtUiksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKC1sdW1HKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooMS1sdW1CKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooMC4xNDMpLGx1bUcrY29zVmFsKigxLWx1bUcpK3NpblZhbCooMC4xNDApLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigtMC4yODMpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigtKDEtbHVtUikpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKihsdW1HKSxsdW1CK2Nvc1ZhbCooMS1sdW1CKStzaW5WYWwqKGx1bUIpLDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25jYXRlbmF0ZXMgKG11bHRpcGxpZXMpIHRoZSBzcGVjaWZpZWQgbWF0cml4IHdpdGggdGhpcyBvbmUuXG5cdCAqIEBtZXRob2QgY29uY2F0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvbmNhdCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdG1hdHJpeCA9IHRoaXMuX2ZpeE1hdHJpeChtYXRyaXgpO1xuXHRcdGlmIChtYXRyaXgubGVuZ3RoICE9IENvbG9yTWF0cml4LkxFTkdUSCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBBIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAobmV3IENvbG9yTWF0cml4KCkpLmNvcHkodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIGxlbmd0aCAyNSAoNXg1KSBhcnJheSBpbnN0YW5jZSBjb250YWluaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHRvQXJyYXlcblx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGhvbGRpbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqKi9cblx0cC50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9Q29sb3JNYXRyaXguTEVOR1RIOyBpPGw7IGkrKykge1xuXHRcdFx0YXJyW2ldID0gdGhpc1tpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogQ29weSB0aGUgc3BlY2lmaWVkIG1hdHJpeCdzIHZhbHVlcyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbCA9IENvbG9yTWF0cml4LkxFTkdUSDtcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xuXHRcdFx0dGhpc1tpXSA9IG1hdHJpeFtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4XVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX211bHRpcGx5TWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fbXVsdGlwbHlNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgaSwgaiwgaywgY29sID0gW107XG5cblx0XHRmb3IgKGk9MDtpPDU7aSsrKSB7XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdGNvbFtqXSA9IHRoaXNbaitpKjVdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChqPTA7ajw1O2orKykge1xuXHRcdFx0XHR2YXIgdmFsPTA7XG5cdFx0XHRcdGZvciAoaz0wO2s8NTtrKyspIHtcblx0XHRcdFx0XHR2YWwgKz0gbWF0cml4W2orayo1XSpjb2xba107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tqK2kqNV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlIHN1cmUgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZSwgaHVlIGhhcyBhIGxpbWl0IG9mIDE4MCwgYnJpZ2h0bmVzcyBpcyAyNTUsIG90aGVycyBhcmUgMTAwLlxuXHQgKiBAbWV0aG9kIF9jbGVhblZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcmF3IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1heGltdW0gdGhhdCB0aGUgbnVtYmVyIGNhbiBiZS4gVGhlIG1pbmltdW0gaXMgdGhlIGxpbWl0ICogLTEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbGVhblZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGxpbWl0KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKGxpbWl0LE1hdGgubWF4KC1saW1pdCx2YWx1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1hdHJpeGVzIGFyZSA1eDUgKDI1IGxvbmcpLlxuXHQgKiBAbWV0aG9kIF9maXhNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9maXhNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRpZiAobWF0cml4IGluc3RhbmNlb2YgQ29sb3JNYXRyaXgpIHsgbWF0cml4ID0gbWF0cml4LnRvQXJyYXkoKTsgfVxuXHRcdGlmIChtYXRyaXgubGVuZ3RoIDwgQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxtYXRyaXgubGVuZ3RoKS5jb25jYXQoQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLnNsaWNlKG1hdHJpeC5sZW5ndGgsQ29sb3JNYXRyaXguTEVOR1RIKSk7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID4gQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxDb2xvck1hdHJpeC5MRU5HVEgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXggPSBDb2xvck1hdHJpeDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFsbG93cyB5b3UgdG8gY2Fycnkgb3V0IGNvbXBsZXggY29sb3Igb3BlcmF0aW9ucyBzdWNoIGFzIG1vZGlmeWluZyBzYXR1cmF0aW9uLCBicmlnaHRuZXNzLCBvciBpbnZlcnRpbmcuIFNlZSB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gY2hhbmdpbmcgY29sb3JzLiBGb3IgYW4gZWFzaWVyIGNvbG9yIHRyYW5zZm9ybSxcblx0ICogY29uc2lkZXIgdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgcmVkIGNpcmNsZSwgaW52ZXJ0cyBpdHMgaHVlLCBhbmQgdGhlbiBzYXR1cmF0ZXMgaXQgdG8gYnJpZ2h0ZW4gaXQgdXAuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBtYXRyaXggPSBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXgoKS5hZGp1c3RIdWUoMTgwKS5hZGp1c3RTYXR1cmF0aW9uKDEwMCk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4RmlsdGVyKG1hdHJpeClcblx0ICogICAgICBdO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmNhY2hlKC01MCwgLTUwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4RmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQHBhcmFtIHtBcnJheSB8IENvbG9yTWF0cml4fSBtYXRyaXggQSA0eDUgbWF0cml4IGRlc2NyaWJpbmcgdGhlIGNvbG9yIG9wZXJhdGlvbiB0byBwZXJmb3JtLiBTZWUgYWxzbyB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KSB7XG5cdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uIFNlZSBhbHNvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0XHQgKiBAdHlwZSBBcnJheSB8IENvbG9yTWF0cml4XG5cdFx0ICoqL1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbG9yTWF0cml4RmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29sb3JNYXRyaXhGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JNYXRyaXhGaWx0ZXIodGhpcy5tYXRyaXgpO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7IFxuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIGwgPSBkYXRhLmxlbmd0aDtcblx0XHR2YXIgcixnLGIsYTtcblx0XHR2YXIgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0dmFyIG0wID0gIG10eFswXSwgIG0xID0gIG10eFsxXSwgIG0yID0gIG10eFsyXSwgIG0zID0gIG10eFszXSwgIG00ID0gIG10eFs0XTtcblx0XHR2YXIgbTUgPSAgbXR4WzVdLCAgbTYgPSAgbXR4WzZdLCAgbTcgPSAgbXR4WzddLCAgbTggPSAgbXR4WzhdLCAgbTkgPSAgbXR4WzldO1xuXHRcdHZhciBtMTAgPSBtdHhbMTBdLCBtMTEgPSBtdHhbMTFdLCBtMTIgPSBtdHhbMTJdLCBtMTMgPSBtdHhbMTNdLCBtMTQgPSBtdHhbMTRdO1xuXHRcdHZhciBtMTUgPSBtdHhbMTVdLCBtMTYgPSBtdHhbMTZdLCBtMTcgPSBtdHhbMTddLCBtMTggPSBtdHhbMThdLCBtMTkgPSBtdHhbMTldO1xuXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdHIgPSBkYXRhW2ldO1xuXHRcdFx0ZyA9IGRhdGFbaSsxXTtcblx0XHRcdGIgPSBkYXRhW2krMl07XG5cdFx0XHRhID0gZGF0YVtpKzNdO1xuXHRcdFx0ZGF0YVtpXSA9IHIqbTArZyptMStiKm0yK2EqbTMrbTQ7IC8vIHJlZFxuXHRcdFx0ZGF0YVtpKzFdID0gciptNStnKm02K2IqbTcrYSptOCttOTsgLy8gZ3JlZW5cblx0XHRcdGRhdGFbaSsyXSA9IHIqbTEwK2cqbTExK2IqbTEyK2EqbTEzK20xNDsgLy8gYmx1ZVxuXHRcdFx0ZGF0YVtpKzNdID0gciptMTUrZyptMTYrYiptMTcrYSptMTgrbTE5OyAvLyBhbHBoYVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yTWF0cml4RmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShDb2xvck1hdHJpeEZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVG91Y2guanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuICogR2xvYmFsIHV0aWxpdHkgZm9yIHdvcmtpbmcgd2l0aCBtdWx0aS10b3VjaCBlbmFibGVkIGRldmljZXMgaW4gRWFzZWxKUy4gQ3VycmVudGx5IHN1cHBvcnRzIFczQyBUb3VjaCBBUEkgKGlPUyBhbmRcbiAqIG1vZGVybiBBbmRyb2lkIGJyb3dzZXIpIGFuZCB0aGUgUG9pbnRlciBBUEkgKElFKSwgaW5jbHVkaW5nIG1zLXByZWZpeGVkIGV2ZW50cyBpbiBJRTEwLCBhbmQgdW5wcmVmaXhlZCBpbiBJRTExLlxuICpcbiAqIEVuc3VyZSB0aGF0IHlvdSB7eyNjcm9zc0xpbmsgXCJUb3VjaC9kaXNhYmxlXCJ9fXt7L2Nyb3NzTGlua319IHRvdWNoIHdoZW4gY2xlYW5pbmcgdXAgeW91ciBhcHBsaWNhdGlvbi4gWW91IGRvIG5vdCBoYXZlXG4gKiB0byBjaGVjayBpZiB0b3VjaCBpcyBzdXBwb3J0ZWQgdG8gZW5hYmxlIGl0LCBhcyBpdCB3aWxsIGZhaWwgZ3JhY2VmdWxseSBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0lkXCIpO1xuICogICAgICBjcmVhdGVqcy5Ub3VjaC5lbmFibGUoc3RhZ2UpO1xuICpcbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSXQgaXMgaW1wb3J0YW50IHRvIGRpc2FibGUgVG91Y2ggb24gYSBzdGFnZSB0aGF0IHlvdSBhcmUgbm8gbG9uZ2VyIHVzaW5nOlxuICpcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZGlzYWJsZShzdGFnZSk7XG4gKlxuICogQGNsYXNzIFRvdWNoXG4gKiBAc3RhdGljXG4gKiovXG5cdGZ1bmN0aW9uIFRvdWNoKCkge1xuXHRcdHRocm93IFwiVG91Y2ggY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVyblx0ISEoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgLy8gaU9TICYgQW5kcm9pZFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtc01heFRvdWNoUG9pbnRzJ10gPiAwKSAvLyBJRTEwXG5cdFx0XHR8fCAod2luZG93Lm5hdmlnYXRvclsncG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtYXhUb3VjaFBvaW50cyddID4gMCkpOyAvLyBJRTExK1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRvdWNoIGludGVyYWN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0uIEN1cnJlbnRseSBzdXBwb3J0cyBpT1Ncblx0ICogKGFuZCBjb21wYXRpYmxlIGJyb3dzZXJzLCBzdWNoIGFzIG1vZGVybiBBbmRyb2lkIGJyb3dzZXJzKSwgYW5kIElFMTAvMTEuIFN1cHBvcnRzIGJvdGggc2luZ2xlIHRvdWNoIGFuZFxuXHQgKiBtdWx0aS10b3VjaCBtb2Rlcy4gRXh0ZW5kcyB0aGUgRWFzZWxKUyB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG1vZGVsLCBidXQgd2l0aG91dCBzdXBwb3J0IGZvclxuXHQgKiBkb3VibGUgY2xpY2sgb3Igb3Zlci9vdXQgZXZlbnRzLiBTZWUgdGhlIE1vdXNlRXZlbnQge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudC9wb2ludGVySWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgZW5hYmxlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSB0byBlbmFibGUgdG91Y2ggb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZVRvdWNoPWZhbHNlXSBJZiBgdHJ1ZWAsIG9ubHkgYSBzaW5nbGUgdG91Y2ggd2lsbCBiZSBhY3RpdmUgYXQgYSB0aW1lLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd0RlZmF1bHQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiBkZWZhdWx0IGdlc3R1cmUgYWN0aW9ucyAoZXguIHNjcm9sbGluZywgem9vbWluZykgd2lsbCBiZVxuXHQgKiBhbGxvd2VkIHdoZW4gdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdGFyZ2V0IGNhbnZhcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggd2FzIHN1Y2Nlc3NmdWxseSBlbmFibGVkIG9uIHRoZSB0YXJnZXQgc3RhZ2UuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5lbmFibGUgPSBmdW5jdGlvbihzdGFnZSwgc2luZ2xlVG91Y2gsIGFsbG93RGVmYXVsdCkge1xuXHRcdGlmICghc3RhZ2UgfHwgIXN0YWdlLmNhbnZhcyB8fCAhVG91Y2guaXNTdXBwb3J0ZWQoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gaW5qZWN0IHJlcXVpcmVkIHByb3BlcnRpZXMgb24gc3RhZ2U6XG5cdFx0c3RhZ2UuX190b3VjaCA9IHtwb2ludGVyczp7fSwgbXVsdGl0b3VjaDohc2luZ2xlVG91Y2gsIHByZXZlbnREZWZhdWx0OiFhbGxvd0RlZmF1bHQsIGNvdW50OjB9O1xuXG5cdFx0Ly8gbm90ZSB0aGF0IGluIHRoZSBmdXR1cmUgd2UgbWF5IG5lZWQgdG8gZGlzYWJsZSB0aGUgc3RhbmRhcmQgbW91c2UgZXZlbnQgbW9kZWwgYmVmb3JlIGFkZGluZ1xuXHRcdC8vIHRoZXNlIHRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxzLiBJdCBkb2Vzbid0IHNlZW0gdG8gYmUgYW4gaXNzdWUgd2l0aCBpT1MgZGV2aWNlcyB0aG91Z2guXG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2VuYWJsZShzdGFnZSk7IH1cblx0XHRlbHNlIGlmICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gfHwgd2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdKSB7IFRvdWNoLl9JRV9lbmFibGUoc3RhZ2UpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0aGF0IHdlcmUgc2V0IHVwIHdoZW4gY2FsbGluZyBgVG91Y2guZW5hYmxlKClgIG9uIGEgc3RhZ2UuXG5cdCAqIEBtZXRob2QgZGlzYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZGlzYWJsZSB0b3VjaCBvbi5cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLmRpc2FibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZGlzYWJsZShzdGFnZSk7IH1cblx0XHRcblx0XHRkZWxldGUgc3RhZ2UuX190b3VjaDtcblx0fTtcblxuXG4vLyBQcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lPU19oYW5kbGVFdmVudChzdGFnZSxlKTsgfTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2Rpc2FibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdGlmICghY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JT1NfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQmJmUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcblx0XHRmb3IgKHZhciBpPSAwLGw9dG91Y2hlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0dmFyIGlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0XHRcdGlmICh0b3VjaC50YXJnZXQgIT0gc3RhZ2UuY2FudmFzKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmICh0eXBlID09IFwidG91Y2hzdGFydFwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZVN0YXJ0KHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNobW92ZVwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZU1vdmUoc3RhZ2UsIGlkLCBlLCB0b3VjaC5wYWdlWCwgdG91Y2gucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwidG91Y2hlbmRcIiB8fCB0eXBlID09IFwidG91Y2hjYW5jZWxcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVFbmQoc3RhZ2UsIGlkLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mID0gZnVuY3Rpb24oZSkgeyBUb3VjaC5fSUVfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlck1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJVcFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBjYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7IH1cblxuXHRcdH1cblx0XHRzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcyA9IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuY2FudmFzKSB7XG5cdFx0XHRcdHN0YWdlLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0dmFyIGlkID0gZS5wb2ludGVySWQ7XG5cdFx0dmFyIGlkcyA9IHN0YWdlLl9fdG91Y2guYWN0aXZlSURzO1xuXG5cdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJEb3duXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJkb3duXCIpIHtcblx0XHRcdGlmIChlLnNyY0VsZW1lbnQgIT0gc3RhZ2UuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdH0gZWxzZSBpZiAoaWRzW2lkXSkgeyAvLyBpdCdzIGFuIGlkIHdlJ3JlIHdhdGNoaW5nXG5cdFx0XHRpZiAodHlwZSA9PSBcIk1TUG9pbnRlck1vdmVcIiB8fCB0eXBlID09IFwicG9pbnRlcm1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJVcFwiIHx8IHR5cGUgPT0gXCJNU1BvaW50ZXJDYW5jZWxcIlxuXHRcdFx0XHRcdHx8IHR5cGUgPT0gXCJwb2ludGVydXBcIiB8fCB0eXBlID09IFwicG9pbnRlcmNhbmNlbFwiKSB7XG5cdFx0XHRcdGRlbGV0ZShpZHNbaWRdKTtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFydFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUsIHgsIHkpIHtcblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdGlmICghcHJvcHMubXVsdGl0b3VjaCAmJiBwcm9wcy5jb3VudCkgeyByZXR1cm47IH1cblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKGlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0cHJvcHMuY291bnQrKztcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlckRvd24oaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3ZlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVNb3ZlID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0aWYgKCFzdGFnZS5fX3RvdWNoLnBvaW50ZXJzW2lkXSkgeyByZXR1cm47IH1cblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlck1vdmUoaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFbmRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSkge1xuXHRcdC8vIFRPRE86IGNhbmNlbCBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmb3IgcHJvcGVyIFVJIChleC4gYW4gdXAgd291bGQgdHJpZ2dlciBhIGNsaWNrLCBhIGNhbmNlbCB3b3VsZCBtb3JlIGNsb3NlbHkgcmVzZW1ibGUgYW4gb3V0KS5cblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdHZhciBpZHMgPSBwcm9wcy5wb2ludGVycztcblx0XHRpZiAoIWlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0cHJvcHMuY291bnQtLTtcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCB0cnVlKTtcblx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Ub3VjaCA9IFRvdWNoO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mXG5cdCAqIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgRWFzZWxKU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuRWFzZWxKUyA9IGNyZWF0ZWpzLkVhc2VsSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC44LjJcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyNiBOb3YgMjAxNSAyMDo0NDozNCBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgUHJlbG9hZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzEgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb3h5LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFcnJvckV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHRoYXQgZGVzY3JpYmVzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQsIGFzIHdlbGwgYXMgYW55IGRldGFpbHMuXG5cdCAqIEBjbGFzcyBFcnJvckV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIFRoZSBlcnJvciB0aXRsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBlcnJvciBkZXNjcmlwdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwiZXJyb3JcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aXRsZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRXJyb3JFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQodGhpcy50aXRsZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm9ncmVzc0V2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKHNjb3BlKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIENyZWF0ZUpTIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZGlzcGF0Y2hlZCB3aGVuIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBjbGFzcyBQcm9ncmVzc0V2ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2FkZWQgVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZC4gVGhpcyBjYW4gYmUgYW55IG51bWJlciByZWxhdGl2ZSB0byB0aGUgdG90YWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdG90YWw9MV0gVGhlIHRvdGFsIGFtb3VudCB0aGF0IHdpbGwgbG9hZC4gVGhpcyB3aWxsIGRlZmF1bHQgdG8gMSwgc28gaWYgdGhlIGBsb2FkZWRgIHZhbHVlIGlzXG5cdCAqIGEgcGVyY2VudGFnZSAoYmV0d2VlbiAwIGFuZCAxKSwgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdCAqIEB0b2RvIENvbnNpZGVyIGhhdmluZyB0aGlzIGV2ZW50IGJlIGEgXCJmaWxlcHJvZ3Jlc3NcIiBldmVudCBhcyB3ZWxsXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudChsb2FkZWQsIHRvdGFsKSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3RvcihcInByb2dyZXNzXCIpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZCAob3V0IG9mIGEgdG90YWwgYW1vdW50KVxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gbG9hZGVkO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvdGFsIFwic2l6ZVwiIG9mIHRoZSBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0b3RhbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudG90YWwgPSAodG90YWwgPT0gbnVsbCkgPyAxIDogdG90YWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGVyY2VudGFnZSAob3V0IG9mIDEpIHRoYXQgdGhlIGxvYWQgaGFzIGJlZW4gY29tcGxldGVkLiBUaGlzIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYGxvYWRlZC90b3RhbGAuXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9ICh0b3RhbCA9PSAwKSA/IDAgOiB0aGlzLmxvYWRlZCAvIHRoaXMudG90YWw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoUHJvZ3Jlc3NFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFByb2dyZXNzRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UHJvZ3Jlc3NFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLmxvYWRlZCwgdGhpcy50b3RhbCk7XG5cdH07XG5cblx0Y3JlYXRlanMuUHJvZ3Jlc3NFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoUHJvZ3Jlc3NFdmVudCwgXCJFdmVudFwiKTtcblxufSh3aW5kb3cpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGpzb24zLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEb21VdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQSBmZXcgdXRpbGl0aWVzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBkb20uXG5cdCAqIEBjbGFzcyBEb21VdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHRzLmFwcGVuZFRvSGVhZCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHMuZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGVsKVxuXHR9XG5cblx0cy5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fVxuXG5cdHMuZ2V0Qm9keSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG5cdH1cblxuXHRjcmVhdGVqcy5Eb21VdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEYXRhVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IGRhdGEgdXRpbGl0aWVzIGZvciBmb3JtYXR0aW5nIGRpZmZlcmVudCBkYXRhIHR5cGVzLlxuXHQgKiBAY2xhc3MgRGF0YVV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBQYXJzZSBYTUwgdXNpbmcgdGhlIERPTS4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHByZWxvYWRpbmcgWE1MIG9yIFNWRy5cblx0ICogQG1ldGhvZCBwYXJzZVhNTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgcmF3IHRleHQgb3IgWE1MIHRoYXQgaXMgbG9hZGVkIGJ5IFhIUi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG1pbWUgdHlwZSBvZiB0aGUgWE1MLiBVc2UgXCJ0ZXh0L3htbFwiIGZvciBYTUwsIGFuZCAgXCJpbWFnZS9zdmcreG1sXCIgZm9yIFNWRyBwYXJzaW5nLlxuXHQgKiBAcmV0dXJuIHtYTUx9IEFuIFhNTCBkb2N1bWVudFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlWE1MID0gZnVuY3Rpb24gKHRleHQsIHR5cGUpIHtcblx0XHR2YXIgeG1sID0gbnVsbDtcblx0XHQvLyBDb2Nvb25KUyBkb2VzIG5vdCBzdXBwb3J0IFhNTCBwYXJzaW5nIHdpdGggZWl0aGVyIG1ldGhvZC5cblxuXHRcdC8vIE1vc3QgYnJvd3NlcnMgd2lsbCB1c2UgRE9NUGFyc2VyXG5cdFx0Ly8gSUUgZmFpbHMgb24gY2VydGFpbiBTVkcgZmlsZXMsIHNvIHdlIGhhdmUgYSBmYWxsYmFjayBiZWxvdy5cblx0XHR0cnkge1xuXHRcdFx0aWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcblx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0eG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCB0eXBlKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgZm9yIElFIHN1cHBvcnQuXG5cdFx0aWYgKCF4bWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gZmFsc2U7XG5cdFx0XHRcdHhtbC5sb2FkWE1MKHRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR4bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB4bWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgc3RyaW5nIGludG8gYW4gT2JqZWN0LlxuXHQgKiBAbWV0aG9kIHBhcnNlSlNPTlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGxvYWRlZCBKU09OIHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEphdmFTY3JpcHQgb2JqZWN0LlxuXHQgKi9cblx0cy5wYXJzZUpTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBUT0RPOyBIYW5kbGUgdGhpcyB3aXRoIGEgY3VzdG9tIGVycm9yP1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuRGF0YVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRJdGVtLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQWxsIGxvYWRlcnMgYWNjZXB0IGFuIGl0ZW0gY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXMgY2xhc3MuIElmIGEgcmF3IG9iamVjdCBpcyBwYXNzZWQgaW5zdGVhZCxcblx0ICogaXQgd2lsbCBub3QgYmUgYWZmZWN0ZWQsIGJ1dCBpdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuIEFcblx0ICogc3RyaW5nIHBhdGggb3IgSFRNTCB0YWcgaXMgYWxzbyBhY2NlcHRhYmxlLCBidXQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHVzaW5nIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJjcmVhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGJ5IHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBjbGFzcyBMb2FkSXRlbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRmdW5jdGlvbiBMb2FkSXRlbSgpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgc291cmNlIG9mIHRoZSBmaWxlIHRoYXQgaXMgYmVpbmcgbG9hZGVkLiBUaGlzIHByb3BlcnR5IGlzIDxiPnJlcXVpcmVkPC9iPi4gVGhlIHNvdXJjZSBjYW4gZWl0aGVyIGJlIGFcblx0XHQgKiBzdHJpbmcgKHJlY29tbWVuZGVkKSwgb3IgYW4gSFRNTCB0YWcuXG5cdFx0ICogVGhpcyBjYW4gYWxzbyBiZSBhbiBvYmplY3QsIGJ1dCBpbiB0aGF0IGNhc2UgaXQgaGFzIHRvIGluY2x1ZGUgYSB0eXBlIGFuZCBiZSBoYW5kbGVkIGJ5IGEgcGx1Z2luLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcmNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNyYyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBmaWxlIHRoYXQgaXMgYmVpbmcgbG9hZGVkLiBUaGUgdHlwZSBvZiB0aGUgZmlsZSBpcyB1c3VhbGx5IGluZmVycmVkIGJ5IHRoZSBleHRlbnNpb24sIGJ1dCBjYW4gYWxzb1xuXHRcdCAqIGJlIHNldCBtYW51YWxseS4gVGhpcyBpcyBoZWxwZnVsIGluIGNhc2VzIHdoZXJlIGEgZmlsZSBkb2VzIG5vdCBoYXZlIGFuIGV4dGVuc2lvbi5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyBpZGVudGlmaWVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgbG9hZGVkIG9iamVjdC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhpcyB3aWxsIGJlXG5cdFx0ICogYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgaWRcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmlkID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgYSBtYW5pZmVzdCB3aWxsIG1haW50YWluIHRoZSBvcmRlciBvZiB0aGlzIGl0ZW0sIGluIHJlbGF0aW9uIHRvIG90aGVyIGl0ZW1zIGluIHRoZSBtYW5pZmVzdFxuXHRcdCAqIHRoYXQgaGF2ZSBhbHNvIHNldCB0aGUgYG1haW50YWluT3JkZXJgIHByb3BlcnR5IHRvIGB0cnVlYC4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlbiB0aGUgbWF4IGNvbm5lY3Rpb25zIGhhc1xuXHRcdCAqIGJlZW4gc2V0IGFib3ZlIDEgKHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSkuIEV2ZXJ5dGhpbmcgd2l0aCB0aGlzXG5cdFx0ICogcHJvcGVydHkgc2V0IHRvIGBmYWxzZWAgd2lsbCBmaW5pc2ggYXMgaXQgaXMgbG9hZGVkLiBPcmRlcmVkIGl0ZW1zIGFyZSBjb21iaW5lZCB3aXRoIHNjcmlwdCB0YWdzIGxvYWRpbmcgaW5cblx0XHQgKiBvcmRlciB3aGVuIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBgdHJ1ZWAuXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluT3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubWFpbnRhaW5PcmRlciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBjYWxsYmFjayB1c2VkIGJ5IEpTT05QIHJlcXVlc3RzIHRoYXQgZGVmaW5lcyB3aGF0IGdsb2JhbCBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSBKU09OUCBjb250ZW50IGlzIGxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgY2FsbGJhY2tcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNhbGxiYWNrID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCwgd2hpY2ggaXMgaW5jbHVkZWQgd2l0aCB0aGUgbG9hZGVkIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgZGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVxdWVzdCBtZXRob2QgdXNlZCBmb3IgSFRUUCBjYWxscy4gQm90aCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9QT1NUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHJlcXVlc3QgdHlwZXMgYXJlIHN1cHBvcnRlZCwgYW5kIGFyZSBkZWZpbmVkIGFzXG5cdFx0ICogY29uc3RhbnRzIG9uIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBtZXRob2Rcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IGdldFxuXHRcdCAqL1xuXHRcdHRoaXMubWV0aG9kID0gY3JlYXRlanMuTG9hZEl0ZW0uR0VUO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG5cdFx0ICogQHByb3BlcnR5IHZhbHVlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudmFsdWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGhlYWRlcnMgdG8gYXR0YWNoIHRvIGFuIFhIUiByZXF1ZXN0LiBQcmVsb2FkSlMgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGFjaCBzb21lIGRlZmF1bHRcblx0XHQgKiBoZWFkZXJzIHdoZW4gcmVxdWlyZWQsIGluY2x1ZGluZyBcIk9yaWdpblwiLCBcIkNvbnRlbnQtVHlwZVwiLCBhbmQgXCJYLVJlcXVlc3RlZC1XaXRoXCIuIFlvdSBtYXkgb3ZlcnJpZGUgdGhlXG5cdFx0ICogZGVmYXVsdCBoZWFkZXJzIGJ5IGluY2x1ZGluZyB0aGVtIGluIHlvdXIgaGVhZGVycyBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGhlYWRlcnNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmhlYWRlcnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIGNyZWRlbnRpYWxzIGZvciBYSFIgcmVxdWVzdHMuXG5cdFx0ICogQHByb3BlcnR5IHdpdGhDcmVkZW50aWFsc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgbWltZSB0eXBlIG9mIFhIUi1iYXNlZCByZXF1ZXN0cy4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIiBmb3IgdGV4dFxuXHRcdCAqIGJhc2VkIGZpbGVzIChqc29uLCB4bWwsIHRleHQsIGNzcywganMpLlxuXHRcdCAqIEBwcm9wZXJ0eSBtaW1lVHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubWltZVR5cGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIGZvciBDT1JTLWVuYWJsZWQgaW1hZ2VzIGxvYWRpbmcgY3Jvc3MtZG9tYWluLlxuXHRcdCAqIEBwcm9wZXJ0eSBjcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IEFub255bW91c1xuXHRcdCAqL1xuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhIHJlcXVlc3QgdGltZXMgb3V0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0YWctYmFzZWQgYW5kIGFuZCBYSFJcblx0XHQgKiAobGV2ZWwgb25lKSBsb2FkaW5nLCBhcyBYSFIgKGxldmVsIDIpIHByb3ZpZGVzIGl0cyBvd24gdGltZW91dCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgbG9hZFRpbWVvdXRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDgwMDAgKDggc2Vjb25kcylcblx0XHQgKi9cblx0XHR0aGlzLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcblx0fTtcblxuXHR2YXIgcCA9IExvYWRJdGVtLnByb3RvdHlwZSA9IHt9O1xuXHR2YXIgcyA9IExvYWRJdGVtO1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhIHJlcXVlc3QgdGltZXMgb3V0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0YWctYmFzZWQgYW5kIGFuZCBYSFJcblx0ICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG5cdCAqIEBwcm9wZXJ0eSBMT0FEX1RJTUVPVVRfREVGQVVMVFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkxPQURfVElNRU9VVF9ERUZBVUxUID0gODAwMDtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgTG9hZEl0ZW0uXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5TdHJpbmctYmFzZWQgaXRlbXMgYXJlIGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHdpdGggYSBwb3B1bGF0ZWQge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LjwvbGk+XG5cdCAqICAgICA8bGk+TG9hZEl0ZW0gaW5zdGFuY2VzIGFyZSByZXR1cm5lZCBhcy1pczwvbGk+XG5cdCAqICAgICA8bGk+T2JqZWN0cyBhcmUgcmV0dXJuZWQgd2l0aCBhbnkgbmVlZGVkIHByb3BlcnRpZXMgYWRkZWQ8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfFN0cmluZ3xPYmplY3R9IHZhbHVlIFRoZSBsb2FkIGl0ZW0gdmFsdWVcblx0ICogQHJldHVybnMge0xvYWRJdGVtfE9iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBpdGVtID0gbmV3IExvYWRJdGVtKCk7XG5cdFx0XHRpdGVtLnNyYyA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHMpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHZhbHVlLnNyYykge1xuXHRcdFx0aWYgKHZhbHVlLmxvYWRUaW1lb3V0ID09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUubG9hZFRpbWVvdXQgPSBzLkxPQURfVElNRU9VVF9ERUZBVUxUO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG5vdCByZWNvZ25pemVkLlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBsb2FkSXRlbSA9IG5ldyBjcmVhdGVqcy5Mb2FkSXRlbSgpLnNldCh7c3JjOlwiaW1hZ2UucG5nXCIsIG1haW50YWluT3JkZXI6dHJ1ZX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgTG9hZEl0ZW0gaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0xvYWRJdGVtfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkxvYWRJdGVtID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFJlcXVlc3RVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogVXRpbGl0aWVzIHRoYXQgYXNzaXN0IHdpdGggcGFyc2luZyBsb2FkIGl0ZW1zLCBhbmQgZGV0ZXJtaW5pbmcgZmlsZSB0eXBlcywgZXRjLlxuXHQgKiBAY2xhc3MgUmVxdWVzdFV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGFuIGFic29sdXRlIHBhdGguXG5cdCAqIEBwcm9wZXJ0eSBBQlNPTFVURV9QQVRIXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuQUJTT0xVVEVfUEFUVCA9IC9eKD86XFx3KzopP1xcL3syfS9pO1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGEgcmVsYXRpdmUgcGF0aC5cblx0ICogQHByb3BlcnR5IFJFTEFUSVZFX1BBVEhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5SRUxBVElWRV9QQVRUID0gKC9eWy4vXSo/XFwvL2kpO1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGFuIGV4dGVuc2lvbi4gTm90ZSB0aGF0IFVSSXMgbXVzdCBhbHJlYWR5IGhhdmUgdGhlIHF1ZXJ5IHN0cmluZ1xuXHQgKiByZW1vdmVkLlxuXHQgKiBAcHJvcGVydHkgRVhURU5TSU9OX1BBVFRcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5FWFRFTlNJT05fUEFUVCA9IC9cXC8/W14vXStcXC4oXFx3ezEsNX0pJC9pO1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIGZpbGUgcGF0aCB0byBkZXRlcm1pbmUgdGhlIGluZm9ybWF0aW9uIHdlIG5lZWQgdG8gd29yayB3aXRoIGl0LiBDdXJyZW50bHksIFByZWxvYWRKUyBuZWVkcyB0byBrbm93OlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIEFic29sdXRlIHBhdGhzIHN0YXJ0IHdpdGggYSBwcm90b2NvbCAoc3VjaCBhcyBgaHR0cDovL2AsIGBmaWxlOi8vYCwgb3Jcblx0ICogICAgIGAvL25ldHdvcmtQYXRoYCk8L2xpPlxuXHQgKiAgICAgPGxpPklmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLiBSZWxhdGl2ZSBwYXRocyBzdGFydCB3aXRoIGAuLi9gIG9yIGAvcGF0aGAgKG9yIHNpbWlsYXIpPC9saT5cblx0ICogICAgIDxsaT5UaGUgZmlsZSBleHRlbnNpb24uIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlsZW5hbWUgd2l0aCBhbiBleHRlbnNpb24uIFF1ZXJ5IHN0cmluZ3MgYXJlIGRyb3BwZWQsIGFuZFxuXHQgKiAgICAgdGhlIGZpbGUgcGF0aCBpcyBleHBlY3RlZCB0byBmb2xsb3cgdGhlIGZvcm1hdCBgbmFtZS5leHRgLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgcGFyc2VVUklcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcblx0ICogQHJldHVybnMge09iamVjdH0gQW4gT2JqZWN0IHdpdGggYW4gYGFic29sdXRlYCBhbmQgYHJlbGF0aXZlYCBCb29sZWFuIHZhbHVlcywgYXMgd2VsbCBhcyBhbiBvcHRpb25hbCAnZXh0ZW5zaW9uYFxuXHQgKiBwcm9wZXJ0eSwgd2hpY2ggaXMgdGhlIGxvd2VyY2FzZSBleHRlbnNpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucGFyc2VVUkkgPSBmdW5jdGlvbiAocGF0aCkge1xuXHRcdHZhciBpbmZvID0ge2Fic29sdXRlOiBmYWxzZSwgcmVsYXRpdmU6IGZhbHNlfTtcblx0XHRpZiAocGF0aCA9PSBudWxsKSB7IHJldHVybiBpbmZvOyB9XG5cblx0XHQvLyBEcm9wIHRoZSBxdWVyeSBzdHJpbmdcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0cGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5SW5kZXgpO1xuXHRcdH1cblxuXHRcdC8vIEFic29sdXRlXG5cdFx0dmFyIG1hdGNoO1xuXHRcdGlmIChzLkFCU09MVVRFX1BBVFQudGVzdChwYXRoKSkge1xuXHRcdFx0aW5mby5hYnNvbHV0ZSA9IHRydWU7XG5cblx0XHRcdC8vIFJlbGF0aXZlXG5cdFx0fSBlbHNlIGlmIChzLlJFTEFUSVZFX1BBVFQudGVzdChwYXRoKSkge1xuXHRcdFx0aW5mby5yZWxhdGl2ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRXh0ZW5zaW9uXG5cdFx0aWYgKG1hdGNoID0gcGF0aC5tYXRjaChzLkVYVEVOU0lPTl9QQVRUKSkge1xuXHRcdFx0aW5mby5leHRlbnNpb24gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5mbztcblx0fTtcblxuXHQvKipcblx0ICogRm9ybWF0cyBhbiBvYmplY3QgaW50byBhIHF1ZXJ5IHN0cmluZyBmb3IgZWl0aGVyIGEgUE9TVCBvciBHRVQgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBmb3JtYXRRdWVyeVN0cmluZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0IHRvIGEgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcXVlcnldIEV4aXN0aW5nIG5hbWUvdmFsdWUgcGFpcnMgdG8gYXBwZW5kIG9uIHRvIHRoaXMgcXVlcnkuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZm9ybWF0UXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgcXVlcnkpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgZGF0YS4nKTtcblx0XHR9XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gZGF0YSkge1xuXHRcdFx0cGFyYW1zLnB1c2gobiArICc9JyArIGVzY2FwZShkYXRhW25dKSk7XG5cdFx0fVxuXHRcdGlmIChxdWVyeSkge1xuXHRcdFx0cGFyYW1zID0gcGFyYW1zLmNvbmNhdChxdWVyeSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbXMuam9pbignJicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIHV0aWxpdHkgbWV0aG9kIHRoYXQgYnVpbGRzIGEgZmlsZSBwYXRoIHVzaW5nIGEgc291cmNlIGFuZCBhIGRhdGEgb2JqZWN0LCBhbmQgZm9ybWF0cyBpdCBpbnRvIGEgbmV3IHBhdGguXG5cdCAqIEBtZXRob2QgYnVpbGRQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBwYXRoIHRvIGFkZCB2YWx1ZXMgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gT2JqZWN0IHVzZWQgdG8gYXBwZW5kIHZhbHVlcyB0byB0aGlzIHJlcXVlc3QgYXMgYSBxdWVyeSBzdHJpbmcuIEV4aXN0aW5nIHBhcmFtZXRlcnMgb24gdGhlXG5cdCAqIHBhdGggd2lsbCBiZSBwcmVzZXJ2ZWQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBwYXRoIGFuZCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVycy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAoc3JjLCBkYXRhKSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR9XG5cblx0XHR2YXIgcXVlcnkgPSBbXTtcblx0XHR2YXIgaWR4ID0gc3JjLmluZGV4T2YoJz8nKTtcblxuXHRcdGlmIChpZHggIT0gLTEpIHtcblx0XHRcdHZhciBxID0gc3JjLnNsaWNlKGlkeCArIDEpO1xuXHRcdFx0cXVlcnkgPSBxdWVyeS5jb25jYXQocS5zcGxpdCgnJicpKTtcblx0XHR9XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKDAsIGlkeCkgKyAnPycgKyB0aGlzLmZvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHNyYyArICc/JyArIHRoaXMuZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0Nyb3NzRG9tYWluXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWQgaXRlbSBpcyBsb2FkaW5nIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgbG9jYXRpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNDcm9zc0RvbWFpbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cblx0XHR2YXIgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdGhvc3QuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSAodGFyZ2V0Lmhvc3RuYW1lICE9IFwiXCIpICYmXG5cdFx0XHRcdFx0XHQgICh0YXJnZXQucG9ydCAhPSBob3N0LnBvcnQgfHxcblx0XHRcdFx0XHRcdCAgIHRhcmdldC5wcm90b2NvbCAhPSBob3N0LnByb3RvY29sIHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQuaG9zdG5hbWUgIT0gaG9zdC5ob3N0bmFtZSk7XG5cdFx0cmV0dXJuIGNyb3NzZG9tYWluO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGlzTG9jYWxcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIHRoZSBcImZpbGU6XCIgcHJvdG9jb2wuIEFzc3VtZSB0aGF0IHRoZSBob3N0IG11c3QgYmUgbG9jYWwgYXNcblx0ICogd2VsbC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0xvY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0dGFyZ2V0LmhyZWYgPSBpdGVtLnNyYztcblx0XHRyZXR1cm4gdGFyZ2V0Lmhvc3RuYW1lID09IFwiXCIgJiYgdGFyZ2V0LnByb3RvY29sID09IFwiZmlsZTpcIjtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBzaG91bGQgYmUgbG9hZGVkIGFzIGEgYmluYXJ5IGZpbGUuIEN1cnJlbnRseSwgb25seSBpbWFnZXMgYW5kIGl0ZW1zIG1hcmtlZFxuXHQgKiBzcGVjaWZpY2FsbHkgYXMgXCJiaW5hcnlcIiBhcmUgbG9hZGVkIGFzIGJpbmFyeS4gTm90ZSB0aGF0IGF1ZGlvIGlzIDxiPm5vdDwvYj4gYSBiaW5hcnkgdHlwZSwgYXMgd2UgY2FuIG5vdCBwbGF5XG5cdCAqIGJhY2sgdXNpbmcgYW4gYXVkaW8gdGFnIGlmIGl0IGlzIGxvYWRlZCBhcyBiaW5hcnkuIFBsdWdpbnMgY2FuIGNoYW5nZSB0aGUgaXRlbSB0eXBlIHRvIGJpbmFyeSB0byBlbnN1cmUgdGhleSBnZXRcblx0ICogYSBiaW5hcnkgcmVzdWx0IHRvIHdvcmsgd2l0aC4gQmluYXJ5IGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgWEhSMi4gVHlwZXMgYXJlIGRlZmluZWQgYXMgc3RhdGljIGNvbnN0YW50cyBvblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpc0JpbmFyeVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmluYXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQmluYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEltYWdlRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzSW1hZ2VUYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNJbWFnZVRhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MQXVkaW9FbGVtZW50XG5cdCAqIEBtZXRob2QgaXNBdWRpb1RhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0F1ZGlvVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh3aW5kb3cuSFRNTEF1ZGlvRWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTFZpZGVvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzVmlkZW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNWaWRlb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBpcyBhIHRleHQtYmFzZWQgYXNzZXQsIGFuZCBzaG91bGQgYmUgbG9hZGVkIGFzIFVURi04LlxuXHQgKiBAbWV0aG9kIGlzVGV4dFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgdGV4dC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1RleHQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRzpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgdXNpbmcgY29tbW9uIGV4dGVuc2lvbnMuIE5vdGUgdGhhdCB0aGUgdHlwZSBjYW4gYmUgcGFzc2VkIGluIHdpdGggdGhlIGxvYWQgaXRlbVxuXHQgKiBpZiBpdCBpcyBhbiB1bnVzdWFsIGV4dGVuc2lvbi5cblx0ICogQG1ldGhvZCBnZXRUeXBlQnlFeHRlbnNpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiBUaGUgZmlsZSBleHRlbnNpb24gdG8gdXNlIHRvIGRldGVybWluZSB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBkZXRlcm1pbmVkIGxvYWQgdHlwZSAoZm9yIGV4YW1wbGUsIDxjb2RlPkFic3RyYWN0TG9hZGVyLklNQUdFPC9jb2RlPikuIFdpbGwgcmV0dXJuIGBudWxsYCBpZlxuXHQgKiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQgYnkgdGhlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXRUeXBlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0aWYgKGV4dGVuc2lvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlIFwianBlZ1wiOlxuXHRcdFx0Y2FzZSBcImpwZ1wiOlxuXHRcdFx0Y2FzZSBcImdpZlwiOlxuXHRcdFx0Y2FzZSBcInBuZ1wiOlxuXHRcdFx0Y2FzZSBcIndlYnBcIjpcblx0XHRcdGNhc2UgXCJibXBcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHRcdFx0Y2FzZSBcIm9nZ1wiOlxuXHRcdFx0Y2FzZSBcIm1wM1wiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHRcdFx0Y2FzZSBcIm1wNFwiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdGNhc2UgXCJ0c1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdFx0XHRjYXNlIFwianNvblwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjtcblx0XHRcdGNhc2UgXCJ4bWxcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDtcblx0XHRcdGNhc2UgXCJjc3NcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0XHRcdGNhc2UgXCJqc1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblx0XHRcdGNhc2UgJ3N2Zyc6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuUmVxdWVzdFV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBiYXNlIGxvYWRlciwgd2hpY2ggZGVmaW5lcyBhbGwgdGhlIGdlbmVyaWMgbWV0aG9kcywgcHJvcGVydGllcywgYW5kIGV2ZW50cy4gQWxsIGxvYWRlcnMgZXh0ZW5kIHRoaXMgY2xhc3MsXG5cdCAqIGluY2x1ZGluZyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R8c3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlclhIUl0gRGV0ZXJtaW5lcyBpZiB0aGUgTG9hZEl0ZW0gc2hvdWxkIDxlbT50cnk8L2VtPiBhbmQgbG9hZCB1c2luZyBYSFIsIG9yIHRha2UgYVxuXHQgKiB0YWctYmFzZWQgYXBwcm9hY2gsIHdoaWNoIGNhbiBiZSBiZXR0ZXIgaW4gY3Jvc3MtZG9tYWluIHNpdHVhdGlvbnMuIE5vdCBhbGwgbG9hZGVycyBjYW4gbG9hZCB1c2luZyBvbmUgb3IgdGhlXG5cdCAqIG90aGVyLCBzbyB0aGlzIGlzIGEgc3VnZ2VzdGVkIGRpcmVjdGl2ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgdHlwZSBvZiBsb2FkZXIuIExvYWRlciB0eXBlcyBhcmUgZGVmaW5lZCBhcyBjb25zdGFudHMgb24gdGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzLFxuXHQgKiBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIklNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIGV0Yy5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqL1xuXHRmdW5jdGlvbiBBYnN0cmFjdExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgcHJvdmlkZXMgYSBxdWljayBjaGVjaywgYnV0IGFsc28gZW5zdXJlcyB0aGF0IHRoZSBkaWZmZXJlbnQgYXBwcm9hY2hlc1xuXHRcdCAqIHVzZWQgZm9yIGxvYWRpbmcgZG8gbm90IHBpbGUgdXAgcmVzdWx0aW5nIGluIG1vcmUgdGhhbiBvbmUgYGNvbXBsZXRlYCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lIGlmIHRoZSBsb2FkZXIgd2FzIGNhbmNlbGVkLiBDYW5jZWxlZCBsb2FkcyB3aWxsIG5vdCBmaXJlIGNvbXBsZXRlIGV2ZW50cy4gTm90ZSB0aGF0IHRoaXMgcHJvcGVydHlcblx0XHQgKiBpcyByZWFkb25seSwgc28ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IHF1ZXVlcyBzaG91bGQgYmUgY2xvc2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9jbG9zZVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGluc3RlYWQuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBsb2FkIHByb2dyZXNzIChwZXJjZW50YWdlKSBmb3IgdGhpcyBpdGVtLiBUaGlzIHdpbGwgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHQgKiAgICAgcXVldWUubG9hZEZpbGUoXCJsYXJnZUltYWdlLnBuZ1wiKTtcblx0XHQgKiAgICAgcXVldWUub24oXCJwcm9ncmVzc1wiLCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJvZ3Jlc3M6XCIsIHF1ZXVlLnByb2dyZXNzLCBldmVudC5wcm9ncmVzcyk7XG5cdFx0ICogICAgIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBpdGVtIHRoaXMgbG9hZGVyIHdpbGwgbG9hZC4gU2VlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGZ1bGwgbGlzdCBvZlxuXHRcdCAqIHN1cHBvcnRlZCB0eXBlcy5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgdGhlIGxvYWRlZCByYXcgcmVzdWx0IGludG8gdGhlIGZpbmFsIHJlc3VsdC4gRm9yIGV4YW1wbGUsIHRoZSBKU09OTG9hZGVyXG5cdFx0ICogY29udmVydHMgYSBzdHJpbmcgb2YgdGV4dCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuIE5vdCBhbGwgbG9hZGVycyBoYXZlIGEgcmVzdWx0Rm9ybWF0dGVyLCBhbmQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIHByb3ZpZGUgY3VzdG9tIGZvcm1hdHRpbmcuXG5cdFx0ICpcblx0XHQgKiBPcHRpb25hbGx5LCBhIHJlc3VsdEZvcm1hdHRlciBjYW4gcmV0dXJuIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW4gY2FzZXMgd2hlcmUgdGhlIGZvcm1hdHRpbmcgbmVlZHMgdG8gYmVcblx0XHQgKiBhc3luY2hyb25vdXMsIHN1Y2ggYXMgY3JlYXRpbmcgYSBuZXcgaW1hZ2UuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgMiBwYXJhbWV0ZXJzLCB3aGljaCBhcmUgY2FsbGJhY2tzXG5cdFx0ICogdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGVycm9yIGNvbmRpdGlvbnMgaW4gdGhlIHJlc3VsdEZvcm1hdHRlci4gTm90ZSB0aGF0IHRoZSByZXN1bHRGb3JtYXR0ZXIgbWV0aG9kIGlzXG5cdFx0ICogY2FsbGVkIGluIHRoZSBjdXJyZW50IHNjb3BlLCBhcyB3ZWxsIGFzIHRoZSBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZSBhc3luY2hyb25vdXMgcmVzdWx0Rm9ybWF0dGVyPC9oND5cblx0XHQgKlxuXHRcdCAqIFx0ZnVuY3Rpb24gX2Zvcm1hdFJlc3VsdChsb2FkZXIpIHtcblx0XHQgKiBcdFx0cmV0dXJuIGZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0ICogXHRcdFx0aWYgKGVycm9yQ29uZGl0aW9uKSB7IGVycm9yKGVycm9yRGV0YWlsRXZlbnQpOyB9XG5cdFx0ICogXHRcdFx0c3VjY2VzcyhyZXN1bHQpO1xuXHRcdCAqIFx0XHR9XG5cdFx0ICogXHR9XG5cdFx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gdGhpcyBsb2FkZXIgcmVwcmVzZW50cy4gTm90ZSB0aGF0IHRoaXMgaXMgbnVsbCBpbiBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiBidXQgd2lsbCBiZSBhdmFpbGFibGUgb24gbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIlhNTExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiSW1hZ2VMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9pdGVtXG5cdFx0ICogQHR5cGUge0xvYWRJdGVtfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGlmIChsb2FkSXRlbSkge1xuXHRcdFx0dGhpcy5faXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZShsb2FkSXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIGxvYWRlciB3aWxsIHRyeSBhbmQgbG9hZCBjb250ZW50IHVzaW5nIFhIUiAodHJ1ZSkgb3IgSFRNTCB0YWdzIChmYWxzZSkuXG5cdFx0ICogQHByb3BlcnR5IF9wcmVmZXJYSFJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZWZlclhIUiA9IHByZWZlclhIUjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb2FkZWQgcmVzdWx0IGFmdGVyIGl0IGlzIGZvcm1hdHRlZCBieSBhbiBvcHRpb25hbCB7eyNjcm9zc0xpbmsgXCJyZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0uIEZvclxuXHRcdCAqIGl0ZW1zIHRoYXQgYXJlIG5vdCBmb3JtYXR0ZWQsIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiX3Jhd1Jlc3VsdDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBUaGUgcmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzdWx0XG5cdFx0ICogQHR5cGUge09iamVjdHxTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXN1bHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYmVmb3JlIGl0IGlzIGZvcm1hdHRlZC4gVGhlIHJhd1Jlc3VsdCBpcyBhY2Nlc3NlZCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kLCBhbmQgcGFzc2luZyBgdHJ1ZWAuXG5cdFx0ICogQHByb3BlcnR5IF9yYXdSZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2YgaXRlbXMgdGhhdCBsb2FkZXJzIGxvYWQgYmVoaW5kIHRoZSBzY2VuZXMuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgbWFpbiBpdGVtIHRoZSBsb2FkZXIgaXNcblx0XHQgKiByZXNwb25zaWJsZSBmb3IgbG9hZGluZy4gRXhhbXBsZXMgb2YgbG9hZGVycyB0aGF0IGhhdmUgc3ViLWl0ZW1zIGluY2x1ZGUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhdHRyaWJ1dGUgdGhlIGl0ZW1zIGxvYWRlZCB1c2luZyB0YWdzIHVzZSBmb3IgdGhlIHNvdXJjZS5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBIVE1MIHRhZyAob3Igc2ltaWxhcikgdGhhdCBhIGxvYWRlciBtYXkgdXNlIHRvIGxvYWQgSFRNTCBjb250ZW50LCBzdWNoIGFzIGltYWdlcywgc2NyaXB0cywgZXRjLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZyA9IG51bGw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RMb2FkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cdHZhciBzID0gQWJzdHJhY3RMb2FkZXI7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuXHQvKipcblx0ICogRGVmaW5lcyBhIFBPU1QgcmVxdWVzdCwgdXNlIGZvciBhIG1ldGhvZCB2YWx1ZSB3aGVuIGxvYWRpbmcgZGF0YS5cblx0ICogQHByb3BlcnR5IFBPU1Rcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgcG9zdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBPU1QgPSBcIlBPU1RcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyBhIEdFVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgR0VUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGdldFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkdFVCA9IFwiR0VUXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGdlbmVyaWMgYmluYXJ5IHR5cGVzLiBOb3RlIHRoYXQgaW1hZ2VzIGFyZSBsb2FkZWQgYXMgYmluYXJ5IGZpbGVzIHdoZW4gdXNpbmcgWEhSLlxuXHQgKiBAcHJvcGVydHkgQklOQVJZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGJpbmFyeVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5CSU5BUlkgPSBcImJpbmFyeVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBjc3MgZmlsZXMuIENTUyBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIGEgJmx0O2xpbmsmZ3Q7IHdoZW4gbG9hZGVkIHdpdGggWEhSLCBvciBhXG5cdCAqICZsdDtzdHlsZSZndDsgdGFnIHdoZW4gbG9hZGVkIHdpdGggdGFncy5cblx0ICogQHByb3BlcnR5IENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuQ1NTID0gXCJjc3NcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgaW1hZ2UgZmlsZXMsIHVzdWFsbHkgcG5nLCBnaWYsIG9yIGpwZy9qcGVnLiBJbWFnZXMgYXJlIGxvYWRlZCBpbnRvIGFuICZsdDtpbWFnZSZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSU1BR0UgPSBcImltYWdlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGphdmFzY3JpcHQgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc1wiIGZpbGUgZXh0ZW5zaW9uLiBKYXZhU2NyaXB0IGZpbGVzIGFyZSBsb2FkZWQgaW50byBhXG5cdCAqICZsdDtzY3JpcHQmZ3Q7IHRhZy5cblx0ICpcblx0ICogU2luY2UgdmVyc2lvbiAwLjQuMSssIGR1ZSB0byBob3cgdGFnLWxvYWRlZCBzY3JpcHRzIHdvcmssIGFsbCBKYXZhU2NyaXB0IGZpbGVzIGFyZSBhdXRvbWF0aWNhbGx5IGluamVjdGVkIGludG9cblx0ICogdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHRvIG1haW50YWluIHBhcml0eSBiZXR3ZWVuIFhIUiBhbmQgdGFnLWxvYWRlZCBzY3JpcHRzLiBJbiB2ZXJzaW9uIDAuNC4wIGFuZCBlYXJsaWVyLFxuXHQgKiBvbmx5IHRhZy1sb2FkZWQgc2NyaXB0cyBhcmUgaW5qZWN0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IFwiamF2YXNjcmlwdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBOb3RlIHRoYXQgaWYgYSBgY2FsbGJhY2tgIGlzIHByZXNlbnQgb24gdGhlIGxvYWQgaXRlbSwgdGhlIGZpbGUgd2lsbCBiZSBsb2FkZWQgd2l0aCBKU09OUCxcblx0ICogbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaXMgc2V0IHRvLCBhbmQgdGhlIEpTT05cblx0ICogbXVzdCBjb250YWluIGEgbWF0Y2hpbmcgd3JhcHBlciBmdW5jdGlvbi5cblx0ICogQHByb3BlcnR5IEpTT05cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvblxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KU09OID0gXCJqc29uXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb25wIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG5cdCAqIEphdmFTY3JpcHQgb2JqZWN0LiBZb3UgYXJlIHJlcXVpcmVkIHRvIHBhc3MgYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBtYXRjaGVzIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGluIHRoZSBKU09OLlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgd2lsbCBhbHdheXMgYmUgdXNlZCBpZiB0aGVyZSBpcyBhIGNhbGxiYWNrIHByZXNlbnQsIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IEpTT05QXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25wXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT05QID0gXCJqc29ucFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uLWJhc2VkIG1hbmlmZXN0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBUaGUgSlNPTiBkYXRhIGlzIGxvYWRlZFxuXHQgKiBhbmQgcGFyc2VkIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gUHJlbG9hZEpTIHdpbGwgdGhlbiBsb29rIGZvciBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSBpbiB0aGUgSlNPTiwgd2hpY2ggaXMgYW5cblx0ICogQXJyYXkgb2YgZmlsZXMgdG8gbG9hZCwgZm9sbG93aW5nIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIElmIGEgXCJjYWxsYmFja1wiIGlzIHNwZWNpZmllZCBvbiB0aGUgbWFuaWZlc3Qgb2JqZWN0LCB0aGVuIGl0IHdpbGwgYmUgbG9hZGVkIHVzaW5nIEpTT05QIGluc3RlYWQsXG5cdCAqIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8uXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5NQU5JRkVTVCA9IFwibWFuaWZlc3RcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3Igc291bmQgZmlsZXMsIHVzdWFsbHkgbXAzLCBvZ2csIG9yIHdhdi4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCBhdWRpbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7YXVkaW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNPVU5EID0gXCJzb3VuZFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB2aWRlbyBmaWxlcywgdXN1YWxseSBtcDQsIHRzLCBvciBvZ2cuIFdoZW4gbG9hZGluZyB2aWEgdGFncywgdmlkZW8gaXMgbG9hZGVkIGludG8gYW5cblx0ICogJmx0O3ZpZGVvJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5WSURFTyA9IFwidmlkZW9cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU3ByaXRlU2hlZXQgZmlsZXMuIFNwcml0ZVNoZWV0IGZpbGVzIGFyZSBKU09OIGZpbGVzIHRoYXQgY29udGFpbiBzdHJpbmcgaW1hZ2UgcGF0aHMuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzcHJpdGVzaGVldFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TUFJJVEVTSEVFVCA9IFwic3ByaXRlc2hlZXRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TVkcgPSBcInN2Z1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB0ZXh0IGZpbGVzLCB3aGljaCBpcyBhbHNvIHRoZSBkZWZhdWx0IGZpbGUgdHlwZSBpZiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuIFRleHQgaXNcblx0ICogbG9hZGVkIGFzIHJhdyB0ZXh0LlxuXHQgKiBAcHJvcGVydHkgVEVYVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB0ZXh0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlRFWFQgPSBcInRleHRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgeG1sIGZpbGVzLiBYTUwgaXMgbG9hZGVkIGludG8gYW4gWE1MIGRvY3VtZW50LlxuXHQgKiBAcHJvcGVydHkgWE1MXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHhtbFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5YTUwgPSBcInhtbFwiO1xuXG4vLyBFdmVudHNcblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgb3ZlcmFsbCBwcm9ncmVzcyBjaGFuZ2VzLiBQcmlvciB0b1xuXHQgKiB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhcyBqdXN0IGEgcmVndWxhciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGV2ZW50IHByb2dyZXNzXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWQgc3RhcnRzLlxuXHQgKiBAZXZlbnQgbG9hZHN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuMy4xXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBlbnRpcmUgcXVldWUgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFcnJvckV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gZXJyb3IuIElmIHRoZSBlcnJvciB3YXNcblx0ICogZW5jb3VudGVyZWQgYnkgYSBmaWxlLCB0aGUgZXZlbnQgd2lsbCBjb250YWluIHRoZSBpdGVtIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gUHJpb3IgdG8gdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXNcblx0ICoganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBldmVudCBlcnJvclxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGxvYWRlciBlbmNvdW50ZXJzIGFuIGludGVybmFsIGZpbGUgbG9hZCBlcnJvci5cblx0ICogVGhpcyBlbmFibGVzIGxvYWRlcnMgdG8gbWFpbnRhaW4gaW50ZXJuYWwgcXVldWVzLCBhbmQgc3VyZmFjZSBmaWxlIGxvYWQgZXJyb3JzLlxuXHQgKiBAZXZlbnQgZmlsZWVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbiB0eXBlIChcImZpbGVlcnJvclwiKVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdH0gVGhlIGl0ZW0gdGhhdCBlbmNvdW50ZXJlZCB0aGUgZXJyb3Jcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGludGVybmFsbHkgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXNcblx0ICogbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHRvIG1haW50YWluIGludGVybmFsIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fXNcblx0ICogYW5kIG5vdGlmeSB3aGVuIHRoZXkgaGF2ZSBsb2FkZWQgYSBmaWxlLiBUaGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGRpc3BhdGNoZXMgYVxuXHQgKiBzbGlnaHRseSBkaWZmZXJlbnQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImZpbGVsb2FkXCIpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIEhUTUwgdGFnIG9yIHBhcnNlZCByZXN1bHQgb2YgdGhlIGxvYWRlZCBpdGVtLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3UmVzdWx0IFRoZSB1bnByb2Nlc3NlZCByZXN1bHQsIHVzdWFsbHkgdGhlIHJhdyB0ZXh0IG9yIGJpbmFyeSBkYXRhIGJlZm9yZSBpdCBpcyBjb252ZXJ0ZWRcblx0ICogdG8gYSB1c2FibGUgb2JqZWN0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIGFmdGVyIHRoZSBpbnRlcm5hbCByZXF1ZXN0IGlzIGNyZWF0ZWQsIGJ1dCBiZWZvcmUgYSBsb2FkLlxuXHQgKiBUaGlzIGFsbG93cyB1cGRhdGVzIHRvIHRoZSBsb2FkZXIgZm9yIHNwZWNpZmljIGxvYWRpbmcgbmVlZHMsIHN1Y2ggYXMgYmluYXJ5IG9yIFhIUiBpbWFnZSBsb2FkaW5nLlxuXHQgKiBAZXZlbnQgaW5pdGlhbGl6ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiaW5pdGlhbGl6ZVwiKVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuXHQgKi9cblxuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCBpcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuIEluIHNvbWUgY2FzZXMgdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSB0aGF0IHdhc1xuXHQgKiBwYXNzZWQgaW50byB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEhvd2V2ZXIgaWYgb25seSBhIFN0cmluZyBwYXRoIHdhcyBwYXNzZWQgaW4sIHRoZW4gaXQgd2lsbFxuXHQgKiBiZSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWFuaWZlc3QgaXRlbSB0aGF0IHRoaXMgbG9hZGVyIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0SXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCBieSB0aGUgbG9hZGVyIChvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUge3sjY3Jvc3NMaW5rIFwiY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3PWZhbHNlXSBEZXRlcm1pbmVzIGlmIHRoZSByZXR1cm5lZCByZXN1bHQgd2lsbCBiZSB0aGUgZm9ybWF0dGVkIGNvbnRlbnQsIG9yIHRoZSByYXcgbG9hZGVkXG5cdCAqIGRhdGEgKGlmIGl0IGV4aXN0cykuXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRyZXR1cm4gcmF3ID8gdGhpcy5fcmF3UmVzdWx0IDogdGhpcy5fcmVzdWx0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGB0YWdgIHRoaXMgb2JqZWN0IGNyZWF0ZXMgb3IgdXNlcyBmb3IgbG9hZGluZy5cblx0ICogQG1ldGhvZCBnZXRUYWdcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFnIGluc3RhbmNlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RhZztcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBgdGFnYCB0aGlzIGl0ZW0gdXNlcyBmb3IgbG9hZGluZy5cblx0ICogQG1ldGhvZCBzZXRUYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhZyBUaGUgdGFnIGluc3RhbmNlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRUYWcgPSBmdW5jdGlvbih0YWcpIHtcblx0ICB0aGlzLl90YWcgPSB0YWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgdGhlIGl0ZW0uIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYSBsb2FkZXIgYnkgaXRzZWxmLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChmaWxlQXJyYXksIGZhbHNlKTsgLy8gTm90ZSB0aGUgMm5kIGFyZ3VtZW50IHRoYXQgdGVsbHMgdGhlIHF1ZXVlIG5vdCB0byBzdGFydCBsb2FkaW5nIHlldFxuXHQgKiAgICAgIHF1ZXVlLmxvYWQoKTtcblx0ICpcblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqL1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY3JlYXRlUmVxdWVzdCgpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJwcm9ncmVzc1wiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwibG9hZFN0YXJ0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJhYm9ydFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwidGltZW91dFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgdGhpcywgdGhpcyk7XG5cblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcblx0XHRldnQubG9hZGVyID0gdGhpcy5fcmVxdWVzdDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHRcdHRoaXMuX3JlcXVlc3QubG9hZCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgdGhlIGl0ZW0uIFRoaXMgd2lsbCBzdG9wIGFueSBvcGVuIHJlcXVlc3RzIChhbHRob3VnaCBkb3dubG9hZHMgdXNpbmcgSFRNTCB0YWdzIG1heSBzdGlsbCBjb250aW51ZSBpblxuXHQgKiB0aGUgYmFja2dyb3VuZCksIGJ1dCBldmVudHMgd2lsbCBub3QgbG9uZ2VyIGJlIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgY2FuY2VsXG5cdCAqL1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLmRlc3Ryb3koKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIGxvYWRlci5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cblx0XHR0aGlzLl9pdGVtID0gbnVsbDtcblx0XHR0aGlzLl9yYXdSZXN1bHQgPSBudWxsO1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHR0aGlzLl9sb2FkSXRlbXMgPSBudWxsO1xuXG5cdFx0dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYW55IGl0ZW1zIGxvYWRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsb2FkZXIuIFRoZSBlbmFibGVzIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0byBleHBvc2UgaXRlbXMgaXQgbG9hZHMgaW50ZXJuYWxseS5cblx0ICogQG1ldGhvZCBnZXRMb2FkZWRJdGVtc1xuXHQgKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIHRoZSBpdGVtcyBsb2FkZWQgYnkgdGhlIGxvYWRlci5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldExvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkZWRJdGVtcztcblx0fTtcblxuXG5cdC8vIFByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlIGFuIGludGVybmFsIHJlcXVlc3QgdXNlZCBmb3IgbG9hZGluZy4gQnkgZGVmYXVsdCwgYW4ge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IGlzIGNyZWF0ZWQsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBPdGhlciBsb2FkZXJzIG1heSBvdmVycmlkZSB0aGlzIHRvIHVzZSBkaWZmZXJlbnQgcmVxdWVzdCB0eXBlcywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogd2hpY2ggdXNlcyB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHVuZGVyIHRoZSBob29kLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVSZXF1ZXN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5UYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBIVE1MIHRhZyB1c2VkIGZvciBsb2FkaW5nLiBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgYnkgZGVmYXVsdCwgYW5kIG5lZWRzIHRvIGJlIGltcGxlbWVudGVkXG5cdCAqIGJ5IGxvYWRlcnMgdGhhdCByZXF1aXJlIHRhZyBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVUYWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgdGFnIHNvdXJjZVxuXHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIHRhZyB0aGF0IHdhcyBjcmVhdGVkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uKHNyYykgeyByZXR1cm4gbnVsbDsgfTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBsb2Fkc3RhcnQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRzdGFydDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZExvYWRTdGFydFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX3NlbmRQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge051bWJlciB8IE9iamVjdH0gdmFsdWUgVGhlIHByb2dyZXNzIG9mIHRoZSBsb2FkZWQgaXRlbSwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgPGNvZGU+bG9hZGVkPC9jb2RlPlxuXHQgKiBhbmQgPGNvZGU+dG90YWw8L2NvZGU+IHByb3BlcnRpZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGV2ZW50ID0gbnVsbDtcblx0XHRpZiAodHlwZW9mKHZhbHVlKSA9PSBcIm51bWJlclwiKSB7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWU7XG5cdFx0XHRldmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMucHJvZ3Jlc3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5wcm9ncmVzcyA9IHZhbHVlLmxvYWRlZCAvIHZhbHVlLnRvdGFsO1xuXHRcdFx0ZXZlbnQucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuXHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHR9XG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBjb21wbGV0ZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcblx0ICogQG1ldGhvZCBfc2VuZENvbXBsZXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xuXG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiY29tcGxldGVcIik7XG5cdFx0ZXZlbnQucmF3UmVzdWx0ID0gdGhpcy5fcmF3UmVzdWx0O1xuXG5cdFx0aWYgKHRoaXMuX3Jlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRldmVudC5yZXN1bHQgPSB0aGlzLl9yZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYW4gZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgc3BlY2lmaWMgZXJyb3IgcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCAhdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZXJyb3JcIikpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKGV2ZW50ID09IG51bGwpIHtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX0VSUk9SX0VNUFRZXCIpOyAvLyBUT0RPOiBQb3B1bGF0ZSBlcnJvclxuXHRcdH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWQgaGFzIGJlZW4gY2FuY2VsZWQuIFRoaXMgaXMgaW1wb3J0YW50IHRvIGVuc3VyZSB0aGF0IG1ldGhvZCBjYWxscyBvciBhc3luY2hyb25vdXMgZXZlbnRzXG5cdCAqIGRvIG5vdCBjYXVzZSBpc3N1ZXMgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBiZWVuIGNsZWFuZWQgdXAuXG5cdCAqIEBtZXRob2QgX2lzQ2FuY2VsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWRlciBoYXMgYmVlbiBjYW5jZWxlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faXNDYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAod2luZG93LmNyZWF0ZWpzID09IG51bGwgfHwgdGhpcy5jYW5jZWxlZCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogQSBjdXN0b20gcmVzdWx0IGZvcm1hdHRlciBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIGp1c3QgYmVmb3JlIGEgcmVxdWVzdCBkaXNwYXRjaGVzIGl0cyBjb21wbGV0ZSBldmVudC4gTW9zdFxuXHQgKiBsb2FkZXIgdHlwZXMgYWxyZWFkeSBoYXZlIGFuIGludGVybmFsIGZvcm1hdHRlciwgYnV0IHRoaXMgY2FuIGJlIHVzZXItb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIGZvcm1hdHRpbmcuIFRoZVxuXHQgKiBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIExvYWRlcnMgdXNpbmcge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgcGFzc2luZyBgdHJ1ZWAuXG5cdCAqIEBwcm9wZXJ0eSByZXN1bHRGb3JtYXR0ZXJcblx0ICogQHR5cGUgRnVuY3Rpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZm9ybWF0dGVkIHJlc3VsdFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAucmVzdWx0Rm9ybWF0dGVyID0gbnVsbDtcblxuXHQvKipcblx0ICogSGFuZGxlIGV2ZW50cyBmcm9tIGludGVybmFsIHJlcXVlc3RzLiBCeSBkZWZhdWx0LCBsb2FkZXJzIHdpbGwgaGFuZGxlLCBhbmQgcmVkaXNwYXRjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50cywgYnV0XG5cdCAqIHRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGZvciBjdXN0b20gYmVoYXZpb3Vycy5cblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdGhhdCB0aGUgaW50ZXJuYWwgcmVxdWVzdCBkaXNwYXRjaGVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5fcmVzcG9uc2U7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKTtcblx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0cmVzdWx0LmNhbGwodGhpcyxcblx0XHRcdFx0XHRcdFx0Y3JlYXRlanMucHJveHkodGhpcy5fcmVzdWx0Rm9ybWF0U3VjY2VzcywgdGhpcyksXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZWpzLnByb3h5KHRoaXMuX3Jlc3VsdEZvcm1hdEZhaWxlZCwgdGhpcylcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3VsdCA9ICByZXN1bHQgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxvYWRzdGFydFwiOlxuXHRcdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFib3J0XCI6XG5cdFx0XHRjYXNlIFwidGltZW91dFwiOlxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzQ2FuY2VsZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfXCIgKyBldmVudC50eXBlLnRvVXBwZXJDYXNlKCkgKyBcIl9FUlJPUlwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgXCJzdWNjZXNzXCIgY2FsbGJhY2sgcGFzc2VkIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Jlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fSBhc3luY2hyb25vdXNcblx0ICogZnVuY3Rpb25zLlxuXHQgKiBAbWV0aG9kIF9yZXN1bHRGb3JtYXRTdWNjZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIGZvcm1hdHRlZCByZXN1bHRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3Jlc3VsdEZvcm1hdFN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gcmVzdWx0O1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgXCJlcnJvclwiIGNhbGxiYWNrIHBhc3NlZCB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9yZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0gYXN5bmNocm9ub3VzXG5cdCAqIGZ1bmN0aW9ucy5cblx0ICogQG1ldGhvZCBfcmVzdWx0Rm9ybWF0U3VjY2Vzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgVGhlIGVycm9yIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9yZXN1bHRGb3JtYXRGYWlsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJ1aWxkUGF0aFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiUmVxdWVzdFV0aWxzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB7eyNjcm9zc0xpbmsgXCJSZXF1ZXN0VXRpbHMvYnVpbGRQYXRoXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RlYWQuXG5cdCAqL1xuXHRwLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmJ1aWxkUGF0aChzcmMsIGRhdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIEFic3RyYWN0TG9hZGVyXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdExvYWRlciwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdE1lZGlhTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIEFic3RyYWN0TWVkaWFMb2FkZXIgaXMgYSBiYXNlIGNsYXNzIHRoYXQgaGFuZGxlcyBzb21lIG9mIHRoZSBzaGFyZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBvZiBsb2FkZXJzIHRoYXRcblx0ICogaGFuZGxlIEhUTUwgbWVkaWEgZWxlbWVudHMsIHN1Y2ggYXMgVmlkZW8gYW5kIEF1ZGlvLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbWVkaWEgdG8gbG9hZC4gVXN1YWxseSBcInZpZGVvXCIgb3IgXCJhdWRpb1wiLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TWVkaWFMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXG4gICAgICAgIHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RNZWRpYUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUYWdSZXF1ZXN0IHdpbGwgaGFuZGxlIG1vc3Qgb2YgdGhpcywgYnV0IFNvdW5kIC8gVmlkZW8gbmVlZCBhIGZldyBjdXN0b20gcHJvcGVydGllcywgc28ganVzdCBoYW5kbGUgdGhlbSBoZXJlLlxuXHRcdGlmICghdGhpcy5fdGFnKSB7XG5cdFx0XHR0aGlzLl90YWcgPSB0aGlzLl9jcmVhdGVUYWcodGhpcy5faXRlbS5zcmMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RhZy5wcmVsb2FkID0gXCJhdXRvXCI7XG5cdFx0dGhpcy5fdGFnLmxvYWQoKTtcblxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHRhZyBmb3IgbG9hZGluZyBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cblx0ICogQG1ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7fTtcblxuXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5NZWRpYVRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG4gICAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCBpdHMgbWltZVR5cGUgYW5kIHJlc3BvbnNlVHlwZS5cbiAgICAgKiBAcHJvcGVydHkgX3VwZGF0ZVhIUlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gT25seSBleGlzdHMgZm9yIFhIUlxuICAgICAgICBpZiAoZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImJsb2JcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgbWVkaWEgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxWaWRlb0VsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5vbnN0YWxsZWQgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblxuXHRcdFx0bG9hZGVyLmdldFRhZygpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvYWRlci5nZXRUYWcoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdE1lZGlhTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBiYXNlIGNsYXNzIGZvciBhY3R1YWwgZGF0YSByZXF1ZXN0cywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiTWVkaWFSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBQcmVsb2FkSlMgbG9hZGVycyB3aWxsIHR5cGljYWxseSB1c2UgYSBkYXRhIGxvYWRlciB1bmRlciB0aGVcblx0ICogaG9vZCB0byBnZXQgZGF0YS5cblx0ICogQGNsYXNzIEFic3RyYWN0UmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBpdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIEFic3RyYWN0UmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RSZXF1ZXN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWdpbiBhIGxvYWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gIGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIGEgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24oKSB7fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0UmVxdWVzdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzLCBzdWNoIGFzIGltYWdlcyBhbmQgc2NyaXB0cy5cblx0ICogQGNsYXNzIFRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHQgKi9cblx0ZnVuY3Rpb24gVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3Rvcihsb2FkSXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBIVE1MIHRhZyBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgdG8gbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1xuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gdGFnO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnU3JjQXR0cmlidXRlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtZXRob2QgY2xvc3VyZSB1c2VkIGZvciBoYW5kbGluZyB0aGUgdGFnIGxvYWQgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRIYW5kbGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBET00gYXV0b21hdGljYWxseSBieSBQcmVsb2FkSlMsIHNvIGl0IGNhbiBiZSBjbGVhbmVkIHVwIGFmdGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWRkZWRUb0RPTVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYWRkZWRUb0RPTSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyB3aGF0IHRoZSB0YWdzIGluaXRpYWwgc3R5bGUudmlzaWJpbGl0eSB3YXMsIHNvIHdlIGNhbiBzZXQgaXQgY29ycmVjdGx5IGFmdGVyIGEgbG9hZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5ID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUYWdSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl90YWc7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHRcdHRoaXMuX2hpZGVUYWcoKTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHR0aGlzLl90YWdbdGhpcy5fdGFnU3JjQXR0cmlidXRlXSA9IHRoaXMuX2l0ZW0uc3JjO1xuXG5cdFx0Ly8gd2RnOjogQXBwZW5kIHRoZSB0YWcgQUZURVIgc2V0dGluZyB0aGUgc3JjLCBvciBTVkcgbG9hZGluZyBvbiBpT1Mgd2lsbCBmYWlsLlxuXHRcdGlmICh0aGlzLl90YWcucGFyZW50Tm9kZSA9PSBudWxsKSB7XG5cdFx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl90YWcpO1xuXHRcdFx0dGhpcy5fYWRkZWRUb0RPTSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblxuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2Rlc3Ryb3koKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgcmVhZHlTdGF0ZUNoYW5nZSBldmVudCBmcm9tIGEgdGFnLiBXZSBuZWVkIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGBvbmxvYWRgIGNhbGxiYWNrIChtYWlubHkgU0NSSVBUXG5cdCAqIGFuZCBMSU5LIHRhZ3MpLCBidXQgb3RoZXIgY2FzZXMgbWF5IGV4aXN0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0Ly8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgZm9yIG9sZCBJRSBzdXBwb3J0LlxuXHRcdGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuXHRcdFx0dGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbnkgZXJyb3IgZXZlbnRzIGZyb20gdGhlIHRhZy5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImVycm9yXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIHRhZydzIG9ubG9hZCBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGFnQ29tcGxldGVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRhZ0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IHRoaXMuX3RhZztcblx0XHR0aGlzLl9yZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKSB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3Nob3dUYWcoKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNpZmllZCBpbiBsb2FkVGltZW91dC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLCBidXQgZG9uJ3QgZGVzdHJveSB0aGUgcmVxdWVzdCBvYmplY3Rcblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdGFnLm9ubG9hZCA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0dGhpcy5fdGFnLm9uZXJyb3IgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9hZGRlZFRvRE9NICYmIHRoaXMuX3RhZy5wYXJlbnROb2RlICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG5cdFx0fVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdH07XG5cblx0cC5faGlkZVRhZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eSA9IHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5O1xuXHRcdHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblx0fTtcblxuXHRwLl9zaG93VGFnID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhIHN0YWxsZWQgYXVkaW8gZXZlbnQuIFRoZSBtYWluIHBsYWNlIHRoaXMgaGFwcGVucyBpcyB3aXRoIEhUTUxBdWRpbyBpbiBDaHJvbWUgd2hlbiBwbGF5aW5nIGJhY2sgYXVkaW9cblx0ICogdGhhdCBpcyBhbHJlYWR5IGluIGEgbG9hZCwgYnV0IG5vdCBjb21wbGV0ZS5cblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhbGxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0Y3JlYXRlanMuVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoVGFnUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZWRpYVRhZ1JlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzIGZvciB2aWRlbyBhbmQgYXVkaW8uXG5cdCAqIEBjbGFzcyBNZWRpYVRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNZWRpYVRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTWVkaWFUYWdSZXF1ZXN0LCBjcmVhdGVqcy5UYWdSZXF1ZXN0KTtcblx0dmFyIHMgPSBNZWRpYVRhZ1JlcXVlc3Q7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVN0YWxsZWQsIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRDYWxsYmFjayA9IHNjO1xuXG5cdFx0dmFyIHBjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzID0gcGM7XG5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgc2MpO1xuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcGMpO1xuXG5cdFx0Ly8gVGhpcyB3aWxsIHRlbGwgdXMgd2hlbiBhdWRpbyBpcyBidWZmZXJlZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoLCBidXQgbm90IHdoZW4gaXRzIGxvYWRlZC5cblx0XHQvLyBUaGUgdGFnIGRvZXNuJ3Qga2VlcCBsb2FkaW5nIGluIENocm9tZSBvbmNlIGVub3VnaCBoYXMgYnVmZmVyZWQsIGFuZCB3ZSBoYXZlIGRlY2lkZWQgdGhhdCBiZWhhdmlvdXIgaXMgc3VmZmljaWVudC5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIsIGZhbHNlKTsgLy8gY2FucGxheXRocm91Z2ggY2FsbGJhY2sgZG9lc24ndCB3b3JrIGluIENocm9tZSwgc28gd2UgdXNlIGFuIGV2ZW50LlxuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgdGhpcy5fc3RhbGxlZENhbGxiYWNrKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2spO1xuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X19jbGVhbigpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoTWVkaWFUYWdSZXF1ZXN0LCBcIlRhZ1JlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYSFJSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgcHJlbG9hZGVyIHRoYXQgbG9hZHMgaXRlbXMgdXNpbmcgWEhSIHJlcXVlc3RzLCB1c3VhbGx5IFhNTEh0dHBSZXF1ZXN0LiBIb3dldmVyIFhEb21haW5SZXF1ZXN0cyB3aWxsIGJlIHVzZWRcblx0ICogZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBpZiBwb3NzaWJsZSwgYW5kIG9sZGVyIHZlcnNpb25zIG9mIElFIGZhbGwgYmFjayBvbiB0byBBY3RpdmVYIG9iamVjdHMgd2hlbiBuZWNlc3NhcnkuXG5cdCAqIFhIUiByZXF1ZXN0cyBsb2FkIHRoZSBjb250ZW50IGFzIHRleHQgb3IgYmluYXJ5IGRhdGEsIHByb3ZpZGUgcHJvZ3Jlc3MgYW5kIGNvbnNpc3RlbnQgY29tcGxldGlvbiBldmVudHMsIGFuZFxuXHQgKiBjYW4gYmUgY2FuY2VsZWQgZHVyaW5nIGxvYWQuIE5vdGUgdGhhdCBYSFIgaXMgbm90IHN1cHBvcnRlZCBpbiBJRSA2IG9yIGVhcmxpZXIsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yXG5cdCAqIGNyb3NzLWRvbWFpbiBsb2FkaW5nLlxuXHQgKiBAY2xhc3MgWEhSUmVxdWVzdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGZpbGUgdG8gbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBvdmVydmlldyBvZiBzdXBwb3J0ZWQgZmlsZSBwcm9wZXJ0aWVzLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gWEhSUmVxdWVzdCAoaXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgWEhSIHJlcXVlc3QgdXNlZCB0byBsb2FkIHRoZSBjb250ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVxdWVzdFxuXHRcdCAqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdCB8IFhEb21haW5SZXF1ZXN0IHwgQWN0aXZlWC5YTUxIVFRQfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIG1hbnVhbCBsb2FkIHRpbWVvdXQgdGhhdCBpcyB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBvblRpbWVvdXQgZXZlbnQgb24gWEhSIChYSFIgbGV2ZWwgMSxcblx0XHQgKiB0eXBpY2FsbHkgSUU5KS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBicm93c2VyJ3MgWEhSIChYTUxIVFRQUmVxdWVzdCkgdmVyc2lvbi4gU3VwcG9ydGVkIHZlcnNpb25zIGFyZSAxIGFuZCAyLiBUaGVyZSBpcyBubyBvZmZpY2lhbCB3YXkgdG8gZGV0ZWN0XG5cdFx0ICogdGhlIHZlcnNpb24sIHNvIHdlIHVzZSBjYXBhYmlsaXRpZXMgdG8gbWFrZSBhIGJlc3QgZ3Vlc3MuXG5cdFx0ICogQHByb3BlcnR5IF94aHJMZXZlbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5feGhyTGV2ZWwgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlc3BvbnNlIG9mIGEgbG9hZGVkIGZpbGUuIFRoaXMgaXMgc2V0IGJlY2F1c2UgaXQgaXMgZXhwZW5zaXZlIHRvIGxvb2sgdXAgY29uc3RhbnRseS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG5cdFx0ICogbnVsbCB1bnRpbCB0aGUgZmlsZSBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yZXNwb25zZVxuXHRcdCAqIEB0eXBlIHttaXhlZH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiB0aGUgbG9hZGVkIGZpbGUgYmVmb3JlIGl0IGlzIG1vZGlmaWVkLiBJbiBtb3N0IGNhc2VzLCBjb250ZW50IGlzIGNvbnZlcnRlZCBmcm9tIHJhdyB0ZXh0IHRvXG5cdFx0ICogYW4gSFRNTCB0YWcgb3IgYSBmb3JtYXR0ZWQgb2JqZWN0IHdoaWNoIGlzIHNldCB0byB0aGUgPGNvZGU+cmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSwgYnV0IHRoZSBkZXZlbG9wZXIgbWF5IHN0aWxsXG5cdFx0ICogd2FudCB0byBhY2Nlc3MgdGhlIHJhdyBjb250ZW50IGFzIGl0IHdhcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yYXdSZXNwb25zZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0dGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNldHVwIG91ciBldmVudCBoYW5kbGVycyBub3cuXG5cdFx0dGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkU3RhcnQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlQWJvcnRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUFib3J0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVFcnJvclByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUxvYWRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLl9jcmVhdGVYSFIoaXRlbSkpIHtcblx0XHRcdC8vVE9ETzogVGhyb3cgZXJyb3I/XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhIUlJlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgWE1MSFRUUCBvYmplY3QgSURzIHRvIHRyeSB3aGVuIGJ1aWxkaW5nIGFuIEFjdGl2ZVggb2JqZWN0IGZvciBYSFIgcmVxdWVzdHMgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBJRS5cblx0ICogQHByb3BlcnR5IEFDVElWRVhfVkVSU0lPTlNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc2luY2UgMC40LjJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdFhIUlJlcXVlc3QuQUNUSVZFWF9WRVJTSU9OUyA9IFtcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjYuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNS4wXCIsXG5cdFx0XCJNc3htbDIuWE1MSFRUUC40LjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLFxuXHRcdFwiTVNYTUwyLlhNTEhUVFBcIixcblx0XHRcIk1pY3Jvc29mdC5YTUxIVFRQXCJcblx0XTtcblxuLy8gUHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIExvb2sgdXAgdGhlIGxvYWRlZCByZXN1bHQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhdz1mYWxzZV0gUmV0dXJuIGEgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIGEgZm9ybWF0dGVkIHJlc3VsdC4gVGhpcyBhcHBsaWVzIHRvIGNvbnRlbnRcblx0ICogbG9hZGVkIHZpYSBYSFIgc3VjaCBhcyBzY3JpcHRzLCBYTUwsIENTUywgYW5kIEltYWdlcy4gSWYgdGhlcmUgaXMgbm8gcmF3IHJlc3VsdCwgdGhlIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZVxuXHQgKiByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCwgc3VjaCBhczpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG5cdCAqICAgICAgPGxpPkEgc2NyaXB0IHRhZyBmb3IgSmF2YVNjcmlwdCAoJmx0O3NjcmlwdCAvJmd0OykuIE5vdGUgdGhhdCBzY3JpcHRzIGxvYWRlZCB3aXRoIHRhZ3MgbWF5IGJlIGFkZGVkIHRvIHRoZVxuXHQgKiAgICAgIEhUTUwgaGVhZC48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBiaW5hcnkgYXJyYXlidWZmZXIgbG9hZGVkIGJ5IFhIUjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdGlmIChyYXcgJiYgdGhpcy5fcmF3UmVzcG9uc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yYXdSZXNwb25zZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RSZXF1ZXN0XG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RMb2FkZXJcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0ID09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9FdmVudHNcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdGhpcy5faGFuZGxlQWJvcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHksIGZhbHNlKTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHksIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSUU5IHN1cHBvcnRcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSB0aGlzLl9oYW5kbGVBYm9ydFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gdGhpcy5faGFuZGxlRXJyb3JQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gdGhpcy5faGFuZGxlVGltZW91dFByb3h5O1xuXG5cdFx0XHQvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gdGhpcy5faGFuZGxlTG9hZFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGEgdGltZW91dCBpZiB3ZSBkb24ndCBoYXZlIFhIUjJcblx0XHRpZiAodGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuXHRcdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblx0XHR9XG5cblx0XHQvLyBTb21ldGltZXMgd2UgZ2V0IGJhY2sgNDA0cyBpbW1lZGlhdGVseSwgcGFydGljdWxhcmx5IHdoZW4gdGhlcmUgaXMgYSBjcm9zcyBvcmlnaW4gcmVxdWVzdC4gIC8vIG5vdGUgdGhpcyBkb2VzIG5vdCBjYXRjaCBpbiBDaHJvbWVcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLl9pdGVtLnZhbHVlcyB8fCB0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2l0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1QpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5mb3JtYXRRdWVyeVN0cmluZyh0aGlzLl9pdGVtLnZhbHVlcykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJYSFJfU0VORFwiLCBudWxsLCBlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRwLnNldFJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0Ly8gU29tZSBvbGQgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGJsb2IsIHNvIHdlIGNvbnZlcnQgYXJyYXlidWZmZXIgdG8gYmxvYiBhZnRlciByZXNwb25zZSBpcyBkb3dubG9hZGVkXG5cdFx0aWYgKHR5cGUgPT09ICdibG9iJykge1xuXHRcdFx0dHlwZSA9IHdpbmRvdy5VUkwgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInO1xuXHRcdFx0dGhpcy5fcmVzcG9uc2VUeXBlID0gdHlwZTtcblx0XHR9XG5cdFx0dGhpcy5fcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybiBhbGwgdGhlIEhUVFAgaGVhZGVycywgZXhjbHVkaW5nIGhlYWRlcnMgdGhhdCBhcmUgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoXG5cdCAqIGZvciBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLCBhcyBhIHNpbmdsZSBzdHJpbmcsIHdpdGggZWFjaCBoZWFkZXIgbGluZSBzZXBhcmF0ZWQgYnkgYSBVKzAwMEQgQ1IgVSswMDBBIExGIHBhaXIsXG5cdCAqIGV4Y2x1ZGluZyB0aGUgc3RhdHVzIGxpbmUsIGFuZCB3aXRoIGVhY2ggaGVhZGVyIG5hbWUgYW5kIGhlYWRlciB2YWx1ZSBzZXBhcmF0ZWQgYnkgYSBVKzAwM0EgQ09MT04gVSswMDIwIFNQQUNFXG5cdCAqIHBhaXIuXG5cdCAqIEBtZXRob2QgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgc3BlY2lmaWMgcmVzcG9uc2UgaGVhZGVyIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybnMgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB3aGljaCB0aGUgZmllbGQgbmFtZSBtYXRjaGVzXG5cdCAqIGhlYWRlciwgdW5sZXNzIHRoZSBmaWVsZCBuYW1lIGlzIFNldC1Db29raWUgb3IgU2V0LUNvb2tpZTIuXG5cdCAqIEBtZXRob2QgZ2V0UmVzcG9uc2VIZWFkZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgaGVhZGVyIG5hbWUgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSBsb2FkIHN0YXJ0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkU3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgbG9hZFN0YXJ0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gYWJvcnQgZXZlbnQuXG5cdCAqIEBtZXRob2QgaGFuZGxlQWJvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgYWJvcnQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVBYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX0FCT1JURURcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciBldmVudC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KGV2ZW50Lm1lc3NhZ2UpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhIHJlYWR5U3RhdGUgY2hhbmdlLiBOb3RlIHRoYXQgb2xkZXIgYnJvd3NlcnMgKElFIDcgJiA4KSBkbyBub3QgcHJvdmlkZSBhbiBvbmxvYWRcblx0ICogZXZlbnQsIHNvIHdlIG11c3QgbW9uaXRvciB0aGUgcmVhZHlTdGF0ZUNoYW5nZSB0byBkZXRlcm1pbmUgaWYgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVMb2FkKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciBieSBhIHJlYWR5U3RhdGVDaGFuZ2UgdGhhdCBoYXNcblx0ICogPGNvZGU+cmVxdWVzdC5yZWFkeVN0YXRlID09IDQ8L2NvZGU+LiBPbmx5IHRoZSBmaXJzdCBjYWxsIHRvIHRoaXMgbWV0aG9kIHdpbGwgYmUgcHJvY2Vzc2VkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMubG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuXHRcdHZhciBlcnJvciA9IHRoaXMuX2NoZWNrRXJyb3IoKTtcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXNwb25zZSA9IHRoaXMuX2dldFJlc3BvbnNlKCk7XG5cdFx0Ly8gQ29udmVydCBhcnJheWJ1ZmZlciBiYWNrIHRvIGJsb2Jcblx0XHRpZiAodGhpcy5fcmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IG5ldyBCbG9iKFt0aGlzLl9yZXNwb25zZV0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byB1c2UgQmxvYkJ1aWxkZXIgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdC8vIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyB+IDQuMiBhbmQgaU9TNSBzYWZhcmlcblx0XHRcdFx0d2luZG93LkJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cdFx0XHRcdGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIHdpbmRvdy5CbG9iQnVpbGRlcikge1xuXHRcdFx0XHRcdHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdFx0XHRcdFx0YnVpbGRlci5hcHBlbmQodGhpcy5fcmVzcG9uc2UpO1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3BvbnNlID0gYnVpbGRlci5nZXRCbG9iKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgdGltZWQgb3V0LiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIHZpYSBhIDxjb2RlPnNldFRpbWVvdXQ8L2NvZGU+XG5cdCAqIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIFRoZSBYSFIgdGltZW91dCBldmVudC4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgbnVsbCB3aGVuIGNhbGxlZCBieSB0aGUgYmFja3VwIHNldFRpbWVvdXQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiLCBudWxsLCBldmVudCkpO1xuXHR9O1xuXG4vLyBQcm90ZWN0ZWRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY3VycmVudCBsb2FkLiBUaGlzIGNoZWNrcyB0aGUgc3RhdHVzIG9mIHRoZSByZXF1ZXN0IGZvciBwcm9ibGVtIGNvZGVzLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBkb2VzIG5vdCBjaGVjayBmb3IgYW4gYWN0dWFsIHJlc3BvbnNlLiBDdXJyZW50bHksIGl0IG9ubHkgY2hlY2tzIGZvciA0MDQgb3IgMCBlcnJvciBjb2RlLlxuXHQgKiBAbWV0aG9kIF9jaGVja0Vycm9yXG5cdCAqIEByZXR1cm4ge2ludH0gSWYgdGhlIHJlcXVlc3Qgc3RhdHVzIHJldHVybnMgYW4gZXJyb3IgY29kZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9MTTogUHJvYmFibHkgbmVlZCBhZGRpdGlvbmFsIGhhbmRsZXJzIGhlcmUsIG1heWJlIDUwMVxuXHRcdHZhciBzdGF0dXMgPSBwYXJzZUludCh0aGlzLl9yZXF1ZXN0LnN0YXR1cyk7XG5cblx0XHRzd2l0Y2ggKHN0YXR1cykge1xuXHRcdFx0Y2FzZSA0MDQ6ICAgLy8gTm90IEZvdW5kXG5cdFx0XHRjYXNlIDA6ICAgICAvLyBOb3QgTG9hZGVkXG5cdFx0XHRcdHJldHVybiBuZXcgRXJyb3Ioc3RhdHVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlIHRoZSByZXNwb25zZS4gRGlmZmVyZW50IGJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvbWUgb2Ygd2hpY2ggdGhyb3cgZXJyb3JzIHdoZW4gYWNjZXNzZWRcblx0ICogaW4gb3RoZXIgYnJvd3NlcnMuIElmIHRoZXJlIGlzIG5vIHJlc3BvbnNlLCB0aGUgPGNvZGU+X3Jlc3BvbnNlPC9jb2RlPiBwcm9wZXJ0eSB3aWxsIHJlbWFpbiBudWxsLlxuXHQgKiBAbWV0aG9kIF9nZXRSZXNwb25zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZ2V0UmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlICE9IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBbmRyb2lkIDIuMiB1c2VzIC5yZXNwb25zZVRleHRcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHQvLyBXaGVuIGxvYWRpbmcgWE1MLCBJRTkgZG9lcyBub3QgcmV0dXJuIC5yZXNwb25zZSwgaW5zdGVhZCBpdCByZXR1cm5zIHJlc3BvbnNlWE1MLnhtbFxuXHRcdHRyeSB7XG5cdFx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlWE1MO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0LiBEZXBlbmRpbmcgb24gYSBudW1iZXIgb2YgZmFjdG9ycywgd2UgZ2V0IHRvdGFsbHkgZGlmZmVyZW50IHJlc3VsdHMuXG5cdCAqIDxvbD48bGk+U29tZSBicm93c2VycyBnZXQgYW4gPGNvZGU+WERvbWFpblJlcXVlc3Q8L2NvZGU+IHdoZW4gbG9hZGluZyBjcm9zcy1kb21haW4uPC9saT5cblx0ICogICAgICA8bGk+WE1MSHR0cFJlcXVlc3QgYXJlIGNyZWF0ZWQgd2hlbiBhdmFpbGFibGUuPC9saT5cblx0ICogICAgICA8bGk+QWN0aXZlWC5YTUxIVFRQIG9iamVjdHMgYXJlIHVzZWQgaW4gb2xkZXIgSUUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+VGV4dCByZXF1ZXN0cyBvdmVycmlkZSB0aGUgbWltZSB0eXBlIGlmIHBvc3NpYmxlPC9saT5cblx0ICogICAgICA8bGk+T3JpZ2luIGhlYWRlcnMgYXJlIHNlbnQgZm9yIGNyb3NzZG9tYWluIHJlcXVlc3RzIGluIHNvbWUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+QmluYXJ5IGxvYWRzIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCI8L2xpPjwvb2w+XG5cdCAqIEBtZXRob2QgX2NyZWF0ZVhIUlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgcmVxdWVzdGVkIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIGFuIFhIUiByZXF1ZXN0IG9yIGVxdWl2YWxlbnQgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlWEhSID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHQvLyBDaGVjayBmb3IgY3Jvc3MtZG9tYWluIGxvYWRzLiBXZSBjYW4ndCBmdWxseSBzdXBwb3J0IHRoZW0sIGJ1dCB3ZSBjYW4gdHJ5LlxuXHRcdHZhciBjcm9zc2RvbWFpbiA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0Nyb3NzRG9tYWluKGl0ZW0pO1xuXHRcdHZhciBoZWFkZXJzID0ge307XG5cblx0XHQvLyBDcmVhdGUgdGhlIHJlcXVlc3QuIEZhbGxiYWNrIHRvIHdoYXRldmVyIHN1cHBvcnQgd2UgaGF2ZS5cblx0XHR2YXIgcmVxID0gbnVsbDtcblx0XHRpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRyZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdC8vIFRoaXMgaXMgOCBvciA5LCBzbyB1c2UgWERvbWFpblJlcXVlc3QgaW5zdGVhZC5cblx0XHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG5cdFx0XHRcdHJlcSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIE9sZCBJRSB2ZXJzaW9ucyB1c2UgYSBkaWZmZXJlbnQgYXBwcm9hY2hcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5BQ1RJVkVYX1ZFUlNJT05TLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgYXhWZXJzaW9uID0gcy5BQ1RJVkVYX1ZFUlNJT05TW2ldO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KGF4VmVyc2lvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIHV0Zi04IGZvciBUZXh0IHJlcXVlc3RzLlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlID09IG51bGwgJiYgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVGV4dChpdGVtLnR5cGUpKSB7XG5cdFx0XHRpdGVtLm1pbWVUeXBlID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5cdFx0fVxuXG5cdFx0Ly8gSUU5IGRvZXNuJ3Qgc3VwcG9ydCBvdmVycmlkZU1pbWVUeXBlKCksIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0LlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlICYmIHJlcS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHRyZXEub3ZlcnJpZGVNaW1lVHlwZShpdGVtLm1pbWVUeXBlKTtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIFhIUiBsZXZlbFxuXHRcdHRoaXMuX3hockxldmVsID0gKHR5cGVvZiByZXEucmVzcG9uc2VUeXBlID09PSBcInN0cmluZ1wiKSA/IDIgOiAxO1xuXG5cdFx0dmFyIHNyYyA9IG51bGw7XG5cdFx0aWYgKGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCkge1xuXHRcdFx0c3JjID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmJ1aWxkUGF0aChpdGVtLnNyYywgaXRlbS52YWx1ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBpdGVtLnNyYztcblx0XHR9XG5cblx0XHQvLyBPcGVuIHRoZSByZXF1ZXN0LiAgU2V0IGNyb3NzLWRvbWFpbiBmbGFncyBpZiBpdCBpcyBzdXBwb3J0ZWQgKFhIUiBsZXZlbCAxIG9ubHkpXG5cdFx0cmVxLm9wZW4oaXRlbS5tZXRob2QgfHwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VULCBzcmMsIHRydWUpO1xuXG5cdFx0aWYgKGNyb3NzZG9tYWluICYmIHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdGhlYWRlcnNbXCJPcmlnaW5cIl0gPSBsb2NhdGlvbi5vcmlnaW47XG5cdFx0fVxuXG5cdFx0Ly8gVG8gc2VuZCBkYXRhIHdlIG5lZWQgdG8gc2V0IHRoZSBDb250ZW50LXR5cGUgaGVhZGVyKVxuXHRcdGlmIChpdGVtLnZhbHVlcyAmJiBpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblx0XHR9XG5cblx0XHRpZiAoIWNyb3NzZG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xuXHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0uaGVhZGVycykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBpdGVtLmhlYWRlcnMpIHtcblx0XHRcdFx0aGVhZGVyc1tuXSA9IGl0ZW0uaGVhZGVyc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKG4gaW4gaGVhZGVycykge1xuXHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIobiwgaGVhZGVyc1tuXSlcblx0XHR9XG5cblx0XHRpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgaXRlbS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVxLndpdGhDcmVkZW50aWFscyA9IGl0ZW0ud2l0aENyZWRlbnRpYWxzO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlcXVlc3QgPSByZXE7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSByZXF1ZXN0IGhhcyBjb21wbGV0ZWQgKG9yIGZhaWxlZCBvciBjYW5jZWxlZCksIGFuZCBuZWVkcyB0byBiZSBkaXNwb3NlZC5cblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnByb2dyZXNzID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25hYm9ydCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnRpbWVvdXQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgWEhSUmVxdWVzdF1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5YSFJSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShYSFJSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRRdWV1ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLypcbiBUT0RPOiBXSU5ET1dTIElTU1VFU1xuICogTm8gZXJyb3IgZm9yIEhUTUwgYXVkaW8gaW4gSUUgNjc4XG4gKiBTVkcgbm8gZmFpbHVyZSBlcnJvciBpbiBJRSA2NyAobWF5YmUgOCkgVEFHUyBBTkQgWEhSXG4gKiBObyBzY3JpcHQgY29tcGxldGUgaGFuZGxlciBpbiBJRSA2NyBUQUdTIChYSFIgaXMgZmluZSlcbiAqIE5vIFhNTC9KU09OIGluIElFNiBUQUdTXG4gKiBOZWVkIHRvIGhpZGUgbG9hZGluZyBTVkcgaW4gT3BlcmEgVEFHU1xuICogTm8gQ1NTIG9ubG9hZC9yZWFkeXN0YXRlY2hhbmdlIGluIFNhZmFyaSBvciBBbmRyb2lkIFRBR1MgKHJlcXVpcmVzIHJ1bGUgY2hlY2tpbmcpXG4gKiBTVkcgbm8gbG9hZCBvciBmYWlsdXJlIGluIE9wZXJhIFhIUlxuICogUmVwb3J0ZWQgaXNzdWVzIHdpdGggSUU3LzhcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBMb2FkUXVldWUgY2xhc3MgaXMgdGhlIG1haW4gQVBJIGZvciBwcmVsb2FkaW5nIGNvbnRlbnQuIExvYWRRdWV1ZSBpcyBhIGxvYWQgbWFuYWdlciwgd2hpY2ggY2FuIHByZWxvYWQgZWl0aGVyXG5cdCAqIGEgc2luZ2xlIGZpbGUsIG9yIHF1ZXVlIG9mIGZpbGVzLlxuXHQgKlxuXHQgKiA8Yj5DcmVhdGluZyBhIFF1ZXVlPC9iPjxiciAvPlxuXHQgKiBUbyB1c2UgTG9hZFF1ZXVlLCBjcmVhdGUgYSBMb2FkUXVldWUgaW5zdGFuY2UuIElmIHlvdSB3YW50IHRvIGZvcmNlIHRhZyBsb2FkaW5nIHdoZXJlIHBvc3NpYmxlLCBzZXQgdGhlIHByZWZlclhIUlxuXHQgKiBhcmd1bWVudCB0byBmYWxzZS5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRydWUpO1xuXHQgKlxuXHQgKiA8Yj5MaXN0ZW5pbmcgZm9yIEV2ZW50czwvYj48YnIgLz5cblx0ICogQWRkIGFueSBsaXN0ZW5lcnMgeW91IHdhbnQgdG8gdGhlIHF1ZXVlLiBTaW5jZSBQcmVsb2FkSlMgMC4zLjAsIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbGV0cyB5b3UgYWRkIGFzIG1hbnkgbGlzdGVuZXJzIGFzIHlvdSB3YW50IGZvciBldmVudHMuIFlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSBmb2xsb3dpbmcgZXZlbnRzOjx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiBhIHF1ZXVlIGNvbXBsZXRlcyBsb2FkaW5nIGFsbFxuXHQgKiAgICAgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Vycm9yOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIHRoZSBxdWV1ZSBlbmNvdW50ZXJzIGFuIGVycm9yIHdpdGhcblx0ICogICAgIGFueSBmaWxlLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciB0aGUgZW50aXJlIHF1ZXVlIGhhc1xuXHQgKiAgICAgY2hhbmdlZC48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fTogQSBzaW5nbGUgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXByb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBQcm9ncmVzcyBmb3IgYSBzaW5nbGUgZmlsZSBoYXMgY2hhbmdlcy4gTm90ZVxuXHQgKiAgICAgdGhhdCBvbmx5IGZpbGVzIGxvYWRlZCB3aXRoIFhIUiAob3IgcG9zc2libHkgYnkgcGx1Z2lucykgd2lsbCBmaXJlIHByb2dyZXNzIGV2ZW50cyBvdGhlciB0aGFuIDAgb3IgMTAwJS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHQgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUsIHRoaXMpO1xuXHQgKlxuXHQgKiA8Yj5BZGRpbmcgZmlsZXMgYW5kIG1hbmlmZXN0czwvYj48YnIgLz5cblx0ICogQWRkIGZpbGVzIHlvdSB3YW50IHRvIGxvYWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBhXG5cdCAqIHRpbWUgdXNpbmcgYSBsaXN0IG9yIGEgbWFuaWZlc3QgZGVmaW5pdGlvbiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBGaWxlcyBhcmVcblx0ICogYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYWN0aXZlIHF1ZXVlLCBzbyB5b3UgY2FuIHVzZSB0aGVzZSBtZXRob2RzIGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UsIHdoZW5ldmVyIHlvdVxuXHQgKiBsaWtlLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKFwiZmlsZVBhdGgvZmlsZS5qcGdcIik7XG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn0pO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXCJmaWxlUGF0aC9maWxlLmpwZ1wiLCB7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifV0pO1xuXHQgKlxuXHQgKiAgICAgIC8vIFVzZSBhbiBleHRlcm5hbCBtYW5pZmVzdFxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChcInBhdGgvdG8vbWFuaWZlc3QuanNvblwiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3Qoe3NyYzpcIm1hbmlmZXN0Lmpzb25cIiwgdHlwZTpcIm1hbmlmZXN0XCJ9KTtcblx0ICpcblx0ICogSWYgeW91IHBhc3MgYGZhbHNlYCBhcyB0aGUgYGxvYWROb3dgIHBhcmFtZXRlciwgdGhlIHF1ZXVlIHdpbGwgbm90IGtpY2sgb2YgdGhlIGxvYWQgb2YgdGhlIGZpbGVzLCBidXQgaXQgd2lsbCBub3Rcblx0ICogc3RvcCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuIENhbGwgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvIGJlZ2luXG5cdCAqIGEgcGF1c2VkIHF1ZXVlLiBOb3RlIHRoYXQgYSBwYXVzZWQgcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc3VtZSB3aGVuIG5ldyBmaWxlcyBhcmUgYWRkZWQgdG8gaXQgd2l0aCBhXG5cdCAqIGBsb2FkTm93YCBhcmd1bWVudCBvZiBgdHJ1ZWAuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiA8Yj5GaWxlIFR5cGVzPC9iPjxiciAvPlxuXHQgKiBUaGUgZmlsZSB0eXBlIG9mIGEgbWFuaWZlc3QgaXRlbSBpcyBhdXRvLWRldGVybWluZWQgYnkgdGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGUgcGF0dGVybiBtYXRjaGluZyBpbiBQcmVsb2FkSlNcblx0ICogc2hvdWxkIGhhbmRsZSB0aGUgbWFqb3JpdHkgb2Ygc3RhbmRhcmQgZmlsZSBhbmQgdXJsIGZvcm1hdHMsIGFuZCB3b3JrcyB3aXRoIGNvbW1vbiBmaWxlIGV4dGVuc2lvbnMuIElmIHlvdSBoYXZlXG5cdCAqIGVpdGhlciBhIG5vbi1zdGFuZGFyZCBmaWxlIGV4dGVuc2lvbiwgb3IgYXJlIHNlcnZpbmcgdGhlIGZpbGUgdXNpbmcgYSBwcm94eSBzY3JpcHQsIHRoZW4geW91IGNhbiBwYXNzIGluIGFcblx0ICogPGNvZGU+dHlwZTwvY29kZT4gcHJvcGVydHkgd2l0aCBhbnkgbWFuaWZlc3QgaXRlbS5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwicGF0aC90by9teUZpbGUubXAzeFwiLCB0eXBlOmNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EfSk7XG5cdCAqXG5cdCAqICAgICAgLy8gTm90ZSB0aGF0IFByZWxvYWRKUyB3aWxsIG5vdCByZWFkIGEgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcImh0dHA6Ly9zZXJ2ZXIuY29tL3Byb3h5P2ZpbGU9aW1hZ2UuanBnXCIsIHR5cGU6Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0V9KTtcblx0ICpcblx0ICogU3VwcG9ydGVkIHR5cGVzIGFyZSBkZWZpbmVkIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYW5kIGluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFJhdyBiaW5hcnkgZGF0YSB2aWEgWEhSPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENTUyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IENvbW1vbiBpbWFnZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKYXZhU2NyaXB0IGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGRhdGE8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIGZpbGVzIGNyb3NzLWRvbWFpbjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEEgbGlzdCBvZiBmaWxlcyB0byBsb2FkIGluIEpTT04gZm9ybWF0LCBzZWVcblx0ICogICAgIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU09VTkQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEF1ZGlvIGZpbGUgZm9ybWF0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gU3ByaXRlU2hlZXQgZGVmaW5pdGlvbnMuIFRoaXNcblx0ICogICAgIHdpbGwgYWxzbyBsb2FkIHN1Yi1pbWFnZXMsIGFuZCBwcm92aWRlIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFNWRyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBWaWRlbyBvYmplY3RzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFhNTCBkYXRhPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGVtPk5vdGU6IExvYWRlciB0eXBlcyB1c2VkIHRvIGJlIGRlZmluZWQgb24gTG9hZFF1ZXVlLCBidXQgaGF2ZSBiZWVuIG1vdmVkIHRvIEFic3RyYWN0TG9hZGVyIGZvciBiZXR0ZXJcblx0ICogcG9ydGFiaWxpdHkgb2YgbG9hZGVyIGNsYXNzZXMsIHdoaWNoIGNhbiBiZSB1c2VkIGluZGl2aWR1YWxseSBub3cuIFRoZSBwcm9wZXJ0aWVzIG9uIExvYWRRdWV1ZSBzdGlsbCBleGlzdCwgYnV0XG5cdCAqIGFyZSBkZXByZWNhdGVkLjwvZW0+XG5cdCAqXG5cdCAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG5cdCAqIFdoZW4gYSBmaWxlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBpc1xuXHQgKiBkaXNwYXRjaGVkLiBJbiBhbiBleGFtcGxlIGFib3ZlLCB0aGVyZSBpcyBhbiBldmVudCBsaXN0ZW5lciBzbmlwcGV0IGZvciBmaWxlbG9hZC4gTG9hZGVkIGZpbGVzIGFyZSB1c3VhbGx5IGFcblx0ICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CaW5hcnk6IFRoZSBiaW5hcnkgbG9hZGVkIHJlc3VsdDwvbGk+XG5cdCAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2U6IEFuICZsdDtpbWcgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KYXZhU2NyaXB0OiBBICZsdDtzY3JpcHQgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG5cdCAqICAgICA8bGk+TWFuaWZlc3Q6IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqICAgICA8bGk+U291bmQ6IEFuICZsdDthdWRpbyAvJmd0OyB0YWc8L2E+XG5cdCAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cblx0ICogICAgIDxsaT5TVkc6IEFuICZsdDtvYmplY3QgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5UZXh0OiBSYXcgdGV4dDwvbGk+XG4gICAgICogICAgIDxsaT5WaWRlbzogQSBWaWRlbyBET00gbm9kZTwvbGk+XG5cdCAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIHZhciBpdGVtID0gZXZlbnQuaXRlbTsgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIHRvIHRoZSBMb2FkUXVldWVcblx0ICogICAgICAgICAgdmFyIHR5cGUgPSBpdGVtLnR5cGU7XG5cdCAqXG5cdCAqICAgICAgICAgIC8vIEFkZCBhbnkgaW1hZ2VzIHRvIHRoZSBwYWdlIGJvZHkuXG5cdCAqICAgICAgICAgIGlmICh0eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSkge1xuXHQgKiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChldmVudC5yZXN1bHQpO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBBdCBhbnkgdGltZSBhZnRlciB0aGUgZmlsZSBoYXMgYmVlbiBsb2FkZWQgKHVzdWFsbHkgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQpLCBhbnkgcmVzdWx0IGNhbiBiZSBsb29rZWQgdXBcblx0ICogdmlhIGl0cyBcImlkXCIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS4gSWYgbm8gaWQgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZVxuXHQgKiBcInNyY1wiIG9yIGZpbGUgcGF0aCBjYW4gYmUgdXNlZCBpbnN0ZWFkLCBpbmNsdWRpbmcgdGhlIGBwYXRoYCBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QsIGJ1dCA8c3Ryb25nPm5vdCBpbmNsdWRpbmc8L3N0cm9uZz5cblx0ICogYSBiYXNlIHBhdGggZGVmaW5lZCBvbiB0aGUgTG9hZFF1ZXVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhbHdheXMgcGFzcyBhbiBpZCBpZiB5b3Ugd2FudCB0byBsb29rIHVwIGNvbnRlbnQuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIik7XG5cdCAqICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZSk7XG5cdCAqXG5cdCAqIFJhdyBsb2FkZWQgY29udGVudCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlIDxjb2RlPnJhd1Jlc3VsdDwvY29kZT4gcHJvcGVydHkgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCwgb3IgY2FuIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBwYXNzaW5nIGB0cnVlYCBhcyB0aGUgMm5kXG5cdCAqIGFyZ3VtZW50LiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY29udGVudCB0aGF0IGhhcyBiZWVuIHBhcnNlZCBmb3IgdGhlIGJyb3dzZXIsIHNwZWNpZmljYWxseTogSmF2YVNjcmlwdCxcblx0ICogQ1NTLCBYTUwsIFNWRywgYW5kIEpTT04gb2JqZWN0cywgb3IgYW55dGhpbmcgbG9hZGVkIHdpdGggWEhSLlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIsIHRydWUpOyAvLyBsb2FkIHRoZSBiaW5hcnkgaW1hZ2UgZGF0YSBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIExvYWRRdWV1ZSBoYXMgYSBzaW1wbGUgcGx1Z2luIGFyY2hpdGVjdHVyZSB0byBoZWxwIHByb2Nlc3MgYW5kIHByZWxvYWQgY29udGVudC4gRm9yIGV4YW1wbGUsIHRvIHByZWxvYWQgYXVkaW8sXG5cdCAqIG1ha2Ugc3VyZSB0byBpbnN0YWxsIHRoZSA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4gU291bmQgY2xhc3MsIHdoaWNoIHdpbGwgaGVscCBsb2FkIEhUTUwgYXVkaW8sXG5cdCAqIEZsYXNoIGF1ZGlvLCBhbmQgV2ViQXVkaW8gZmlsZXMuIFRoaXMgc2hvdWxkIGJlIGluc3RhbGxlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPiBsb2FkaW5nIGFueSBhdWRpbyBmaWxlcy5cblx0ICpcblx0ICogICAgICBxdWV1ZS5pbnN0YWxsUGx1Z2luKGNyZWF0ZWpzLlNvdW5kKTtcblx0ICpcblx0ICogPGg0Pktub3duIEJyb3dzZXIgSXNzdWVzPC9oND5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJyb3dzZXJzIHdpdGhvdXQgYXVkaW8gc3VwcG9ydCBjYW4gbm90IGxvYWQgYXVkaW8gZmlsZXMuPC9saT5cblx0ICogICAgIDxsaT5TYWZhcmkgb24gTWFjIE9TIFggY2FuIG9ubHkgcGxheSBIVE1MIGF1ZGlvIGlmIFF1aWNrVGltZSBpcyBpbnN0YWxsZWQ8L2xpPlxuXHQgKiAgICAgPGxpPkhUTUwgQXVkaW8gdGFncyB3aWxsIG9ubHkgZG93bmxvYWQgdW50aWwgdGhlaXIgPGNvZGU+Y2FuUGxheVRocm91Z2g8L2NvZGU+IGV2ZW50IGlzIGZpcmVkLiBCcm93c2VycyBvdGhlclxuXHQgKiAgICAgdGhhbiBDaHJvbWUgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiAgICAgPGxpPldoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LjwvbGk+XG5cdCAqICAgICA8bGk+U2NyaXB0cyBsb2FkZWQgdmlhIFhIUiBtYXkgbm90IGJlIHByb3Blcmx5IGluc3BlY3RhYmxlIHdpdGggYnJvd3NlciB0b29scy48L2xpPlxuXHQgKiAgICAgPGxpPklFNiBhbmQgSUU3IChhbmQgc29tZSBvdGhlciBicm93c2VycykgbWF5IG5vdCBiZSBhYmxlIHRvIGxvYWQgWE1MLCBUZXh0LCBvciBKU09OLCBzaW5jZSB0aGV5IHJlcXVpcmVcblx0ICogICAgIFhIUiB0byB3b3JrLjwvbGk+XG5cdCAqICAgICA8bGk+Q29udGVudCBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBub3Qgc2hvdyBwcm9ncmVzcywgYW5kIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQgd2hlblxuXHQgKiAgICAgY2FuY2VsZWQsIGFsdGhvdWdoIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQGNsYXNzIExvYWRRdWV1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFI9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcmVsb2FkIGluc3RhbmNlIHdpbGwgZmF2b3IgbG9hZGluZyB3aXRoIFhIUiAoWE1MIEhUVFBcblx0ICogUmVxdWVzdHMpLCBvciBIVE1MIHRhZ3MuIFdoZW4gdGhpcyBpcyBgZmFsc2VgLCB0aGUgcXVldWUgd2lsbCB1c2UgdGFnIGxvYWRpbmcgd2hlbiBwb3NzaWJsZSwgYW5kIGZhbGwgYmFjayBvbiBYSFJcblx0ICogd2hlbiBuZWNlc3NhcnkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGg9XCJcIl0gQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIHNvdXJjZSBwYXJhbWV0ZXIgb2YgYWxsIGl0ZW1zIGluIHRoZSBxdWV1ZVxuXHQgKiBiZWZvcmUgdGhleSBhcmUgbG9hZGVkLiAgU291cmNlcyBiZWdpbm5pbmcgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gXG5cdCAqIHdpbGwgbm90IHJlY2VpdmUgYSBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpbj1cIlwiXSBBbiBvcHRpb25hbCBmbGFnIHRvIHN1cHBvcnQgaW1hZ2VzIGxvYWRlZCBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlci4gVG9cblx0ICogdXNlIGl0LCBzZXQgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIHdoaWNoIHdpbGwgZGVmYXVsdCB0aGUgY3Jvc3NPcmlnaW4gcHJvcGVydHkgb24gaW1hZ2VzIHRvIFwiQW5vbnltb3VzXCIuIEFueVxuXHQgKiBzdHJpbmcgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCwgYnV0IG9ubHkgXCJcIiBhbmQgXCJBbm9ueW1vdXNcIiBhcmUgcmVjb21tZW5kZWQuIDxzdHJvbmc+Tm90ZTogVGhlIGNyb3NzT3JpZ2luXG5cdCAqIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLiBVc2UgTG9hZEl0ZW0uY3Jvc3NPcmlnaW4gaW5zdGVhZDwvc3Ryb25nPlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRRdWV1ZSAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIHR5cGUgYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3R5cGVDYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdHlwZUNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgZXh0ZW5zaW9uIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuXHRcdCAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9leHRlbnNpb25DYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5leHQgcHJlbG9hZCBxdWV1ZSB0byBwcm9jZXNzIHdoZW4gdGhpcyBvbmUgaXMgY29tcGxldGUuIElmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY3VycmVudCBxdWV1ZSwgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIGB0cnVlYCwgdGhlIG5leHQgcXVldWUgd2lsbCBub3QgYmUgcHJvY2Vzc2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBuZXh0XG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuc3VyZSBsb2FkZWQgc2NyaXB0cyBcImNvbXBsZXRlXCIgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHNwZWNpZmllZC4gTG9hZGVkIHNjcmlwdHMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkXG5cdFx0ICogb25jZSB0aGV5IGFyZSBsb2FkZWQuIFNjcmlwdHMgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbG9hZCBvbmUtYXQtYS10aW1lIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIHdoZXJlYXNcblx0XHQgKiBzY3JpcHRzIGxvYWRlZCB1c2luZyBYSFIgY2FuIGxvYWQgaW4gYW55IG9yZGVyLCBidXQgd2lsbCBcImZpbmlzaFwiIGFuZCBiZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgaW4gdGhlIG9yZGVyXG5cdFx0ICogc3BlY2lmaWVkLlxuXHRcdCAqXG5cdFx0ICogQW55IGl0ZW1zIGNhbiBiZSBzZXQgdG8gbG9hZCBpbiBvcmRlciBieSBzZXR0aW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJtYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogcHJvcGVydHkgb24gdGhlIGxvYWQgaXRlbSwgb3IgYnkgZW5zdXJpbmcgdGhhdCBvbmx5IG9uZSBjb25uZWN0aW9uIGNhbiBiZSBvcGVuIGF0IGEgdGltZSB1c2luZ1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHdoZW4gdGhlIGBtYWludGFpblNjcmlwdE9yZGVyYCBwcm9wZXJ0eVxuXHRcdCAqIGlzIHNldCB0byBgdHJ1ZWAsIHNjcmlwdHMgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBtYWludGFpbk9yZGVyPXRydWVgLCBhbmQgY2hhbmdpbmcgdGhlXG5cdFx0ICogYG1haW50YWluU2NyaXB0T3JkZXJgIHRvIGBmYWxzZWAgZHVyaW5nIGEgbG9hZCB3aWxsIG5vdCBjaGFuZ2UgaXRlbXMgYWxyZWFkeSBpbiBhIHF1ZXVlLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygzKTsgLy8gU2V0IGEgaGlnaGVyIG51bWJlciB0byBsb2FkIG11bHRpcGxlIGl0ZW1zIGF0IG9uY2Vcblx0XHQgKiAgICAgIHF1ZXVlLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlOyAvLyBFbnN1cmUgc2NyaXB0cyBhcmUgbG9hZGVkIGluIG9yZGVyXG5cdFx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuXHRcdCAqICAgICAgICAgIFwic2NyaXB0MS5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwic2NyaXB0Mi5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwiaW1hZ2UucG5nXCIsIC8vIExvYWQgYW55IHRpbWVcblx0XHQgKiAgICAgICAgICB7c3JjOiBcImltYWdlMi5wbmdcIiwgbWFpbnRhaW5PcmRlcjogdHJ1ZX0gLy8gV2lsbCB3YWl0IGZvciBzY3JpcHQyLmpzXG5cdFx0ICogICAgICAgICAgXCJpbWFnZTMucG5nXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQzLmpzXCIgLy8gV2lsbCB3YWl0IGZvciBpbWFnZTIucG5nIGJlZm9yZSBsb2FkaW5nIChvciBjb21wbGV0aW5nIHdoZW4gbG9hZGluZyB3aXRoIFhIUilcblx0XHQgKiAgICAgIF0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluU2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpblNjcmlwdE9yZGVyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIExvYWRRdWV1ZSB3aWxsIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBxdWV1ZSB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdG9wT25FcnJvclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5zdG9wT25FcnJvciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBtYXhpbXVtIG9wZW4gY29ubmVjdGlvbnMgdGhhdCBhIGxvYWRRdWV1ZSB0cmllcyB0byBtYWludGFpbi4gUGxlYXNlIHNlZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX21heENvbm5lY3Rpb25zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBsaXN0IG9mIGFsbCB0aGUgZGVmYXVsdCBMb2FkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggUHJlbG9hZEpTLiBCZWZvcmUgYW4gaXRlbSBpcyBsb2FkZWQsIHRoZVxuXHRcdCAqIGF2YWlsYWJsZSBsb2FkZXIgbGlzdCBpcyBpdGVyYXRlZCwgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGluY2x1ZGVkLCBhbmQgYXMgc29vbiBhcyBhIGxvYWRlciBpbmRpY2F0ZXMgaXQgY2FuXG5cdFx0ICogaGFuZGxlIHRoZSBjb250ZW50LCBpdCB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgZGVmYXVsdCBsb2FkZXIsICh7eyNjcm9zc0xpbmsgXCJUZXh0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzXG5cdFx0ICogbGFzdCBpbiB0aGUgbGlzdCwgc28gaXQgd2lsbCBiZSB1c2VkIGlmIG5vIG90aGVyIG1hdGNoIGlzIGZvdW5kLiBUeXBpY2FsbHksIGxvYWRlcnMgd2lsbCBtYXRjaCBiYXNlZCBvbiB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQgdXNpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIG9mXG5cdFx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKlxuXHRcdCAqIExvYWRlcnMgY2FuIGJlIHJlbW92ZWQgZnJvbSBQcmVsb2FkSlMgYnkgc2ltcGx5IG5vdCBpbmNsdWRpbmcgdGhlbS5cblx0XHQgKlxuXHRcdCAqIEN1c3RvbSBsb2FkZXJzIGluc3RhbGxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGlzIGxpc3Rcblx0XHQgKiBzbyB0aGF0IHRoZXkgYXJlIGNoZWNrZWQgZmlyc3QuXG5cdFx0ICogQHByb3BlcnR5IF9hdmFpbGFibGVMb2FkZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycyA9IFtcblx0XHRcdGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkNTU0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OUExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlhNTExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNWR0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVGV4dExvYWRlclxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGJ1aWx0IGluIGxvYWRlcnMsIHNvIHRoZXkgY2FuJ3QgYmUgcmVtb3ZlZCBieSB7eyNjcm9zc0xpbmsgXCJ1bnJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua30uXG5cdFx0XHRcdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdExvYWRlckxlbmd0aFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7XG5cblx0XHR0aGlzLmluaXQocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZFF1ZXVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTG9hZFF1ZXVlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHQvKipcblx0ICogQW4gaW50ZXJuYWwgaW5pdGlhbGl6YXRpb24gbWV0aG9kLCB3aGljaCBpcyB1c2VkIGZvciBpbml0aWFsIHNldCB1cCwgYnV0IGFsc28gdG8gcmVzZXQgdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIGJhc2VQYXRoXG5cdCAqIEBwYXJhbSBjcm9zc09yaWdpblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5pbml0ID0gZnVuY3Rpb24gKHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKSB7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSB1c2VYSFJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlclhIUiBpbnN0ZWFkLlxuXHRcdCAqL1xuXHRcdHRoaXMudXNlWEhSID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRyeSBhbmQgdXNlIFhNTEh0dHBSZXF1ZXN0IChYSFIpIHdoZW4gcG9zc2libGUuIE5vdGUgdGhhdCBMb2FkUXVldWUgd2lsbCBkZWZhdWx0IHRvIHRhZyBsb2FkaW5nIG9yIFhIUlxuXHRcdCAqIGxvYWRpbmcgZGVwZW5kaW5nIG9uIHRoZSByZXF1aXJlbWVudHMgZm9yIGEgbWVkaWEgdHlwZS4gRm9yIGV4YW1wbGUsIEhUTUwgYXVkaW8gY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCBYSFIsXG5cdFx0ICogYW5kIHBsYWluIHRleHQgY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCB0YWdzLCBzbyBpdCB3aWxsIGRlZmF1bHQgdGhlIHRoZSBjb3JyZWN0IHR5cGUgaW5zdGVhZCBvZiB1c2luZyB0aGVcblx0XHQgKiB1c2VyLWRlZmluZWQgdHlwZS5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSB0cnVlOyAvL1RPRE86IEdldC9TZXRcblx0XHR0aGlzLl9wcmVmZXJYSFIgPSB0cnVlO1xuXHRcdHRoaXMuc2V0UHJlZmVyWEhSKHByZWZlclhIUik7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBwYXVzZWQgb3Igbm90LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIG9uIHRvIHRoZSBpdGVtJ3Mge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LiBUaGVcblx0XHQgKiBgX2Jhc2VQYXRoYCBwcm9wZXJ0eSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBhbiBpdGVtJ3Mgc291cmNlIGlzIHJlbGF0aXZlLCBhbmQgZG9lcyBub3QgaW5jbHVkZSBhIHByb3RvY29sIHN1Y2hcblx0XHQgKiBhcyBgaHR0cDovL2AsIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYmFzZVBhdGhcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuMy4xXG5cdFx0ICovXG5cdFx0dGhpcy5fYmFzZVBhdGggPSBiYXNlUGF0aDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9wdGlvbmFsIGZsYWcgdG8gc2V0IG9uIGltYWdlcyB0aGF0IGFyZSBsb2FkZWQgdXNpbmcgUHJlbG9hZEpTLCB3aGljaCBlbmFibGVzIENPUlMgc3VwcG9ydC4gSW1hZ2VzIGxvYWRlZFxuXHRcdCAqIGNyb3NzLWRvbWFpbiBieSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBDT1JTIHJlcXVpcmUgdGhlIGNyb3NzT3JpZ2luIGZsYWcgdG8gYmUgbG9hZGVkIGFuZCBpbnRlcmFjdGVkIHdpdGggYnlcblx0XHQgKiBhIGNhbnZhcy4gV2hlbiBsb2FkaW5nIGxvY2FsbHksIG9yIHdpdGggYSBzZXJ2ZXIgd2l0aCBubyBDT1JTIHN1cHBvcnQsIHRoaXMgZmxhZyBjYW4gY2F1c2Ugb3RoZXIgc2VjdXJpdHkgaXNzdWVzLFxuXHRcdCAqIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIG9ubHkgc2V0IGl0IGlmIHlvdSBhcmUgc3VyZSB0aGUgc2VydmVyIHN1cHBvcnRzIGl0LiBDdXJyZW50bHksIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIFwiXCJcblx0XHQgKiBhbmQgXCJBbm9ueW1vdXNcIi5cblx0XHQgKiBAcHJvcGVydHkgX2Nyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC40LjFcblx0XHQgKi9cblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZFN0YXJ0IGV2ZW50IHdhcyBkaXNwYXRjaGVkIGFscmVhZHkuIFRoaXMgZXZlbnQgaXMgb25seSBmaXJlZCBvbmUgdGltZSwgd2hlbiB0aGUgZmlyc3Rcblx0XHQgKiBmaWxlIGlzIHJlcXVlc3RlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBzY3JpcHQgbG9hZGluZy4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBvbmx5IGEgc2luZ2xlIHNjcmlwdCBsb2FkcyBhdCBvbmNlIHdoZW5cblx0XHQgKiB1c2luZyBhIHNjcmlwdCB0YWcgdG8gZG8gcHJlbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudGx5IGRvd25sb2FkaW5nIGZpbGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudExvYWRzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudExvYWRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBxdWV1ZWQgaXRlbXMgdGhhdCBoYXZlIG5vdCB5ZXQgc3RhcnRlZCBkb3dubG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRRdWV1ZVxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyBkb3dubG9hZHMgdGhhdCBoYXZlIG5vdCBjb21wbGV0ZWQsIHNvIHRoYXQgdGhlIExvYWRRdWV1ZSBjYW4gYmUgcHJvcGVybHkgcmVzZXQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVCYWNrdXBcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBpZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5SWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZCA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaXRlbXMgdGhhdCBoYXZlIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBpbmRleGVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogc291cmNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zQnlTcmNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiB1bi1wYXJzZWQgbG9hZGVkIGl0ZW1zLCBpbmRleGVkIGJ5IHRoZSBJRCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRSYXdSZXN1bHRzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgaXRlbXMgaW5zaWRlIG9mIGxvYWRlcnMgc3VjaCBhcyB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBjb21wbGV0ZWQgbG9hZGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtSXRlbXNMb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBzY3JpcHRzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWVzdGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHNjcmlwdHMgYXJlIFwiY29tcGxldGVkXCIgaW4gdGhlIHJpZ2h0XG5cdFx0ICogb3JkZXIuXG5cdFx0ICogQHByb3BlcnR5IF9zY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3NjcmlwdE9yZGVyID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEl0ZW1zIGFyZSBhZGRlZCB0byB0aGlzIGxpc3QgYXMgPGNvZGU+bnVsbDwvY29kZT4gd2hlbiB0aGV5IGFyZVxuXHRcdCAqIHJlcXVlc3RlZCwgY29udGFpbiB0aGUgbG9hZGVkIGl0ZW0gaWYgaXQgaGFzIGNvbXBsZXRlZCwgYnV0IG5vdCBiZWVuIGRpc3BhdGNoZWQgdG8gdGhlIHVzZXIsIGFuZCA8Y29kZT50cnVlPC90cnVlPlxuXHRcdCAqIG9uY2UgdGhleSBhcmUgY29tcGxldGUgYW5kIGhhdmUgYmVlbiBkaXNwYXRjaGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkU2NyaXB0c1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IHByb2dyZXNzIGFtb3VudC4gVGhpcyBpcyB1c2VkIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBwcm9ncmVzcyBldmVudHMuXG5cdFx0ICogQHByb3BlcnR5IF9sYXN0UHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuXG5cdH07XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQgYmVmb3JlIGFueSBkYXRhIGlzIHJlY2VpdmVkLlxuXHQgKiBAcHJvcGVydHkgbG9hZFRpbWVvdXRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgODAwMFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBJbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vTE9BRF9USU1FT1VUX0RFRkFVTFQ6cHJvcGVydHl9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5sb2FkVGltZW91dCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhc3N1bWUgYSBsb2FkIGhhcyBmYWlsZWQuXG5cdCAqIEBwcm9wZXJ0eSBMT0FEX1RJTUVPVVRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRUaW1lb3V0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVQgPSAwO1xuXG4vLyBQcmVsb2FkIFR5cGVzXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgQklOQVJZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGJpbmFyeVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkJJTkFSWSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5DU1MgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLklNQUdFID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTiA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OUFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29ucFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTlAgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuTUFOSUZFU1QgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNPVU5EID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5WSURFTyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNWRyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFRFWFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5URVhUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFhNTFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB4bWxcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5YTUwgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBQT1NUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvUE9TVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5QT1NUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEdFVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5HRVQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQ7XG5cbi8vIGV2ZW50c1xuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGluZGl2aWR1YWwgZmlsZSBoYXMgbG9hZGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIEhUTUwgdGFnIG9yIHBhcnNlZCByZXN1bHQgb2YgdGhlIGxvYWRlZCBpdGVtLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3UmVzdWx0IFRoZSB1bnByb2Nlc3NlZCByZXN1bHQsIHVzdWFsbHkgdGhlIHJhdyB0ZXh0IG9yIGJpbmFyeSBkYXRhIGJlZm9yZSBpdCBpcyBjb252ZXJ0ZWRcblx0ICogdG8gYSB1c2FibGUgb2JqZWN0LlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYW4gYW4gaW5kaXZpZHVhbCBmaWxlJ3MgcHJvZ3Jlc3MgY2hhbmdlcy5cblx0ICogQGV2ZW50IGZpbGVwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgc3RhcnRzIHRvIGxvYWQuXG5cdCAqIEBldmVudCBmaWxlc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgcHJvcGVydHkuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBbHRob3VnaCBpdCBleHRlbmRzIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCB0aGUgYGluaXRpYWxpemVgIGV2ZW50IGlzIG5ldmVyIGZpcmVkIGZyb21cblx0ICogYSBMb2FkUXVldWUgaW5zdGFuY2UuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjdXN0b20gbG9hZGVycyBjbGFzcy4gTmV3IGxvYWRlcnMgYXJlIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXJzIGFkZGVkIGVhcmxpZXIgYW5kIGRlZmF1bHQgbG9hZGVycy5cblx0ICogSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBsb2FkZXJzIGV4dGVuZCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gTG9hZGVycyBjYW4gb25seSBiZSBhZGRlZFxuXHQgKiBvbmNlLCBhbmQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGxvYWRlcnMuXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJMb2FkZXJcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byBhZGQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAoIWxvYWRlciB8fCAhbG9hZGVyLmNhbkxvYWRJdGVtKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgaXMgb2YgYW4gaW5jb3JyZWN0IHR5cGUuXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fYXZhaWxhYmxlTG9hZGVycy5pbmRleE9mKGxvYWRlcikgIT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxvYWRlciBhbHJlYWR5IGV4aXN0cy5cIik7IC8vTE06IE1heWJlIGp1c3Qgc2lsZW50bHkgZmFpbCBoZXJlXG5cdFx0fVxuXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycy51bnNoaWZ0KGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGN1c3RvbSBsb2FkZXIgYWRkZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIE9ubHkgY3VzdG9tIGxvYWRlcnMgY2FuIGJlXG5cdCAqIHVucmVnaXN0ZXJlZCwgdGhlIGRlZmF1bHQgbG9hZGVycyB3aWxsIGFsd2F5cyBiZSBhdmFpbGFibGUuXG5cdCAqIEBtZXRob2QgdW5yZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIHJlbW92ZVxuXHQgKi9cblx0cC51bnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBpZHggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKTtcblx0XHRpZiAoaWR4ICE9IC0xICYmIGlkeCA8IHRoaXMuX2RlZmF1bHRMb2FkZXJMZW5ndGggLSAxKSB7XG5cdFx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzZXRVc2VYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHVzZVhIUiB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBuZXcgdXNlWEhSIHZhbHVlLiBJZiBYSFIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHJldHVybiBmYWxzZSwgZXZlbiBpZlxuXHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUgYXJndW1lbnQgd2FzIHRydWUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHksIG9yIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0VXNlWEhSXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5zZXRVc2VYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRQcmVmZXJYSFIodmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgaXQgbWF5XG5cdCAqIGZhaWwsIG9yIGJlIGlnbm9yZWQgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyJ3MgY2FwYWJpbGl0aWVzIGFuZCB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAbWV0aG9kIHNldFByZWZlclhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUaGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBzZXQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRQcmVmZXJYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBEZXRlcm1pbmUgaWYgd2UgY2FuIHVzZSBYSFIuIFhIUiBkZWZhdWx0cyB0byBUUlVFLCBidXQgdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlxuXHRcdC8vVE9ETzogU2hvdWxkIHdlIGJlIGNoZWNraW5nIGZvciB0aGUgb3RoZXIgWEhSIHR5cGVzPyBNaWdodCBoYXZlIHRvIGRvIGEgdHJ5L2NhdGNoIG9uIHRoZSBkaWZmZXJlbnQgdHlwZXMgc2ltaWxhciB0byBjcmVhdGVYSFIuXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSAodmFsdWUgIT0gZmFsc2UgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9IG51bGwpO1xuXHRcdHJldHVybiB0aGlzLnByZWZlclhIUjtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIHF1ZXVlZCBhbmQgbG9hZGluZyBpdGVtcywgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgYWxzbyByZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZFxuXHQgKiBjb250ZW50LCBhbmQgYWxsb3dzIHRoZSBxdWV1ZSB0byBiZSB1c2VkIGFnYWluLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFuIGl0ZW0gZnJvbSBiZWluZyBsb2FkZWQsIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHBhc3NlZCwgYWxsIGl0ZW1zIGFyZSByZW1vdmVkLlxuXHQgKiBUaGlzIGFsc28gcmVtb3ZlcyBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZCBpdGVtKHMpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcblx0ICogICAgICAgICAge3NyYzpcInRlc3QucG5nXCIsIGlkOlwicG5nXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5qcGdcIiwgaWQ6XCJqcGdcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0Lm1wM1wiLCBpZDpcIm1wM1wifVxuXHQgKiAgICAgIF0pO1xuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShcInBuZ1wiKTsgLy8gU2luZ2xlIGl0ZW0gYnkgSURcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIiwgXCJ0ZXN0LmpwZ1wiKTsgLy8gSXRlbXMgYXMgYXJndW1lbnRzLiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShbXCJ0ZXN0LnBuZ1wiLCBcImpwZ1wiXSk7IC8vIEl0ZW1zIGluIGFuIEFycmF5LiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBpZHNPclVybHMqIFRoZSBpZCBvciBpZHMgdG8gcmVtb3ZlIGZyb20gdGhpcyBxdWV1ZS4gWW91IGNhbiBwYXNzIGFuIGl0ZW0sIGFuIGFycmF5IG9mXG5cdCAqIGl0ZW1zLCBvciBtdWx0aXBsZSBpdGVtcyBhcyBhcmd1bWVudHMuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbiAoaWRzT3JVcmxzKSB7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXG5cdFx0aWYgKGlkc09yVXJscyAmJiAhQXJyYXkuaXNBcnJheShpZHNPclVybHMpKSB7XG5cdFx0XHRhcmdzID0gW2lkc09yVXJsc107XG5cdFx0fSBlbHNlIGlmIChpZHNPclVybHMpIHtcblx0XHRcdGFyZ3MgPSBpZHNPclVybHM7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpdGVtc1dlcmVSZW1vdmVkID0gZmFsc2U7XG5cblx0XHQvLyBEZXN0cm95IGV2ZXJ5dGhpbmdcblx0XHRpZiAoIWFyZ3MpIHtcblx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLl9sb2FkSXRlbXNCeUlkW25dKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5pdCh0aGlzLnByZWZlclhIUiwgdGhpcy5fYmFzZVBhdGgpO1xuXG5cdFx0XHQvLyBSZW1vdmUgc3BlY2lmaWMgaXRlbXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gYXJncy5wb3AoKTtcblx0XHRcdFx0dmFyIHIgPSB0aGlzLmdldFJlc3VsdChpdGVtKTtcblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBtYWluIGxvYWQgUXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9SZW1vdmUgZnJvbSB0aGUgYmFja3VwIHF1ZXVlXG5cdFx0XHRcdGZvciAoaSA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5nZXRJdGVtKGl0ZW0pKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdFx0aXRlbXNXZXJlUmVtb3ZlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBjYWxsZWQgZHVyaW5nIGEgbG9hZCwgdHJ5IHRvIGxvYWQgdGhlIG5leHQgaXRlbS5cblx0XHRcdGlmIChpdGVtc1dlcmVSZW1vdmVkKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbGwgb3BlbiBsb2FkcywgZGVzdHJveXMgYW55IGxvYWRlZCBpdGVtcywgYW5kIHJlc2V0cyB0aGUgcXVldWUsIHNvIGFsbCBpdGVtcyBjYW5cblx0ICogYmUgcmVsb2FkZWQgYWdhaW4gYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319LiBJdGVtcyBhcmUgbm90IHJlbW92ZWQgZnJvbSB0aGVcblx0ICogcXVldWUuIFRvIHJlbW92ZSBpdGVtcyB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZUFsbFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdH1cblxuXHRcdC8vUmVzZXQgdGhlIHF1ZXVlIHRvIGl0cyBzdGFydCBzdGF0ZVxuXHRcdHZhciBhID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRhLnB1c2godGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5sb2FkTWFuaWZlc3QoYSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIHBsdWdpbi4gUGx1Z2lucyBjYW4gbWFwIHRvIGxvYWQgdHlwZXMgKHNvdW5kLCBpbWFnZSwgZXRjKSwgb3Igc3BlY2lmaWMgZXh0ZW5zaW9ucyAocG5nLCBtcDMsIGV0YykuXG5cdCAqIEN1cnJlbnRseSwgb25seSBvbmUgcGx1Z2luIGNhbiBleGlzdCBwZXIgdHlwZS9leHRlbnNpb24uXG5cdCAqXG5cdCAqIFdoZW4gYSBwbHVnaW4gaXMgaW5zdGFsbGVkLCBhIDxjb2RlPmdldFByZWxvYWRIYW5kbGVycygpPC9jb2RlPiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gaXQuIEZvciBtb3JlIGluZm9ybWF0aW9uXG5cdCAqIG9uIHRoaXMgbWV0aG9kLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9nZXRQcmVsb2FkSGFuZGxlcnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG5cdCAqXG5cdCAqIEJlZm9yZSBhIGZpbGUgaXMgbG9hZGVkLCBhIG1hdGNoaW5nIHBsdWdpbiBoYXMgYW4gb3Bwb3J0dW5pdHkgdG8gbW9kaWZ5IHRoZSBsb2FkLiBJZiBhIGBjYWxsYmFja2AgaXMgcmV0dXJuZWRcblx0ICogZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGl0IHdpbGwgYmUgaW52b2tlZCBmaXJzdCwgYW5kIGl0c1xuXHQgKiByZXN1bHQgbWF5IGNhbmNlbCBvciBtb2RpZnkgdGhlIGl0ZW0uIFRoZSBjYWxsYmFjayBtZXRob2QgY2FuIGFsc28gcmV0dXJuIGEgYGNvbXBsZXRlSGFuZGxlcmAgdG8gYmUgZmlyZWQgd2hlblxuXHQgKiB0aGUgZmlsZSBpcyBsb2FkZWQsIG9yIGEgYHRhZ2Agb2JqZWN0LCB3aGljaCB3aWxsIG1hbmFnZSB0aGUgYWN0dWFsIGRvd25sb2FkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZVxuXHQgKiBtZXRob2RzLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9wcmVsb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2ZpbGVMb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzIG9uIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsLlxuXHQgKi9cblx0cC5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdGlmIChwbHVnaW4gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0dmFyIG1hcCA9IHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMoKTtcblx0XHRcdG1hcC5zY29wZSA9IHBsdWdpbjtcblxuXHRcdFx0aWYgKG1hcC50eXBlcyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbWFwLnR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX3R5cGVDYWxsYmFja3NbbWFwLnR5cGVzW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWFwLmV4dGVuc2lvbnMgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gbWFwLmV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW21hcC5leHRlbnNpb25zW2ldXSA9IG1hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgYnJvd3NlcnMgYW5kIHNlcnZlcnMgbWF5IGhhdmUgYSBidWlsdC1pbiBtYXhpbXVtXG5cdCAqIG51bWJlciBvZiBvcGVuIGNvbm5lY3Rpb25zLCBzbyBhbnkgYWRkaXRpb25hbCBjb25uZWN0aW9ucyBtYXkgcmVtYWluIGluIGEgcGVuZGluZyBzdGF0ZSB1bnRpbCB0aGUgYnJvd3NlclxuXHQgKiBvcGVucyB0aGUgY29ubmVjdGlvbi4gV2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgYW5kIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYHRydWVgLCBvbmx5IG9uZSBzY3JpcHQgaXMgbG9hZGVkIGF0IGEgdGltZSBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9ucy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygxMCk7IC8vIEFsbG93IDEwIGNvbmN1cnJlbnQgbG9hZHNcblx0ICpcblx0ICogQG1ldGhvZCBzZXRNYXhDb25uZWN0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGxvYWRzIHRvIGFsbG93LiBCeSBkZWZhdWx0LCBvbmx5IGEgc2luZ2xlIGNvbm5lY3Rpb24gcGVyIExvYWRRdWV1ZVxuXHQgKiBpcyBvcGVuIGF0IGFueSB0aW1lLlxuXHQgKi9cblx0cC5zZXRNYXhDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fbG9hZFF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGEgc2luZ2xlIGZpbGUuIFRvIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKlxuXHQgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG5cdCAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgbG9hZEZpbGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R8U3RyaW5nfSBmaWxlIFRoZSBmaWxlIG9iamVjdCBvciBwYXRoIHRvIGxvYWQuIEEgZmlsZSBjYW4gYmUgZWl0aGVyXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPk9SIEEgc3RyaW5nIHBhdGggdG8gYSByZXNvdXJjZS4gTm90ZSB0aGF0IHRoaXMga2luZCBvZiBsb2FkIGl0ZW0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogPC91bD5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcblx0ICogdmFsdWUgaXMgdHJ1ZS4gSWYgdGhlIHF1ZXVlIGlzIHBhdXNlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdGhlIHZhbHVlIGlzXG5cdCAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuXHQgKiBwYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuIE5vdGUgdGhhdCBpZiB5b3UgbG9hZCBhIG1hbmlmZXN0IHVzaW5nIGEgZmlsZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBsb2FkTm93LCBiYXNlUGF0aCkge1xuXHRcdGlmIChmaWxlID09IG51bGwpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9OT19GSUxFXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRkSXRlbShmaWxlLCBudWxsLCBiYXNlUGF0aCk7XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkIGFuIGFycmF5IG9mIGZpbGVzLiBUbyBsb2FkIGEgc2luZ2xlIGZpbGUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogVGhlIGZpbGVzIGluIHRoZSBtYW5pZmVzdCBhcmUgcmVxdWVzdGVkIGluIHRoZSBzYW1lIG9yZGVyLCBidXQgbWF5IGNvbXBsZXRlIGluIGEgZGlmZmVyZW50IG9yZGVyIGlmIHRoZSBtYXhcblx0ICogY29ubmVjdGlvbnMgYXJlIHNldCBhYm92ZSAxIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gU2NyaXB0cyB3aWxsIGxvYWRcblx0ICogaW4gdGhlIHJpZ2h0IG9yZGVyIGFzIGxvbmcgYXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXMgdHJ1ZSAod2hpY2ggaXNcblx0ICogZGVmYXVsdCkuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtBcnJheXxTdHJpbmd8T2JqZWN0fSBtYW5pZmVzdCBBbiBsaXN0IG9mIGZpbGVzIHRvIGxvYWQuIFRoZSBsb2FkTWFuaWZlc3QgY2FsbCBzdXBwb3J0cyBmb3VyIHR5cGVzIG9mXG5cdCAqIG1hbmlmZXN0czpcblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPkEgc3RyaW5nIHBhdGgsIHdoaWNoIHBvaW50cyB0byBhIG1hbmlmZXN0IGZpbGUsIHdoaWNoIGlzIGEgSlNPTiBmaWxlIHRoYXQgY29udGFpbnMgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksXG5cdCAqICAgICB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmVcblx0ICogICAgIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3Qgd2hpY2ggZGVmaW5lcyBhIFwic3JjXCIsIHdoaWNoIGlzIGEgSlNPTiBvciBKU09OUCBmaWxlLiBBIFwiY2FsbGJhY2tcIiBjYW4gYmUgZGVmaW5lZCBmb3IgSlNPTlBcblx0ICogICAgIGZpbGUuIFRoZSBKU09OL0pTT05QIGZpbGUgc2hvdWxkIGNvbnRhaW4gYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCxcblx0ICogICAgIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuXG5cdCAqICAgICBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gQXJyYXkgb2YgZmlsZXMgdG8gbG9hZC48L2xpPlxuXHQgKiA8L29sPlxuXHQgKlxuXHQgKiBFYWNoIFwiZmlsZVwiIGluIGEgbWFuaWZlc3QgY2FuIGJlIGVpdGhlcjpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoaXMgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQbGVhc2UgZWl0aGVyIHVzZSB0aGUgYGJhc2VQYXRoYCBwYXJhbWV0ZXIgaW4gdGhlIExvYWRRdWV1ZVxuXHQgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuXHQgKi9cblx0cC5sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGZpbGVMaXN0ID0gbnVsbDtcblx0XHR2YXIgcGF0aCA9IG51bGw7XG5cblx0XHQvLyBBcnJheS1iYXNlZCBsaXN0IG9mIGl0ZW1zXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWFuaWZlc3QpKSB7XG5cdFx0XHRpZiAobWFuaWZlc3QubGVuZ3RoID09IDApIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX0VNUFRZXCIpO1xuXHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmaWxlTGlzdCA9IG1hbmlmZXN0O1xuXG5cdFx0XHQvLyBTdHJpbmctYmFzZWQuIE9ubHkgZmlsZSBtYW5pZmVzdHMgY2FuIGJlIHNwZWNpZmllZCB0aGlzIHdheS4gQW55IG90aGVyIHR5cGVzIHdpbGwgY2F1c2UgYW4gZXJyb3Igd2hlbiBsb2FkZWQuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRmaWxlTGlzdCA9IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNyYzogbWFuaWZlc3QsXG5cdFx0XHRcdFx0dHlwZTogcy5NQU5JRkVTVFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09IFwib2JqZWN0XCIpIHtcblxuXHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0IHBhdGhcblx0XHRcdGlmIChtYW5pZmVzdC5zcmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWFuaWZlc3QudHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bWFuaWZlc3QudHlwZSA9IHMuTUFOSUZFU1Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWFuaWZlc3QudHlwZSAhPSBzLk1BTklGRVNUKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX1RZUEVcIik7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWxlTGlzdCA9IFttYW5pZmVzdF07XG5cblx0XHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0XG5cdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0Lm1hbmlmZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdC5tYW5pZmVzdDtcblx0XHRcdFx0cGF0aCA9IG1hbmlmZXN0LnBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVuc3VwcG9ydGVkLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9OVUxMXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGZpbGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fYWRkSXRlbShmaWxlTGlzdFtpXSwgcGF0aCwgYmFzZVBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogU3RhcnQgYSBMb2FkUXVldWUgdGhhdCB3YXMgY3JlYXRlZCwgYnV0IG5vdCBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIiB3YXNcblx0ICogc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWQgaXRlbSB0aGF0IHdhcyBpbml0aWFsbHkgcmVxdWVzdGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGFzIHRoZSBgaXRlbWAgcGFyYW1ldGVyLlxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIGxvYWRlZCByZXN1bHQgdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiXG5cdCAqIHdhcyBzdXBwbGllZCB3aXRoIHRoZSBsb2FkIGl0ZW0sIHRoZSBJRCB3aWxsIGJlIHRoZSBcInNyY1wiLCBpbmNsdWRpbmcgYSBgcGF0aGAgcHJvcGVydHkgZGVmaW5lZCBieSBhIG1hbmlmZXN0LiBUaGVcblx0ICogYGJhc2VQYXRoYCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBJRC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXdSZXN1bHQ9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgSFRNTFxuXHQgKiAgICAgIERPTS48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDsgb3IgJmx0O2xpbmsgJmd0Oyk8L2xpPlxuXHQgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG5cdCAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIFhNTCBkb2N1bWVudDwvbGk+XG5cdCAqICAgICAgPGxpPkEgYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBhdWRpbyB0YWcgKCZsdDthdWRpbyAmZ3Q7KSBmb3IgSFRNTCBhdWRpby4gTm90ZSB0aGF0IGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBTb3VuZEpTIEFQSXMgdG8gcGxheVxuXHQgKiAgICAgIGxvYWRlZCBhdWRpby4gU3BlY2lmaWNhbGx5LCBhdWRpbyBsb2FkZWQgYnkgRmxhc2ggYW5kIFdlYkF1ZGlvIHdpbGwgcmV0dXJuIGEgbG9hZGVyIG9iamVjdCB1c2luZyB0aGlzIG1ldGhvZFxuXHQgKiAgICAgIHdoaWNoIGNhbiBub3QgYmUgdXNlZCB0byBwbGF5IGF1ZGlvIGJhY2suPC9saT5cblx0ICogPC91bD5cblx0ICogVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBhcyB0aGUgJ2l0ZW1gXG5cdCAqIHBhcmFtZXRlci4gTm90ZSB0aGF0IGlmIGEgcmF3IHJlc3VsdCBpcyByZXF1ZXN0ZWQsIGJ1dCBub3QgZm91bmQsIHRoZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUsIHJhd1Jlc3VsdCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgaWQgPSBpdGVtLmlkO1xuXHRcdGlmIChyYXdSZXN1bHQgJiYgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF0pIHtcblx0XHRcdHJldHVybiB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2lkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZFJlc3VsdHNbaWRdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbiBsaXN0IG9mIGl0ZW1zIGxvYWRlZCBieSB0aGlzIHF1ZXVlLlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZGVkIERldGVybWluZXMgaWYgb25seSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgc2hvdWxkIGJlIHJldHVybmVkLiBJZiBmYWxzZSwgaW4tcHJvZ3Jlc3Ncblx0ICogYW5kIGZhaWxlZCBsb2FkIGl0ZW1zIHdpbGwgYWxzbyBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybnMge0FycmF5fSBBIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEVhY2ggaXRlbSBpbmNsdWRlcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHJlc3VsdCwgYW5kIHJhd1Jlc3VsdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlZCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFtuXTtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmdldFJlc3VsdChuKTtcblx0XHRcdGlmIChsb2FkZWQgPT09IHRydWUgJiYgcmVzdWx0ID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRhcnIucHVzaCh7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHJlc3VsdDogcmVzdWx0LFxuXHRcdFx0XHRyYXdSZXN1bHQ6IHRoaXMuZ2V0UmVzdWx0KG4sIHRydWUpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2Ugb3IgcmVzdW1lIHRoZSBjdXJyZW50IGxvYWQuIEFjdGl2ZSBsb2FkcyB3aWxsIG5vdCBiZSBjYW5jZWxsZWQsIGJ1dCB0aGUgbmV4dCBpdGVtcyBpbiB0aGUgcXVldWUgd2lsbCBub3Rcblx0ICogYmUgcHJvY2Vzc2VkIHdoZW4gYWN0aXZlIGxvYWRzIGNvbXBsZXRlLiBMb2FkUXVldWVzIGFyZSBub3QgcGF1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiBuZXcgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBxdWV1ZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSwgYSBwYXVzZWQgcXVldWUgd2lsbCBiZSByZXN1bWVkLCB1bmxlc3MgdGhlIGBsb2FkTm93YFxuXHQgKiBhcmd1bWVudCBpcyBgZmFsc2VgLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCBiZSBwYXVzZWQgb3Igbm90LlxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSBhY3RpdmUgcXVldWUuIENsb3NpbmcgYSBxdWV1ZSBjb21wbGV0ZWx5IGVtcHRpZXMgdGhlIHF1ZXVlLCBhbmQgcHJldmVudHMgYW55IHJlbWFpbmluZyBpdGVtcyBmcm9tXG5cdCAqIHN0YXJ0aW5nIHRvIGRvd25sb2FkLiBOb3RlIHRoYXQgY3VycmVudGx5IGFueSBhY3RpdmUgbG9hZHMgd2lsbCByZW1haW4gb3BlbiwgYW5kIGV2ZW50cyBtYXkgYmUgcHJvY2Vzc2VkLlxuXHQgKlxuXHQgKiBUbyBzdG9wIGFuZCByZXN0YXJ0IGEgcXVldWUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBjbG9zZVxuXHQgKi9cblx0cC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aGlsZSAodGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JpcHRPcmRlci5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmxvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIEFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZS4gSXRlbXMgYXJlIGZvcm1hdHRlZCBpbnRvIGEgdXNhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcHJvcGVydGllcyBuZWNlc3NhcnkgdG9cblx0ICogbG9hZCB0aGUgY29udGVudC4gVGhlIGxvYWQgcXVldWUgaXMgcG9wdWxhdGVkIHdpdGggdGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IGhhbmRsZXMgcHJlbG9hZGluZywgYW5kIG5vdCB0aGUgbG9hZFxuXHQgKiBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gVG8gbG9vayB1cCB0aGUgbG9hZCBpdGVtIGJ5IGlkIG9yIHNyYywgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgX2FkZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIHF1ZXVlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEFuIG9wdGlvbmFsIHBhdGggcHJlcGVuZGVkIHRvIHRoZSBgc3JjYC4gVGhlIHBhdGggd2lsbCBvbmx5IGJlIHByZXBlbmRlZCBpZiB0aGUgc3JjIGlzXG5cdCAqIHJlbGF0aXZlLCBhbmQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gLCBvciBhIHBhdGggbGlrZSBgLi4vYC4gSWYgdGhlIExvYWRRdWV1ZSB3YXNcblx0ICogcHJvdmlkZWQgYSB7eyNjcm9zc0xpbmsgXCJfYmFzZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0sIHRoZW4gaXQgd2lsbCBvcHRpb25hbGx5IGJlIHByZXBlbmRlZCBhZnRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWNhdGVkPC9zdHJvbmc+QW4gb3B0aW9uYWwgYmFzZVBhdGggcGFzc2VkIGludG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdGFnZ2VkXG5cdCAqIHZlcnNpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9hZGRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fY3JlYXRlTG9hZEl0ZW0odmFsdWUsIHBhdGgsIGJhc2VQYXRoKTsgLy8gYmFzZVBhdGggYW5kIG1hbmlmZXN0IHBhdGggYXJlIGFkZGVkIHRvIHRoZSBzcmMuXG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy8gU29tZXRpbWVzIHBsdWdpbnMgb3IgdHlwZXMgc2hvdWxkIGJlIHNraXBwZWQuXG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuX2NyZWF0ZUxvYWRlcihpdGVtKTtcblx0XHRpZiAobG9hZGVyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInBsdWdpbnNcIiBpbiBsb2FkZXIpIHtcblx0XHRcdFx0bG9hZGVyLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0fVxuXHRcdFx0aXRlbS5fbG9hZGVyID0gbG9hZGVyO1xuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnB1c2gobG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5wdXNoKGxvYWRlcik7XG5cblx0XHRcdHRoaXMuX251bUl0ZW1zKys7XG5cdFx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG5cdFx0XHQvLyBPbmx5IHdvcnJ5IGFib3V0IHNjcmlwdCBvcmRlciB3aGVuIHVzaW5nIFhIUiB0byBsb2FkIHNjcmlwdHMuIFRhZ3MgYXJlIG9ubHkgbG9hZGluZyBvbmUgYXQgYSB0aW1lLlxuXHRcdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXJcblx0XHRcdFx0XHQmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFRcblx0XHRcdFx0XHRcdC8vJiYgbG9hZGVyIGluc3RhbmNlb2YgY3JlYXRlanMuWEhSTG9hZGVyIC8vTk9URTogSGF2ZSB0byB0cmFjayBhbGwgSlMgZmlsZXMgdGhpcyB3YXlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuX3NjcmlwdE9yZGVyLnB1c2goaXRlbSk7XG5cdFx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMucHVzaChudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHJlZmluZWQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIHR5cGUgb2Zcblx0ICogaXRlbSBpcyBkZXRlcm1pbmVkIGJ5IGJyb3dzZXIgc3VwcG9ydCwgcmVxdWlyZW1lbnRzIGJhc2VkIG9uIHRoZSBmaWxlIHR5cGUsIGFuZCBkZXZlbG9wZXIgc2V0dGluZ3MuIEZvciBleGFtcGxlLFxuXHQgKiBYSFIgaXMgb25seSB1c2VkIGZvciBmaWxlIHR5cGVzIHRoYXQgc3VwcG9ydCBpdCBpbiBuZXcgYnJvd3NlcnMuXG5cdCAqXG5cdCAqIEJlZm9yZSB0aGUgaXRlbSBpcyByZXR1cm5lZCwgYW55IHBsdWdpbnMgcmVnaXN0ZXJlZCB0byBoYW5kbGUgdGhlIHR5cGUgb3IgZXh0ZW5zaW9uIHdpbGwgYmUgZmlyZWQsIHdoaWNoIG1heVxuXHQgKiBhbHRlciB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdCB8IEhUTUxBdWRpb0VsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSB2YWx1ZSBUaGUgaXRlbSB0aGF0IG5lZWRzIHRvIGJlIHByZWxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbSdzIHNvdXJjZS4gU291cmNlcyBiZWdpbm5pbmcgd2l0aCBodHRwOi8vIG9yIHNpbWlsYXIgd2lsbFxuXHQgKiBub3QgcmVjZWl2ZSBhIHBhdGguIFNpbmNlIFByZWxvYWRKUyAwLjQuMSwgdGhlIHNyYyB3aWxsIGJlIG1vZGlmaWVkIHRvIGluY2x1ZGUgdGhlIGBwYXRoYCBhbmQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19iYXNlUGF0aDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGl0IGlzIGFkZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY3RhdGVkPC9zdHJvbmc+IEEgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW1zIHNvdXJjZSBpbiBhZGRpdGlvbiB0b1xuXHQgKiB0aGUgcGF0aCBhcmd1bWVudC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbG9hZGVyIGluc3RhbmNlIHRoYXQgd2lsbCBiZSB1c2VkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlTG9hZEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdGgsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGl0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUodmFsdWUpO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBicCA9IFwiXCI7IC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgYmFzZVBhdGhcblx0XHR2YXIgdXNlQmFzZVBhdGggPSBiYXNlUGF0aCB8fCB0aGlzLl9iYXNlUGF0aDtcblxuXHRcdGlmIChpdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0aWYgKCFpdGVtLnR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIHRoZSB0aGUgc3JjIGlzIGFuIG9iamVjdCwgdHlwZSBpcyByZXF1aXJlZCB0byBwYXNzIG9mZiB0byBwbHVnaW5cblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0dmFyIHBhdGhNYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShwYXRoKTtcblx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0aWYgKHVzZUJhc2VQYXRoICE9IG51bGwgJiYgIXBhdGhNYXRjaC5hYnNvbHV0ZSAmJiAhcGF0aE1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHVzZUJhc2VQYXRoICE9IG51bGwpIHtcblx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGV0ZXJtaW5lIEV4dGVuc2lvbiwgZXRjLlxuXHRcdFx0dmFyIG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24pIHtcblx0XHRcdFx0aXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IG51bGwpIHtcblx0XHRcdFx0aXRlbS50eXBlID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmdldFR5cGVCeUV4dGVuc2lvbihpdGVtLmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluamVjdCBwYXRoICYgYmFzZVBhdGhcblx0XHRcdHZhciBhdXRvSWQgPSBpdGVtLnNyYztcblx0XHRcdGlmICghbWF0Y2guYWJzb2x1dGUgJiYgIW1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdFx0YXV0b0lkID0gcGF0aCArIGF1dG9JZDtcblx0XHRcdFx0XHQvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuXHRcdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS5zcmMgPSBicCArIGl0ZW0uc3JjO1xuXHRcdH1cblx0XHRpdGVtLnBhdGggPSBicDtcblxuXHRcdC8vIElmIHRoZXJlJ3Mgbm8gaWQsIHNldCBvbmUgbm93LlxuXHRcdGlmIChpdGVtLmlkID09PSB1bmRlZmluZWQgfHwgaXRlbS5pZCA9PT0gbnVsbCB8fCBpdGVtLmlkID09PSBcIlwiKSB7XG5cdFx0XHRpdGVtLmlkID0gYXV0b0lkO1xuXHRcdH1cblxuXHRcdC8vIEdpdmUgcGx1Z2lucyBhIGNoYW5jZSB0byBtb2RpZnkgdGhlIGxvYWRJdGVtOlxuXHRcdHZhciBjdXN0b21IYW5kbGVyID0gdGhpcy5fdHlwZUNhbGxiYWNrc1tpdGVtLnR5cGVdIHx8IHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrc1tpdGVtLmV4dF07XG5cdFx0aWYgKGN1c3RvbUhhbmRsZXIpIHtcblx0XHRcdC8vIFBsdWdpbnMgYXJlIG5vdyBwYXNzZWQgYm90aCB0aGUgZnVsbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBjb21iaW5lZCBwYXRoK2Jhc2VQYXRoIChhcHByb3ByaWF0ZWx5KVxuXHRcdFx0dmFyIHJlc3VsdCA9IGN1c3RvbUhhbmRsZXIuY2FsbGJhY2suY2FsbChjdXN0b21IYW5kbGVyLnNjb3BlLCBpdGVtLCB0aGlzKTtcblxuXHRcdFx0Ly8gVGhlIHBsdWdpbiB3aWxsIGhhbmRsZSB0aGUgbG9hZCwgb3IgaGFzIGNhbmNlbGVkIGl0LiBJZ25vcmUgaXQuXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHQvLyBMb2FkIGFzIG5vcm1hbDpcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIERvIE5vdGhpbmdcblxuXHRcdFx0XHQvLyBSZXN1bHQgaXMgYSBsb2FkZXIgY2xhc3M6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uX2xvYWRlciA9IHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBleHRlbnNpb24gaW4gY2FzZSB0aGUgdHlwZSBjaGFuZ2VkOlxuXHRcdFx0bWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkoaXRlbS5zcmMpO1xuXHRcdFx0aWYgKG1hdGNoLmV4dGVuc2lvbiAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBpdGVtIGZvciBsb29rdXAuIFRoaXMgYWxzbyBoZWxwcyBjbGVhbi11cCBsYXRlci5cblx0XHR0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdID0gaXRlbTtcblx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXG5cdFx0aWYgKGl0ZW0uY3Jvc3NPcmlnaW4gPT0gbnVsbCkge1xuXHRcdFx0aXRlbS5jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBsb2FkZXIgZm9yIGEgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBmb3JtYXR0ZWQgbG9hZCBpdGVtIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBsb2FkZXIuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0TG9hZGVyfSBBIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQgY29udGVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0aWYgKGl0ZW0uX2xvYWRlciAhPSBudWxsKSB7IC8vIEEgcGx1Z2luIGFscmVhZHkgc3BlY2lmaWVkIGEgbG9hZGVyXG5cdFx0XHRyZXR1cm4gaXRlbS5fbG9hZGVyO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxseSwgdHJ5IGFuZCB1c2UgdGhlIHByb3ZpZGVkL3N1cHBvcnRlZCBYSFIgbW9kZTpcblx0XHR2YXIgcHJlZmVyWEhSID0gdGhpcy5wcmVmZXJYSFI7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzW2ldO1xuXHRcdFx0aWYgKGxvYWRlciAmJiBsb2FkZXIuY2FuTG9hZEl0ZW0oaXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBsb2FkZXIoaXRlbSwgcHJlZmVyWEhSKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBMb2cgZXJyb3IgKHJlcXVpcmVzIGNyZWF0ZWpzLmxvZylcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogTG9hZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBxdWV1ZS4gSWYgdGhlIHF1ZXVlIGlzIGVtcHR5IChhbGwgaXRlbXMgaGF2ZSBiZWVuIGxvYWRlZCksIHRoZW4gdGhlIGNvbXBsZXRlIGV2ZW50XG5cdCAqIGlzIHByb2Nlc3NlZC4gVGhlIHF1ZXVlIHdpbGwgXCJmaWxsIHVwXCIgYW55IGVtcHR5IHNsb3RzLCB1cCB0byB0aGUgbWF4IGNvbm5lY3Rpb24gc3BlY2lmaWVkIHVzaW5nXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS5zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBzY3JpcHRzIHRoYXQgYXJlIGxvYWRlZFxuXHQgKiB1c2luZyB0YWdzLCB3aGljaCBoYXZlIHRvIGJlIGxvYWRlZCBvbmUgYXQgYSB0aW1lIHRvIG1haW50YWluIGxvYWQgb3JkZXIuXG5cdCAqIEBtZXRob2QgX2xvYWROZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25seSBkaXNwYXRjaCBsb2Fkc3RhcnQgZXZlbnQgd2hlbiB0aGUgZmlyc3QgZmlsZSBpcyBsb2FkZWQuXG5cdFx0aWYgKCF0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkKSB7XG5cdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHR0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUaGUgcXVldWUgaGFzIGNvbXBsZXRlZC5cblx0XHRpZiAodGhpcy5fbnVtSXRlbXMgPT0gdGhpcy5fbnVtSXRlbXNMb2FkZWQpIHtcblx0XHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0XHQvLyBMb2FkIHRoZSBuZXh0IHF1ZXVlLCBpZiBpdCBoYXMgYmVlbiBkZWZpbmVkLlxuXHRcdFx0aWYgKHRoaXMubmV4dCAmJiB0aGlzLm5leHQubG9hZCkge1xuXHRcdFx0XHR0aGlzLm5leHQubG9hZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE11c3QgaXRlcmF0ZSBmb3J3YXJkcyB0byBsb2FkIGluIHRoZSByaWdodCBvcmRlci5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggPj0gdGhpcy5fbWF4Q29ubmVjdGlvbnMpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fbG9hZFF1ZXVlW2ldO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGJlIG9ubHkgbG9hZGluZyBvbmUgdGFnLXNjcmlwdCBhdCBhIHRpbWU6XG5cdFx0XHQvLyBOb3RlOiBtYWludGFpbk9yZGVyIGl0ZW1zIGRvbid0IGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB3ZSBjYW4gaG9sZCBvbnRvIHRoZWlyIGxvYWRlZCB2YWx1ZVxuXHRcdFx0aWYgKCF0aGlzLl9jYW5TdGFydExvYWQobG9hZGVyKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRpLS07XG5cdFx0XHR0aGlzLl9sb2FkSXRlbShsb2FkZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyBhbiBpdGVtLiBFdmVudCBsaXN0ZW5lcnMgYXJlIG5vdCBhZGRlZCB0byB0aGUgbG9hZGVycyB1bnRpbCB0aGUgbG9hZCBzdGFydHMuXG5cdCAqIEBtZXRob2QgX2xvYWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGluc3RhbmNlIHRvIHN0YXJ0LiBDdXJyZW50bHksIHRoaXMgd2lsbCBiZSBhbiBYSFJMb2FkZXIgb3IgVGFnTG9hZGVyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVGaWxlQ29tcGxldGUsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJmaWxlZXJyb3JcIiwgdGhpcy5faGFuZGxlRmlsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9jdXJyZW50TG9hZHMucHVzaChsb2FkZXIpO1xuXHRcdHRoaXMuX3NlbmRGaWxlU3RhcnQobG9hZGVyLmdldEl0ZW0oKSk7XG5cdFx0bG9hZGVyLmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlcyBsb2FkZXJzIGxpa2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdG8gbWFpbnRhaW4gaW50ZXJuYWwgcXVldWVzLCBidXQgZm9yIHRoaXMgcXVldWUgdG8gZGlzcGF0Y2ggdGhlIHt7I2Nyb3NzTGluayBcImZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50cy5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yIGZyb20gYW4gaW50ZXJuYWwgZmlsZSBsb2FkIG9wZXJhdGlvbi4gVGhpcyBlbmFibGVzXG5cdCAqIGxvYWRlcnMgbGlrZSBNXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJGSUxFX0xPQURfRVJST1JcIiwgbnVsbCwgZXZlbnQuaXRlbSk7XG5cdFx0dGhpcy5fc2VuZEVycm9yKG5ld0V2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBUaGUgcXVldWUgd2lsbCBjb250aW51ZSBsb2FkaW5nIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgc2V0IHRvIGB0cnVlYC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudCBUaGUgZXJyb3IgZXZlbnQsIGNvbnRhaW5pbmcgcmVsZXZhbnQgZXJyb3IgaW5mb3JtYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuXHRcdHRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlciwgdHJ1ZSk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdC8vIFRPRE86IFByb3BhZ2F0ZSBhY3R1YWwgZXJyb3IgbWVzc2FnZS5cblxuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cblx0XHRpZiAoIXRoaXMuc3RvcE9uRXJyb3IpIHtcblx0XHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGZpbmlzaGVkIGxvYWRpbmcuIFdlIGNhbiBhc3N1bWUgdGhhdCBpdCBpcyB0b3RhbGx5IGxvYWRlZCwgaGFzIGJlZW4gcGFyc2VkIGZvciBpbW1lZGlhdGUgdXNlLCBhbmRcblx0ICogaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5IG9uIHRoZSBsb2FkIGl0ZW0uIFRoZSByYXcgdGV4dCByZXN1bHQgZm9yIGEgcGFyc2VkIGl0ZW0gKHN1Y2ggYXMgSlNPTiwgWE1MLFxuXHQgKiBDU1MsIEphdmFTY3JpcHQsIGV0YykgaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJhd1Jlc3VsdFwiIHByb3BlcnR5LCBhbmQgY2FuIGFsc28gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX2hhbmRsZUZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQoKTtcblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gcmVzdWx0O1xuXHRcdHZhciByYXdSZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdGlmIChyYXdSZXN1bHQgIT0gbnVsbCAmJiByYXdSZXN1bHQgIT09IHJlc3VsdCkge1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IHJhd1Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLl9zYXZlTG9hZGVkSXRlbXMobG9hZGVyKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fcmVtb3ZlTG9hZEl0ZW0obG9hZGVyKTtcblxuXHRcdGlmICghdGhpcy5fZmluaXNoT3JkZXJlZEl0ZW0obG9hZGVyKSkge1xuXHRcdFx0Ly8gVGhlIGl0ZW0gd2FzIE5PVCBtYW5hZ2VkLCBzbyBwcm9jZXNzIGl0IG5vd1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBsb2FkIGl0ZW1cblx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNvbWUgbG9hZGVycyBtaWdodCBsb2FkIGFkZGl0aW9uYWwgY29udGVudCwgb3RoZXIgdGhhbiB0aGUgaXRlbSB0aGV5IHdlcmUgcGFzc2VkIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogQW55IGl0ZW1zIGV4cG9zZWQgYnkgdGhlIGxvYWRlciB1c2luZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9nZXRMb2FkSXRlbXNcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGFkZGVkIHRvIHRoZVxuXHQgKiBMb2FkUXVldWUncyBsb29rLXVwcywgaW5jbHVkaW5nIHt7I2Nyb3NzTGluayBcImdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzLlxuXHQgKiBAbWV0aG9kIF9zYXZlTG9hZGVkSXRlbXNcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9zYXZlTG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0Ly8gVE9ETzogTm90IHN1cmUgaG93IHRvIGhhbmRsZSB0aGlzLiBXb3VsZCBiZSBuaWNlIHRvIGV4cG9zZSB0aGUgaXRlbXMuXG5cdFx0Ly8gTG9hZGVycyBtYXkgbG9hZCBzdWItaXRlbXMuIFRoaXMgYWRkcyB0aGVtIHRvIHRoaXMgcXVldWVcblx0XHR2YXIgbGlzdCA9IGxvYWRlci5nZXRMb2FkZWRJdGVtcygpO1xuXHRcdGlmIChsaXN0ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGxpc3RbaV0uaXRlbTtcblxuXHRcdFx0Ly8gU3RvcmUgaXRlbSBsb29rdXBzXG5cdFx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGxvYWRlZCBjb250ZW50XG5cdFx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yZXN1bHQ7XG5cdFx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yYXdSZXN1bHQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGbGFnIGFuIGl0ZW0gYXMgZmluaXNoZWQuIElmIHRoZSBpdGVtJ3Mgb3JkZXIgaXMgYmVpbmcgbWFuYWdlZCwgdGhlbiBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGZpbmlzaCwgYW5kIGlmXG5cdCAqIHNvLCB0cmlnZ2VyIHByaW9yIGl0ZW1zIHRvIHRyaWdnZXIgYXMgd2VsbC5cblx0ICogQG1ldGhvZCBfZmluaXNoT3JkZXJlZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZEZhaWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQuIFRoaXMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gdGFrZSBhbiBhbHRlcm5hdGVcblx0ICogYmVoYXZpb3VyIGlmIGl0IGlzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZmluaXNoT3JkZXJlZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyLCBsb2FkRmFpbGVkKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKVxuXHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIpIHtcblxuXHRcdFx0Ly9UT0RPOiBFdmFsdWF0ZSByZW1vdmFsIG9mIHRoZSBfY3VycmVudGx5TG9hZGluZ1NjcmlwdFxuXHRcdFx0aWYgKGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3NjcmlwdE9yZGVyLCBpdGVtKTtcblx0XHRcdGlmIChpbmRleCA9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIFRoaXMgbG9hZGVyIG5vIGxvbmdlciBleGlzdHNcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaW5kZXhdID0gKGxvYWRGYWlsZWQgPT09IHRydWUpID8gdHJ1ZSA6IGl0ZW07XG5cblx0XHRcdHRoaXMuX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGUgc2NyaXB0cyBsb2FkIGFuZCBkaXNwYXRjaCBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2hlbiB1c2luZyBYSFIsIHNjcmlwdHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBpbiB0aGVcblx0ICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBidXQgd2l0aCBhIFwibnVsbFwiIHZhbHVlLiBXaGVuIHRoZXkgYXJlIGNvbXBsZXRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgbG9hZCBpdGVtLFxuXHQgKiBhbmQgdGhlbiB3aGVuIHRoZXkgYXJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAuIFRoaXMgbWV0aG9kIHNpbXBseVxuXHQgKiBpdGVyYXRlcyB0aGUgYXJyYXksIGFuZCBlbnN1cmVzIHRoYXQgYW55IGxvYWRlZCBpdGVtcyB0aGF0IGFyZSBub3QgcHJlY2VkZWQgYnkgYSBgbnVsbGAgdmFsdWUgYXJlXG5cdCAqIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgX2NoZWNrU2NyaXB0TG9hZE9yZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja1NjcmlwdExvYWRPcmRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChpdGVtID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvLyBUaGlzIGlzIHN0aWxsIGxvYWRpbmcuIERvIG5vdCBwcm9jZXNzIGZ1cnRoZXIuXG5cdFx0XHRpZiAoaXRlbSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gLy8gVGhpcyBoYXMgY29tcGxldGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuIE1vdmUgb24uXG5cblx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRcdC8vIEFwcGVuZCBzY3JpcHQgdGFncyB0byB0aGUgaGVhZCBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQobG9hZEl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9hZGVyID0gaXRlbS5fbG9hZGVyO1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0c1tpXSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCBhbmQgdGhlIExvYWRRdWV1ZSBjYW4gbW92ZSBvbi4gVGhpcyB0cmlnZ2VycyB0aGUgY29tcGxldGUgZXZlbnQsIGFuZCBraWNrLXN0YXJ0c1xuXHQgKiB0aGUgbmV4dCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9wcm9jZXNzRmluaXNoZWRMb2FkXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9wcm9jZXNzRmluaXNoZWRMb2FkID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHQvLyBTaW5jZSBMb2FkUXVldWUgbmVlZHMgbWFpbnRhaW4gb3JkZXIsIHdlIGNhbid0IGFwcGVuZCBzY3JpcHRzIGluIHRoZSBsb2FkZXIuXG5cdFx0Ly8gU28gd2UgZG8gaXQgaGVyZSBpbnN0ZWFkLiBPciBpbiBfY2hlY2tTY3JpcHRMb2FkT3JkZXIoKTtcblx0XHRpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciAmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXHRcdHRoaXMuX3NlbmRGaWxlQ29tcGxldGUoaXRlbSwgbG9hZGVyKTtcblx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnN1cmUgaXRlbXMgd2l0aCBgbWFpbnRhaW5PcmRlcj10cnVlYCB0aGF0IGFyZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBpdGVtIGhhdmUgbG9hZGVkLiBUaGlzIG9ubHkgYXBwbGllcyB0b1xuXHQgKiBKYXZhU2NyaXB0IGl0ZW1zIHRoYXQgYXJlIGJlaW5nIGxvYWRlZCB3aXRoIGEgVGFnTG9hZGVyLCBzaW5jZSB0aGV5IGhhdmUgdG8gYmUgbG9hZGVkIGFuZCBjb21wbGV0ZWQgPHN0cm9uZz5iZWZvcmU8L3N0cm9uZz5cblx0ICogdGhlIHNjcmlwdCBjYW4gZXZlbiBiZSBzdGFydGVkLCBzaW5jZSBpdCBleGlzdCBpbiB0aGUgRE9NIHdoaWxlIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NhblN0YXJ0TG9hZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBmb3IgdGhlIGl0ZW1cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBjYW4gc3RhcnQgYSBsb2FkIG9yIG5vdC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NhblN0YXJ0TG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciB8fCBsb2FkZXIucHJlZmVyWEhSKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXHRcdGlmIChpdGVtLnR5cGUgIT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX3NjcmlwdE9yZGVyLmluZGV4T2YoaXRlbSk7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlIChpIDwgaW5kZXgpIHtcblx0XHRcdHZhciBjaGVja0l0ZW0gPSB0aGlzLl9sb2FkZWRTY3JpcHRzW2ldO1xuXHRcdFx0aWYgKGNoZWNrSXRlbSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgbG9hZCBpdGVtIGlzIGNvbXBsZXRlZCBvciB3YXMgY2FuY2VsZWQsIGFuZCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBfcmVtb3ZlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIEEgbG9hZGVyIGluc3RhbmNlIHRvIHJlbW92ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3JlbW92ZUxvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkc1tpXSA9PSBsb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdW5uZWVkZWQgcmVmZXJlbmNlcyBmcm9tIGEgbG9hZGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0gbG9hZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbkxvYWRJdGVtID0gZnVuY3Rpb24obG9hZGVyKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRkZWxldGUgaXRlbS5fbG9hZGVyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBkaXNwYXRjaGVkIHByb2dyZXNzLiBQcm9wYWdhdGUgdGhhdCBwcm9ncmVzcywgYW5kIHVwZGF0ZSB0aGUgTG9hZFF1ZXVlJ3Mgb3ZlcmFsbCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudCBUaGUgcHJvZ3Jlc3MgZXZlbnQgZnJvbSB0aGUgaXRlbS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcblx0XHR0aGlzLl9zZW5kRmlsZVByb2dyZXNzKGxvYWRlci5nZXRJdGVtKCksIGxvYWRlci5wcm9ncmVzcyk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmFsbCBwcm9ncmVzcyBoYXMgY2hhbmdlZCwgc28gZGV0ZXJtaW5lIHRoZSBuZXcgcHJvZ3Jlc3MgYW1vdW50IGFuZCBkaXNwYXRjaCBpdC4gVGhpcyBjaGFuZ2VzIGFueSB0aW1lIGFuXG5cdCAqIGl0ZW0gZGlzcGF0Y2hlcyBwcm9ncmVzcyBvciBjb21wbGV0ZXMuIE5vdGUgdGhhdCBzaW5jZSB3ZSBkb24ndCBhbHdheXMga25vdyB0aGUgYWN0dWFsIGZpbGVzaXplIG9mIGl0ZW1zIGJlZm9yZVxuXHQgKiB0aGV5IGFyZSBsb2FkZWQuIEluIHRoaXMgY2FzZSwgd2UgZGVmaW5lIGEgXCJzbG90XCIgZm9yIGVhY2ggaXRlbSAoMSBpdGVtIGluIDEwIHdvdWxkIGdldCAxMCUpLCBhbmQgdGhlbiBhcHBlbmRcblx0ICogbG9hZGVkIHByb2dyZXNzIG9uIHRvcCBvZiB0aGUgYWxyZWFkeS1sb2FkZWQgaXRlbXMuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBpZiA1LzEwIGl0ZW1zIGhhdmUgbG9hZGVkLCBhbmQgaXRlbSA2IGlzIDIwJSBsb2FkZWQsIHRoZSB0b3RhbCBwcm9ncmVzcyB3b3VsZCBiZTpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT41LzEwIG9mIHRoZSBpdGVtcyBpbiB0aGUgcXVldWUgKDUwJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5wbHVzIDIwJSBvZiBpdGVtIDYncyBzbG90ICgyJSk8L2xpPlxuXHQgKiAgICAgIDxsaT5lcXVhbHMgNTIlPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBfdXBkYXRlUHJvZ3Jlc3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsb2FkZWQgPSB0aGlzLl9udW1JdGVtc0xvYWRlZCAvIHRoaXMuX251bUl0ZW1zOyAvLyBGdWxseSBMb2FkZWQgUHJvZ3Jlc3Ncblx0XHR2YXIgcmVtYWluaW5nID0gdGhpcy5fbnVtSXRlbXMgLSB0aGlzLl9udW1JdGVtc0xvYWRlZDtcblx0XHRpZiAocmVtYWluaW5nID4gMCkge1xuXHRcdFx0dmFyIGNodW5rID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VycmVudExvYWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaHVuayArPSB0aGlzLl9jdXJyZW50TG9hZHNbaV0ucHJvZ3Jlc3M7XG5cdFx0XHR9XG5cdFx0XHRsb2FkZWQgKz0gKGNodW5rIC8gcmVtYWluaW5nKSAqIChyZW1haW5pbmcgLyB0aGlzLl9udW1JdGVtcyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2xhc3RQcm9ncmVzcyAhPSBsb2FkZWQpIHtcblx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhsb2FkZWQpO1xuXHRcdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gbG9hZGVkO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gb3V0IGl0ZW0gcmVzdWx0cywgdG8gZnJlZSB0aGVtIGZyb20gbWVtb3J5LiBNYWlubHksIHRoZSBsb2FkZWQgaXRlbSBhbmQgcmVzdWx0cyBhcmUgY2xlYXJlZCBmcm9tIGludGVybmFsXG5cdCAqIGhhc2hlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZUl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIGZvciBwcmVsb2FkaW5nLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdO1xuXHRcdGRlbGV0ZSB0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY107XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgXCJmaWxlcHJvZ3Jlc3NcIiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUgTG9hZFF1ZXVlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyBUaGUgYW1vdW50IHRoZSBpdGVtIGhhcyBiZWVuIGxvYWRlZCAoYmV0d2VlbiAwIGFuZCAxKS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChpdGVtLCBwcm9ncmVzcykge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXByb2dyZXNzXCIpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9MTTogUmV3b3JrIFByb2dyZXNzRXZlbnQgdG8gc3VwcG9ydCB0aGlzP1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVwcm9ncmVzc1wiKTtcblx0XHRldmVudC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LmxvYWRlZCA9IHByb2dyZXNzO1xuXHRcdGV2ZW50LnRvdGFsID0gMTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZWxvYWQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3Jcblx0ICogZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtT2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdGV2ZW50LmxvYWRlciA9IGxvYWRlcjtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHRldmVudC5yZXN1bHQgPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cblx0XHQvLyBUaGlzIGNhbGxzIGEgaGFuZGxlciBzcGVjaWZpZWQgb24gdGhlIGFjdHVhbCBsb2FkIGl0ZW0uIEN1cnJlbnRseSwgdGhlIFNvdW5kSlMgcGx1Z2luIHVzZXMgdGhpcy5cblx0XHRpZiAoaXRlbS5jb21wbGV0ZUhhbmRsZXIpIHtcblx0XHRcdGl0ZW0uY29tcGxldGVIYW5kbGVyKGV2ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGZpbGVzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBpbW1lZGlhdGVseSBiZWZvcmUgYSBmaWxlIHN0YXJ0cyB0byBsb2FkLiBQbGVhc2Ugc2VlXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZVN0YXJ0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVN0YXJ0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlc3RhcnRcIik7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZXN0YXJ0XCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIExvYWRRdWV1ZV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkUXVldWUgPSBjcmVhdGVqcy5wcm9tb3RlKExvYWRRdWV1ZSwgXCJBYnN0cmFjdExvYWRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUZXh0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFRleHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBUZXh0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFRleHRMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gVGV4dExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgbG9hZHMgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgaXMgYWxzbyB0aGUgZGVmYXVsdCBsb2FkZXIgaWYgYSBmaWxlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdH07XG5cblx0Y3JlYXRlanMuVGV4dExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpbmFyeUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBiaW5hcnkgZmlsZXMuIFRoaXMgaXMgdXNlZnVsIGZvciBsb2FkaW5nIHdlYiBhdWRpbywgb3IgY29udGVudCB0aGF0IHJlcXVpcmVzIGFuIEFycmF5QnVmZmVyLlxuXHQgKiBAY2xhc3MgQmluYXJ5TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJpbmFyeUxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWSk7XG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaW5hcnlMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBCaW5hcnlMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCJcblx0ICogQHByb3BlcnR5IF91cGRhdGVYSFJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5CaW5hcnlMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEJpbmFyeUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENTU0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBjbGFzcyBDU1NMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQ1NTTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImhyZWZcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGFnLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXHRcdHRoaXMuX3RhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENTU0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IENTU0xvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBDU1MgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cblx0XHRcdGlmICh0YWcuc3R5bGVTaGVldCkgeyAvLyBJRVxuXHRcdFx0XHR0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdFx0XHR0YWcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWcgPSB0aGlzLl90YWc7XG5cdFx0fVxuXG5cdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKHRhZyk7XG5cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkNTU0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQ1NTTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSW1hZ2VMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgaW1hZ2UgZmlsZXMuXG5cdCAqIEBjbGFzcyBJbWFnZUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBJbWFnZUxvYWRlciAobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0UpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBwcmVsb2FkIGl0ZW0gaXMgYWxyZWFkeSBhIHRhZy5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnNyYztcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnRhZztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSW1hZ2VMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBJbWFnZUxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdGFnLnNyYyAhPSBcIlwiICYmIHRoaXMuX3RhZy5jb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNyb3NzT3JpZ2luID0gdGhpcy5faXRlbS5jcm9zc09yaWdpbjtcblx0XHRpZiAoY3Jvc3NPcmlnaW4gPT0gdHJ1ZSkgeyBjcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7IH1cblx0XHRpZiAoY3Jvc3NPcmlnaW4gIT0gbnVsbCAmJiAhY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzTG9jYWwodGhpcy5faXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG5cdFx0Ly8gT25seSBleGlzdHMgZm9yIFhIUlxuXHRcdGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm9ybWF0SW1hZ2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBhc3luY2hyb25vdXMgaW1hZ2UgZm9ybWF0dGVyIGZ1bmN0aW9uLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgaW1hZ2VzIGhhdmVcblx0ICogYSBzaG9ydCBkZWxheSBiZWZvcmUgdGhleSBhcmUgcmVhZHkuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdEltYWdlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3NDYWxsYmFjayBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgcmVzdWx0IGhhcyBmaW5pc2hlZCBmb3JtYXR0aW5nXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgZm9ybWF0dGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0SW1hZ2UgPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdC8vZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH0gZWxzZSBpZiAoVVJMKSB7XG5cdFx0XHR2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0XHR0YWcuc3JjID0gb2JqVVJMO1xuXG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5fY2xlYW5VcFVSTCwgZmFsc2UpO1xuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9jbGVhblVwVVJMLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZy5zcmMgPSB0aGlzLl9pdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGFnLmNvbXBsZXRlKSB7XG5cdFx0XHRzdWNjZXNzQ2FsbGJhY2sodGFnKTtcblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgdGFnLm9ubG9hZCA9IGNyZWF0ZWpzLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh0aGlzLl90YWcpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhfdGhpcy5fdGFnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIE9iamVjdFVSTCwgdGhlIHRhZyBpcyBkb25lIHdpdGggaXQuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHJ1blxuXHQgKiBhcyBhbiBldmVudCBsaXN0ZW5lciB3aXRob3V0IGEgcHJveHkvY2xvc3VyZSwgYXMgaXQgZG9lc24ndCByZXF1aXJlIGl0IC0gc28gZG8gbm90XG5cdCAqIGluY2x1ZGUgYW55IGZ1bmN0aW9uYWxpdHkgdGhhdCByZXF1aXJlcyBzY29wZSB3aXRob3V0IGNoYW5naW5nIGl0LlxuXHQgKiBAbWV0aG9kIF9jbGVhblVwVVJMXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW5VcFVSTCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChldmVudC50YXJnZXQuc3JjKTtcblx0fTtcblxuXHRjcmVhdGVqcy5JbWFnZUxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSW1hZ2VMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKYXZhU2NyaXB0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBKYXZhU2NyaXB0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEphdmFTY3JpcHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKYXZhU2NyaXB0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRhZy50ZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKYXZhU2NyaXB0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTkxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIGZpbGVzLiBUbyBsb2FkIEpTT04gY3Jvc3MtZG9tYWluLCB1c2UgSlNPTlAgYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cywgdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG9cblx0ICogbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgSlNPTkxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTik7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgSlNPTiBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGpzb24gPSBudWxsO1xuXHRcdHRyeSB7XG5cdFx0XHRqc29uID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlSlNPTihsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkpTT05fRk9STUFUXCIsIG51bGwsIGUpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybiBlO1xuXHRcdH1cblxuXHRcdHJldHVybiBqc29uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkpTT05Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEpTT05Mb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OUExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OUCBmaWxlcywgd2hpY2ggYXJlIEpTT04tZm9ybWF0dGVkIHRleHQgZmlsZXMsIHdyYXBwZWQgaW4gYSBjYWxsYmFjay4gVG8gbG9hZCByZWd1bGFyIEpTT05cblx0ICogd2l0aG91dCBhIGNhbGxiYWNrIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cyxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBKU09OUCBpcyBhIGZvcm1hdCB0aGF0IHByb3ZpZGVzIGEgc29sdXRpb24gZm9yIGxvYWRpbmcgSlNPTiBmaWxlcyBjcm9zcy1kb21haW4gPGVtPndpdGhvdXQ8L2VtPiByZXF1aXJpbmcgQ09SUy5cblx0ICogSlNPTlAgZmlsZXMgYXJlIGxvYWRlZCBhcyBKYXZhU2NyaXB0LCBhbmQgdGhlIFwiY2FsbGJhY2tcIiBpcyBleGVjdXRlZCBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIGluIHRoZVxuXHQgKiBKU09OUCBtdXN0IG1hdGNoIHRoZSBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvYWRJdGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZSBKU09OUDwvaDQ+XG5cdCAqXG5cdCAqIFx0XHRjYWxsYmFja05hbWUoe1xuXHQgKiBcdFx0XHRcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuXHQgKlx0IFx0XHRcIm51bVwiOiAzLFxuXHQgKlx0XHRcdFwib2JqXCI6IHsgXCJib29sXCI6dHJ1ZSB9XG5cdCAqIFx0XHR9KTtcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0dmFyIGxvYWRJdGVtID0ge2lkOlwianNvblwiLCB0eXBlOlwianNvbnBcIiwgc3JjOlwiaHR0cDovL3NlcnZlci5jb20vdGV4dC5qc29uXCIsIGNhbGxiYWNrOlwiY2FsbGJhY2tOYW1lXCJ9XG5cdCAqIFx0XHR2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqIFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcblx0ICogXHRcdHF1ZXVlLmxvYWRJdGVtKGxvYWRJdGVtKTtcblx0ICpcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKGV2ZW50KSB9XG5cdCAqIFx0XHRcdHZhciBqc29uID0gcXVldWUuZ2V0UmVzdWx0KFwianNvblwiKTtcblx0ICogXHRcdFx0Y29uc29sZS5sb2coanNvbi5vYmouYm9vbCk7IC8vIHRydWVcblx0ICogXHRcdH1cblx0ICpcblx0ICogTm90ZSB0aGF0IEpTT05QIGZpbGVzIGxvYWRlZCBjb25jdXJyZW50bHkgcmVxdWlyZSBhIDxlbT51bmlxdWU8L2VtPiBjYWxsYmFjay4gVG8gZW5zdXJlIEpTT05QIGZpbGVzIGFyZSBsb2FkZWRcblx0ICogaW4gb3JkZXIsIGVpdGhlciB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgKHNldCB0byAxKSxcblx0ICogb3Igc2V0IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL21haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb24gaXRlbXMgd2l0aCB0aGUgc2FtZSBjYWxsYmFjay5cblx0ICpcblx0ICogQGNsYXNzIEpTT05QTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEpTT05QTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgZmFsc2UsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT05QKTtcblx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKTtcblx0XHR0aGlzLmdldFRhZygpLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05QTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTlBMb2FkZXI7XG5cblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT05QO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY2FuY2VsKCk7XG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2FkcyB0aGUgSlNPTnAgZmlsZS4gIEJlY2F1c2Ugb2YgdGhlIHVuaXF1ZSBsb2FkaW5nIG5lZWRzIG9mIEpTT05wXG5cdCAqIHdlIGRvbid0IHVzZSB0aGUgQWJzdHJhY3RMb2FkZXIubG9hZCgpIG1ldGhvZC5cblx0ICpcblx0ICogQG1ldGhvZCBsb2FkXG5cdCAqXG5cdCAqL1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2l0ZW0uY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyByZXF1aXJlZCBmb3IgbG9hZGluZyBKU09OUCByZXF1ZXN0cy4nKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBMb29rIGludG8gY3JlYXRpbmcgb3VyIG93biBpRnJhbWUgdG8gaGFuZGxlIHRoZSBsb2FkXG5cdFx0Ly8gSW4gdGhlIGZpcnN0IGF0dGVtcHQsIEZGIGRpZCBub3QgZ2V0IHRoZSByZXN1bHRcblx0XHQvLyAgIHJlc3VsdCBpbnN0YW5jZW9mIE9iamVjdCBkaWQgbm90IHdvcmsgZWl0aGVyXG5cdFx0Ly8gICBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNsb25lIHRoZSByZXN1bHQuXG5cdFx0aWYgKHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXSAhPSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiSlNPTlAgY2FsbGJhY2sgJ1wiICtcblx0XHRcdFx0dGhpcy5faXRlbS5jYWxsYmFjayArXG5cdFx0XHRcdFwiJyBhbHJlYWR5IGV4aXN0cyBvbiB3aW5kb3cuIFlvdSBuZWVkIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgY2FsbGJhY2sgb3IgcmUtbmFtZSB0aGUgY3VycmVudCBvbmUuXCIpO1xuXHRcdH1cblxuXHRcdHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWQsIHRoaXMpO1xuXHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3RhZyk7XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0Ly8gTG9hZCB0aGUgdGFnXG5cdFx0dGhpcy5fdGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSBKU09OUCBjYWxsYmFjaywgd2hpY2ggaXMgYSBwdWJsaWMgbWV0aG9kIGRlZmluZWQgb24gYHdpbmRvd2AuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGZvcm1hdHRlZCBKU09OIGRhdGEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQgPSBkYXRhO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcInRpbWVvdXRcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgSlNPTlAgbG9hZC4gVGhpcyBjbGVhcnMgb3V0IHRoZSBjYWxsYmFjayBhbmQgc2NyaXB0IHRhZyB0aGF0IHRoaXMgbG9hZGVyIGNyZWF0ZXMuXG5cdCAqIEBtZXRob2QgX2Rpc3Bvc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0d2luZG93LmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHRkZWxldGUgd2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OUExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTlBMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNYW5pZmVzdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIG1hbmlmZXN0cy4gSXRlbXMgaW5zaWRlIHRoZSBtYW5pZmVzdCBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyIGNvbXBsZXRlcy4gVG8gbG9hZCBtYW5pZmVzdHNcblx0ICogdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyBwYXJ0IG9mIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIGxpc3Qgb2YgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IG11c3QgYmUgZGVmaW5lZCBvbiB0aGUgdG9wLWxldmVsIEpTT04gb2JqZWN0IGluIGEgYG1hbmlmZXN0YCBwcm9wZXJ0eS4gVGhpc1xuXHQgKiBleGFtcGxlIHNob3dzIGEgc2FtcGxlIG1hbmlmZXN0IGRlZmluaXRpb24sIGFzIHdlbGwgYXMgaG93IHRvIHRvIGluY2x1ZGUgYSBzdWItbWFuaWZlc3QuXG5cdCAqXG5cdCAqIFx0XHR7XG5cdCAqIFx0XHRcdFwicGF0aFwiOiBcImFzc2V0cy9cIixcblx0ICpcdCBcdCAgICBcIm1hbmlmZXN0XCI6IFtcblx0ICpcdFx0XHRcdFwiaW1hZ2UucG5nXCIsXG5cdCAqXHRcdFx0XHR7XCJzcmNcIjogXCJpbWFnZTIucG5nXCIsIFwiaWRcIjpcImltYWdlMlwifSxcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcInN1Yi1tYW5pZmVzdC5qc29uXCIsIFwidHlwZVwiOlwibWFuaWZlc3RcIiwgXCJjYWxsYmFja1wiOlwianNvbkNhbGxiYWNrXCJ9XG5cdCAqXHQgXHQgICAgXVxuXHQgKlx0IFx0fVxuXHQgKlxuXHQgKiBXaGVuIGEgTWFuaWZlc3RMb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCB0aGUgcGFyZW50IGxvYWRlciAodXN1YWxseSBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGNvdWxkIGFsc28gYmUgYW5vdGhlciBNYW5pZmVzdExvYWRlcikgd2lsbCBpbmhlcml0IGFsbCB0aGUgbG9hZGVkIGl0ZW1zLCBzbyB5b3UgY2FuIGFjY2VzcyB0aGVtIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZVxuXHQgKiBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gbWFuaWZlc3RzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBNYW5pZmVzdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNYW5pZmVzdExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIG51bGwsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUKTtcblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdXNlZCB0byBwYXNzIHBsdWdpbnMgdG8gbmV3IExvYWRRdWV1ZXMgdGhhdCBtYXkgYmUgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG5cblx0Ly8gUHJvdGVjdGVkIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IE1hbmlmZXN0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQU5JRkVTVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5NQU5JRkVTVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24ubWFuaWZlc3QpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcdC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcblx0XHRcdFx0cXVldWUuaW5zdGFsbFBsdWdpbih0aGlzLnBsdWdpbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5NQU5JRkVTVF9QUk9HUkVTUykgKyBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShNYW5pZmVzdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEhUTUwgYXVkaW8gZmlsZXMuIFByZWxvYWRKUyBjYW4gbm90IGxvYWQgV2ViQXVkaW8gZmlsZXMsIGFzIGEgV2ViQXVkaW8gY29udGV4dCBpcyByZXF1aXJlZCwgd2hpY2hcblx0ICogc2hvdWxkIGJlIGNyZWF0ZWQgYnkgZWl0aGVyIGEgbGlicmFyeSBwbGF5aW5nIHRoZSBzb3VuZCAoc3VjaCBhcyA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4sIG9yIGFuXG5cdCAqIGV4dGVybmFsIGZyYW1ld29yayB0aGF0IGhhbmRsZXMgYXVkaW8gcGxheWJhY2suIFRvIGxvYWQgY29udGVudCB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgV2ViQXVkaW8sIHVzZSB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQmluYXJ5TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgaGFuZGxlIHRoZSBhdWRpbyBjb250ZXh0IGRlY29kaW5nIG1hbnVhbGx5LlxuXHQgKiBAY2xhc3MgU291bmRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTb3VuZExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSA/IGxvYWRJdGVtIDogbG9hZEl0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNvdW5kTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcblx0dmFyIHMgPSBTb3VuZExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdHRhZy5hdXRvcGxheSA9IGZhbHNlO1xuXHRcdHRhZy5wcmVsb2FkID0gXCJub25lXCI7XG5cblx0XHQvL0xNOiBGaXJlZm94IGZhaWxzIHdoZW4gdGhpcyB0aGUgcHJlbG9hZD1cIm5vbmVcIiBmb3Igb3RoZXIgdGFncywgYnV0IGl0IG5lZWRzIHRvIGJlIFwibm9uZVwiIHRvIGVuc3VyZSBQcmVsb2FkSlMgd29ya3MuXG5cdFx0dGFnLnNyYyA9IHNyYztcblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNvdW5kTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTb3VuZExvYWRlciwgXCJBYnN0cmFjdE1lZGlhTG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVmlkZW9Mb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgdmlkZW8gZmlsZXMuXG5cdCAqIEBjbGFzcyBWaWRlb0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFZpZGVvTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TWVkaWFMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU8pO1xuXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKSB8fCBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLnNldFRhZyhjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbSk/bG9hZEl0ZW06bG9hZEl0ZW0uc3JjKTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3QgdXNlIFhIUiBmb3IgYSB0YWcgdGhhdCdzIHBhc3NlZCBpbi5cblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyh0aGlzLl9jcmVhdGVUYWcoKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFZpZGVvTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcblx0dmFyIHMgPSBWaWRlb0xvYWRlcjtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IHZpZGVvIHRhZ1xuXHQgKlxuXHQgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcblx0fTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlZpZGVvTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShWaWRlb0xvYWRlciwgXCJBYnN0cmFjdE1lZGlhTG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgRWFzZWxKUyBTcHJpdGVTaGVldHMuIEltYWdlcyBpbnNpZGUgdGhlIHNwcml0ZXNoZWV0IGRlZmluaXRpb24gYXJlIGxvYWRlZCBiZWZvcmUgdGhlIGxvYWRlclxuXHQgKiBjb21wbGV0ZXMuIFRvIGxvYWQgU3ByaXRlU2hlZXRzIHVzaW5nIEpTT05QLCBzcGVjaWZ5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYXMgcGFydCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBTcHJpdGVTaGVldHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+XG5cdCAqIHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0ge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eVxuXHQgKiB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2Nyb3NzT3JpZ2luOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHdlbGxcblx0ICogYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZSdzXCJ9fXt7L2Nyb3NzTGlua319IGBiYXNlUGF0aGAgYXJndW1lbnQgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fcHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IHN1cHBsaWVkIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gYXJlIHBhc3NlZCBvbiB0byB0aGUgc3ViLW1hbmlmZXN0IHRoYXQgbG9hZHNcblx0ICogdGhlIFNwcml0ZVNoZWV0IGltYWdlcy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBTcHJpdGVTaGVldCBKU09OIGRvZXMgbm90IHJlc3BlY3QgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5LCB3aGljaCBzaG91bGQgaW5zdGVhZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IG9uIHRoZSBTcHJpdGVTaGVldCBsb2FkIGl0ZW0uIFRoaXMgaXMgYmVjYXVzZSB0aGUgSlNPTiBsb2FkZWQgd2lsbCBoYXZlIGEgZGlmZmVyZW50IGZvcm1hdCBkZXBlbmRpbmcgb25cblx0ICogaWYgaXQgaXMgbG9hZGVkIGFzIEpTT04sIHNvIGp1c3QgY2hhbmdpbmcgYHByZWZlclhIUmAgaXMgbm90IGVub3VnaCB0byBjaGFuZ2UgaG93IGl0IGlzIGxvYWRlZC5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQW4gaW50ZXJuYWwgcXVldWUgd2hpY2ggbG9hZHMgdGhlIFNwcml0ZVNoZWV0J3MgaW1hZ2VzLlxuXHRcdCAqIEBtZXRob2QgX21hbmlmZXN0UXVldWVcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG51bGw7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFNwcml0ZVNoZWV0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IFNQUklURVNIRUVUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5TUFJJVEVTSEVFVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfZGVzdHJveTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMuX2l0ZW0uY2FsbGJhY2s7XG5cdFx0aWYgKGNhbGxiYWNrICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTkxvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpO1xuXHRcdFx0XHR0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdGV2ZW50LmxvYWRlZCAqPSBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdFx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG5cdFx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgaW1hZ2VzIG9uY2UgdGhlIFNwcml0ZVNoZWV0IEpTT04gaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5pbWFnZXMpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKHRoaXMuX3ByZWZlclhIUiwgdGhpcy5faXRlbS5wYXRoLCB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbi5pbWFnZXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGltYWdlID0gZXZlbnQucmVzdWx0O1xuXHRcdGlmIChpbWFnZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgaW1hZ2VzID0gdGhpcy5nZXRSZXN1bHQoKS5pbWFnZXM7XG5cdFx0XHR2YXIgcG9zID0gaW1hZ2VzLmluZGV4T2YoZXZlbnQuaXRlbS5zcmMpO1xuXHRcdFx0aW1hZ2VzW3Bvc10gPSBpbWFnZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMgaGF2ZSBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgU3ByaXRlU2hlZXRMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9yZXN1bHQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQodGhpcy5fcmVzdWx0KTtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBpbWFnZXMge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLlNQUklURVNIRUVUX1BST0dSRVNTKSArIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG5cdFx0dGhpcy5fc2VuZFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpbWFnZSBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNWR0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBjbGFzcyBTVkdMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU1ZHTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImRhdGFcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpKTtcblx0XHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTVkdMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTVkdMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHQvLyBtaW1lIHNob3VsZCBiZSBpbWFnZS9zdmcreG1sLCBidXQgT3BlcmEgcmVxdWlyZXMgdGV4dC94bWxcblx0XHR2YXIgeG1sID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModGFnKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH1cblxuXHRcdGlmICh4bWwuZG9jdW1lbnRFbGVtZW50ICE9IG51bGwpIHtcblx0XHRcdHRhZy5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdHRhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH0gZWxzZSB7IC8vIEZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgU1ZHLCBqdXN0IGdpdmUgdGhlbSB0aGUgWE1MLiAoSUUgOS04KVxuXHRcdFx0cmV0dXJuIHhtbDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAY2xhc3MgWE1MTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFhNTExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhNTExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFhNTExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBYTUwgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge1hNTERvY3VtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHJldHVybiBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSwgXCJ0ZXh0L3htbFwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5YTUxMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFhNTExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBUaGUgU291bmRKUyBjbGFzcyBoYXMgYmVlbiByZW5hbWVkIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LiAgUGxlYXNlIHNlZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgaW5mb3JtYXRpb24gb24gdXNpbmcgc291bmQuXG5cdCAqIEBjbGFzcyBTb3VuZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5Tb3VuZEpTID0gY3JlYXRlanMuU291bmRKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDI2IE5vdiAyMDE1IDIwOjQ0OjMxIEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgc3BlY2lmaWVkIHZhbHVlIHNlYXJjaEVsZW1lbnQgaW4gdGhlIHBhc3NlZCBpbiBhcnJheSwgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mXG4gKiB0aGF0IHZhbHVlLiAgUmV0dXJucyAtMSBpZiB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogICAgICB2YXIgaSA9IGNyZWF0ZWpzLmluZGV4T2YobXlBcnJheSwgbXlFbGVtZW50VG9GaW5kKTtcbiAqXG4gKiBAbWV0aG9kIGluZGV4T2ZcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaCBmb3Igc2VhcmNoRWxlbWVudFxuICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBmaW5kIGluIGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmlyc3QgaW5kZXggb2Ygc2VhcmNoRWxlbWVudCBpbiBhcnJheS5cbiAqL1xuY3JlYXRlanMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgc2VhcmNoRWxlbWVudCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZvciAodmFyIGkgPSAwLGw9YXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0aWYgKHNlYXJjaEVsZW1lbnQgPT09IGFycmF5W2ldKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFByb3h5LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCcm93c2VyRGV0ZWN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBicm93c2VyLCB2ZXJzaW9uLCBvcGVyYXRpbmcgc3lzdGVtLCBhbmQgb3RoZXIgZW52aXJvbm1lbnRcblx0ICogdmFyaWFibGVzIHZpYSB1c2VyIGFnZW50IHN0cmluZy5cblx0ICpcblx0ICogVXNlZCBmb3IgYXVkaW8gYmVjYXVzZSBmZWF0dXJlIGRldGVjdGlvbiBpcyB1bmFibGUgdG8gZGV0ZWN0IHRoZSBtYW55IGxpbWl0YXRpb25zIG9mIG1vYmlsZSBkZXZpY2VzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgaWYgKGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNJT1MpIHsgLy8gZG8gc3R1ZmYgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgQnJvd3NlckRldGVjdFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRmlyZWZveCBUcnVlIGlmIG91ciBicm93c2VyIGlzIEZpcmVmb3guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcGVyYSBUcnVlIGlmIG91ciBicm93c2VyIGlzIG9wZXJhLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hyb21lIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQ2hyb21lLiAgTm90ZSB0aGF0IENocm9tZSBmb3IgQW5kcm9pZCByZXR1cm5zIHRydWUsIGJ1dCBpcyBhXG5cdCAqIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSU9TIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgc2FmYXJpIGZvciBpT1MgZGV2aWNlcyAoaVBhZCwgaVBob25lLCBhbmQgaVBvZCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBbmRyb2lkIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQW5kcm9pZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JsYWNrYmVycnkgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBCbGFja2JlcnJ5LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0ZnVuY3Rpb24gQnJvd3NlckRldGVjdCgpIHtcblx0XHR0aHJvdyBcIkJyb3dzZXJEZXRlY3QgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9O1xuXG5cdHZhciBhZ2VudCA9IEJyb3dzZXJEZXRlY3QuYWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0QnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lID0gKGFnZW50LmluZGV4T2YoXCJJRU1vYmlsZVwiKSA+IC0xKSB8fCAoYWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPiAtMSk7XG5cdEJyb3dzZXJEZXRlY3QuaXNGaXJlZm94ID0gKGFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTEpO1xuXHRCcm93c2VyRGV0ZWN0LmlzT3BlcmEgPSAod2luZG93Lm9wZXJhICE9IG51bGwpO1xuXHRCcm93c2VyRGV0ZWN0LmlzQ2hyb21lID0gKGFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPiAtMSk7ICAvLyBOT1RFIHRoYXQgQ2hyb21lIG9uIEFuZHJvaWQgcmV0dXJucyB0cnVlIGJ1dCBpcyBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzXG5cdEJyb3dzZXJEZXRlY3QuaXNJT1MgPSAoYWdlbnQuaW5kZXhPZihcImlQb2RcIikgPiAtMSB8fCBhZ2VudC5pbmRleE9mKFwiaVBob25lXCIpID4gLTEgfHwgYWdlbnQuaW5kZXhPZihcImlQYWRcIikgPiAtMSkgJiYgIUJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZTtcblx0QnJvd3NlckRldGVjdC5pc0FuZHJvaWQgPSAoYWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIikgPiAtMSkgJiYgIUJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZTtcblx0QnJvd3NlckRldGVjdC5pc0JsYWNrYmVycnkgPSAoYWdlbnQuaW5kZXhPZihcIkJsYWNrYmVycnlcIikgPiAtMSk7XG5cblx0Y3JlYXRlanMuQnJvd3NlckRldGVjdCA9IEJyb3dzZXJEZXRlY3Q7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBdWRpb1Nwcml0ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLy8gIE5PVEUgdGhpcyBpcyBcIkNsYXNzXCIgaXMgcHVyZWx5IHRvIGRvY3VtZW50IGF1ZGlvU3ByaXRlIFNldHVwIGFuZCB1c2FnZS5cblxuXG4vKipcbiAqIDxzdHJvbmc+Tm90ZTogQXVkaW9TcHJpdGUgaXMgbm90IGEgY2xhc3MsIGJ1dCBpdHMgdXNhZ2UgaXMgZWFzaWx5IGxvc3QgaW4gdGhlIGRvY3VtZW50YXRpb24sIHNvIGl0IGhhcyBiZWVuIGNhbGxlZFxuICogb3V0IGhlcmUgZm9yIHF1aWNrIHJlZmVyZW5jZS48L3N0cm9uZz5cbiAqXG4gKiBBdWRpbyBzcHJpdGVzIGFyZSBtdWNoIGxpa2UgQ1NTIHNwcml0ZXMgb3IgaW1hZ2Ugc3ByaXRlIHNoZWV0czogbXVsdGlwbGUgYXVkaW8gYXNzZXRzIGdyb3VwZWQgaW50byBhIHNpbmdsZSBmaWxlLlxuICogQXVkaW8gc3ByaXRlcyB3b3JrIGFyb3VuZCBsaW1pdGF0aW9ucyBpbiBjZXJ0YWluIGJyb3dzZXJzLCB3aGVyZSBvbmx5IGEgc2luZ2xlIHNvdW5kIGNhbiBiZSBsb2FkZWQgYW5kIHBsYXllZCBhdCBhXG4gKiB0aW1lLiBXZSByZWNvbW1lbmQgYXQgbGVhc3QgMzAwbXMgb2Ygc2lsZW5jZSBiZXR3ZWVuIGF1ZGlvIGNsaXBzIHRvIGRlYWwgd2l0aCBIVE1MIGF1ZGlvIHRhZyBpbmFjY3VyYWN5LCBhbmQgdG8gcHJldmVudFxuICogYWNjaWRlbnRhbGx5IHBsYXlpbmcgYml0cyBvZiB0aGUgbmVpZ2hib3VyaW5nIGNsaXBzLlxuICpcbiAqIDxzdHJvbmc+QmVuZWZpdHMgb2YgQXVkaW8gU3ByaXRlczo8L3N0cm9uZz5cbiAqIDx1bD5cbiAqICAgICA8bGk+TW9yZSByb2J1c3Qgc3VwcG9ydCBmb3Igb2xkZXIgYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBvbmx5IGFsbG93IGEgc2luZ2xlIGF1ZGlvIGluc3RhbmNlLCBzdWNoIGFzIGlPUyA1LjwvbGk+XG4gKiAgICAgPGxpPlRoZXkgcHJvdmlkZSBhIHdvcmsgYXJvdW5kIGZvciB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgOSBhdWRpbyB0YWcgbGltaXQsIHdoaWNoIHJlc3RyaWN0cyBob3cgbWFueSBkaWZmZXJlbnRcbiAqICAgICBzb3VuZHMgdGhhdCBjb3VsZCBiZSBsb2FkZWQgYXQgb25jZS48L2xpPlxuICogICAgIDxsaT5GYXN0ZXIgbG9hZGluZyBieSBvbmx5IHJlcXVpcmluZyBhIHNpbmdsZSBuZXR3b3JrIHJlcXVlc3QgZm9yIHNldmVyYWwgc291bmRzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzXG4gKiB3aGVyZSB0aGUgbmV0d29yayByb3VuZCB0cmlwIGZvciBlYWNoIGZpbGUgY2FuIGFkZCBzaWduaWZpY2FudCBsYXRlbmN5LjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxzdHJvbmc+RHJhd2JhY2tzIG9mIEF1ZGlvIFNwcml0ZXM8L3N0cm9uZz5cbiAqIDx1bD5cbiAqICAgICA8bGk+Tm8gZ3VhcmFudGVlIG9mIHNtb290aCBsb29waW5nIHdoZW4gdXNpbmcgSFRNTCBvciBGbGFzaCBhdWRpby4gSWYgeW91IGhhdmUgYSB0cmFjayB0aGF0IG5lZWRzIHRvIGxvb3BcbiAqIFx0XHRzbW9vdGhseSBhbmQgeW91IGFyZSBzdXBwb3J0aW5nIG5vbi13ZWIgYXVkaW8gYnJvd3NlcnMsIGRvIG5vdCB1c2UgYXVkaW8gc3ByaXRlcyBmb3IgdGhhdCBzb3VuZCBpZiB5b3UgY2FuIGF2b2lkXG4gKiBcdFx0aXQuPC9saT5cbiAqICAgICA8bGk+Tm8gZ3VhcmFudGVlIHRoYXQgSFRNTCBhdWRpbyB3aWxsIHBsYXkgYmFjayBpbW1lZGlhdGVseSwgZXNwZWNpYWxseSB0aGUgZmlyc3QgdGltZS4gSW4gc29tZSBicm93c2Vyc1xuICogICAgIChDaHJvbWUhKSwgSFRNTCBhdWRpbyB3aWxsIG9ubHkgbG9hZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoIGF0IHRoZSBjdXJyZW50IGRvd25sb2FkIHNwZWVkIMOi4oKs4oCcIHNvIHdlIHJlbHkgb24gdGhlXG4gKiAgICAgYGNhbnBsYXl0aHJvdWdoYCBldmVudCB0byBkZXRlcm1pbmUgaWYgdGhlIGF1ZGlvIGlzIGxvYWRlZC4gU2luY2UgYXVkaW8gc3ByaXRlcyBtdXN0IGp1bXAgYWhlYWQgdG8gcGxheSBzcGVjaWZpY1xuICogICAgIHNvdW5kcywgdGhlIGF1ZGlvIG1heSBub3QgeWV0IGhhdmUgZG93bmxvYWRlZCBmdWxseS48L2xpPlxuICogICAgIDxsaT5BdWRpbyBzcHJpdGVzIHNoYXJlIHRoZSBzYW1lIGNvcmUgc291cmNlLCBzbyBpZiB5b3UgaGF2ZSBhIHNwcml0ZSB3aXRoIDUgc291bmRzIGFuZCBhcmUgbGltaXRlZCB0byAyXG4gKiBcdFx0Y29uY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzLCB5b3UgY2FuIG9ubHkgcGxheSAyIG9mIHRoZSBzb3VuZHMgYXQgdGhlIHNhbWUgdGltZS48L2xpPlxuICogPC91bD5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICpcdFx0Y3JlYXRlanMuU291bmQuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCk7XG4gKlx0XHR2YXIgYXNzZXRzUGF0aCA9IFwiLi9hc3NldHMvXCI7XG4gKlx0XHR2YXIgc291bmRzID0gW3tcbiAqXHRcdFx0c3JjOlwiTXlBdWRpb1Nwcml0ZS5vZ2dcIiwgZGF0YToge1xuICpcdFx0XHRcdGF1ZGlvU3ByaXRlOiBbXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDFcIiwgc3RhcnRUaW1lOjAsIGR1cmF0aW9uOjUwMH0sXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDJcIiwgc3RhcnRUaW1lOjEwMDAsIGR1cmF0aW9uOjQwMH0sXG4gKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDNcIiwgc3RhcnRUaW1lOjE3MDAsIGR1cmF0aW9uOiAxMDAwfVxuICpcdFx0XHRcdF19XG4gKlx0XHRcdH1cbiAqXHRcdF07XG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuICpcdFx0Y3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBsb2FkU291bmQpO1xuICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldHNQYXRoKTtcbiAqXHRcdC8vIGFmdGVyIGxvYWQgaXMgY29tcGxldGVcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJzb3VuZDJcIik7XG4gKlxuICogWW91IGNhbiBhbHNvIGNyZWF0ZSBhdWRpbyBzcHJpdGVzIG9uIHRoZSBmbHkgYnkgc2V0dGluZyB0aGUgc3RhcnRUaW1lIGFuZCBkdXJhdGlvbiB3aGVuIGNyZWF0aW5nIGFuIG5ldyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG4gKlxuICogXHRcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJNeUF1ZGlvU3ByaXRlXCIsIHtzdGFydFRpbWU6IDEwMDAsIGR1cmF0aW9uOiA0MDB9KTtcbiAqXG4gKiBUaGUgZXhjZWxsZW50IENyZWF0ZUpTIGNvbW11bml0eSBoYXMgY3JlYXRlZCBhIHRvb2wgdG8gY3JlYXRlIGF1ZGlvIHNwcml0ZXMsIGF2YWlsYWJsZSBhdFxuICogPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS90b25pc3RpaWdpL2F1ZGlvc3ByaXRlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cHM6Ly9naXRodWIuY29tL3RvbmlzdGlpZ2kvYXVkaW9zcHJpdGU8L2E+LFxuICogYXMgd2VsbCBhcyBhIDxhIGhyZWY9XCJodHRwOi8vanNmaWRkbGUubmV0L2JoYXJhdF9iYXR0dS9nOGZGUC8xMi9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5qc2ZpZGRsZTwvYT4gdG8gY29udmVydCB0aGUgb3V0cHV0XG4gKiB0byBTb3VuZEpTIGZvcm1hdC5cbiAqXG4gKiBAY2xhc3MgQXVkaW9TcHJpdGVcbiAqIEBzaW5jZSAwLjYuMFxuICovXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQbGF5UHJvcHNDb25maWcuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKipcblx0ICogQSBjbGFzcyB0byBzdG9yZSB0aGUgb3B0aW9uYWwgcGxheSBwcm9wZXJ0aWVzIHBhc3NlZCBpbiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fSBjYWxscy5cblx0ICpcblx0ICogT3B0aW9uYWwgUGxheSBQcm9wZXJ0aWVzIEluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogPGxpPmludGVycnVwdCAtIEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPlxuXHQgKiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LjwvbGk+XG5cdCAqIDxsaT5kZWxheSAtIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8bGk+b2Zmc2V0IC0gVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8bGk+bG9vcCAtIEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLjwvbGk+XG5cdCAqIDxsaT52b2x1bWUgLSBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS48L2xpPlxuXHQgKiA8bGk+cGFuIC0gVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS48L2xpPlxuXHQgKiA8bGk+c3RhcnRUaW1lIC0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuPC9saT5cblx0ICogPGxpPmR1cmF0aW9uIC0gVG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0dmFyIHBwYyA9IG5ldyBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcoKS5zZXQoe2ludGVycnVwdDogY3JlYXRlanMuU291bmQuSU5URVJSVVBUX0FOWSwgbG9vcDogLTEsIHZvbHVtZTogMC41fSlcblx0ICogXHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlTb3VuZFwiLCBwcGMpO1xuXHQgKiBcdG15U291bmRJbnN0YW5jZS5wbGF5KHBwYyk7XG5cdCAqXG5cdCAqIEBjbGFzcyBQbGF5UHJvcHNDb25maWdcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0Ly8gVE9ETyB0aGluayBvZiBhIGJldHRlciBuYW1lIGZvciB0aGlzIGNsYXNzXG5cdHZhciBQbGF5UHJvcHNDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4vLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0XHQgKiBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiBWYWx1ZXMgYXJlIGRlZmluZWQgYXNcblx0XHQgKiA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT4gY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5XG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbnRlcnJ1cHRcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmludGVycnVwdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IGRlbGF5XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kZWxheSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBhdWRpbyB0byBiZWdpbiBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdFx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkXG5cdFx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuXG5cdFx0ICogQHByb3BlcnR5IHZvbHVtZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudm9sdW1lID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdFx0ICogQHByb3BlcnR5IHBhblxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucGFuID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBkdXJhdGlvbiksIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0VGltZVxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSAod2l0aCBzdGFydFRpbWUpLCB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gbnVsbDtcblx0fTtcblx0dmFyIHAgPSBQbGF5UHJvcHNDb25maWcucHJvdG90eXBlID0ge307XG5cdHZhciBzID0gUGxheVByb3BzQ29uZmlnO1xuXG5cbi8vIFN0YXRpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgUGxheVByb3BzQ29uZmlnIGZyb20gYW5vdGhlciBQbGF5UHJvcHNDb25maWcgb3IgYW4gT2JqZWN0LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ3xPYmplY3R9IHZhbHVlIFRoZSBwbGF5IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge1BsYXlQcm9wc0NvbmZpZ31cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBzIHx8IHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHR2YXIgcHBjID0gbmV3IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZygpO1xuXHRcdFx0cHBjLnNldCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gcHBjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG5vdCByZWNvZ25pemVkLlwiKTtcblx0XHR9XG5cdH07XG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgUGxheVByb3BzQ29uZmlnID0gbmV3IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZygpLnNldCh7bG9vcDotMSwgdm9sdW1lOjAuN30pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgUGxheVByb3BzQ29uZmlnIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtQbGF5UHJvcHNDb25maWd9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQbGF5UHJvcHNDb25maWddXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuUGxheVByb3BzQ29uZmlnID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVGhlIFNvdW5kIGNsYXNzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBjcmVhdGluZyBzb3VuZHMsIGNvbnRyb2xsaW5nIHRoZSBvdmVyYWxsIHNvdW5kIGxldmVscywgYW5kIG1hbmFnaW5nIHBsdWdpbnMuXG5cdCAqIEFsbCBTb3VuZCBBUElzIG9uIHRoaXMgY2xhc3MgYXJlIHN0YXRpYy5cblx0ICpcblx0ICogPGI+UmVnaXN0ZXJpbmcgYW5kIFByZWxvYWRpbmc8L2I+PGJyIC8+XG5cdCAqIEJlZm9yZSB5b3UgY2FuIHBsYXkgYSBzb3VuZCwgaXQgPGI+bXVzdDwvYj4gYmUgcmVnaXN0ZXJlZC4gWW91IGNhbiBkbyB0aGlzIHdpdGgge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogb3IgcmVnaXN0ZXIgbXVsdGlwbGUgc291bmRzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LiBJZiB5b3UgZG9uJ3QgcmVnaXN0ZXIgYVxuXHQgKiBzb3VuZCBwcmlvciB0byBhdHRlbXB0aW5nIHRvIHBsYXkgaXQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBvciBjcmVhdGUgaXQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHRoZSBzb3VuZCBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyZWQgYnV0IHBsYXliYWNrIHdpbGwgZmFpbCBhcyB0aGUgc291cmNlIHdpbGwgbm90IGJlIHJlYWR5LiBJZiB5b3UgdXNlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4sIHJlZ2lzdHJhdGlvbiBpcyBoYW5kbGVkIGZvciB5b3Ugd2hlbiB0aGUgc291bmQgaXNcblx0ICogcHJlbG9hZGVkLiBJdCBpcyByZWNvbW1lbmRlZCB0byBwcmVsb2FkIHNvdW5kcyBlaXRoZXIgaW50ZXJuYWxseSB1c2luZyB0aGUgcmVnaXN0ZXIgZnVuY3Rpb25zIG9yIGV4dGVybmFsbHkgdXNpbmdcblx0ICogUHJlbG9hZEpTIHNvIHRoZXkgYXJlIHJlYWR5IHdoZW4geW91IHdhbnQgdG8gdXNlIHRoZW0uXG5cdCAqXG5cdCAqIDxiPlBsYXliYWNrPC9iPjxiciAvPlxuXHQgKiBUbyBwbGF5IGEgc291bmQgb25jZSBpdCdzIGJlZW4gcmVnaXN0ZXJlZCBhbmQgcHJlbG9hZGVkLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHdoaWNoIGNhbiBiZSBwYXVzZWQsIHJlc3VtZWQsIG11dGVkLCBldGMuXG5cdCAqIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIG9uIHRoZSBpbnN0YW5jZSBjb250cm9sIEFQSXMuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIEJ5IGRlZmF1bHQsIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBvciB0aGUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFyZSB1c2VkICh3aGVuIGF2YWlsYWJsZSksIGFsdGhvdWdoIGRldmVsb3BlcnMgY2FuIGNoYW5nZSBwbHVnaW4gcHJpb3JpdHkgb3IgYWRkIG5ldyBwbHVnaW5zIChzdWNoIGFzIHRoZVxuXHQgKiBwcm92aWRlZCB7eyNjcm9zc0xpbmsgXCJGbGFzaEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319KS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gQVBJXG5cdCAqIG1ldGhvZHMgZm9yIG1vcmUgb24gdGhlIHBsYXliYWNrIGFuZCBwbHVnaW4gQVBJcy4gVG8gaW5zdGFsbCBwbHVnaW5zLCBvciBzcGVjaWZ5IGEgZGlmZmVyZW50IHBsdWdpbiBvcmRlciwgc2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luc3RhbGxQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbi5zd2ZQYXRoID0gXCIuLi9zcmMvc291bmRqcy9mbGFzaGF1ZGlvXCI7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbl0pO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCB0aGlzLmxvYWRIYW5kbGVyLCB0aGlzKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwicGF0aC90by9teVNvdW5kLm9nZ1wiLCBcInNvdW5kXCIpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGxvYWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgICAgLy8gVGhpcyBpcyBmaXJlZCBmb3IgZWFjaCBzb3VuZCB0aGF0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICogICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcInNvdW5kXCIpOyAgLy8gcGxheSB1c2luZyBpZC4gIENvdWxkIGFsc28gdXNlIGZ1bGwgc291cmNlIHBhdGggb3IgZXZlbnQuc3JjLlxuICAgICAqICAgICAgICAgIGluc3RhbmNlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5oYW5kbGVDb21wbGV0ZSwgdGhpcyk7XG4gICAgICogICAgICAgICAgaW5zdGFuY2Uudm9sdW1lID0gMC41O1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzb3VuZCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBcImRhdGFcIiBhcmd1bWVudFxuXHQgKiBvZiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LiAgTm90ZSB0aGF0IGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBhY3RpdmUgcGx1Z2luIHdpbGwgYXBwbHlcblx0ICogYSBkZWZhdWx0IGxpbWl0LiAgQ3VycmVudGx5IEhUTUxBdWRpb1BsdWdpbiBzZXRzIGEgZGVmYXVsdCBsaW1pdCBvZiAyLCB3aGlsZSBXZWJBdWRpb1BsdWdpbiBhbmQgRmxhc2hBdWRpb1BsdWdpbiBzZXQgYVxuXHQgKiBkZWZhdWx0IGxpbWl0IG9mIDEwMC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwic291bmQubXAzXCIsIFwic291bmRJZFwiLCA0KTtcblx0ICpcblx0ICogU291bmQgY2FuIGJlIHVzZWQgYXMgYSBwbHVnaW4gd2l0aCBQcmVsb2FkSlMgdG8gaGVscCBwcmVsb2FkIGF1ZGlvIHByb3Blcmx5LiBBdWRpbyBwcmVsb2FkZWQgd2l0aCBQcmVsb2FkSlMgaXNcblx0ICogYXV0b21hdGljYWxseSByZWdpc3RlcmVkIHdpdGggdGhlIFNvdW5kIGNsYXNzLiBXaGVuIGF1ZGlvIGlzIG5vdCBwcmVsb2FkZWQsIFNvdW5kIHdpbGwgZG8gYW4gYXV0b21hdGljIGludGVybmFsXG5cdCAqIGxvYWQuIEFzIGEgcmVzdWx0LCBpdCBtYXkgZmFpbCB0byBwbGF5IHRoZSBmaXJzdCB0aW1lIHBsYXkgaXMgY2FsbGVkIGlmIHRoZSBhdWRpbyBpcyBub3QgZmluaXNoZWQgbG9hZGluZy4gVXNlXG5cdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCB0byBkZXRlcm1pbmUgd2hlbiBhIHNvdW5kIGhhcyBmaW5pc2hlZCBpbnRlcm5hbGx5XG5cdCAqIHByZWxvYWRpbmcuIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYWxsIGF1ZGlvIGlzIHByZWxvYWRlZCBiZWZvcmUgaXQgaXMgcGxheWVkLlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICpcdFx0cXVldWUuaW5zdGFsbFBsdWdpbihjcmVhdGVqcy5Tb3VuZCk7XG5cdCAqXG5cdCAqIDxiPkF1ZGlvIFNwcml0ZXM8L2I+PGJyIC8+XG5cdCAqIFNvdW5kSlMgaGFzIGFkZGVkIHN1cHBvcnQgZm9yIHt7I2Nyb3NzTGluayBcIkF1ZGlvU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319LCBhdmFpbGFibGUgYXMgb2YgdmVyc2lvbiAwLjYuMC5cblx0ICogRm9yIHRob3NlIHVuZmFtaWxpYXIgd2l0aCBhdWRpbyBzcHJpdGVzLCB0aGV5IGFyZSBtdWNoIGxpa2UgQ1NTIHNwcml0ZXMgb3Igc3ByaXRlIHNoZWV0czogbXVsdGlwbGUgYXVkaW8gYXNzZXRzXG5cdCAqIGdyb3VwZWQgaW50byBhIHNpbmdsZSBmaWxlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdHZhciBhc3NldHNQYXRoID0gXCIuL2Fzc2V0cy9cIjtcblx0ICpcdFx0dmFyIHNvdW5kcyA9IFt7XG5cdCAqXHRcdFx0c3JjOlwiTXlBdWRpb1Nwcml0ZS5vZ2dcIiwgZGF0YToge1xuXHQgKlx0XHRcdFx0YXVkaW9TcHJpdGU6IFtcblx0ICpcdFx0XHRcdFx0e2lkOlwic291bmQxXCIsIHN0YXJ0VGltZTowLCBkdXJhdGlvbjo1MDB9LFxuXHQgKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDJcIiwgc3RhcnRUaW1lOjEwMDAsIGR1cmF0aW9uOjQwMH0sXG5cdCAqXHRcdFx0XHRcdHtpZDpcInNvdW5kM1wiLCBzdGFydFRpbWU6MTcwMCwgZHVyYXRpb246IDEwMDB9XG5cdCAqXHRcdFx0XHRdfVxuIFx0ICpcdFx0XHR9XG5cdCAqXHRcdF07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgbG9hZFNvdW5kKTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldHNQYXRoKTtcblx0ICpcdFx0Ly8gYWZ0ZXIgbG9hZCBpcyBjb21wbGV0ZVxuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwic291bmQyXCIpO1xuXHQgKlxuXHQgKiA8Yj5Nb2JpbGUgUGxheWJhY2s8L2I+PGJyIC8+XG5cdCAqIERldmljZXMgcnVubmluZyBpT1MgcmVxdWlyZSB0aGUgV2ViQXVkaW8gY29udGV4dCB0byBiZSBcInVubG9ja2VkXCIgYnkgcGxheWluZyBhdCBsZWFzdCBvbmUgc291bmQgaW5zaWRlIG9mIGEgdXNlci1cblx0ICogaW5pdGlhdGVkIGV2ZW50IChzdWNoIGFzIHRvdWNoL2NsaWNrKS4gRWFybGllciB2ZXJzaW9ucyBvZiBTb3VuZEpTIGluY2x1ZGVkIGEgXCJNb2JpbGVTYWZlXCIgc2FtcGxlLCBidXQgdGhpcyBpcyBub1xuXHQgKiBsb25nZXIgbmVjZXNzYXJ5IGFzIG9mIFNvdW5kSlMgMC42LjIuXG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBJbiBTb3VuZEpTIDAuNC4xIGFuZCBhYm92ZSwgeW91IGNhbiBlaXRoZXIgaW5pdGlhbGl6ZSBwbHVnaW5zIG9yIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vcGxheUVtcHR5U291bmRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgICAgICBtZXRob2QgaW4gdGhlIGNhbGwgc3RhY2sgb2YgYSB1c2VyIGlucHV0IGV2ZW50IHRvIG1hbnVhbGx5IHVubG9jayB0aGUgYXVkaW8gY29udGV4dC5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgSW4gU291bmRKUyAwLjYuMiBhbmQgYWJvdmUsIFNvdW5kSlMgd2lsbCBhdXRvbWF0aWNhbGx5IGxpc3RlbiBmb3IgdGhlIGZpcnN0IGRvY3VtZW50LWxldmVsIFwibW91c2Vkb3duXCJcblx0ICogICAgICAgICBhbmQgXCJ0b3VjaGVuZFwiIGV2ZW50LCBhbmQgdW5sb2NrIFdlYkF1ZGlvLiBUaGlzIHdpbGwgY29udGludWUgdG8gY2hlY2sgdGhlc2UgZXZlbnRzIHVudGlsIHRoZSBXZWJBdWRpb1xuXHQgKiAgICAgICAgIGNvbnRleHQgYmVjb21lcyBcInVubG9ja2VkXCIgKGNoYW5nZXMgZnJvbSBcInN1c3BlbmRlZFwiIHRvIFwicnVubmluZ1wiKVxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBCb3RoIHRoZSBcIm1vdXNlZG93blwiIGFuZCBcInRvdWNoZW5kXCIgZXZlbnRzIGNhbiBiZSB1c2VkIHRvIHVubG9jayBhdWRpbyBpbiBpT1M5KywgdGhlIFwidG91Y2hzdGFydFwiIGV2ZW50XG5cdCAqICAgICAgICAgd2lsbCB3b3JrIGluIGlPUzggYW5kIGJlbG93LiBUaGUgXCJ0b3VjaGVuZFwiIGV2ZW50IHdpbGwgb25seSB3b3JrIGluIGlPUzkgd2hlbiB0aGUgZ2VzdHVyZSBpcyBpbnRlcnByZXRlZFxuXHQgKiAgICAgICAgIGFzIGEgXCJjbGlja1wiLCBzbyBpZiB0aGUgdXNlciBsb25nLXByZXNzZXMgdGhlIGJ1dHRvbiwgaXQgd2lsbCBubyBsb25nZXIgd29yay5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgV2hlbiB1c2luZyB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuY3JlYXRlanMuY29tL2RvY3MvZWFzZWxqcy9jbGFzc2VzL1RvdWNoLmh0bWxcIj5FYXNlbEpTIFRvdWNoIGNsYXNzPC9hPixcblx0ICogICAgICAgICB0aGUgXCJtb3VzZWRvd25cIiBldmVudCB3aWxsIG5vdCBmaXJlIHdoZW4gYSBjYW52YXMgaXMgY2xpY2tlZCwgc2luY2UgTW91c2VFdmVudHMgYXJlIHByZXZlbnRlZCwgdG8gZW5zdXJlXG5cdCAqICAgICAgICAgb25seSB0b3VjaCBldmVudHMgZmlyZS4gVG8gZ2V0IGFyb3VuZCB0aGlzLCB5b3UgY2FuIGVpdGhlciByZWx5IG9uIFwidG91Y2hlbmRcIiwgb3I6XG5cdCAqICAgICAgICAgPG9sPlxuXHQgKiAgICAgICAgICAgICA8bGk+U2V0IHRoZSBgYWxsb3dEZWZhdWx0YCBwcm9wZXJ0eSBvbiB0aGUgVG91Y2ggY2xhc3MgY29uc3RydWN0b3IgdG8gYHRydWVgIChkZWZhdWx0cyB0byBgZmFsc2VgKS48L2xpPlxuXHQgKiAgICAgICAgICAgICA8bGk+U2V0IHRoZSBgcHJldmVudFNlbGVjdGlvbmAgcHJvcGVydHkgb24gdGhlIEVhc2VsSlMgYFN0YWdlYCB0byBgZmFsc2VgLjwvbGk+XG5cdCAqICAgICAgICAgPC9vbD5cblx0ICogICAgICAgICBUaGVzZSBzZXR0aW5ncyBtYXkgY2hhbmdlIGhvdyB5b3VyIGFwcGxpY2F0aW9uIGJlaGF2ZXMsIGFuZCBhcmUgbm90IHJlY29tbWVuZGVkLlxuXHQgKiAgICAgPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGI+TG9hZGluZyBBbHRlcm5hdGUgUGF0aHMgYW5kIEV4dGVuc2lvbi1sZXNzIEZpbGVzPC9iPjxiciAvPlxuXHQgKiBTb3VuZEpTIHN1cHBvcnRzIGxvYWRpbmcgYWx0ZXJuYXRlIHBhdGhzIGFuZCBleHRlbnNpb24tbGVzcyBmaWxlcyBieSBwYXNzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nIGZvclxuXHQgKiB0aGUgYHNyY2AgcHJvcGVydHksIHdoaWNoIGlzIGEgaGFzaCB1c2luZyB0aGUgZm9ybWF0IGB7ZXh0ZW5zaW9uOlwicGF0aFwiLCBleHRlbnNpb24yOlwicGF0aDJcIn1gLiBUaGVzZSBsYWJlbHMgYXJlXG5cdCAqIGhvdyBTb3VuZEpTIGRldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgd2lsbCBzdXBwb3J0IHRoZSBzb3VuZC4gVGhpcyBhbHNvIGVuYWJsZXMgbXVsdGlwbGUgZm9ybWF0cyB0byBsaXZlIGluXG5cdCAqIGRpZmZlcmVudCBmb2xkZXJzLCBvciBvbiBDRE5zLCB3aGljaCBvZnRlbiBoYXMgY29tcGxldGVseSBkaWZmZXJlbnQgZmlsZW5hbWVzIGZvciBlYWNoIGZpbGUuXG5cdCAqXG5cdCAqIFByaW9yaXR5IGlzIGRldGVybWluZWQgYnkgdGhlIHByb3BlcnR5IG9yZGVyIChmaXJzdCBwcm9wZXJ0eSBpcyB0cmllZCBmaXJzdCkuICBUaGlzIGlzIHN1cHBvcnRlZCBieSBib3RoIGludGVybmFsIGxvYWRpbmdcblx0ICogYW5kIGxvYWRpbmcgd2l0aCBQcmVsb2FkSlMuXG5cdCAqXG5cdCAqIDxlbT5Ob3RlOiBhbiBpZCBpcyByZXF1aXJlZCBmb3IgcGxheWJhY2suPC9lbT5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHR2YXIgc291bmRzID0ge3BhdGg6XCIuL2F1ZGlvUGF0aC9cIixcblx0ICogXHRcdFx0XHRtYW5pZmVzdDogW1xuXHQgKlx0XHRcdFx0e2lkOiBcImNvb2xcIiwgc3JjOiB7bXAzOlwibXAzL2F3ZXNvbWUubXAzXCIsIG9nZzpcIm5vRXh0ZW5zaW9uT2dnRmlsZVwifX1cblx0ICpcdFx0XX07XG5cdCAqXG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTtcblx0ICpcdFx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzKTtcblx0ICpcblx0ICogPGgzPktub3duIEJyb3dzZXIgYW5kIE9TIGlzc3VlczwvaDM+XG5cdCAqIDxiPklFIDkgSFRNTCBBdWRpbyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5UaGVyZSBpcyBhIGRlbGF5IGluIGFwcGx5aW5nIHZvbHVtZSBjaGFuZ2VzIHRvIHRhZ3MgdGhhdCBvY2N1cnMgb25jZSBwbGF5YmFjayBpcyBzdGFydGVkLiBTbyBpZiB5b3UgaGF2ZVxuXHQgKiBtdXRlZCBhbGwgc291bmRzLCB0aGV5IHdpbGwgYWxsIHBsYXkgZHVyaW5nIHRoaXMgZGVsYXkgdW50aWwgdGhlIG11dGUgYXBwbGllcyBpbnRlcm5hbGx5LiBUaGlzIGhhcHBlbnMgcmVnYXJkbGVzcyBvZlxuXHQgKiB3aGVuIG9yIGhvdyB5b3UgYXBwbHkgdGhlIHZvbHVtZSBjaGFuZ2UsIGFzIHRoZSB0YWcgc2VlbXMgdG8gbmVlZCB0byBwbGF5IHRvIGFwcGx5IGl0LjwvbGk+XG4gICAgICogPGxpPk1QMyBlbmNvZGluZyB3aWxsIG5vdCBhbHdheXMgd29yayBmb3IgYXVkaW8gdGFncywgcGFydGljdWxhcmx5IGluIEludGVybmV0IEV4cGxvcmVyLiBXZSd2ZSBmb3VuZCBkZWZhdWx0XG5cdCAqIGVuY29kaW5nIHdpdGggNjRrYnBzIHdvcmtzLjwvbGk+XG5cdCAqIDxsaT5PY2Nhc2lvbmFsbHkgdmVyeSBzaG9ydCBzYW1wbGVzIHdpbGwgZ2V0IGN1dCBvZmYuPC9saT5cblx0ICogPGxpPlRoZXJlIGlzIGEgbGltaXQgdG8gaG93IG1hbnkgYXVkaW8gdGFncyB5b3UgY2FuIGxvYWQgYW5kIHBsYXkgYXQgb25jZSwgd2hpY2ggYXBwZWFycyB0byBiZSBkZXRlcm1pbmVkIGJ5XG5cdCAqIGhhcmR3YXJlIGFuZCBicm93c2VyIHNldHRpbmdzLiAgU2VlIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpbi5NQVhfSU5TVEFOQ0VTXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIHNhZmVcblx0ICogZXN0aW1hdGUuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5GaXJlZm94IDI1IFdlYiBBdWRpbyBsaW1pdGF0aW9uczwvYj5cblx0ICogPHVsPjxsaT5tcDMgYXVkaW8gZmlsZXMgZG8gbm90IGxvYWQgcHJvcGVybHkgb24gYWxsIHdpbmRvd3MgbWFjaGluZXMsIHJlcG9ydGVkXG5cdCAqIDxhIGhyZWY9XCJodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05Mjk5NjlcIiB0YXJnZXQ9XCJfYmxhbmtcIj5oZXJlPC9hPi4gPC9icj5cblx0ICogRm9yIHRoaXMgcmVhc29uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHBhc3MgYW5vdGhlciBGRiBzdXBwb3J0ZWQgdHlwZSAoaWUgb2dnKSBmaXJzdCB1bnRpbCB0aGlzIGJ1ZyBpcyByZXNvbHZlZCwgaWZcblx0ICogcG9zc2libGUuPC9saT48L3VsPlxuXG5cdCAqIDxiPlNhZmFyaSBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5TYWZhcmkgcmVxdWlyZXMgUXVpY2t0aW1lIHRvIGJlIGluc3RhbGxlZCBmb3IgYXVkaW8gcGxheWJhY2suPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5pT1MgNiBXZWIgQXVkaW8gbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+U291bmQgaXMgaW5pdGlhbGx5IGxvY2tlZCwgYW5kIG11c3QgYmUgdW5sb2NrZWQgdmlhIGEgdXNlci1pbml0aWF0ZWQgZXZlbnQuIFBsZWFzZSBzZWUgdGhlIHNlY3Rpb24gb25cblx0ICogTW9iaWxlIFBsYXliYWNrIGFib3ZlLjwvbGk+XG5cdCAqIDxsaT5BIGJ1ZyBleGlzdHMgdGhhdCB3aWxsIGRpc3RvcnQgdW4tY2FjaGVkIHdlYiBhdWRpbyB3aGVuIGEgdmlkZW8gZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBET00gdGhhdCBoYXMgYXVkaW9cblx0ICogYXQgYSBkaWZmZXJlbnQgc2FtcGxlUmF0ZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8Yj5BbmRyb2lkIEhUTUwgQXVkaW8gbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+V2UgaGF2ZSBubyBjb250cm9sIG92ZXIgYXVkaW8gdm9sdW1lLiBPbmx5IHRoZSB1c2VyIGNhbiBzZXQgdm9sdW1lIG9uIHRoZWlyIGRldmljZS48L2xpPlxuXHQgKiA8bGk+V2UgY2FuIG9ubHkgcGxheSBhdWRpbyBpbnNpZGUgYSB1c2VyIGV2ZW50ICh0b3VjaC9jbGljaykuICBUaGlzIGN1cnJlbnRseSBtZWFucyB5b3UgY2Fubm90IGxvb3Agc291bmQgb3IgdXNlXG5cdCAqIGEgZGVsYXkuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5XZWIgQXVkaW8gYW5kIFByZWxvYWRKUzwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5XZWIgQXVkaW8gbXVzdCBiZSBsb2FkZWQgdGhyb3VnaCBYSFIsIHRoZXJlZm9yZSB3aGVuIHVzZWQgd2l0aCBQcmVsb2FkSlMsIHRhZyBsb2FkaW5nIGlzIG5vdCBwb3NzaWJsZS5cblx0ICogVGhpcyBtZWFucyB0aGF0IHRhZyBsb2FkaW5nIGNhbiBub3QgYmUgdXNlZCB0byBhdm9pZCBjcm9zcyBkb21haW4gaXNzdWVzLjwvbGk+PHVsPlxuXHQgKlxuXHQgKiBAY2xhc3MgU291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAdXNlcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIFNvdW5kKCkge1xuXHRcdHRocm93IFwiU291bmQgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblx0dmFyIHMgPSBTb3VuZDtcblxuXG4vLyBTdGF0aWMgUHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc291cmNlLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2Zcblx0ICogaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX0FOWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBhbnlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfQU5ZID0gXCJhbnlcIjtcblxuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBpbnRlcnJ1cHQgdGhlIGVhcmxpZXN0IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc291cmNlIHRoYXQgcHJvZ3Jlc3NlZCB0aGVcblx0ICogbGVhc3QgZGlzdGFuY2UgaW4gdGhlIGF1ZGlvIHRyYWNrLCBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiBAcHJvcGVydHkgSU5URVJSVVBUX0VBUkxZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGVhcmx5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuSU5URVJSVVBUX0VBUkxZID0gXCJlYXJseVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIGludGVycnVwdCB0aGUgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBzb3VyY2UgdGhhdCBwcm9ncmVzc2VkIHRoZSBtb3N0XG5cdCAqIGRpc3RhbmNlIGluIHRoZSBhdWRpbyB0cmFjaywgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9MQVRFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGxhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfTEFURSA9IFwibGF0ZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIG5vdCBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSwgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mXG5cdCAqIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9OT05FXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG5vbmVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5JTlRFUlJVUFRfTk9ORSA9IFwibm9uZVwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCBpcyBzdGlsbCBpbml0aWFsaXppbmcuXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX0lOSVRFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5SW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9JTklURUQgPSBcInBsYXlJbml0ZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcgb3IgcGF1c2VkLlxuXHQgKiBAcHJvcGVydHkgUExBWV9TVUNDRUVERURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheVN1Y2NlZWRlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfU1VDQ0VFREVEID0gXCJwbGF5U3VjY2VlZGVkXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IHdhcyBpbnRlcnJ1cHRlZCBieSBhbm90aGVyIGluc3RhbmNlLlxuXHQgKiBAcHJvcGVydHkgUExBWV9JTlRFUlJVUFRFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5SW50ZXJydXB0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0lOVEVSUlVQVEVEID0gXCJwbGF5SW50ZXJydXB0ZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgY29tcGxldGVkIHBsYXliYWNrLlxuXHQgKiBAcHJvcGVydHkgUExBWV9GSU5JU0hFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5RmluaXNoZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0ZJTklTSEVEID0gXCJwbGF5RmluaXNoZWRcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgZmFpbGVkIHRvIHBsYXkuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBsYWNrIG9mIGF2YWlsYWJsZSBjaGFubmVsc1xuXHQgKiB3aGVuIHRoZSBpbnRlcnJ1cHQgbW9kZSB3YXMgXCJJTlRFUlJVUFRfTk9ORVwiLCB0aGUgcGxheWJhY2sgc3RhbGxlZCwgb3IgdGhlIHNvdW5kIGNvdWxkIG5vdCBiZSBmb3VuZC5cblx0ICogQHByb3BlcnR5IFBMQVlfRkFJTEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlGYWlsZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX0ZBSUxFRCA9IFwicGxheUZhaWxlZFwiO1xuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgdGhlIGRlZmF1bHQgc3VwcG9ydGVkIGV4dGVuc2lvbnMgdGhhdCBTb3VuZCB3aWxsIDxpPnRyeTwvaT4gdG8gcGxheS4gUGx1Z2lucyB3aWxsIGNoZWNrIGlmIHRoZSBicm93c2VyXG5cdCAqIGNhbiBwbGF5IHRoZXNlIHR5cGVzLCBzbyBtb2RpZnlpbmcgdGhpcyBsaXN0IGJlZm9yZSBhIHBsdWdpbiBpcyBpbml0aWFsaXplZCB3aWxsIGFsbG93IHRoZSBwbHVnaW5zIHRvIHRyeSB0b1xuXHQgKiBzdXBwb3J0IGFkZGl0aW9uYWwgbWVkaWEgdHlwZXMuXG5cdCAqXG5cdCAqIE5PVEUgdGhpcyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBmb3Ige3sjY3Jvc3NMaW5rIFwiRmxhc2hBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogTW9yZSBkZXRhaWxzIG9uIGZpbGUgZm9ybWF0cyBjYW4gYmUgZm91bmQgYXQgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVkaW9fZmlsZV9mb3JtYXRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F1ZGlvX2ZpbGVfZm9ybWF0PC9hPi48YnIgLz5cblx0ICogQSB2ZXJ5IGRldGFpbGVkIGxpc3Qgb2YgZmlsZSBmb3JtYXRzIGNhbiBiZSBmb3VuZCBhdCA8YSBocmVmPVwiaHR0cDovL3d3dy5maWxlaW5mby5jb20vZmlsZXR5cGVzL2F1ZGlvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cDovL3d3dy5maWxlaW5mby5jb20vZmlsZXR5cGVzL2F1ZGlvPC9hPi5cblx0ICogQHByb3BlcnR5IFNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheVtTdHJpbmddfVxuXHQgKiBAZGVmYXVsdCBbXCJtcDNcIiwgXCJvZ2dcIiwgXCJvcHVzXCIsIFwibXBlZ1wiLCBcIndhdlwiLCBcIm00YVwiLCBcIm1wNFwiLCBcImFpZmZcIiwgXCJ3bWFcIiwgXCJtaWRcIl1cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuU1VQUE9SVEVEX0VYVEVOU0lPTlMgPSBbXCJtcDNcIiwgXCJvZ2dcIiwgXCJvcHVzXCIsIFwibXBlZ1wiLCBcIndhdlwiLCBcIm00YVwiLCBcIm1wNFwiLCBcImFpZmZcIiwgXCJ3bWFcIiwgXCJtaWRcIl07XG5cblx0LyoqXG5cdCAqIFNvbWUgZXh0ZW5zaW9ucyB1c2UgYW5vdGhlciB0eXBlIG9mIGV4dGVuc2lvbiBzdXBwb3J0IHRvIHBsYXkgKG9uZSBvZiB0aGVtIGlzIGEgY29kZXgpLiAgVGhpcyBhbGxvd3MgeW91IHRvIG1hcFxuXHQgKiB0aGF0IHN1cHBvcnQgc28gcGx1Z2lucyBjYW4gYWNjdXJhdGVseSBkZXRlcm1pbmUgaWYgYW4gZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZC4gIEFkZGluZyB0byB0aGlzIGxpc3QgY2FuIGhlbHBcblx0ICogcGx1Z2lucyBkZXRlcm1pbmUgbW9yZSBhY2N1cmF0ZWx5IGlmIGFuIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQuXG5cdCAqXG4gXHQgKiBBIHVzZWZ1bCBsaXN0IG9mIGV4dGVuc2lvbnMgZm9yIGVhY2ggZm9ybWF0IGNhbiBiZSBmb3VuZCBhdCA8YSBocmVmPVwiaHR0cDovL2h0bWw1ZG9jdG9yLmNvbS9odG1sNS1hdWRpby10aGUtc3RhdGUtb2YtcGxheS9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5odHRwOi8vaHRtbDVkb2N0b3IuY29tL2h0bWw1LWF1ZGlvLXRoZS1zdGF0ZS1vZi1wbGF5LzwvYT4uXG5cdCAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fTUFQXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVmYXVsdCB7bTRhOlwibXA0XCJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuRVhURU5TSU9OX01BUCA9IHtcblx0XHRtNGE6XCJtcDRcIlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgUmVnRXhwIHBhdHRlcm4gdXNlZCB0byBwYXJzZSBmaWxlIFVSSXMuIFRoaXMgc3VwcG9ydHMgc2ltcGxlIGZpbGUgbmFtZXMsIGFzIHdlbGwgYXMgZnVsbCBkb21haW4gVVJJcyB3aXRoXG5cdCAqIHF1ZXJ5IHN0cmluZ3MuIFRoZSByZXN1bHRpbmcgbWF0Y2ggaXM6IHByb3RvY29sOiQxIGRvbWFpbjokMiBwYXRoOiQzIGZpbGU6JDQgZXh0ZW5zaW9uOiQ1IHF1ZXJ5OiQ2LlxuXHQgKiBAcHJvcGVydHkgRklMRV9QQVRURVJOXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5GSUxFX1BBVFRFUk4gPSAvXig/OihcXHcrOilcXC97Mn0oXFx3Kyg/OlxcLlxcdyspKlxcLz8pKT8oWy8uXSo/KD86W14/XSspP1xcLyk/KCg/OlteLz9dKylcXC4oXFx3KykpKD86XFw/KFxcUyspPyk/JC87XG5cblxuLy8gQ2xhc3MgUHVibGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIERldGVybWluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGludGVycnVwdGluZyBvdGhlciBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgd2l0aCB0aGUgc2FtZSBzb3VyY2UsIGlmIHRoZVxuXHQgKiBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuICBDdXJyZW50bHkgdGhlIGRlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiU291bmQvSU5URVJSVVBUX05PTkU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYnV0IHRoaXMgY2FuIGJlIHNldCBhbmQgd2lsbCBjaGFuZ2UgcGxheWJhY2sgYmVoYXZpb3IgYWNjb3JkaW5nbHkuICBUaGlzIGlzIG9ubHkgdXNlZCB3aGVuIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgY2FsbGVkIHdpdGhvdXQgcGFzc2luZyBhIHZhbHVlIGZvciBpbnRlcnJ1cHQuXG5cdCAqIEBwcm9wZXJ0eSBkZWZhdWx0SW50ZXJydXB0QmVoYXZpb3Jcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgU291bmQuSU5URVJSVVBUX05PTkUsIG9yIFwibm9uZVwiXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqL1xuXHRzLmRlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvciA9IHMuSU5URVJSVVBUX05PTkU7ICAvLyBPSlIgZG9lcyBzLklOVEVSUlVQVF9BTlkgbWFrZSBtb3JlIHNlbnNlIGFzIGRlZmF1bHQ/ICBOZWVkcyBnYW1lIGRldiB0ZXN0aW5nIHRvIHNlZSB3aGljaCBjYXNlIG1ha2VzIG1vcmUgc2Vuc2UuXG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIGV4dGVuc2lvbnMgdG8gYXR0ZW1wdCB0byB1c2Ugd2hlbiBsb2FkaW5nIHNvdW5kLCBpZiB0aGUgZGVmYXVsdCBpcyB1bnN1cHBvcnRlZCBieSB0aGUgYWN0aXZlIHBsdWdpbi5cblx0ICogVGhlc2UgYXJlIGFwcGxpZWQgaW4gb3JkZXIsIHNvIGlmIHlvdSB0cnkgdG8gTG9hZCBUaHVuZGVyLm9nZyBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IG9nZywgYW5kIHlvdXJcblx0ICogZXh0ZW5zaW9ucyBhcnJheSBpcyBbXCJtcDNcIiwgXCJtNGFcIiwgXCJ3YXZcIl0gaXQgd2lsbCBjaGVjayBtcDMgc3VwcG9ydCwgdGhlbiBtNGEsIHRoZW4gd2F2LiBUaGUgYXVkaW8gZmlsZXMgbmVlZFxuXHQgKiB0byBleGlzdCBpbiB0aGUgc2FtZSBsb2NhdGlvbiwgYXMgb25seSB0aGUgZXh0ZW5zaW9uIGlzIGFsdGVyZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCByZWdhcmRsZXNzIG9mIHdoaWNoIGZpbGUgaXMgbG9hZGVkLCB5b3UgY2FuIGNhbGwge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcgdGhlIHNhbWUgaWQgb3IgZnVsbCBzb3VyY2UgcGF0aCBwYXNzZWQgZm9yIGxvYWRpbmcuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdHZhciBzb3VuZHMgPSBbXG5cdCAqXHRcdHtzcmM6XCJteVBhdGgvbXlTb3VuZC5vZ2dcIiwgaWQ6XCJleGFtcGxlXCJ9LFxuXHQgKlx0XTtcblx0ICpcdGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07IC8vIG5vdyBpZiBvZ2cgaXMgbm90IHN1cHBvcnRlZCwgU291bmRKUyB3aWxsIHRyeSBhc3NldDAubXAzXG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpOyAvLyBjYWxsIGhhbmRsZUxvYWQgd2hlbiBlYWNoIHNvdW5kIGxvYWRzXG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kcyhzb3VuZHMsIGFzc2V0UGF0aCk7XG5cdCAqXHQvLyAuLi5cblx0ICpcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteVBhdGgvbXlTb3VuZC5vZ2dcIik7IC8vIHdvcmtzIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLiAgTm90ZSBjYWxsaW5nIHdpdGggSUQgaXMgYSBiZXR0ZXIgYXBwcm9hY2hcblx0ICpcblx0ICogQHByb3BlcnR5IGFsdGVybmF0ZUV4dGVuc2lvbnNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc2luY2UgMC41LjJcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5hbHRlcm5hdGVFeHRlbnNpb25zID0gW107XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbi4gSWYgdGhpcyBpcyBudWxsLCB0aGVuIG5vIHBsdWdpbiBjb3VsZCBiZSBpbml0aWFsaXplZC4gSWYgbm8gcGx1Z2luIHdhcyBzcGVjaWZpZWQsXG5cdCAqIFNvdW5kIGF0dGVtcHRzIHRvIGFwcGx5IHRoZSBkZWZhdWx0IHBsdWdpbnM6IHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LCBmb2xsb3dlZCBieVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBhY3RpdmVQbHVnaW5cblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgICBzLmFjdGl2ZVBsdWdpbiA9IG51bGw7XG5cblxuLy8gY2xhc3MgZ2V0dGVyIC8gc2V0dGVyIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZSBvZiBTb3VuZC4gVGhlIG1hc3RlciB2b2x1bWUgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGVhY2ggc291bmQncyBpbmRpdmlkdWFsIHZvbHVtZS4gIEZvclxuXHQgKiBleGFtcGxlLCBpZiBtYXN0ZXIgdm9sdW1lIGlzIDAuNSBhbmQgYSBzb3VuZCdzIHZvbHVtZSBpcyAwLjUsIHRoZSByZXN1bHRpbmcgdm9sdW1lIGlzIDAuMjUuIFRvIHNldCBpbmRpdmlkdWFsXG5cdCAqIHNvdW5kIHZvbHVtZSwgdXNlIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGNyZWF0ZWpzLlNvdW5kLnZvbHVtZSA9IDAuNTtcblx0ICpcblx0ICpcblx0ICogQHByb3BlcnR5IHZvbHVtZVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fbWFzdGVyVm9sdW1lID0gMTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwidm9sdW1lXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5fbWFzdGVyVm9sdW1lO30sXG5cdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKE51bWJlcih2YWx1ZSkgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHRcdFx0cy5fbWFzdGVyVm9sdW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0Vm9sdW1lKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZXNbaV0uc2V0TWFzdGVyVm9sdW1lKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIE11dGUvVW5tdXRlIGFsbCBhdWRpby4gTm90ZSB0aGF0IG11dGVkIGF1ZGlvIHN0aWxsIHBsYXlzIGF0IDAgdm9sdW1lLiBUaGlzIGdsb2JhbCBtdXRlIHZhbHVlIGlzIG1haW50YWluZWRcblx0ICogc2VwYXJhdGVseSBhbmQgd2hlbiBzZXQgd2lsbCBvdmVycmlkZSwgYnV0IG5vdCBjaGFuZ2UgdGhlIG11dGUgcHJvcGVydHkgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMuIFRvIG11dGUgYW4gaW5kaXZpZHVhbFxuXHQgKiBpbnN0YW5jZSwgdXNlIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQubXV0ZWQgPSB0cnVlO1xuXHQgKlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgbXV0ZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fbWFzdGVyTXV0ZSA9IGZhbHNlO1xuXHQvLyBPSlIgcmVmZXJlbmNlcyB0byB0aGUgbWV0aG9kcyB3ZXJlIG5vdCB3b3JraW5nLCBzbyB0aGUgY29kZSBoYWQgdG8gYmUgZHVwbGljYXRlZCBoZXJlXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIm11dGVkXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5fbWFzdGVyTXV0ZTt9LFxuXHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdFx0XHR0aGlzLl9tYXN0ZXJNdXRlID0gdmFsdWU7XG5cdFx0XHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJNdXRlKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFjdGl2ZSBwbHVnaW5zIGNhcGFiaWxpdGllcywgd2hpY2ggaGVscCBkZXRlcm1pbmUgaWYgYSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQsXG5cdCAqIG9yIGlmIHRoZSBwbHVnaW4gc3VwcG9ydHMgYSBzcGVjaWZpYyBmZWF0dXJlLiBDYXBhYmlsaXRpZXMgaW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPjxiPnBhbm5pbmc6PC9iPiBJZiB0aGUgcGx1Z2luIGNhbiBwYW4gYXVkaW8gZnJvbSBsZWZ0IHRvIHJpZ2h0PC9saT5cblx0ICogICAgIDxsaT48Yj52b2x1bWU7PC9iPiBJZiB0aGUgcGx1Z2luIGNhbiBjb250cm9sIGF1ZGlvIHZvbHVtZS48L2xpPlxuXHQgKiAgICAgPGxpPjxiPnRyYWNrczo8L2I+IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhdWRpbyB0cmFja3MgdGhhdCBjYW4gYmUgcGxheWVkIGJhY2sgYXQgYSB0aW1lLiBUaGlzIHdpbGwgYmUgLTFcblx0ICogICAgIGlmIHRoZXJlIGlzIG5vIGtub3duIGxpbWl0LjwvbGk+XG5cdCAqIDxiciAvPkFuIGVudHJ5IGZvciBlYWNoIGZpbGUgdHlwZSBpbiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9TVVBQT1JURURfRVhURU5TSU9OUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTpcblx0ICogICAgIDxsaT48Yj5tcDM6PC9iPiBJZiBNUDMgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+b2dnOjwvYj4gSWYgT0dHIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPndhdjo8L2I+IElmIFdBViBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5tcGVnOjwvYj4gSWYgTVBFRyBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5tNGE6PC9iPiBJZiBNNEEgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+bXA0OjwvYj4gSWYgTVA0IGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPmFpZmY6PC9iPiBJZiBhaWZmIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPndtYTo8L2I+IElmIHdtYSBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5taWQ6PC9iPiBJZiBtaWQgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFlvdSBjYW4gZ2V0IGEgc3BlY2lmaWMgY2FwYWJpbGl0eSBvZiB0aGUgYWN0aXZlIHBsdWdpbiB1c2luZyBzdGFuZGFyZCBvYmplY3Qgbm90YXRpb25cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBtcDMgPSBjcmVhdGVqcy5Tb3VuZC5jYXBhYmlsaXRpZXMubXAzO1xuXHQgKlxuXHQgKiBOb3RlIHRoaXMgcHJvcGVydHkgaXMgcmVhZCBvbmx5LlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICogQHJlYWRPbmx5XG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwiY2FwYWJpbGl0aWVzXCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBudWxsO31cblx0XHRcdFx0XHRyZXR1cm4gcy5hY3RpdmVQbHVnaW4uX2NhcGFiaWxpdGllcztcblx0XHRcdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZmFsc2U7fVxuXHR9KTtcblxuXG4vLyBDbGFzcyBQcml2YXRlIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIHBsdWdpbnMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuIElmIGZhbHNlLCB0aGUgZmlyc3QgY2FsbCB0byBwbGF5KCkgd2lsbCBpbnN0YW50aWF0ZSB0aGUgZGVmYXVsdFxuXHQgKiBwbHVnaW5zICh7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSwgZm9sbG93ZWQgYnkge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogSWYgcGx1Z2lucyBoYXZlIGJlZW4gcmVnaXN0ZXJlZCwgYnV0IG5vbmUgYXJlIGFwcGxpY2FibGUsIHRoZW4gc291bmQgcGxheWJhY2sgd2lsbCBmYWlsLlxuXHQgKiBAcHJvcGVydHkgX3BsdWdpbnNSZWdpc3RlcmVkXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX3BsdWdpbnNSZWdpc3RlcmVkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFVzZWQgaW50ZXJuYWxseSB0byBhc3NpZ24gdW5pcXVlIElEcyB0byBlYWNoIEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogQHByb3BlcnR5IF9sYXN0SURcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9sYXN0SUQgPSAwO1xuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMuIFRoaXMgYWxsb3dzIFNvdW5kIHRvIGNvbnRyb2wgdGhlIHZvbHVtZSwgbXV0ZSwgYW5kIHBsYXliYWNrIG9mXG5cdCAqIGFsbCBpbnN0YW5jZXMgd2hlbiB1c2luZyBzdGF0aWMgQVBJcyBsaWtlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3N0b3BcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3NldFZvbHVtZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogV2hlbiBhbiBpbnN0YW5jZSBoYXMgZmluaXNoZWQgcGxheWJhY2ssIGl0IGdldHMgcmVtb3ZlZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2ZpbmlzaGVkUGxheWluZ1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIElmIHRoZSB1c2VyIHJlcGxheXMgYW4gaW5zdGFuY2UsIGl0IGdldHMgYWRkZWQgYmFjayBpbiB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL19iZWdpblBsYXlpbmdcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAcHJvcGVydHkgX2luc3RhbmNlc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBoYXNoIHN0b3Jpbmcgb2JqZWN0cyB3aXRoIHNvdW5kIHNvdXJjZXMsIHN0YXJ0VGltZSwgYW5kIGR1cmF0aW9uIHZpYSB0aGVyZSBjb3JyZXNwb25kaW5nIElELlxuXHQgKiBAcHJvcGVydHkgX2lkSGFzaFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2lkSGFzaCA9IHt9O1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgaGFzaCB0aGF0IHN0b3JlcyBwcmVsb2FkaW5nIHNvdW5kIHNvdXJjZXMgdmlhIHRoZSBwYXJzZWQgc291cmNlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBwbHVnaW4uICBDb250YWlucyB0aGVcblx0ICogc291cmNlLCBpZCwgYW5kIGRhdGEgdGhhdCB3YXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyLiAgUGFyc2VkIHNvdXJjZXMgY2FuIGNvbnRhaW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHNvdXJjZSwgaWQsXG5cdCAqIGFuZCBkYXRhLlxuXHQgKiBAcHJvcGVydHkgX3ByZWxvYWRIYXNoXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcHJlbG9hZEhhc2ggPSB7fTtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IGhhc2ggc3RvcmluZyB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gdmlhIHRoZSBwYXJzZWQgc291cmNlIHRoYXQgaXMgcGFzc2VkIGFzIGRlZmF1bHRQbGF5UHJvcHMgaW5cblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdFBsYXlQcm9wc0hhc2hcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5fZGVmYXVsdFBsYXlQcm9wc0hhc2ggPSB7fTtcblxuXG4vLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0cy5hZGRFdmVudExpc3RlbmVyID0gbnVsbDtcblx0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0cy5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IG51bGw7XG5cdHMuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdHMuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdHMuX2xpc3RlbmVycyA9IG51bGw7XG5cblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUocyk7IC8vIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcy5cblxuXG4vLyBFdmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGZpbGUgZmluaXNoZXMgbG9hZGluZyBpbnRlcm5hbGx5LiBUaGlzIGV2ZW50IGlzIGZpcmVkIGZvciBlYWNoIGxvYWRlZCBzb3VuZCxcblx0ICogc28gYW55IGhhbmRsZXIgbWV0aG9kcyBzaG91bGQgbG9vayB1cCB0aGUgPGNvZGU+ZXZlbnQuc3JjPC9jb2RlPiB0byBoYW5kbGUgYSBwYXJ0aWN1bGFyIHNvdW5kLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIHRoYXQgd2FzIGxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVGhlIGlkIHBhc3NlZCBpbiB3aGVuIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZC4gSWYgb25lIHdhcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF0YV0gQW55IGFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSB1bmRlZmluZWQuXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblxuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgZmlsZSBmYWlscyBsb2FkaW5nIGludGVybmFsbHkuIFRoaXMgZXZlbnQgaXMgZmlyZWQgZm9yIGVhY2ggbG9hZGVkIHNvdW5kLFxuXHQgKiBzbyBhbnkgaGFuZGxlciBtZXRob2RzIHNob3VsZCBsb29rIHVwIHRoZSA8Y29kZT5ldmVudC5zcmM8L2NvZGU+IHRvIGhhbmRsZSBhIHBhcnRpY3VsYXIgc291bmQuXG5cdCAqIEBldmVudCBmaWxlZXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIHRoYXQgd2FzIGxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVGhlIGlkIHBhc3NlZCBpbiB3aGVuIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZC4gSWYgb25lIHdhcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF0YV0gQW55IGFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSB1bmRlZmluZWQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBDbGFzcyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogR2V0IHRoZSBwcmVsb2FkIHJ1bGVzIHRvIGFsbG93IFNvdW5kIHRvIGJlIHVzZWQgYXMgYSBwbHVnaW4gYnkgPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi5cblx0ICogQW55IGxvYWQgY2FsbHMgdGhhdCBoYXZlIHRoZSBtYXRjaGluZyB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGZpcmUgdGhlIGNhbGxiYWNrIG1ldGhvZCwgYW5kIHVzZSB0aGUgcmVzdWx0aW5nXG5cdCAqIG9iamVjdCwgd2hpY2ggaXMgcG90ZW50aWFsbHkgbW9kaWZpZWQgYnkgU291bmQuIFRoaXMgaGVscHMgd2hlbiBkZXRlcm1pbmluZyB0aGUgY29ycmVjdCBwYXRoLCBhcyB3ZWxsIGFzXG5cdCAqIHJlZ2lzdGVyaW5nIHRoZSBhdWRpbyBpbnN0YW5jZShzKSB3aXRoIFNvdW5kLiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCwgZXhjZXB0IGJ5IFByZWxvYWRKUy5cblx0ICogQG1ldGhvZCBnZXRQcmVsb2FkSGFuZGxlcnNcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZzpcblx0ICogPHVsPjxsaT5jYWxsYmFjazogQSBwcmVsb2FkIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGZpbGUgaXMgYWRkZWQgdG8gUHJlbG9hZEpTLCB3aGljaCBwcm92aWRlc1xuXHQgKiAgICAgIFNvdW5kIGEgbWVjaGFuaXNtIHRvIG1vZGlmeSB0aGUgbG9hZCBwYXJhbWV0ZXJzLCBzZWxlY3QgdGhlIGNvcnJlY3QgZmlsZSBmb3JtYXQsIHJlZ2lzdGVyIHRoZSBzb3VuZCwgZXRjLjwvbGk+XG5cdCAqICAgICAgPGxpPnR5cGVzOiBBIGxpc3Qgb2YgZmlsZSB0eXBlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgU291bmQgKGN1cnJlbnRseSBzdXBwb3J0cyBcInNvdW5kXCIpLjwvbGk+XG5cdCAqICAgICAgPGxpPmV4dGVuc2lvbnM6IEEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IFNvdW5kIChzZWUge3sjY3Jvc3NMaW5rIFwiU291bmQvU1VQUE9SVEVEX0VYVEVOU0lPTlM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0pLjwvbGk+PC91bD5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLmdldFByZWxvYWRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbGJhY2s6Y3JlYXRlanMucHJveHkocy5pbml0TG9hZCwgcyksXG5cdFx0XHR0eXBlczpbXCJzb3VuZFwiXSxcblx0XHRcdGV4dGVuc2lvbnM6cy5TVVBQT1JURURfRVhURU5TSU9OU1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZGlzcGF0Y2ggZmlsZWxvYWQgZXZlbnRzIGZyb20gaW50ZXJuYWwgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZENvbXBsZXRlXG5cdCAqIEBwYXJhbSBldmVudCBBIGxvYWRlciBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5faGFuZGxlTG9hZENvbXBsZXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc3JjID0gZXZlbnQudGFyZ2V0LmdldEl0ZW0oKS5zcmM7XG5cdFx0aWYgKCFzLl9wcmVsb2FkSGFzaFtzcmNdKSB7cmV0dXJuO31cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5fcHJlbG9hZEhhc2hbc3JjXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gcy5fcHJlbG9hZEhhc2hbc3JjXVtpXTtcblx0XHRcdHMuX3ByZWxvYWRIYXNoW3NyY11baV0gPSB0cnVlO1xuXG5cdFx0XHRpZiAoIXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVsb2FkXCIpO1xuXHRcdFx0ZXZlbnQuc3JjID0gaXRlbS5zcmM7XG5cdFx0XHRldmVudC5pZCA9IGl0ZW0uaWQ7XG5cdFx0XHRldmVudC5kYXRhID0gaXRlbS5kYXRhO1xuXHRcdFx0ZXZlbnQuc3ByaXRlID0gaXRlbS5zcHJpdGU7XG5cblx0XHRcdHMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGRpc3BhdGNoIGVycm9yIGV2ZW50cyBmcm9tIGludGVybmFsIHByZWxvYWRpbmcuXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9oYW5kbGVMb2FkRXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzcmMgPSBldmVudC50YXJnZXQuZ2V0SXRlbSgpLnNyYztcblx0XHRpZiAoIXMuX3ByZWxvYWRIYXNoW3NyY10pIHtyZXR1cm47fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzLl9wcmVsb2FkSGFzaFtzcmNdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzLl9wcmVsb2FkSGFzaFtzcmNdW2ldO1xuXHRcdFx0cy5fcHJlbG9hZEhhc2hbc3JjXVtpXSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVlcnJvclwiKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlZXJyb3JcIik7XG5cdFx0XHRldmVudC5zcmMgPSBpdGVtLnNyYztcblx0XHRcdGV2ZW50LmlkID0gaXRlbS5pZDtcblx0XHRcdGV2ZW50LmRhdGEgPSBpdGVtLmRhdGE7XG5cdFx0XHRldmVudC5zcHJpdGUgPSBpdGVtLnNwcml0ZTtcblxuXHRcdFx0cy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IHRvIHJlZ2lzdGVyIGEgU291bmQgcGx1Z2luLlxuXHQgKlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclBsdWdpblxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcGx1Z2luIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHMuX3JlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdC8vIE5vdGU6IEVhY2ggcGx1Z2luIGlzIHBhc3NlZCBpbiBhcyBhIGNsYXNzIHJlZmVyZW5jZSwgYnV0IHdlIHN0b3JlIHRoZSBhY3RpdmVQbHVnaW4gYXMgYW4gaW5zdGFuY2Vcblx0XHRpZiAocGx1Z2luLmlzU3VwcG9ydGVkKCkpIHtcblx0XHRcdHMuYWN0aXZlUGx1Z2luID0gbmV3IHBsdWdpbigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBsaXN0IG9mIFNvdW5kIHBsdWdpbnMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuIFRvIHJlZ2lzdGVyIGEgc2luZ2xlIHBsdWdpbiwgcGFzcyBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSBhcnJheS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW4uc3dmUGF0aCA9IFwiLi4vc3JjL3NvdW5kanMvZmxhc2hhdWRpby9cIjtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclBsdWdpbnMoW2NyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW5dKTtcblx0ICpcblx0ICogQG1ldGhvZCByZWdpc3RlclBsdWdpbnNcblx0ICogQHBhcmFtIHtBcnJheX0gcGx1Z2lucyBBbiBhcnJheSBvZiBwbHVnaW5zIGNsYXNzZXMgdG8gaW5zdGFsbC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBhIHBsdWdpbiB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnJlZ2lzdGVyUGx1Z2lucyA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XG5cdFx0cy5fcGx1Z2luc1JlZ2lzdGVyZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChzLl9yZWdpc3RlclBsdWdpbihwbHVnaW5zW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBkZWZhdWx0IHBsdWdpbnMuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gYW55IGF1ZGlvIGlzIHBsYXllZCBvciByZWdpc3RlcmVkIGJlZm9yZVxuXHQgKiB0aGUgdXNlciBoYXMgbWFudWFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLCBhbmQgZW5hYmxlcyBTb3VuZCB0byB3b3JrIHdpdGhvdXQgbWFudWFsIHBsdWdpbiBzZXR1cC4gQ3VycmVudGx5LCB0aGVcblx0ICogZGVmYXVsdCBwbHVnaW5zIGFyZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBmb2xsb3dlZCBieSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRpZiAoIWNyZWF0ZWpzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpKSB7IHJldHVybjsgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVEZWZhdWx0UGx1Z2luc1xuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhIHBsdWdpbiB3YXMgaW5pdGlhbGl6ZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiAhPSBudWxsKSB7cmV0dXJuIHRydWU7fVxuXHRcdGlmIChzLl9wbHVnaW5zUmVnaXN0ZXJlZCkge3JldHVybiBmYWxzZTt9XG5cdFx0aWYgKHMucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luXSkpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIFNvdW5kIGhhcyBiZWVuIGluaXRpYWxpemVkLCBhbmQgYSBwbHVnaW4gaGFzIGJlZW4gYWN0aXZhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBzZXRzIHVwIGEgRmxhc2ggZmFsbGJhY2ssIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIHBsdWdpbiBzcGVjaWZpZWQgeWV0LlxuXHQgKlxuXHQgKiBcdGlmICghY3JlYXRlanMuU291bmQuaXNSZWFkeSgpKSB7XG5cdCAqXHRcdGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW4uc3dmUGF0aCA9IFwiLi4vc3JjL3NvdW5kanMvZmxhc2hhdWRpby9cIjtcblx0ICogXHRcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyUGx1Z2lucyhbY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbiwgY3JlYXRlanMuRmxhc2hBdWRpb1BsdWdpbl0pO1xuXHQgKlx0fVxuXHQgKlxuXHQgKiBAbWV0aG9kIGlzUmVhZHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgU291bmQgaGFzIGluaXRpYWxpemVkIGEgcGx1Z2luLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIChzLmFjdGl2ZVBsdWdpbiAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jYXBhYmlsaXRpZXM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRDYXBhYmlsaXRpZXNcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBhY3RpdmUgcGx1Z2luLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLmdldENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBudWxsO31cblx0XHRyZXR1cm4gcy5hY3RpdmVQbHVnaW4uX2NhcGFiaWxpdGllcztcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jYXBhYmlsaXRpZXM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRDYXBhYmlsaXR5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGNhcGFiaWxpdHkgdG8gcmV0cmlldmVcblx0ICogQHJldHVybiB7TnVtYmVyfEJvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgY2FwYWJpbGl0eS5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2VlIGdldENhcGFiaWxpdGllc1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbiA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXHRcdHJldHVybiBzLmFjdGl2ZVBsdWdpbi5fY2FwYWJpbGl0aWVzW2tleV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgbWFuaWZlc3QgaXRlbXMgZnJvbSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZFxuXHQgKiBmb3IgdXNhZ2UgYnkgYSBwbHVnaW4sIGFuZCBub3QgZm9yIGRpcmVjdCBpbnRlcmFjdGlvbi5cblx0ICogQG1ldGhvZCBpbml0TG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3JjIFRoZSBvYmplY3QgdG8gbG9hZC5cblx0ICogQHJldHVybiB7T2JqZWN0fEFic3RyYWN0TG9hZGVyfSBBbiBpbnN0YW5jZSBvZiBBYnN0cmFjdExvYWRlci5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmluaXRMb2FkID0gZnVuY3Rpb24gKGxvYWRJdGVtKSB7XG5cdFx0cmV0dXJuIHMuX3JlZ2lzdGVyU291bmQobG9hZEl0ZW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBtZXRob2QgZm9yIGxvYWRpbmcgc291bmRzLiAgVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cblx0ICpcblx0ICogQG1ldGhvZCBfcmVnaXN0ZXJTb3VuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3JjIFRoZSBvYmplY3QgdG8gbG9hZCwgY29udGFpbmluZyBzcmMgcHJvcGVydHkgYW5kIG9wdGlvbmFsbHkgY29udGFpbmluZyBpZCBhbmQgZGF0YS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWVzIHRoYXQgd2VyZSBwYXNzZWQgaW4sIHdoaWNoIGRlZmluZXMgdGhlIHNvdW5kLlxuXHQgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZCBvciBubyBwbHVnaW5zIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VyY2UgaXMgYWxyZWFkeSBsb2FkZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdHMuX3JlZ2lzdGVyU291bmQgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHRpZiAoIXMuaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zKCkpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dmFyIGRldGFpbHM7XG5cdFx0aWYgKGxvYWRJdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlU3JjKGxvYWRJdGVtLnNyYyk7XG5cdFx0XHRkZXRhaWxzLnNyYyA9IGxvYWRJdGVtLnBhdGggKyBkZXRhaWxzLnNyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlUGF0aChsb2FkSXRlbS5zcmMpO1xuXHRcdH1cblx0XHRpZiAoZGV0YWlscyA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRsb2FkSXRlbS5zcmMgPSBkZXRhaWxzLnNyYztcblx0XHRsb2FkSXRlbS50eXBlID0gXCJzb3VuZFwiO1xuXG5cdFx0dmFyIGRhdGEgPSBsb2FkSXRlbS5kYXRhO1xuXHRcdHZhciBudW1DaGFubmVscyA9IG51bGw7XG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCFpc05hTihkYXRhLmNoYW5uZWxzKSkge1xuXHRcdFx0XHRudW1DaGFubmVscyA9IHBhcnNlSW50KGRhdGEuY2hhbm5lbHMpO1xuXHRcdFx0fSBlbHNlIGlmICghaXNOYU4oZGF0YSkpIHtcblx0XHRcdFx0bnVtQ2hhbm5lbHMgPSBwYXJzZUludChkYXRhKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YS5hdWRpb1Nwcml0ZSkge1xuXHRcdFx0XHR2YXIgc3A7XG5cdFx0XHRcdGZvcih2YXIgaSA9IGRhdGEuYXVkaW9TcHJpdGUubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdHNwID0gZGF0YS5hdWRpb1Nwcml0ZVtpXTtcblx0XHRcdFx0XHRzLl9pZEhhc2hbc3AuaWRdID0ge3NyYzogbG9hZEl0ZW0uc3JjLCBzdGFydFRpbWU6IHBhcnNlSW50KHNwLnN0YXJ0VGltZSksIGR1cmF0aW9uOiBwYXJzZUludChzcC5kdXJhdGlvbil9O1xuXG5cdFx0XHRcdFx0aWYgKHNwLmRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdFx0XHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3NwLmlkXSA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoc3AuZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChsb2FkSXRlbS5pZCAhPSBudWxsKSB7cy5faWRIYXNoW2xvYWRJdGVtLmlkXSA9IHtzcmM6IGxvYWRJdGVtLnNyY319O1xuXHRcdHZhciBsb2FkZXIgPSBzLmFjdGl2ZVBsdWdpbi5yZWdpc3Rlcihsb2FkSXRlbSk7XG5cblx0XHRTb3VuZENoYW5uZWwuY3JlYXRlKGxvYWRJdGVtLnNyYywgbnVtQ2hhbm5lbHMpO1xuXG5cdFx0Ly8gcmV0dXJuIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIHRvIHRoZSB1c2VyLiAgVGhpcyB3aWxsIGFsc28gYmUgcmV0dXJuZWQgaW4gdGhlIGxvYWQgZXZlbnQuXG5cdFx0aWYgKGRhdGEgPT0gbnVsbCB8fCAhaXNOYU4oZGF0YSkpIHtcblx0XHRcdGxvYWRJdGVtLmRhdGEgPSBudW1DaGFubmVscyB8fCBTb3VuZENoYW5uZWwubWF4UGVyQ2hhbm5lbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2FkSXRlbS5kYXRhLmNoYW5uZWxzID0gbnVtQ2hhbm5lbHMgfHwgU291bmRDaGFubmVsLm1heFBlckNoYW5uZWwoKTtcblx0XHR9XG5cblx0XHRpZiAobG9hZGVyLnR5cGUpIHtsb2FkSXRlbS50eXBlID0gbG9hZGVyLnR5cGU7fVxuXG5cdFx0aWYgKGxvYWRJdGVtLmRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2xvYWRJdGVtLnNyY10gPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKGxvYWRJdGVtLmRlZmF1bHRQbGF5UHJvcHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9hZGVyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhbiBhdWRpbyBmaWxlIGZvciBsb2FkaW5nIGFuZCBmdXR1cmUgcGxheWJhY2sgaW4gU291bmQuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiB1c2luZ1xuXHQgKiA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gcmVnaXN0ZXIgYWxsIHNvdW5kcyB0aGF0XG5cdCAqIG5lZWQgdG8gYmUgcGxheWVkIGJhY2sgaW4gb3JkZXIgdG8gcHJvcGVybHkgcHJlcGFyZSBhbmQgcHJlbG9hZCB0aGVtLiBTb3VuZCBkb2VzIGludGVybmFsIHByZWxvYWRpbmcgd2hlbiByZXF1aXJlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTsgLy8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB3aGVuIGxvYWQgaXMgY29tcGxldGVkXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcIm15QXVkaW9QYXRoL215U291bmQub2dnXCIsIFwibXlJRFwiLCAzKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKHtvZ2c6XCJwYXRoMS9teVNvdW5kLm9nZ1wiLCBtcDM6XCJwYXRoMi9teVNvdW5kTm9FeHRlbnNpb25cIn0sIFwibXlJRFwiLCAzKTtcblx0ICpcblx0ICpcblx0ICogQG1ldGhvZCByZWdpc3RlclNvdW5kXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBzcmMgVGhlIHNvdXJjZSBvciBhbiBPYmplY3Qgd2l0aCBhIFwic3JjXCIgcHJvcGVydHkgb3IgYW4gT2JqZWN0IHdpdGggbXVsdGlwbGUgZXh0ZW5zaW9uIGxhYmVsZWQgc3JjIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaWRdIEFuIGlkIHNwZWNpZmllZCBieSB0aGUgdXNlciB0byBwbGF5IHRoZSBzb3VuZCBsYXRlci4gIE5vdGUgaWQgaXMgcmVxdWlyZWQgZm9yIHdoZW4gc3JjIGlzIG11bHRpcGxlIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge051bWJlciB8IE9iamVjdH0gW2RhdGFdIERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLiBTb3VuZCB1c2VzIHRoZSBkYXRhIHBhcmFtZXRlciBhcyB0aGUgbnVtYmVyIG9mXG5cdCAqIGNoYW5uZWxzIGZvciBhbiBhdWRpbyBpbnN0YW5jZSwgaG93ZXZlciBhIFwiY2hhbm5lbHNcIiBwcm9wZXJ0eSBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIGRhdGEgb2JqZWN0IGlmIGl0IGlzIHVzZWRcblx0ICogZm9yIG90aGVyIGluZm9ybWF0aW9uLiBUaGUgYXVkaW8gY2hhbm5lbHMgd2lsbCBzZXQgYSBkZWZhdWx0IGJhc2VkIG9uIHBsdWdpbiBpZiBubyB2YWx1ZSBpcyBmb3VuZC5cblx0ICogU291bmQgYWxzbyB1c2VzIHRoZSBkYXRhIHByb3BlcnR5IHRvIGhvbGQgYW4ge3sjY3Jvc3NMaW5rIFwiQXVkaW9TcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0gYXJyYXkgb2Ygb2JqZWN0cyBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdCB7aWQsIHN0YXJ0VGltZSwgZHVyYXRpb259Ljxici8+XG5cdCAqICAgaWQgdXNlZCB0byBwbGF5IHRoZSBzb3VuZCBsYXRlciwgaW4gdGhlIHNhbWUgbWFubmVyIGFzIGEgc291bmQgc3JjIHdpdGggYW4gaWQuPGJyLz5cblx0ICogICBzdGFydFRpbWUgaXMgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy48YnIvPlxuXHQgKiAgIGR1cmF0aW9uIGlzIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLjxici8+XG5cdCAqIFRoaXMgYWxsb3dzIFNvdW5kIHRvIHN1cHBvcnQgYXVkaW8gc3ByaXRlcyB0aGF0IGFyZSBwbGF5ZWQgYmFjayBieSBpZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBzcmMgZm9yIGxvYWRpbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgUGxheVByb3BzQ29uZmlnfSBkZWZhdWx0UGxheVByb3BzIE9wdGlvbmFsIFBsYXliYWNrIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNldCBhcyB0aGUgZGVmYXVsdHMgb24gYW55IG5ldyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluLCB3aGljaCBkZWZpbmVzIHRoZSBzb3VuZC5cblx0ICogUmV0dXJucyBmYWxzZSBpZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWQgb3Igbm8gcGx1Z2lucyBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc291cmNlIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0cy5yZWdpc3RlclNvdW5kID0gZnVuY3Rpb24gKHNyYywgaWQsIGRhdGEsIGJhc2VQYXRoLCBkZWZhdWx0UGxheVByb3BzKSB7XG5cdFx0dmFyIGxvYWRJdGVtID0ge3NyYzogc3JjLCBpZDogaWQsIGRhdGE6ZGF0YSwgZGVmYXVsdFBsYXlQcm9wczpkZWZhdWx0UGxheVByb3BzfTtcblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0ICYmIHNyYy5zcmMpIHtcblx0XHRcdGJhc2VQYXRoID0gaWQ7XG5cdFx0XHRsb2FkSXRlbSA9IHNyYztcblx0XHR9XG5cdFx0bG9hZEl0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUobG9hZEl0ZW0pO1xuXHRcdGxvYWRJdGVtLnBhdGggPSBiYXNlUGF0aDtcblxuXHRcdGlmIChiYXNlUGF0aCAhPSBudWxsICYmICEobG9hZEl0ZW0uc3JjIGluc3RhbmNlb2YgT2JqZWN0KSkge2xvYWRJdGVtLnNyYyA9IGJhc2VQYXRoICsgc3JjO31cblxuXHRcdHZhciBsb2FkZXIgPSBzLl9yZWdpc3RlclNvdW5kKGxvYWRJdGVtKTtcblx0XHRpZighbG9hZGVyKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdGlmICghcy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXSkgeyBzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdID0gW107fVxuXHRcdHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10ucHVzaChsb2FkSXRlbSk7XG5cdFx0aWYgKHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10ubGVuZ3RoID09IDEpIHtcblx0XHRcdC8vIE9KUiBub3RlIHRoaXMgd2lsbCBkaXNhbGxvdyByZWxvYWRpbmcgYSBzb3VuZCBpZiBsb2FkaW5nIGZhaWxzIG9yIHRoZSBzb3VyY2UgY2hhbmdlc1xuXHRcdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZENvbXBsZXRlLCB0aGlzKSk7XG5cdFx0XHRsb2FkZXIub24oXCJlcnJvclwiLCBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkRXJyb3IsIHRoaXMpKTtcblx0XHRcdHMuYWN0aXZlUGx1Z2luLnByZWxvYWQobG9hZGVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY11bMF0gPT0gdHJ1ZSkge3JldHVybiB0cnVlO31cblx0XHR9XG5cblx0XHRyZXR1cm4gbG9hZEl0ZW07XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGFuIGFycmF5IG9mIGF1ZGlvIGZpbGVzIGZvciBsb2FkaW5nIGFuZCBmdXR1cmUgcGxheWJhY2sgaW4gU291bmQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHJlZ2lzdGVyIGFsbFxuXHQgKiBzb3VuZHMgdGhhdCBuZWVkIHRvIGJlIHBsYXllZCBiYWNrIGluIG9yZGVyIHRvIHByb3Blcmx5IHByZXBhcmUgYW5kIHByZWxvYWQgdGhlbS4gU291bmQgZG9lcyBpbnRlcm5hbCBwcmVsb2FkaW5nXG5cdCAqIHdoZW4gcmVxdWlyZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdHZhciBhc3NldFBhdGggPSBcIi4vbXlBdWRpb1BhdGgvXCI7XG5cdCAqICAgICAgdmFyIHNvdW5kcyA9IFtcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0MC5vZ2dcIiwgaWQ6XCJleGFtcGxlXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQxLm9nZ1wiLCBpZDpcIjFcIiwgZGF0YTo2fSxcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0Mi5tcDNcIiwgaWQ6XCJ3b3Jrc1wifVxuXHQgKiAgICAgICAgICB7c3JjOnttcDM6XCJwYXRoMS9hc3NldDMubXAzXCIsIG9nZzpcInBhdGgyL2Fzc2V0M05vRXh0ZW5zaW9ufSwgaWQ6XCJiZXR0ZXJcIn1cblx0ICogICAgICBdO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLmFsdGVybmF0ZUV4dGVuc2lvbnMgPSBbXCJtcDNcIl07XHQvLyBpZiB0aGUgcGFzc2VkIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkLCB0cnkgdGhpcyBleHRlbnNpb25cblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpOyAvLyBjYWxsIGhhbmRsZUxvYWQgd2hlbiBlYWNoIHNvdW5kIGxvYWRzXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldFBhdGgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyU291bmRzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNvdW5kcyBBbiBhcnJheSBvZiBvYmplY3RzIHRvIGxvYWQuIE9iamVjdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgbmVlZGVkIGZvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319OiA8Y29kZT57c3JjOnNyY1VSSSwgaWQ6SUQsIGRhdGE6RGF0YX08L2NvZGU+XG5cdCAqIHdpdGggXCJpZFwiIGFuZCBcImRhdGFcIiBiZWluZyBvcHRpb25hbC5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgYW4gb2JqZWN0IHdpdGggcGF0aCBhbmQgbWFuaWZlc3QgcHJvcGVydGllcywgd2hlcmUgcGF0aCBpcyBhIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIGxvYWQuXG5cdCAqIE5vdGUgaWQgaXMgcmVxdWlyZWQgaWYgc3JjIGlzIGFuIG9iamVjdCB3aXRoIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggc3JjIHdoZW4gbG9hZGluZy4gIFdoZW4gY3JlYXRpbmcsIHBsYXlpbmcsIG9yIHJlbW92aW5nXG5cdCAqIGF1ZGlvIHRoYXQgd2FzIGxvYWRlZCB3aXRoIGEgYmFzZVBhdGggYnkgc3JjLCB0aGUgYmFzZVBhdGggbXVzdCBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluLCB3aGljaCBkZWZpbmVzIGVhY2ggc291bmQuXG5cdCAqIExpa2UgcmVnaXN0ZXJTb3VuZCwgaXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGFueSB2YWx1ZXMgd2hlbiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWQgb3IgaWYgbm8gcGx1Z2lucyBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEFsc28sIGl0IHdpbGwgcmV0dXJuIHRydWUgZm9yIGFueSB2YWx1ZXMgd2hlbiB0aGUgc291cmNlIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5yZWdpc3RlclNvdW5kcyA9IGZ1bmN0aW9uIChzb3VuZHMsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIHJldHVyblZhbHVlcyA9IFtdO1xuXHRcdGlmIChzb3VuZHMucGF0aCkge1xuXHRcdFx0aWYgKCFiYXNlUGF0aCkge1xuXHRcdFx0XHRiYXNlUGF0aCA9IHNvdW5kcy5wYXRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aCArIHNvdW5kcy5wYXRoO1xuXHRcdFx0fVxuXHRcdFx0c291bmRzID0gc291bmRzLm1hbmlmZXN0O1xuXHRcdFx0Ly8gVE9ETyBkb2N1bWVudCB0aGlzIGZlYXR1cmVcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzb3VuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZXNbaV0gPSBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKHNvdW5kc1tpXS5zcmMsIHNvdW5kc1tpXS5pZCwgc291bmRzW2ldLmRhdGEsIGJhc2VQYXRoLCBzb3VuZHNbaV0uZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHNvdW5kIHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIDxiciAvPk5vdGUgdGhpcyB3aWxsIHN0b3AgcGxheWJhY2sgb24gYWN0aXZlIGluc3RhbmNlcyBwbGF5aW5nIHRoaXMgc291bmQgYmVmb3JlIGRlbGV0aW5nIHRoZW0uXG5cdCAqIDxiciAvPk5vdGUgaWYgeW91IHBhc3NlZCBpbiBhIGJhc2VQYXRoLCB5b3UgbmVlZCB0byBwYXNzIGl0IG9yIHByZXBlbmQgaXQgdG8gdGhlIHNyYyBoZXJlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoXCJteUlEXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKFwibXlBdWRpb0Jhc2VQYXRoL215U291bmQub2dnXCIpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKFwibXlQYXRoL215T3RoZXJTb3VuZC5tcDNcIiwgXCJteUJhc2VQYXRoL1wiKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZCh7bXAzOlwibXVzaWNOb0V4dGVuc2lvblwiLCBvZ2c6XCJtdXNpYy5vZ2dcIn0sIFwibXlCYXNlUGF0aC9cIik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlU291bmRcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IHNyYyBUaGUgc3JjIG9yIElEIG9mIHRoZSBhdWRpbywgb3IgYW4gT2JqZWN0IHdpdGggYSBcInNyY1wiIHByb3BlcnR5LCBvciBhbiBPYmplY3Qgd2l0aCBtdWx0aXBsZSBleHRlbnNpb24gbGFiZWxlZCBzcmMgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIHNyYyB3aGVuIHJlbW92aW5nLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHNvdW5kIGlzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5yZW1vdmVTb3VuZCA9IGZ1bmN0aW9uKHNyYywgYmFzZVBhdGgpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0ICYmIHNyYy5zcmMpIHtzcmMgPSBzcmMuc3JjO31cblxuXHRcdHZhciBkZXRhaWxzO1xuXHRcdGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGRldGFpbHMgPSBzLl9wYXJzZVNyYyhzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYykuc3JjO1xuXHRcdFx0ZGV0YWlscyA9IHMuX3BhcnNlUGF0aChzcmMpO1xuXHRcdH1cblx0XHRpZiAoZGV0YWlscyA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRzcmMgPSBkZXRhaWxzLnNyYztcblx0XHRpZiAoYmFzZVBhdGggIT0gbnVsbCkge3NyYyA9IGJhc2VQYXRoICsgc3JjO31cblxuXHRcdGZvcih2YXIgcHJvcCBpbiBzLl9pZEhhc2gpe1xuXHRcdFx0aWYocy5faWRIYXNoW3Byb3BdLnNyYyA9PSBzcmMpIHtcblx0XHRcdFx0ZGVsZXRlKHMuX2lkSGFzaFtwcm9wXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2xlYXIgZnJvbSBTb3VuZENoYW5uZWwsIHdoaWNoIGFsc28gc3RvcHMgYW5kIGRlbGV0ZXMgYWxsIGluc3RhbmNlc1xuXHRcdFNvdW5kQ2hhbm5lbC5yZW1vdmVTcmMoc3JjKTtcblxuXHRcdGRlbGV0ZShzLl9wcmVsb2FkSGFzaFtzcmNdKTtcblxuXHRcdHMuYWN0aXZlUGx1Z2luLnJlbW92ZVNvdW5kKHNyYyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGFycmF5IG9mIGF1ZGlvIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiA8YnIgLz5Ob3RlIHRoaXMgd2lsbCBzdG9wIHBsYXliYWNrIG9uIGFjdGl2ZSBpbnN0YW5jZXMgcGxheWluZyB0aGlzIGF1ZGlvIGJlZm9yZSBkZWxldGluZyB0aGVtLlxuXHQgKiA8YnIgLz5Ob3RlIGlmIHlvdSBwYXNzZWQgaW4gYSBiYXNlUGF0aCwgeW91IG5lZWQgdG8gcGFzcyBpdCBvciBwcmVwZW5kIGl0IHRvIHRoZSBzcmMgaGVyZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0YXNzZXRQYXRoID0gXCIuL215UGF0aC9cIjtcblx0ICogICAgICB2YXIgc291bmRzID0gW1xuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQwLm9nZ1wiLCBpZDpcImV4YW1wbGVcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDEub2dnXCIsIGlkOlwiMVwiLCBkYXRhOjZ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQyLm1wM1wiLCBpZDpcIndvcmtzXCJ9XG5cdCAqICAgICAgXTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZHMoc291bmRzLCBhc3NldFBhdGgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVNvdW5kc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBzb3VuZHMgQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byByZW1vdmUuIE9iamVjdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgbmVlZGVkIGZvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZW1vdmVTb3VuZFwifX17ey9jcm9zc0xpbmt9fTogPGNvZGU+e3NyY09ySUQ6c3JjVVJJb3JJRH08L2NvZGU+LlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBvYmplY3Qgd2l0aCBwYXRoIGFuZCBtYW5pZmVzdCBwcm9wZXJ0aWVzLCB3aGVyZSBwYXRoIGlzIGEgYmFzZVBhdGggYW5kIG1hbmlmZXN0IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgdG8gcmVtb3ZlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggU2V0IGEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggc3JjIHdoZW4gcmVtb3ZpbmcuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gYXJyYXkgb2YgQm9vbGVhbiB2YWx1ZXMgcmVwcmVzZW50aW5nIGlmIHRoZSBzb3VuZHMgd2l0aCB0aGUgc2FtZSBhcnJheSBpbmRleCB3ZXJlXG5cdCAqIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cy5yZW1vdmVTb3VuZHMgPSBmdW5jdGlvbiAoc291bmRzLCBiYXNlUGF0aCkge1xuXHRcdHZhciByZXR1cm5WYWx1ZXMgPSBbXTtcblx0XHRpZiAoc291bmRzLnBhdGgpIHtcblx0XHRcdGlmICghYmFzZVBhdGgpIHtcblx0XHRcdFx0YmFzZVBhdGggPSBzb3VuZHMucGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJhc2VQYXRoID0gYmFzZVBhdGggKyBzb3VuZHMucGF0aDtcblx0XHRcdH1cblx0XHRcdHNvdW5kcyA9IHNvdW5kcy5tYW5pZmVzdDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzb3VuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZXNbaV0gPSBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZChzb3VuZHNbaV0uc3JjLCBiYXNlUGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgc291bmRzIHRoYXQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiA8YnIgLz5Ob3RlIHRoaXMgd2lsbCBzdG9wIHBsYXliYWNrIG9uIGFsbCBhY3RpdmUgc291bmQgaW5zdGFuY2VzIGJlZm9yZSBkZWxldGluZyB0aGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVBbGxTb3VuZHMoKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVBbGxTb3VuZHNcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucmVtb3ZlQWxsU291bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cy5faWRIYXNoID0ge307XG5cdFx0cy5fcHJlbG9hZEhhc2ggPSB7fTtcblx0XHRTb3VuZENoYW5uZWwucmVtb3ZlQWxsKCk7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luKSB7cy5hY3RpdmVQbHVnaW4ucmVtb3ZlQWxsU291bmRzKCk7fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIHNvdXJjZSBoYXMgYmVlbiBsb2FkZWQgYnkgaW50ZXJuYWwgcHJlbG9hZGVycy4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgc291bmRzIHRoYXQgYXJlXG5cdCAqIG5vdCBjb21wbGV0ZWQgcHJlbG9hZGluZyB3aWxsIG5vdCBraWNrIG9mZiBhIG5ldyBpbnRlcm5hbCBwcmVsb2FkIGlmIHRoZXkgYXJlIHBsYXllZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgdmFyIG15U291bmQgPSBcImFzc2V0UGF0aC9hc3NldDAub2dnXCI7XG5cdCAqICAgICBpZihjcmVhdGVqcy5Tb3VuZC5sb2FkQ29tcGxldGUobXlTb3VuZCkge1xuXHQgKiAgICAgICAgIGNyZWF0ZWpzLlNvdW5kLnBsYXkobXlTb3VuZCk7XG5cdCAqICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBpZCB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNyYyBpcyBhbHJlYWR5IGxvYWRlZC5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMubG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdGlmICghcy5pc1JlYWR5KCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIGRldGFpbHMgPSBzLl9wYXJzZVBhdGgoc3JjKTtcblx0XHRpZiAoZGV0YWlscykge1xuXHRcdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChkZXRhaWxzLnNyYykuc3JjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYykuc3JjO1xuXHRcdH1cblx0XHRpZihzLl9wcmVsb2FkSGFzaFtzcmNdID09IHVuZGVmaW5lZCkge3JldHVybiBmYWxzZTt9XG5cdFx0cmV0dXJuIChzLl9wcmVsb2FkSGFzaFtzcmNdWzBdID09IHRydWUpOyAgLy8gc3JjIG9ubHkgbG9hZHMgb25jZSwgc28gaWYgaXQncyB0cnVlIGZvciB0aGUgZmlyc3QgaXQncyB0cnVlIGZvciBhbGxcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIHBhdGggb2YgYSBzb3VuZC4gQWx0ZXJuYXRlIGV4dGVuc2lvbnMgd2lsbCBiZSBhdHRlbXB0ZWQgaW4gb3JkZXIgaWYgdGhlXG5cdCAqIGN1cnJlbnQgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICogQG1ldGhvZCBfcGFyc2VQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgcGF0aCB0byBhbiBhdWRpbyBzb3VyY2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBmb3JtYXR0ZWQgb2JqZWN0IHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvYWN0aXZlUGx1Z2luOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCByZXR1cm5lZCB0byBhIHByZWxvYWRlciBsaWtlIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGFyc2VQYXRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT0gXCJzdHJpbmdcIikge3ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTt9XG5cblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChzLkZJTEVfUEFUVEVSTik7XG5cdFx0aWYgKG1hdGNoID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dmFyIG5hbWUgPSBtYXRjaFs0XTtcblx0XHR2YXIgZXh0ID0gbWF0Y2hbNV07XG5cdFx0dmFyIGMgPSBzLmNhcGFiaWxpdGllcztcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKCFjW2V4dF0pIHtcblx0XHRcdGV4dCA9IHMuYWx0ZXJuYXRlRXh0ZW5zaW9uc1tpKytdO1xuXHRcdFx0aWYgKGkgPiBzLmFsdGVybmF0ZUV4dGVuc2lvbnMubGVuZ3RoKSB7IHJldHVybiBudWxsO31cdC8vIG5vIGV4dGVuc2lvbnMgYXJlIHN1cHBvcnRlZFxuXHRcdH1cblx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCIuXCIrbWF0Y2hbNV0sIFwiLlwiK2V4dCk7XG5cblx0XHR2YXIgcmV0ID0ge25hbWU6bmFtZSwgc3JjOnZhbHVlLCBleHRlbnNpb246ZXh0fTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgcGF0aCBvZiBhIHNvdW5kIGJhc2VkIG9uIHByb3BlcnRpZXMgb2Ygc3JjIG1hdGNoaW5nIHdpdGggc3VwcG9ydGVkIGV4dGVuc2lvbnMuXG5cdCAqIFJldHVybnMgZmFsc2UgaWYgbm9uZSBvZiB0aGUgcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkXG5cdCAqIEBtZXRob2QgX3BhcnNlU3JjXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgcGF0aHMgdG8gYW4gYXVkaW8gc291cmNlLCBpbmRleGVkIGJ5IGV4dGVuc2lvbiB0eXBlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2FjdGl2ZVBsdWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcmV0dXJuZWQgdG8gYSBwcmVsb2FkZXIgbGlrZSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3BhcnNlU3JjID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIHJldCA9IHtuYW1lOnVuZGVmaW5lZCwgc3JjOnVuZGVmaW5lZCwgZXh0ZW5zaW9uOnVuZGVmaW5lZH07XG5cdFx0dmFyIGMgPSBzLmNhcGFiaWxpdGllcztcblxuXHRcdGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcblx0XHQgIGlmKHZhbHVlLmhhc093blByb3BlcnR5KHByb3ApICYmIGNbcHJvcF0pIHtcblx0XHRcdFx0cmV0LnNyYyA9IHZhbHVlW3Byb3BdO1xuXHRcdFx0XHRyZXQuZXh0ZW5zaW9uID0gcHJvcDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0ICB9XG5cdFx0fVxuXHRcdGlmICghcmV0LnNyYykge3JldHVybiBmYWxzZTt9XHQvLyBubyBtYXRjaGVzXG5cblx0XHR2YXIgaSA9IHJldC5zcmMubGFzdEluZGV4T2YoXCIvXCIpO1xuXHRcdGlmIChpICE9IC0xKSB7XG5cdFx0XHRyZXQubmFtZSA9IHJldC5zcmMuc2xpY2UoaSsxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0Lm5hbWUgPSByZXQuc3JjO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tXG5cdCBTdGF0aWMgQVBJLlxuXHQgLS0tLS0tLS0tLS0tLS0tICovXG5cdC8qKlxuXHQgKiBQbGF5IGEgc291bmQgYW5kIGdldCBhIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBjb250cm9sLiBJZiB0aGUgc291bmQgZmFpbHMgdG8gcGxheSwgYVxuXHQgKiBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYW5kIGhhdmUgYSBwbGF5U3RhdGUgb2Yge3sjY3Jvc3NMaW5rIFwiU291bmQvUExBWV9GQUlMRUQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE5vdGUgdGhhdCBldmVuIG9uIHNvdW5kcyB3aXRoIGZhaWxlZCBwbGF5YmFjaywgeW91IG1heSBzdGlsbCBiZSBhYmxlIHRvIGNhbGwgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBzaW5jZSB0aGUgZmFpbHVyZSBjb3VsZCBiZSBkdWUgdG8gbGFjayBvZiBhdmFpbGFibGUgY2hhbm5lbHMuIElmIHRoZSBzcmMgZG9lcyBub3QgaGF2ZSBhIHN1cHBvcnRlZCBleHRlbnNpb24gb3Jcblx0ICogaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIHBsdWdpbiwgYSBkZWZhdWx0IEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkIHdoaWNoIHdpbGwgbm90IHBsYXkgYW55IGF1ZGlvLCBidXQgd2lsbCBub3QgZ2VuZXJhdGUgZXJyb3JzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclNvdW5kKFwibXlBdWRpb1BhdGgvbXlTb3VuZC5tcDNcIiwgXCJteUlEXCIsIDMpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxvYWQoZXZlbnQpIHtcblx0ICogICAgICBcdGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUlEXCIpO1xuXHQgKiAgICAgIFx0Ly8gc3RvcmUgb2ZmIEFic3RyYWN0U291bmRJbnN0YW5jZSBmb3IgY29udHJvbGxpbmdcblx0ICogICAgICBcdHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15SURcIiwge2ludGVycnVwdDogY3JlYXRlanMuU291bmQuSU5URVJSVVBUX0FOWSwgbG9vcDotMX0pO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogTk9URSB0byBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlIHRoYXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCwgYm90aCBzdGFydFRpbWUgYW5kIGR1cmF0aW9uIG5lZWQgdG8gYmUgc2V0LlxuXHQgKiBUaGlzIGlzIG9ubHkgd2hlbiBjcmVhdGluZyBhIG5ldyBhdWRpbyBzcHJpdGUsIG5vdCB3aGVuIHBsYXlpbmcgdXNpbmcgdGhlIGlkIG9mIGFuIGFscmVhZHkgcmVnaXN0ZXJlZCBhdWRpbyBzcHJpdGUuXG5cdCAqXG5cdCAqIDxiPlBhcmFtZXRlcnMgRGVwcmVjYXRlZDwvYj48YnIgLz5cblx0ICogVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgbWV0aG9kIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGFuIE9iamVjdCBvciB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgb2YgdGhlIGF1ZGlvLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gW2ludGVycnVwdD1cIm5vbmVcInxvcHRpb25zXSA8Yj5UaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbmFtZWQgcGxheVByb3BzIGluIHRoZSBuZXh0IHJlbGVhc2UuPC9iPjxiciAvPlxuXHQgKiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgYW4gaW5zdGFuY2Ugb2Yge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGFueSBvciBhbGwgb3B0aW9uYWwgcHJvcGVydGllcyBieSBuYW1lLFxuXHQgKiBpbmNsdWRpbmc6IGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4sIHN0YXJ0VGltZSwgYW5kIGR1cmF0aW9uIChzZWUgdGhlIGFib3ZlIGNvZGUgc2FtcGxlKS5cblx0ICogPGJyIC8+PHN0cm9uZz5PUjwvc3Ryb25nPjxiciAvPlxuXHQgKiA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG5cdCAqIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhcyA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT5cblx0ICogY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL2RlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxheT0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbG9vcD0wXSA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdCAqIGxvb3BzKSwgYW5kIC0xIGNhbiBiZSB1c2VkIGZvciBpbmZpbml0ZSBwbGF5YmFjay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2b2x1bWU9MV0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS4gTm90ZSB0aGF0IHRoZSBtYXN0ZXIgdm9sdW1lIGlzIGFwcGxpZWRcblx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFuPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRUaW1lPW51bGxdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPW51bGxdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBjYW4gYmUgY29udHJvbGxlZCBhZnRlciBpdCBpcyBjcmVhdGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBsYXkgPSBmdW5jdGlvbiAoc3JjLCBpbnRlcnJ1cHQsIGRlbGF5LCBvZmZzZXQsIGxvb3AsIHZvbHVtZSwgcGFuLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0dmFyIHBsYXlQcm9wcztcblx0XHRpZiAoaW50ZXJydXB0IGluc3RhbmNlb2YgT2JqZWN0IHx8IGludGVycnVwdCBpbnN0YW5jZW9mIGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZykge1xuXHRcdFx0cGxheVByb3BzID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShpbnRlcnJ1cHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKHtpbnRlcnJ1cHQ6aW50ZXJydXB0LCBkZWxheTpkZWxheSwgb2Zmc2V0Om9mZnNldCwgbG9vcDpsb29wLCB2b2x1bWU6dm9sdW1lLCBwYW46cGFuLCBzdGFydFRpbWU6c3RhcnRUaW1lLCBkdXJhdGlvbjpkdXJhdGlvbn0pO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSBzLmNyZWF0ZUluc3RhbmNlKHNyYywgcGxheVByb3BzLnN0YXJ0VGltZSwgcGxheVByb3BzLmR1cmF0aW9uKTtcblx0XHR2YXIgb2sgPSBzLl9wbGF5SW5zdGFuY2UoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0aWYgKCFvaykge2luc3RhbmNlLl9wbGF5RmFpbGVkKCk7fVxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB0aGUgcGFzc2VkIGluIHNyYy4gSWYgdGhlIHNyYyBkb2VzIG5vdCBoYXZlIGFcblx0ICogc3VwcG9ydGVkIGV4dGVuc2lvbiBvciBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgcGx1Z2luLCBhIGRlZmF1bHQgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWQgdGhhdCBjYW4gYmVcblx0ICogY2FsbGVkIHNhZmVseSBidXQgZG9lcyBub3RoaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBudWxsO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcIm15QXVkaW9QYXRoL215U291bmQubXAzXCIsIFwibXlJRFwiLCAzKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgXHRteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UoXCJteUlEXCIpO1xuXHQgKiAgICAgIFx0Ly8gYWx0ZXJuYXRlbHkgd2UgY291bGQgY2FsbCB0aGUgZm9sbG93aW5nXG5cdCAqICAgICAgXHRteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UoXCJteUF1ZGlvUGF0aC9teVNvdW5kLm1wM1wiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIE5PVEUgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSB0aGF0IGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsIGJvdGggc3RhcnRUaW1lIGFuZCBkdXJhdGlvbiBuZWVkIHRvIGJlIHNldC5cblx0ICogVGhpcyBpcyBvbmx5IHdoZW4gY3JlYXRpbmcgYSBuZXcgYXVkaW8gc3ByaXRlLCBub3Qgd2hlbiBwbGF5aW5nIHVzaW5nIHRoZSBpZCBvZiBhbiBhbHJlYWR5IHJlZ2lzdGVyZWQgYXVkaW8gc3ByaXRlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGNyZWF0ZUluc3RhbmNlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCBvZiB0aGUgYXVkaW8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRUaW1lPW51bGxdIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPW51bGxdIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBjYW4gYmUgY29udHJvbGxlZCBhZnRlciBpdCBpcyBjcmVhdGVkLlxuXHQgKiBVbnN1cHBvcnRlZCBleHRlbnNpb25zIHdpbGwgcmV0dXJuIHRoZSBkZWZhdWx0IEFic3RyYWN0U291bmRJbnN0YW5jZS5cblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0aWYgKCFzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpKSB7cmV0dXJuIG5ldyBjcmVhdGVqcy5EZWZhdWx0U291bmRJbnN0YW5jZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pO31cblxuXHRcdHZhciBkZWZhdWx0UGxheVByb3BzID0gcy5fZGVmYXVsdFBsYXlQcm9wc0hhc2hbc3JjXTtcdC8vIGZvciBhdWRpbyBzcHJpdGVzLCB3aGljaCBjcmVhdGUgYW5kIHN0b3JlIGRlZmF1bHRzIGJ5IGlkXG5cdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpO1xuXG5cdFx0dmFyIGRldGFpbHMgPSBzLl9wYXJzZVBhdGgoc3JjLnNyYyk7XG5cblx0XHR2YXIgaW5zdGFuY2UgPSBudWxsO1xuXHRcdGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5zcmMgIT0gbnVsbCkge1xuXHRcdFx0U291bmRDaGFubmVsLmNyZWF0ZShkZXRhaWxzLnNyYyk7XG5cdFx0XHRpZiAoc3RhcnRUaW1lID09IG51bGwpIHtzdGFydFRpbWUgPSBzcmMuc3RhcnRUaW1lO31cblx0XHRcdGluc3RhbmNlID0gcy5hY3RpdmVQbHVnaW4uY3JlYXRlKGRldGFpbHMuc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uIHx8IHNyYy5kdXJhdGlvbik7XG5cblx0XHRcdGRlZmF1bHRQbGF5UHJvcHMgPSBkZWZhdWx0UGxheVByb3BzIHx8IHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2RldGFpbHMuc3JjXTtcblx0XHRcdGlmKGRlZmF1bHRQbGF5UHJvcHMpIHtcblx0XHRcdFx0aW5zdGFuY2UuYXBwbHlQbGF5UHJvcHMoZGVmYXVsdFBsYXlQcm9wcyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluc3RhbmNlID0gbmV3IGNyZWF0ZWpzLkRlZmF1bHRTb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0aW5zdGFuY2UudW5pcXVlSWQgPSBzLl9sYXN0SUQrKztcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBhbGwgYXVkaW8gKGdsb2JhbCBzdG9wKS4gU3RvcHBlZCBhdWRpbyBpcyByZXNldCwgYW5kIG5vdCBwYXVzZWQuIFRvIHBsYXkgYXVkaW8gdGhhdCBoYXMgYmVlbiBzdG9wcGVkLFxuXHQgKiBjYWxsIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQuc3RvcCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0Zm9yICh2YXIgaSA9IGluc3RhbmNlcy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRpbnN0YW5jZXNbaV0uc3RvcCgpOyAgLy8gTk9URSBzdG9wIHJlbW92ZXMgaW5zdGFuY2UgZnJvbSB0aGlzLl9pbnN0YW5jZXNcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0Vm9sdW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbWFzdGVyIHZvbHVtZSB2YWx1ZS4gVGhlIGFjY2VwdGFibGUgcmFuZ2UgaXMgMC0xLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRzLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmIChOdW1iZXIodmFsdWUpID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHRzLl9tYXN0ZXJWb2x1bWUgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuYWN0aXZlUGx1Z2luIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRWb2x1bWUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSh2YWx1ZSkpIHtcblx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldE1hc3RlclZvbHVtZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFZvbHVtZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtYXN0ZXIgdm9sdW1lLCBpbiBhIHJhbmdlIG9mIDAtMS5cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hc3RlclZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9tdXRlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldE11dGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBXaGV0aGVyIHRoZSBhdWRpbyBzaG91bGQgYmUgbXV0ZWQgb3Igbm90LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbXV0ZSB3YXMgc2V0LlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5zZXRNdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0dGhpcy5fbWFzdGVyTXV0ZSA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5hY3RpdmVQbHVnaW4gfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldE11dGUodmFsdWUpKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJNdXRlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRNdXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBtdXRlIHZhbHVlIG9mIFNvdW5kLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRNdXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXN0ZXJNdXRlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgcGxheWJhY2sgcHJvcGVydGllcyBmb3IgYWxsIG5ldyBTb3VuZEluc3RhbmNlcyBvZiB0aGUgcGFzc2VkIGluIHNyYyBvciBJRC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSBmb3IgYXZhaWxhYmxlIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0RGVmYXVsdFBsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgdXNlZCB0byByZWdpc3RlciB0aGUgYXVkaW8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgUGxheVByb3BzQ29uZmlnfSBwbGF5UHJvcHMgVGhlIHBsYXliYWNrIHByb3BlcnRpZXMgeW91IHdvdWxkIGxpa2UgdG8gc2V0LlxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuc2V0RGVmYXVsdFBsYXlQcm9wcyA9IGZ1bmN0aW9uKHNyYywgcGxheVByb3BzKSB7XG5cdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpO1xuXHRcdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3MuX3BhcnNlUGF0aChzcmMuc3JjKS5zcmNdID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShwbGF5UHJvcHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRlZmF1bHQgcGxheWJhY2sgcHJvcGVydGllcyBmb3IgdGhlIHBhc3NlZCBpbiBzcmMgb3IgSUQuICBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIGFsbFxuXHQgKiBuZXcgU291bmRJbnN0YW5jZXMuICBSZXR1cm5zIG51bGwgaWYgZGVmYXVsdCBkb2VzIG5vdCBleGlzdC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UGxheVByb3BzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNyYyBvciBJRCB1c2VkIHRvIHJlZ2lzdGVyIHRoZSBhdWRpby5cblx0ICogQHJldHVybnMge1BsYXlQcm9wc0NvbmZpZ30gcmV0dXJucyBhbiBleGlzdGluZyBQbGF5UHJvcHNDb25maWcgb3IgbnVsbCBpZiBvbmUgZG9lcyBub3QgZXhpc3Rcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLmdldERlZmF1bHRQbGF5UHJvcHMgPSBmdW5jdGlvbihzcmMpIHtcblx0XHRzcmMgPSBzLl9nZXRTcmNCeUlkKHNyYyk7XG5cdFx0cmV0dXJuIHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3MuX3BhcnNlUGF0aChzcmMuc3JjKS5zcmNdO1xuXHR9O1xuXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tXG5cdCBJbnRlcm5hbCBtZXRob2RzXG5cdCAtLS0tLS0tLS0tLS0tLS0gKi9cblx0LyoqXG5cdCAqIFBsYXkgYW4gaW5zdGFuY2UuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBzdGF0aWMgQVBJLCBhcyB3ZWxsIGFzIGZyb20gcGx1Z2lucy4gVGhpcyBhbGxvd3MgdGhlIGNvcmUgY2xhc3MgdG9cblx0ICogY29udHJvbCBkZWxheXMuXG5cdCAqIEBtZXRob2QgX3BsYXlJbnN0YW5jZVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBzdGFydCBwbGF5aW5nLlxuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9iamVjdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNvdW5kIGNhbiBzdGFydCBwbGF5aW5nLiBTb3VuZHMgdGhhdCBmYWlsIGltbWVkaWF0ZWx5IHdpbGwgcmV0dXJuIGZhbHNlLiBTb3VuZHMgdGhhdFxuXHQgKiBoYXZlIGEgZGVsYXkgd2lsbCByZXR1cm4gdHJ1ZSwgYnV0IG1heSBzdGlsbCBmYWlsIHRvIHBsYXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGxheUluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwbGF5UHJvcHMpIHtcblx0XHR2YXIgZGVmYXVsdFBsYXlQcm9wcyA9IHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW2luc3RhbmNlLnNyY10gfHwge307XG5cdFx0aWYgKHBsYXlQcm9wcy5pbnRlcnJ1cHQgPT0gbnVsbCkge3BsYXlQcm9wcy5pbnRlcnJ1cHQgPSBkZWZhdWx0UGxheVByb3BzLmludGVycnVwdCB8fCBzLmRlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcn07XG5cdFx0aWYgKHBsYXlQcm9wcy5kZWxheSA9PSBudWxsKSB7cGxheVByb3BzLmRlbGF5ID0gZGVmYXVsdFBsYXlQcm9wcy5kZWxheSB8fCAwO31cblx0XHRpZiAocGxheVByb3BzLm9mZnNldCA9PSBudWxsKSB7cGxheVByb3BzLm9mZnNldCA9IGluc3RhbmNlLmdldFBvc2l0aW9uKCk7fVxuXHRcdGlmIChwbGF5UHJvcHMubG9vcCA9PSBudWxsKSB7cGxheVByb3BzLmxvb3AgPSBpbnN0YW5jZS5sb29wO31cblx0XHRpZiAocGxheVByb3BzLnZvbHVtZSA9PSBudWxsKSB7cGxheVByb3BzLnZvbHVtZSA9IGluc3RhbmNlLnZvbHVtZTt9XG5cdFx0aWYgKHBsYXlQcm9wcy5wYW4gPT0gbnVsbCkge3BsYXlQcm9wcy5wYW4gPSBpbnN0YW5jZS5wYW47fVxuXG5cdFx0aWYgKHBsYXlQcm9wcy5kZWxheSA9PSAwKSB7XG5cdFx0XHR2YXIgb2sgPSBzLl9iZWdpblBsYXlpbmcoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0XHRpZiAoIW9rKSB7cmV0dXJuIGZhbHNlO31cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9Ob3RlIHRoYXQgd2UgY2FuJ3QgcGFzcyBhcmd1bWVudHMgdG8gcHJveHkgT1Igc2V0VGltZW91dCAoSUUgb25seSksIHNvIGp1c3Qgd3JhcCB0aGUgZnVuY3Rpb24gY2FsbC5cblx0XHRcdC8vIE9KUiBXZWJBdWRpbyBtYXkgd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSwgc28gaXQgbWlnaHQgbWFrZSBzZW5zZSB0byBtb3ZlIHRoaXMgZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBwbHVnaW5zIGluIHRoZSBmdXR1cmVcblx0XHRcdHZhciBkZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzLl9iZWdpblBsYXlpbmcoaW5zdGFuY2UsIHBsYXlQcm9wcyk7XG5cdFx0XHR9LCBwbGF5UHJvcHMuZGVsYXkpO1xuXHRcdFx0aW5zdGFuY2UuZGVsYXlUaW1lb3V0SWQgPSBkZWxheVRpbWVvdXRJZDtcblx0XHR9XG5cblx0XHR0aGlzLl9pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gcGxheWJhY2suIFRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IG9yIGFmdGVyIGRlbGF5IGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfYmVnaW5QbGF5aW5nXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBBIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB0byBiZWdpbiBwbGF5YmFjay5cblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWd9IHBsYXlQcm9wcyBBIFBsYXlQcm9wc0NvbmZpZyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzb3VuZCBjYW4gc3RhcnQgcGxheWluZy4gSWYgdGhlcmUgYXJlIG5vIGF2YWlsYWJsZSBjaGFubmVscywgb3IgdGhlIGluc3RhbmNlIGZhaWxzIHRvXG5cdCAqIHN0YXJ0LCB0aGlzIHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2JlZ2luUGxheWluZyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGxheVByb3BzKSB7XG5cdFx0aWYgKCFTb3VuZENoYW5uZWwuYWRkKGluc3RhbmNlLCBwbGF5UHJvcHMuaW50ZXJydXB0KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gaW5zdGFuY2UuX2JlZ2luUGxheWluZyhwbGF5UHJvcHMpO1xuXHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX2luc3RhbmNlcywgaW5zdGFuY2UpO1xuXHRcdFx0aWYgKGluZGV4ID4gLTEpIHt0aGlzLl9pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTt9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNvdXJjZSBvZiBhIHNvdW5kIHZpYSB0aGUgSUQgcGFzc2VkIGluIHdpdGggYSByZWdpc3RlciBjYWxsLiBJZiBubyBJRCBpcyBmb3VuZCB0aGUgdmFsdWUgaXMgcmV0dXJuZWRcblx0ICogaW5zdGVhZC5cblx0ICogQG1ldGhvZCBfZ2V0U3JjQnlJZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIElEIHRoZSBzb3VuZCB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kIGlmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIElEIG9yIHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fZ2V0U3JjQnlJZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiBzLl9pZEhhc2hbdmFsdWVdIHx8IHtzcmM6IHZhbHVlfTtcblx0fTtcblxuXHQvKipcblx0ICogQSBzb3VuZCBoYXMgY29tcGxldGVkIHBsYXliYWNrLCBiZWVuIGludGVycnVwdGVkLCBmYWlsZWQsIG9yIGJlZW4gc3RvcHBlZC4gVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgaW5zdGFuY2UgZnJvbVxuXHQgKiBTb3VuZCBtYW5hZ2VtZW50LiBJdCB3aWxsIGJlIGFkZGVkIGFnYWluLCBpZiB0aGUgc291bmQgcmUtcGxheXMuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSB0aGVcblx0ICogaW5zdGFuY2VzIHRoZW1zZWx2ZXMuXG5cdCAqIEBtZXRob2QgX3BsYXlGaW5pc2hlZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgZmluaXNoZWQgcGxheWJhY2suXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fcGxheUZpbmlzaGVkID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0U291bmRDaGFubmVsLnJlbW92ZShpbnN0YW5jZSk7XG5cdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9pbnN0YW5jZXMsIGluc3RhbmNlKTtcblx0XHRpZiAoaW5kZXggPiAtMSkge3RoaXMuX2luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO31cdC8vIE9KUiB0aGlzIHdpbGwgYWx3YXlzIGJlID4gLTEsIHRoZXJlIGlzIG5vIHdheSBmb3IgYW4gaW5zdGFuY2UgdG8gZXhpc3Qgd2l0aG91dCBiZWluZyBhZGRlZCB0byB0aGlzLl9pbnN0YW5jZXNcblx0fTtcblxuXHRjcmVhdGVqcy5Tb3VuZCA9IFNvdW5kO1xuXG5cdC8qKlxuXHQgKiBBbiBpbnRlcm5hbCBjbGFzcyB0aGF0IG1hbmFnZXMgdGhlIG51bWJlciBvZiBhY3RpdmUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBmb3Jcblx0ICogZWFjaCBzb3VuZCB0eXBlLiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseSBieSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG5cdCAqXG5cdCAqIFRoZSBudW1iZXIgb2Ygc291bmRzIGlzIGFydGlmaWNpYWxseSBsaW1pdGVkIGJ5IFNvdW5kIGluIG9yZGVyIHRvIHByZXZlbnQgb3Zlci1zYXR1cmF0aW9uIG9mIGFcblx0ICogc2luZ2xlIHNvdW5kLCBhcyB3ZWxsIGFzIHRvIHN0YXkgd2l0aGluIGhhcmR3YXJlIGxpbWl0YXRpb25zLCBhbHRob3VnaCB0aGUgbGF0dGVyIG1heSBkaXNhcHBlYXIgd2l0aCBiZXR0ZXJcblx0ICogYnJvd3NlciBzdXBwb3J0LlxuXHQgKlxuXHQgKiBXaGVuIGEgc291bmQgaXMgcGxheWVkLCB0aGlzIGNsYXNzIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBhbiBhdmFpbGFibGUgaW5zdGFuY2UsIG9yIGludGVycnVwdHMgYW4gYXBwcm9wcmlhdGVcblx0ICogc291bmQgdGhhdCBpcyBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqICNjbGFzcyBTb3VuZENoYW5uZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBpbnN0YW5jZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXg9MV0gVGhlIG51bWJlciBvZiBpbnN0YW5jZXMgYWxsb3dlZFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmRDaGFubmVsKHNyYywgbWF4KSB7XG5cdFx0dGhpcy5pbml0KHNyYywgbWF4KTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0tLVxuXHQgU3RhdGljIEFQSVxuXHQgLS0tLS0tLS0tLS0tICovXG5cdC8qKlxuXHQgKiBBIGhhc2ggb2YgY2hhbm5lbCBpbnN0YW5jZXMgaW5kZXhlZCBieSBzb3VyY2UuXG5cdCAqICNwcm9wZXJ0eSBjaGFubmVsc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuY2hhbm5lbHMgPSB7fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgc291bmQgY2hhbm5lbC4gTm90ZSB0aGF0IGlmIHRoZSBzb3VuZCBjaGFubmVsIGFscmVhZHkgZXhpc3RzLCB0aGlzIHdpbGwgZmFpbC5cblx0ICogI21ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZvciB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIGFtb3VudCB0aGlzIGNoYW5uZWwgaG9sZHMuIFRoZSBkZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIlNvdW5kQ2hhbm5lbC5tYXhEZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgY2hhbm5lbHMgd2VyZSBjcmVhdGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwuY3JlYXRlID0gZnVuY3Rpb24gKHNyYywgbWF4KSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KHNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge1xuXHRcdFx0U291bmRDaGFubmVsLmNoYW5uZWxzW3NyY10gPSBuZXcgU291bmRDaGFubmVsKHNyYywgbWF4KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdC8qKlxuXHQgKiBEZWxldGUgYSBzb3VuZCBjaGFubmVsLCBzdG9wIGFuZCBkZWxldGUgYWxsIHJlbGF0ZWQgaW5zdGFuY2VzLiBOb3RlIHRoYXQgaWYgdGhlIHNvdW5kIGNoYW5uZWwgZG9lcyBub3QgZXhpc3QsIHRoaXMgd2lsbCBmYWlsLlxuXHQgKiAjbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZm9yIHRoZSBjaGFubmVsXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBjaGFubmVscyB3ZXJlIGRlbGV0ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5yZW1vdmVTcmMgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KHNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0Y2hhbm5lbC5fcmVtb3ZlQWxsKCk7XHQvLyB0aGlzIHN0b3BzIGFuZCByZW1vdmVzIGFsbCBhY3RpdmUgaW5zdGFuY2VzXG5cdFx0ZGVsZXRlKFNvdW5kQ2hhbm5lbC5jaGFubmVsc1tzcmNdKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0LyoqXG5cdCAqIERlbGV0ZSBhbGwgc291bmQgY2hhbm5lbHMsIHN0b3AgYW5kIGRlbGV0ZSBhbGwgcmVsYXRlZCBpbnN0YW5jZXMuXG5cdCAqICNtZXRob2QgcmVtb3ZlQWxsXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsIGluIFNvdW5kQ2hhbm5lbC5jaGFubmVscykge1xuXHRcdFx0U291bmRDaGFubmVsLmNoYW5uZWxzW2NoYW5uZWxdLl9yZW1vdmVBbGwoKTtcdC8vIHRoaXMgc3RvcHMgYW5kIHJlbW92ZXMgYWxsIGFjdGl2ZSBpbnN0YW5jZXNcblx0XHR9XG5cdFx0U291bmRDaGFubmVsLmNoYW5uZWxzID0ge307XG5cdH07XG5cdC8qKlxuXHQgKiBBZGQgYW4gaW5zdGFuY2UgdG8gYSBzb3VuZCBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIGFkZCB0byB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZXJydXB0IFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gdXNlLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzIG9uIGludGVycnVwdCBtb2Rlcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGUgY2hhbm5lbCBpcyBmdWxsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmFkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW50ZXJydXB0KSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBTb3VuZENoYW5uZWwuZ2V0KGluc3RhbmNlLnNyYyk7XG5cdFx0aWYgKGNoYW5uZWwgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0cmV0dXJuIGNoYW5uZWwuX2FkZChpbnN0YW5jZSwgaW50ZXJydXB0KTtcblx0fTtcblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpbnN0YW5jZSBmcm9tIHRoZSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHJlbW92ZSBmcm9tIHRoZSBjaGFubmVsXG5cdCAqIEByZXR1cm4gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGVyZSBpcyBubyBjaGFubmVsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLnJlbW92ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdHZhciBjaGFubmVsID0gU291bmRDaGFubmVsLmdldChpbnN0YW5jZS5zcmMpO1xuXHRcdGlmIChjaGFubmVsID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdGNoYW5uZWwuX3JlbW92ZShpbnN0YW5jZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNvdW5kcyB5b3UgY2FuIGhhdmUgaW4gYSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIG1heFBlckNoYW5uZWxcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc291bmRzIHlvdSBjYW4gaGF2ZSBpbiBhIGNoYW5uZWwuXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwubWF4UGVyQ2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gcC5tYXhEZWZhdWx0O1xuXHR9O1xuXHQvKipcblx0ICogR2V0IGEgY2hhbm5lbCBpbnN0YW5jZSBieSBpdHMgc3JjLlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgdG8gdXNlIHRvIGxvb2sgdXAgdGhlIGNoYW5uZWxcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmdldCA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRyZXR1cm4gU291bmRDaGFubmVsLmNoYW5uZWxzW3NyY107XG5cdH07XG5cblx0dmFyIHAgPSBTb3VuZENoYW5uZWwucHJvdG90eXBlO1xuXHRwLmNvbnN0cnVjdG9yID0gU291bmRDaGFubmVsO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG5cdC8qKlxuXHQgKiBUaGUgc291cmNlIG9mIHRoZSBjaGFubmVsLlxuXHQgKiAjcHJvcGVydHkgc3JjXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRwLnNyYyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgaW4gdGhpcyBjaGFubmVsLiAgLTEgaW5kaWNhdGVzIG5vIGxpbWl0XG5cdCAqICNwcm9wZXJ0eSBtYXhcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHAubWF4ID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgdG8gc2V0IGZvciBtYXgsIGlmIGl0IGlzbid0IHBhc3NlZCBpbi4gIEFsc28gdXNlZCBpZiAtMSBpcyBwYXNzZWQuXG5cdCAqICNwcm9wZXJ0eSBtYXhEZWZhdWx0XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDEwMFxuXHQgKiBAc2luY2UgMC40LjBcblx0ICovXG5cdHAubWF4RGVmYXVsdCA9IDEwMDtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGFjdGl2ZSBpbnN0YW5jZXMuXG5cdCAqICNwcm9wZXJ0eSBsZW5ndGhcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHAubGVuZ3RoID0gMDtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgY2hhbm5lbC5cblx0ICogI21ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgaW4gdGhlIGNoYW5uZWxcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5pbml0ID0gZnVuY3Rpb24gKHNyYywgbWF4KSB7XG5cdFx0dGhpcy5zcmMgPSBzcmM7XG5cdFx0dGhpcy5tYXggPSBtYXggfHwgdGhpcy5tYXhEZWZhdWx0O1xuXHRcdGlmICh0aGlzLm1heCA9PSAtMSkge3RoaXMubWF4ID0gdGhpcy5tYXhEZWZhdWx0O31cblx0XHR0aGlzLl9pbnN0YW5jZXMgPSBbXTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFuIGluc3RhbmNlIGJ5IGluZGV4LlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHJldHVybi5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBUaGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGF0IGEgc3BlY2lmaWMgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLl9nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zdGFuY2VzW2luZGV4XTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbmV3IGluc3RhbmNlIHRvIHRoZSBjaGFubmVsLlxuXHQgKiAjbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIGFkZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIG1ldGhvZCBjYWxsLiBJZiB0aGUgY2hhbm5lbCBpcyBmdWxsLCBpdCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICovXG5cdHAuX2FkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW50ZXJydXB0KSB7XG5cdFx0aWYgKCF0aGlzLl9nZXRTbG90KGludGVycnVwdCwgaW5zdGFuY2UpKSB7cmV0dXJuIGZhbHNlO31cblx0XHR0aGlzLl9pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG5cdFx0dGhpcy5sZW5ndGgrKztcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGluc3RhbmNlIGZyb20gdGhlIGNoYW5uZWwsIGVpdGhlciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwbGF5aW5nLCBvciBpdCBoYXMgYmVlbiBpbnRlcnJ1cHRlZC5cblx0ICogI21ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byByZW1vdmVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIHN1Y2Nlc3Mgb2YgdGhlIHJlbW92ZSBjYWxsLiBJZiB0aGUgaW5zdGFuY2UgaXMgbm90IGZvdW5kIGluIHRoaXMgY2hhbm5lbCwgaXQgd2lsbFxuXHQgKiByZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHRwLl9yZW1vdmUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX2luc3RhbmNlcywgaW5zdGFuY2UpO1xuXHRcdGlmIChpbmRleCA9PSAtMSkge3JldHVybiBmYWxzZTt9XG5cdFx0dGhpcy5faW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5sZW5ndGgtLTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBwbGF5YmFjayBhbmQgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgZnJvbSB0aGUgY2hhbm5lbC4gIFVzdWFsbHkgaW4gcmVzcG9uc2UgdG8gYSBkZWxldGUgY2FsbC5cblx0ICogI21ldGhvZCByZW1vdmVBbGxcblx0ICovXG5cdHAuX3JlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBOb3RlIHRoYXQgc3RvcCgpIHJlbW92ZXMgdGhlIGl0ZW0gZnJvbSB0aGUgbGlzdFxuXHRcdGZvciAodmFyIGk9dGhpcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR0aGlzLl9pbnN0YW5jZXNbaV0uc3RvcCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFuIGF2YWlsYWJsZSBzbG90IGRlcGVuZGluZyBvbiBpbnRlcnJ1cHQgdmFsdWUgYW5kIGlmIHNsb3RzIGFyZSBhdmFpbGFibGUuXG5cdCAqICNtZXRob2QgZ2V0U2xvdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW50ZXJydXB0IFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gdXNlLlxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgVGhlIHNvdW5kIGluc3RhbmNlIHRoYXQgd2lsbCBnbyBpbiB0aGUgY2hhbm5lbCBpZiBzdWNjZXNzZnVsLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBEZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGF2YWlsYWJsZSBzbG90LiBEZXBlbmRpbmcgb24gdGhlIGludGVycnVwdCBtb2RlLCBpZiB0aGVyZSBhcmUgbm8gc2xvdHMsXG5cdCAqIGFuIGV4aXN0aW5nIEFic3RyYWN0U291bmRJbnN0YW5jZSBtYXkgYmUgaW50ZXJydXB0ZWQuIElmIHRoZXJlIGFyZSBubyBzbG90cywgdGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZS5cblx0ICovXG5cdHAuX2dldFNsb3QgPSBmdW5jdGlvbiAoaW50ZXJydXB0LCBpbnN0YW5jZSkge1xuXHRcdHZhciB0YXJnZXQsIHJlcGxhY2VtZW50O1xuXG5cdFx0aWYgKGludGVycnVwdCAhPSBTb3VuZC5JTlRFUlJVUFRfTk9ORSkge1xuXHRcdFx0Ly8gRmlyc3QgcmVwbGFjZW1lbnQgY2FuZGlkYXRlXG5cdFx0XHRyZXBsYWNlbWVudCA9IHRoaXMuX2dldCgwKTtcblx0XHRcdGlmIChyZXBsYWNlbWVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5tYXg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldChpKTtcblxuXHRcdFx0Ly8gQXZhaWxhYmxlIFNwYWNlXG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF1ZGlvIGlzIGNvbXBsZXRlIG9yIG5vdCBwbGF5aW5nXG5cdFx0XHRpZiAodGFyZ2V0LnBsYXlTdGF0ZSA9PSBTb3VuZC5QTEFZX0ZJTklTSEVEIHx8XG5cdFx0XHRcdHRhcmdldC5wbGF5U3RhdGUgPT0gU291bmQuUExBWV9JTlRFUlJVUFRFRCB8fFxuXHRcdFx0XHR0YXJnZXQucGxheVN0YXRlID09IFNvdW5kLlBMQVlfRkFJTEVEKSB7XG5cdFx0XHRcdHJlcGxhY2VtZW50ID0gdGFyZ2V0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGludGVycnVwdCA9PSBTb3VuZC5JTlRFUlJVUFRfTk9ORSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXVkaW8gaXMgYSBiZXR0ZXIgY2FuZGlkYXRlIHRoYW4gdGhlIGN1cnJlbnQgdGFyZ2V0LCBhY2NvcmRpbmcgdG8gcGxheWhlYWRcblx0XHRcdGlmICgoaW50ZXJydXB0ID09IFNvdW5kLklOVEVSUlVQVF9FQVJMWSAmJiB0YXJnZXQuZ2V0UG9zaXRpb24oKSA8IHJlcGxhY2VtZW50LmdldFBvc2l0aW9uKCkpIHx8XG5cdFx0XHRcdChpbnRlcnJ1cHQgPT0gU291bmQuSU5URVJSVVBUX0xBVEUgJiYgdGFyZ2V0LmdldFBvc2l0aW9uKCkgPiByZXBsYWNlbWVudC5nZXRQb3NpdGlvbigpKSkge1xuXHRcdFx0XHRcdHJlcGxhY2VtZW50ID0gdGFyZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXBsYWNlbWVudCAhPSBudWxsKSB7XG5cdFx0XHRyZXBsYWNlbWVudC5faW50ZXJydXB0KCk7XG5cdFx0XHR0aGlzLl9yZW1vdmUocmVwbGFjZW1lbnQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltTb3VuZCBTb3VuZENoYW5uZWxdXCI7XG5cdH07XG5cdC8vIGRvIG5vdCBhZGQgU291bmRDaGFubmVsIHRvIG5hbWVzcGFjZVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RTb3VuZEluc3RhbmNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEEgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIGNyZWF0ZWQgd2hlbiBhbnkgY2FsbHMgdG8gdGhlIFNvdW5kIEFQSSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBvclxuICoge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gYXJlIG1hZGUuIFRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGl2ZSBwbHVnaW5cbiAqIGZvciBjb250cm9sIGJ5IHRoZSB1c2VyLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15QXNzZXRQYXRoL215U3JjRmlsZS5tcDNcIik7XG4gKlxuICogQSBudW1iZXIgb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHByb3ZpZGUgYSBxdWljayB3YXkgdG8gZGV0ZXJtaW5lIGhvdyBhIHNvdW5kIGlzIHBsYXllZC4gUGxlYXNlIHNlZSB0aGUgU291bmRcbiAqIEFQSSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBsaXN0IG9mIGFyZ3VtZW50cy5cbiAqXG4gKiBPbmNlIGEgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIGNyZWF0ZWQsIGEgcmVmZXJlbmNlIGNhbiBiZSBzdG9yZWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBhdWRpbyBkaXJlY3RseSB0aHJvdWdoXG4gKiB0aGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlLiBJZiB0aGUgcmVmZXJlbmNlIGlzIG5vdCBzdG9yZWQsIHRoZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBwbGF5IG91dCBpdHMgYXVkaW8gKGFuZCBhbnkgbG9vcHMpLCBhbmRcbiAqIGlzIHRoZW4gZGUtcmVmZXJlbmNlZCBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBzbyB0aGF0IGl0IGNhbiBiZSBjbGVhbmVkIHVwLiBJZiBhdWRpb1xuICogcGxheWJhY2sgaGFzIGNvbXBsZXRlZCwgYSBzaW1wbGUgY2FsbCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgbWV0aG9kXG4gKiB3aWxsIHJlYnVpbGQgdGhlIHJlZmVyZW5jZXMgdGhlIFNvdW5kIGNsYXNzIG5lZWQgdG8gY29udHJvbCBpdC5cbiAqXG4gKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQucGxheShcIm15QXNzZXRQYXRoL215U3JjRmlsZS5tcDNcIiwge2xvb3A6Mn0pO1xuICogICAgICBteUluc3RhbmNlLm9uKFwibG9vcFwiLCBoYW5kbGVMb29wKTtcbiAqICAgICAgZnVuY3Rpb24gaGFuZGxlTG9vcChldmVudCkge1xuICogICAgICAgICAgbXlJbnN0YW5jZS52b2x1bWUgPSBteUluc3RhbmNlLnZvbHVtZSAqIDAuNTtcbiAqICAgICAgfVxuICpcbiAqIEV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBmcm9tIHRoZSBpbnN0YW5jZSB0byBub3RpZnkgd2hlbiB0aGUgc291bmQgaGFzIGNvbXBsZXRlZCwgbG9vcGVkLCBvciB3aGVuIHBsYXliYWNrIGZhaWxzXG4gKlxuICogICAgICB2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUFzc2V0UGF0aC9teVNyY0ZpbGUubXAzXCIpO1xuICogICAgICBteUluc3RhbmNlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuICogICAgICBteUluc3RhbmNlLm9uKFwibG9vcFwiLCBoYW5kbGVMb29wKTtcbiAqICAgICAgbXlJbnN0YW5jZS5vbihcImZhaWxlZFwiLCBoYW5kbGVGYWlsZWQpO1xuICpcbiAqXG4gKiBAY2xhc3MgQWJzdHJhY3RTb3VuZEluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBwYXRoIHRvIGFuZCBmaWxlIG5hbWUgb2YgdGhlIHNvdW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWJhY2tSZXNvdXJjZSBBbnkgcmVzb3VyY2UgbmVlZGVkIGJ5IHBsdWdpbiB0byBzdXBwb3J0IGF1ZGlvIHBsYXliYWNrLlxuICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBDb25zdHJ1Y3Rvcjpcblx0dmFyIEFic3RyYWN0U291bmRJbnN0YW5jZSA9IGZ1bmN0aW9uIChzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBvZiB0aGUgc291bmQuXG5cdFx0ICogQHByb3BlcnR5IHNyY1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3JjID0gc3JjO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgaW5zdGFuY2UuIFRoaXMgaXMgc2V0IGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSB1bmlxdWVJZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9IHwgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHR0aGlzLnVuaXF1ZUlkID0gLTE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGxheSBzdGF0ZSBvZiB0aGUgc291bmQuIFBsYXkgc3RhdGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgcGxheVN0YXRlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBUaW1lb3V0IGNyZWF0ZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gd2hlbiB0aGlzIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBwbGF5ZWQgd2l0aCBhIGRlbGF5LlxuXHRcdCAqIFRoaXMgYWxsb3dzIEFic3RyYWN0U291bmRJbnN0YW5jZSB0byByZW1vdmUgdGhlIGRlbGF5IGlmIHN0b3AsIHBhdXNlLCBvciBjbGVhbnVwIGFyZSBjYWxsZWQgYmVmb3JlIHBsYXliYWNrIGJlZ2lucy5cblx0XHQgKiBAcHJvcGVydHkgZGVsYXlUaW1lb3V0SWRcblx0XHQgKiBAdHlwZSB7dGltZW91dFZhcmlhYmxlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cdFx0Ly8gVE9ETyBjb25zaWRlciBtb3ZpbmcgZGVsYXkgaW50byBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugc28gaXQgY2FuIGJlIGhhbmRsZWQgYnkgcGx1Z2luc1xuXG5cblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdC8vIEdldHRlciAvIFNldHRlciBQcm9wZXJ0aWVzXG5cdFx0Ly8gT0pSIFRPRE8gZmluZCBvcmlnaW5hbCByZWFzb24gdGhhdCB3ZSBkaWRuJ3QgdXNlIGRlZmluZWQgZnVuY3Rpb25zLiAgSSB0aGluayBpdCB3YXMgcGVyZm9ybWFuY2UgcmVsYXRlZFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiBUaGUgYWN0dWFsIG91dHB1dCB2b2x1bWUgb2YgYSBzb3VuZCBjYW4gYmUgY2FsY3VsYXRlZCB1c2luZzpcblx0XHQgKiA8Y29kZT5teUluc3RhbmNlLnZvbHVtZSAqIGNyZWF0ZWpzLlNvdW5kLmdldFZvbHVtZSgpOzwvY29kZT5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB2b2x1bWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLl92b2x1bWUgPSAgMTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2b2x1bWVcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFZvbHVtZSxcblx0XHRcdHNldDogdGhpcy5zZXRWb2x1bWVcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwYW4gb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLiBOb3RlIHRoYXQgcGFuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTCBBdWRpby5cblx0XHQgKlxuXHRcdCAqIDxiciAvPk5vdGUgaW4gV2ViQXVkaW9QbHVnaW4gdGhpcyBvbmx5IGdpdmVzIHVzIHRoZSBcInhcIiB2YWx1ZSBvZiB3aGF0IGlzIGFjdHVhbGx5IDNEIGF1ZGlvLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBhblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhbiA9ICAwO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhblwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UGFuLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBhblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzdGFydGluZyBvZmZzZXQuXG5cdFx0ICogQHByb3BlcnR5IHN0YXJ0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IE1hdGgubWF4KDAsIHN0YXJ0VGltZSB8fCAwKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydFRpbWVcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFN0YXJ0VGltZSxcblx0XHRcdHNldDogdGhpcy5zZXRTdGFydFRpbWVcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgb3IgZ2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBhdWRpbyBjbGlwLCB2YWx1ZSBpcyBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KDAsIGR1cmF0aW9uIHx8IDApO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImR1cmF0aW9uXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXREdXJhdGlvbixcblx0XHRcdHNldDogdGhpcy5zZXREdXJhdGlvblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IHRoYXQgaG9sZHMgcGx1Z2luIHNwZWNpZmljIHJlc291cmNlIG5lZWQgZm9yIGF1ZGlvIHBsYXliYWNrLlxuXHRcdCAqIFRoaXMgaXMgc2V0IGludGVybmFsbHkgYnkgdGhlIHBsdWdpbi4gIEZvciBleGFtcGxlLCBXZWJBdWRpb1BsdWdpbiB3aWxsIHNldCBhbiBhcnJheSBidWZmZXIsXG5cdFx0ICogSFRNTEF1ZGlvUGx1Z2luIHdpbGwgc2V0IGEgdGFnLCBGbGFzaEF1ZGlvUGx1Z2luIHdpbGwgc2V0IGEgZmxhc2ggcmVmZXJlbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBsYXliYWNrUmVzb3VyY2Vcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbGF5YmFja1Jlc291cmNlXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRQbGF5YmFja1Jlc291cmNlLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBsYXliYWNrUmVzb3VyY2Vcblx0XHR9KTtcblx0XHRpZihwbGF5YmFja1Jlc291cmNlICE9PSBmYWxzZSAmJiBwbGF5YmFja1Jlc291cmNlICE9PSB0cnVlKSB7IHRoaXMuc2V0UGxheWJhY2tSZXNvdXJjZShwbGF5YmFja1Jlc291cmNlKTsgfVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBpbiBtaWxsaXNlY29uZHMuIFRoaXMgY2FuIGJlIHNldCB3aGlsZSBhIHNvdW5kIGlzIHBsYXlpbmcsIHBhdXNlZCwgb3Igc3RvcHBlZC5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb3NpdGlvblwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UG9zaXRpb24sXG5cdFx0XHRzZXQ6IHRoaXMuc2V0UG9zaXRpb25cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgcGxheSBsb29wcyByZW1haW5pbmcuIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIGxvb3AgaW5maW5pdGVseS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvb3AgPSAwO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvb3BcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldExvb3AsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0TG9vcFxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogTXV0ZXMgb3IgdW5tdXRlcyB0aGUgY3VycmVudCBhdWRpbyBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBtdXRlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbXV0ZWQgPSBmYWxzZTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtdXRlZFwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0TXV0ZWQsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0TXV0ZWRcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFBhdXNlcyBvciByZXN1bWVzIHRoZSBjdXJyZW50IGF1ZGlvIGluc3RhbmNlLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdXNlZFwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UGF1c2VkLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBhdXNlZFxuXHRcdH0pO1xuXG5cblx0Ly8gRXZlbnRzXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBoYXMgc3RhcnRlZCBzdWNjZXNzZnVsbHkuXG5cdFx0ICogQGV2ZW50IHN1Y2NlZWRlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBpcyBpbnRlcnJ1cHRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gYW5vdGhlciBzb3VuZCB3aXRoIHRoZSBzYW1lXG5cdFx0ICogc3JjIHByb3BlcnR5IGlzIHBsYXllZCB1c2luZyBhbiBpbnRlcnJ1cHQgdmFsdWUgdGhhdCBjYXVzZXMgdGhpcyBpbnN0YW5jZSB0byBzdG9wIHBsYXlpbmcuXG5cdFx0ICogQGV2ZW50IGludGVycnVwdGVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHBsYXliYWNrIGhhcyBmYWlsZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSBjaGFubmVscyB3aXRoIHRoZSBzYW1lXG5cdFx0ICogc3JjIHByb3BlcnR5IGFscmVhZHkgcGxheWluZyAoYW5kIHRoZSBpbnRlcnJ1cHQgdmFsdWUgZG9lc24ndCBjYXVzZSBhbiBpbnRlcnJ1cHQgb2YgYW5vdGhlciBpbnN0YW5jZSksIG9yXG5cdFx0ICogdGhlIHNvdW5kIGNvdWxkIG5vdCBiZSBwbGF5ZWQsIHBlcmhhcHMgZHVlIHRvIGEgNDA0IGVycm9yLlxuXHRcdCAqIEBldmVudCBmYWlsZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gYSBzb3VuZCBoYXMgY29tcGxldGVkIHBsYXlpbmcgYnV0IGhhcyBsb29wcyByZW1haW5pbmcuXG5cdFx0ICogQGV2ZW50IGxvb3Bcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gcGxheWJhY2sgY29tcGxldGVzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNvdW5kIGhhcyBmaW5pc2hlZCBwbGF5aW5nIGluIGl0c1xuXHRcdCAqIGVudGlyZXR5LCBpbmNsdWRpbmcgaXRzIGxvb3AgaXRlcmF0aW9ucy5cblx0XHQgKiBAZXZlbnQgY29tcGxldGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdFNvdW5kSW5zdGFuY2UsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gUHVibGljIE1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQbGF5IGFuIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgb24gU291bmRJbnN0YW5jZXMgdGhhdCBhbHJlYWR5IGV4aXN0IChjcmVhdGVkXG5cdCAqIHdpdGggdGhlIFNvdW5kIEFQSSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9jcmVhdGVJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBteUluc3RhbmNlID0gY3JlYXRlanMuU291bmQuY3JlYXRlSW5zdGFuY2UobXlTcmMpO1xuXHQgKiAgICAgIG15SW5zdGFuY2UucGxheSh7aW50ZXJydXB0OmNyZWF0ZWpzLlNvdW5kLklOVEVSUlVQVF9BTlksIGxvb3A6MiwgcGFuOjAuNX0pO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgdGhpcyBzb3VuZCBpcyBhbHJlYWR5IHBsYXlpbmcsIHRoaXMgY2FsbCB3aWxsIHN0aWxsIHNldCB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG5cblx0ICogPGI+UGFyYW1ldGVycyBEZXByZWNhdGVkPC9iPjxiciAvPlxuXHQgKiBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBtZXRob2QgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYSBzaW5nbGUgcGFyYW1ldGVyIHRoYXQgaXMgYW4gT2JqZWN0IG9yIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBbaW50ZXJydXB0PVwibm9uZVwifG9wdGlvbnNdIDxiPlRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgcmVuYW1lZCBwbGF5UHJvcHMgaW4gdGhlIG5leHQgcmVsZWFzZS48L2I+PGJyIC8+XG5cdCAqIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBhbiBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gb3IgYW4gT2JqZWN0IHRoYXQgY29udGFpbnMgYW55IG9yIGFsbCBvcHRpb25hbCBwcm9wZXJ0aWVzIGJ5IG5hbWUsXG5cdCAqIGluY2x1ZGluZzogaW50ZXJydXB0LCBkZWxheSwgb2Zmc2V0LCBsb29wLCB2b2x1bWUsIHBhbiwgc3RhcnRUaW1lLCBhbmQgZHVyYXRpb24gKHNlZSB0aGUgYWJvdmUgY29kZSBzYW1wbGUpLlxuXHQgKiA8YnIgLz48c3Ryb25nPk9SPC9zdHJvbmc+PGJyIC8+XG5cdCAqIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyB0byBpbnRlcnJ1cHQgYW55IGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcyBvZiBhdWRpbyB3aXRoIHRoZSBzYW1lIHNvdXJjZSxcblx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzIDxjb2RlPklOVEVSUlVQVF9UWVBFPC9jb2RlPlxuXHQgKiBjb25zdGFudHMgb24gdGhlIFNvdW5kIGNsYXNzLCB3aXRoIHRoZSBkZWZhdWx0IGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmQvZGVmYXVsdEludGVycnVwdEJlaGF2aW9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgc3RhcnQgb2YgYXVkaW8gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtsb29wPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IEhvdyBtYW55IHRpbWVzIHRoZSBhdWRpbyBsb29wcyB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIGRlZmF1bHQgaXMgMCAobm9cblx0ICogbG9vcHMpLCBhbmQgLTEgY2FuIGJlIHVzZWQgZm9yIGluZmluaXRlIHBsYXliYWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3ZvbHVtZT0xXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHQgKiBhZ2FpbnN0IHRoZSBpbmRpdmlkdWFsIHZvbHVtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYW49MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIGxlZnQtcmlnaHQgcGFuIG9mIHRoZSBzb3VuZCAoaWYgc3VwcG9ydGVkKSwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICogTm90ZSB0aGF0IHBhbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBIVE1MIEF1ZGlvLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24gKGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4pIHtcblx0XHR2YXIgcGxheVByb3BzO1xuXHRcdGlmIChpbnRlcnJ1cHQgaW5zdGFuY2VvZiBPYmplY3QgfHwgaW50ZXJydXB0IGluc3RhbmNlb2YgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKGludGVycnVwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYXlQcm9wcyA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoe2ludGVycnVwdDppbnRlcnJ1cHQsIGRlbGF5OmRlbGF5LCBvZmZzZXQ6b2Zmc2V0LCBsb29wOmxvb3AsIHZvbHVtZTp2b2x1bWUsIHBhbjpwYW59KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuYXBwbHlQbGF5UHJvcHMocGxheVByb3BzKTtcblx0XHRcdGlmICh0aGlzLl9wYXVzZWQpIHtcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTsgfVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0Y3JlYXRlanMuU291bmQuX3BsYXlJbnN0YW5jZSh0aGlzLCBwbGF5UHJvcHMpO1x0Ly8gbWFrZSB0aGlzIGFuIGV2ZW50IGRpc3BhdGNoPz9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBwbGF5YmFjayBvZiB0aGUgaW5zdGFuY2UuIFN0b3BwZWQgc291bmRzIHdpbGwgcmVzZXQgdGhlaXIgcG9zaXRpb24gdG8gMCwgYW5kIGNhbGxzIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9yZXN1bWVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBmYWlsLiBUbyBzdGFydCBwbGF5YmFjayBhZ2FpbiwgY2FsbCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBkb24ndCB3YW50IHRvIGxvc2UgeW91ciBwb3NpdGlvbiB1c2UgeW91clNvdW5kSW5zdGFuY2UucGF1c2VkID0gdHJ1ZSBpbnN0ZWFkLiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBteUluc3RhbmNlLnN0b3AoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhbmRsZVN0b3AoKTtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0ZJTklTSEVEO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGV4dGVybmFsIHJlZmVyZW5jZXMgYW5kIHJlc291cmNlcyBmcm9tIEFic3RyYWN0U291bmRJbnN0YW5jZS4gIE5vdGUgdGhpcyBpcyBpcnJldmVyc2libGUgYW5kIEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIG5vIGxvbmdlciB3b3JrXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnNyYyA9IG51bGw7XG5cdFx0dGhpcy5wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblxuXHRcdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGFrZXMgYW4gUGxheVByb3BzQ29uZmlnIG9yIE9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYW5kIHNldHMgdGhlbSBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGFwcGx5UGxheVByb3BzXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnIHwgT2JqZWN0fSBwbGF5UHJvcHMgQSBQbGF5UHJvcHNDb25maWcgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgcHJvcGVydGllcy5cblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLmFwcGx5UGxheVByb3BzID0gZnVuY3Rpb24ocGxheVByb3BzKSB7XG5cdFx0aWYgKHBsYXlQcm9wcy5vZmZzZXQgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBsYXlQcm9wcy5vZmZzZXQpIH1cblx0XHRpZiAocGxheVByb3BzLmxvb3AgIT0gbnVsbCkgeyB0aGlzLnNldExvb3AocGxheVByb3BzLmxvb3ApOyB9XG5cdFx0aWYgKHBsYXlQcm9wcy52b2x1bWUgIT0gbnVsbCkgeyB0aGlzLnNldFZvbHVtZShwbGF5UHJvcHMudm9sdW1lKTsgfVxuXHRcdGlmIChwbGF5UHJvcHMucGFuICE9IG51bGwpIHsgdGhpcy5zZXRQYW4ocGxheVByb3BzLnBhbik7IH1cblx0XHRpZiAocGxheVByb3BzLnN0YXJ0VGltZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFN0YXJ0VGltZShwbGF5UHJvcHMuc3RhcnRUaW1lKTtcblx0XHRcdHRoaXMuc2V0RHVyYXRpb24ocGxheVByb3BzLmR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWJzdHJhY3RTb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG4vLyBnZXQvc2V0IG1ldGhvZHMgdGhhdCBhbGxvdyBzdXBwb3J0IGZvciBJRThcblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5LFxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGluc3RhbmNlIGlzIGN1cnJlbnRseSBwYXVzZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICgodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlKSB8fCB0aGlzLl9wYXVzZWQgPT0gdmFsdWUpIHtyZXR1cm47fVxuXHRcdGlmICh2YWx1ZSA9PSB0cnVlICYmIHRoaXMucGxheVN0YXRlICE9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fcGF1c2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzdW1lKCk7XG5cdFx0fVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRWb2x1bWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2b2x1bWUgdG8gc2V0LCBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqL1xuXHRwLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl92b2x1bWUpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl92b2x1bWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuXHRcdGlmICghdGhpcy5fbXV0ZWQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvdm9sdW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRWb2x1bWVcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHNvdW5kIGluc3RhbmNlLlxuXHQgKi9cblx0cC5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldE11dGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgdGhlIHNvdW5kIHNob3VsZCBiZSBtdXRlZC5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldE11dGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkge3JldHVybjt9XG5cdFx0dGhpcy5fbXV0ZWQgPSB2YWx1ZTtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldE11dGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzb3VuZCBpcyBtdXRlZC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldE11dGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tdXRlZDtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGFuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQYW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwYW4gdmFsdWUsIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKi9cblx0cC5zZXRQYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZih2YWx1ZSA9PSB0aGlzLl9wYW4pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9wYW4gPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHR0aGlzLl91cGRhdGVQYW4oKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGFuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRQYW5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIHBhbiwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS5cblx0ICovXG5cdHAuZ2V0UGFuID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYW47XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQgaW4gdGhlIHNvdW5kLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuXHRwLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbigpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bvc2l0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBvc2l0aW9uIHRvIHBsYWNlIHRoZSBwbGF5aGVhZCwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IE1hdGgubWF4KDAsIHZhbHVlKTtcblx0XHRpZiAodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9zdGFydFRpbWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIGdldFN0YXJ0VGltZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdGFydFRpbWUgb2YgdGhlIHNvdW5kIGluc3RhbmNlIGluIG1pbGxpc2Vjb25kcy5cblx0ICovXG5cdHAuZ2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3N0YXJ0VGltZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0U3RhcnRUaW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHN0YXJ0VGltZSB0aW1lIGluIG1pbGxpIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKi9cblx0cC5zZXRTdGFydFRpbWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fc3RhcnRUaW1lKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gTWF0aC5tYXgoMCwgdmFsdWUgfHwgMCk7XG5cdFx0dGhpcy5fdXBkYXRlU3RhcnRUaW1lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXREdXJhdGlvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiB0aGUgc291bmQgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0cC5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXREdXJhdGlvblxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG5ldyBkdXJhdGlvbiB0aW1lIGluIG1pbGxpIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gUmV0dXJucyByZWZlcmVuY2UgdG8gaXRzZWxmIGZvciBjaGFpbmluZyBjYWxsc1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0RHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fZHVyYXRpb24pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KDAsIHZhbHVlIHx8IDApO1xuXHRcdHRoaXMuX3VwZGF0ZUR1cmF0aW9uKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXliYWNrUmVzb3VyY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBsYXliYWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgbmV3IHBsYXliYWNrIHJlc291cmNlLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5zZXRQbGF5YmFja1Jlc291cmNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IHZhbHVlO1xuXHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PSAwKSB7IHRoaXMuX3NldER1cmF0aW9uRnJvbVNvdXJjZSgpOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXliYWNrUmVzb3VyY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBsYXliYWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgbmV3IHBsYXliYWNrIHJlc291cmNlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBsYXliYWNrIHJlc291cmNlIHVzZWQgZm9yIHBsYXlpbmcgYXVkaW9cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5nZXRQbGF5YmFja1Jlc291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbGF5YmFja1Jlc291cmNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRMb29wXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqKi9cblx0cC5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb29wO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHksXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0TG9vcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIGFmdGVyIHBsYXkuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRMb29wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZSAhPSBudWxsKSB7XG5cdFx0XHQvLyByZW1vdmUgbG9vcGluZ1xuXHRcdFx0aWYgKHRoaXMuX2xvb3AgIT0gMCAmJiB2YWx1ZSA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxvb3BpbmcodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGxvb3Bpbmdcblx0XHRcdGVsc2UgaWYgKHRoaXMuX2xvb3AgPT0gMCAmJiB2YWx1ZSAhPSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FkZExvb3BpbmcodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9sb29wID0gdmFsdWU7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBNZXRob2RzOlxuXHQvKipcblx0ICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgZGlzcGF0Y2hlcyBhbGwgZXZlbnRzIGZvciBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgX3NlbmRFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudCh0eXBlKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgaW5zdGFuY2UuIFJlbW92ZSByZWZlcmVuY2VzIGFuZCBjbGVhbiB1cCBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGltZXJzLlxuXHQgKiBAbWV0aG9kIF9jbGVhblVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpOyAvLyBjbGVhciB0aW1lb3V0IHRoYXQgcGxheXMgZGVsYXllZCBzb3VuZFxuXHRcdHRoaXMuX2hhbmRsZUNsZWFuVXAoKTtcblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdGNyZWF0ZWpzLlNvdW5kLl9wbGF5RmluaXNoZWQodGhpcyk7XHQvLyBUT0RPIGNoYW5nZSB0byBhbiBldmVudFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgc291bmQgaGFzIGJlZW4gaW50ZXJydXB0ZWQuXG5cdCAqIEBtZXRob2QgX2ludGVycnVwdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9JTlRFUlJVUFRFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJpbnRlcnJ1cHRlZFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHRoZSBTb3VuZCBjbGFzcyB3aGVuIHRoZSBhdWRpbyBpcyByZWFkeSB0byBwbGF5IChkZWxheSBoYXMgY29tcGxldGVkKS4gU3RhcnRzIHNvdW5kIHBsYXlpbmcgaWYgdGhlXG5cdCAqIHNyYyBpcyBsb2FkZWQsIG90aGVyd2lzZSBwbGF5YmFjayB3aWxsIGZhaWwuXG5cdCAqIEBtZXRob2QgX2JlZ2luUGxheWluZ1xuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9iamVjdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgcGxheWJhY2sgc3VjY2VlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHQvLyBPSlIgRmxhc2hBdWRpb1NvdW5kSW5zdGFuY2Ugb3ZlcndyaXRlc1xuXHRwLl9iZWdpblBsYXlpbmcgPSBmdW5jdGlvbiAocGxheVByb3BzKSB7XG5cdFx0dGhpcy5zZXRQb3NpdGlvbihwbGF5UHJvcHMub2Zmc2V0KTtcblx0XHR0aGlzLnNldExvb3AocGxheVByb3BzLmxvb3ApO1xuXHRcdHRoaXMuc2V0Vm9sdW1lKHBsYXlQcm9wcy52b2x1bWUpO1xuXHRcdHRoaXMuc2V0UGFuKHBsYXlQcm9wcy5wYW4pO1xuXHRcdGlmIChwbGF5UHJvcHMuc3RhcnRUaW1lICE9IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0U3RhcnRUaW1lKHBsYXlQcm9wcy5zdGFydFRpbWUpO1xuXHRcdFx0dGhpcy5zZXREdXJhdGlvbihwbGF5UHJvcHMuZHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlICE9IG51bGwgJiYgdGhpcy5fcG9zaXRpb24gPCB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9oYW5kbGVTb3VuZFJlYWR5KCk7XG5cdFx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEO1xuXHRcdFx0dGhpcy5fc2VuZEV2ZW50KFwic3VjY2VlZGVkXCIpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BsYXlGYWlsZWQoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBsYXkgaGFzIGZhaWxlZCwgd2hpY2ggY2FuIGhhcHBlbiBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMuXG5cdCAqIENsZWFucyB1cCBpbnN0YW5jZSBhbmQgZGlzcGF0Y2hlcyBmYWlsZWQgZXZlbnRcblx0ICogQG1ldGhvZCBfcGxheUZhaWxlZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcGxheUZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX0ZBSUxFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJmYWlsZWRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEF1ZGlvIGhhcyBmaW5pc2hlZCBwbGF5aW5nLiBNYW51YWxseSBsb29wIGl0IGlmIHJlcXVpcmVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTb3VuZENvbXBsZXRlXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVTb3VuZENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAwOyAgLy8gaGF2ZSB0byBzZXQgdGhpcyBhcyBpdCBjYW4gYmUgc2V0IGJ5IHBhdXNlIGR1cmluZyBwbGF5YmFja1xuXG5cdFx0aWYgKHRoaXMuX2xvb3AgIT0gMCkge1xuXHRcdFx0dGhpcy5fbG9vcC0tOyAgLy8gTk9URSB0aGlzIGludHJvZHVjZXMgYSB0aGVvcmV0aWNhbCBsaW1pdCBvbiBsb29wcyA9IGZsb2F0IG1heCBzaXplIHggMiAtIDFcblx0XHRcdHRoaXMuX2hhbmRsZUxvb3AoKTtcblx0XHRcdHRoaXMuX3NlbmRFdmVudChcImxvb3BcIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9GSU5JU0hFRDtcblx0XHR0aGlzLl9zZW5kRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuLy8gUGx1Z2luIHNwZWNpZmljIGNvZGVcblx0LyoqXG5cdCAqIEhhbmRsZXMgc3RhcnRpbmcgcGxheWJhY2sgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVNvdW5kUmVhZHlcblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHZvbHVtZSBiYXNlZCBvbiB0aGUgaW5zdGFuY2Ugdm9sdW1lLCBtYXN0ZXIgdm9sdW1lLCBpbnN0YW5jZSBtdXRlIHZhbHVlLFxuXHQgKiBhbmQgbWFzdGVyIG11dGUgdmFsdWUuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVZvbHVtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHBhblxuXHQgKiBAbWV0aG9kIF91cGRhdGVQYW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3VwZGF0ZVBhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBhdWRpby5cblx0ICogQG1ldGhvZCBfdXBkYXRlU3RhcnRUaW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRwLl91cGRhdGVTdGFydFRpbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpby5cblx0ICogQG1ldGhvZCBfdXBkYXRlRHVyYXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3VwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8gZnJvbSB0aGUgc291cmNlIHdlJ2xsIGJlIHBsYXlpbmcuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUR1cmF0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9zZXREdXJhdGlvbkZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZCBhbmQgc2V0cyB0aGlzLl9wb3NpdGlvbiB0byB0aGF0IHZhbHVlXG5cdCAqIEBtZXRob2QgX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlIHRoYXQgc2V0cyB0aGlzLnBvc2l0aW9uXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBsb29waW5nIGlzIHJlbW92ZWQgZHVyaW5nIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMb29waW5nXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGxvb3AgYWZ0ZXIgcGxheS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3JlbW92ZUxvb3BpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBsb29waW5nIGlzIGFkZGVkIGR1cmluZyBwbGF5YmFjay5cblx0ICogQG1ldGhvZCBfYWRkTG9vcGluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIGFmdGVyIHBsYXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9hZGRMb29waW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gcGF1c2luZyBwbGF5YmFja1xuXHQgKiBAbWV0aG9kIF9wYXVzZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gcmVzdW1pbmcgcGxheWJhY2tcblx0ICogQG1ldGhvZCBfcmVzdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gc3RvcHBpbmcgcGxheWJhY2tcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RvcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlU3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBiZWluZyBjbGVhbmVkIHVwXG5cdCAqIEBtZXRob2QgX2hhbmRsZUNsZWFuVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2hhbmRsZUNsZWFuVXAgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaGFzIHBsYXllZCB0byBlbmQgYW5kIGlzIGxvb3Bpbmdcblx0ICogQG1ldGhvZCBfaGFuZGxlTG9vcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlTG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RTb3VuZEluc3RhbmNlLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblx0Y3JlYXRlanMuRGVmYXVsdFNvdW5kSW5zdGFuY2UgPSBjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2U7XHQvLyB1c2VkIHdoZW4gbm8gcGx1Z2luIGlzIHN1cHBvcnRlZFxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0UGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3RvcjpcbiBcdC8qKlxuXHQgKiBBIGRlZmF1bHQgcGx1Z2luIGNsYXNzIHVzZWQgYXMgYSBiYXNlIGZvciBhbGwgb3RoZXIgcGx1Z2lucy5cblx0ICogQGNsYXNzIEFic3RyYWN0UGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0dmFyIEFic3RyYWN0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLlxuXHRcdCAqIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0XHR0aGlzLl9jYXBhYmlsaXRpZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IGhhc2ggaW5kZXhlZCBieSB0aGUgc291cmNlIFVSSSBvZiBhbGwgY3JlYXRlZCBsb2FkZXJzLCB1c2VkIHRvIHByb3Blcmx5IGRlc3Ryb3kgdGhlbSBpZiBzb3VyY2VzIGFyZSByZW1vdmVkLlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlcnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCBoYXNoIGluZGV4ZWQgYnkgdGhlIHNvdXJjZSBVUkkgb2YgZWFjaCBmaWxlIHRvIGluZGljYXRlIGlmIGFuIGF1ZGlvIHNvdXJjZSBoYXMgYmVndW4gbG9hZGluZyxcblx0XHQgKiBpcyBjdXJyZW50bHkgbG9hZGluZywgb3IgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiAgQ2FuIGJlIHVzZWQgdG8gc3RvcmUgbm9uIGJvb2xlYW4gZGF0YSBhZnRlciBsb2FkaW5nXG5cdFx0ICogaXMgY29tcGxldGUgKGZvciBleGFtcGxlIGFycmF5QnVmZmVycyBmb3Igd2ViIGF1ZGlvKS5cblx0XHQgKiBAcHJvcGVydHkgX2F1ZGlvU291cmNlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2F1ZGlvU291cmNlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IGhhc2ggaW5kZXhlZCBieSB0aGUgc291cmNlIFVSSSBvZiBhbGwgY3JlYXRlZCBTb3VuZEluc3RhbmNlcywgdXBkYXRlcyB0aGUgcGxheWJhY2tSZXNvdXJjZSBpZiBpdCBsb2FkcyBhZnRlciB0aGV5IGFyZSBjcmVhdGVkLFxuXHRcdCAqIGFuZCBwcm9wZXJseSBkZXN0cm95IHRoZW0gaWYgc291cmNlcyBhcmUgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgaW50ZXJuYWwgbWFzdGVyIHZvbHVtZSB2YWx1ZSBvZiB0aGUgcGx1Z2luLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdm9sdW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ZvbHVtZSA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byBhIGxvYWRlciBjbGFzcyB1c2VkIGJ5IGEgcGx1Z2luIHRoYXQgbXVzdCBiZSBzZXQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3M7XG5cblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byBhbiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgY2xhc3MgdXNlZCBieSBhIHBsdWdpbiB0aGF0IG11c3QgYmUgc2V0LlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZDtcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3M7XG5cdH07XG5cdHZhciBwID0gQWJzdHJhY3RQbHVnaW4ucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBTdGF0aWMgUHJvcGVydGllczpcbi8vIE5PVEUgVEhFU0UgUFJPUEVSVElFUyBORUVEIFRPIEJFIEFEREVEIFRPIEVBQ0ggUExVR0lOXG5cdC8qKlxuXHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFRoaXMgaXMgZ2VuZXJhdGVkIHZpYSB0aGUgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0QWJzdHJhY3RQbHVnaW4uX2NhcGFiaWxpdGllcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgcGx1Z2luIGNhbiBiZSB1c2VkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIvT1MuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHBsdWdpbiBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdEFic3RyYWN0UGx1Z2luLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUHJlLXJlZ2lzdGVyIGEgc291bmQgZm9yIHByZWxvYWRpbmcgYW5kIHNldHVwLiBUaGlzIGlzIGNhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm90ZSBhbGwgcGx1Z2lucyBwcm92aWRlIGEgPGNvZGU+TG9hZGVyPC9jb2RlPiBpbnN0YW5jZSwgd2hpY2ggPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPlxuXHQgKiBjYW4gdXNlIHRvIGFzc2lzdCB3aXRoIHByZWxvYWRpbmcuXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxvYWRJdGVtIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBzb3VyY2Ugb2YgdGhlIGF1ZGlvXG5cdCAqIE5vdGUgdGhhdCBub3QgZXZlcnkgcGx1Z2luIHdpbGwgbWFuYWdlIHRoaXMgdmFsdWUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0LCBjb250YWluaW5nIGEgXCJ0YWdcIiBmb3IgcHJlbG9hZGluZyBwdXJwb3Nlcy5cblx0ICovXG5cdHAucmVnaXN0ZXIgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHR2YXIgbG9hZGVyID0gdGhpcy5fbG9hZGVyc1tsb2FkSXRlbS5zcmNdO1xuXHRcdGlmKGxvYWRlciAmJiAhbG9hZGVyLmNhbmNlbGVkKSB7cmV0dXJuIHRoaXMuX2xvYWRlcnNbbG9hZEl0ZW0uc3JjXTt9XHQvLyBhbHJlYWR5IGxvYWRpbmcvbG9hZGVkIHRoaXMsIHNvIGRvbid0IGxvYWQgdHdpY2Vcblx0XHQvLyBPSlIgcG90ZW50aWFsIGlzc3VlIHRoYXQgd2Ugd29uJ3QgYmUgZmlyaW5nIGxvYWRlZCBldmVudCwgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIGlmIHRoaXMgaXMgYWxyZWFkeSBsb2FkZWQ/XG5cdFx0dGhpcy5fYXVkaW9Tb3VyY2VzW2xvYWRJdGVtLnNyY10gPSB0cnVlO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzW2xvYWRJdGVtLnNyY10gPSBbXTtcblx0XHRsb2FkZXIgPSBuZXcgdGhpcy5fbG9hZGVyQ2xhc3MobG9hZEl0ZW0pO1xuXHRcdGxvYWRlci5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZVByZWxvYWRDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fbG9hZGVyc1tsb2FkSXRlbS5zcmNdID0gbG9hZGVyO1xuXHRcdHJldHVybiBsb2FkZXI7XG5cdH07XG5cblx0Ly8gbm90ZSBzb3VuZCBjYWxscyByZWdpc3RlciBiZWZvcmUgY2FsbGluZyBwcmVsb2FkXG5cdC8qKlxuXHQgKiBJbnRlcm5hbGx5IHByZWxvYWQgYSBzb3VuZC5cblx0ICogQG1ldGhvZCBwcmVsb2FkXG5cdCAqIEBwYXJhbSB7TG9hZGVyfSBsb2FkZXIgVGhlIHNvdW5kIFVSSSB0byBsb2FkLlxuXHQgKi9cblx0cC5wcmVsb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZVByZWxvYWRFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHByZWxvYWRpbmcgaGFzIHN0YXJ0ZWQgZm9yIGEgc3BlY2lmaWMgc291cmNlLiBJZiB0aGUgc291cmNlIGlzIGZvdW5kLCB3ZSBjYW4gYXNzdW1lIGl0IGlzIGxvYWRpbmcsXG5cdCAqIG9yIGhhcyBhbHJlYWR5IGZpbmlzaGVkIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgaXNQcmVsb2FkU3RhcnRlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRwLmlzUHJlbG9hZFN0YXJ0ZWQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSAhPSBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHByZWxvYWRpbmcgaGFzIGZpbmlzaGVkIGZvciBhIHNwZWNpZmljIHNvdXJjZS5cblx0ICogQG1ldGhvZCBpc1ByZWxvYWRDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gbG9hZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHAuaXNQcmVsb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0cmV0dXJuICghKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdID09IG51bGwgfHwgdGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gPT0gdHJ1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzb3VuZCBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9yZWdpc3RlclwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGlzIGRvZXMgbm90IGNhbmNlbCBhIHByZWxvYWQuXG5cdCAqIEBtZXRob2QgcmVtb3ZlU291bmRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgVVJJIHRvIHVubG9hZC5cblx0ICovXG5cdHAucmVtb3ZlU291bmQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0aWYgKCF0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXVtpXTtcblx0XHRcdGl0ZW0uZGVzdHJveSgpO1xuXHRcdH1cblx0XHRkZWxldGUodGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXSk7XG5cdFx0ZGVsZXRlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0XHRpZih0aGlzLl9sb2FkZXJzW3NyY10pIHsgdGhpcy5fbG9hZGVyc1tzcmNdLmRlc3Ryb3koKTsgfVxuXHRcdGRlbGV0ZSh0aGlzLl9sb2FkZXJzW3NyY10pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHNvdW5kcyBhZGRlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9yZWdpc3RlclwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGlzIGRvZXMgbm90IGNhbmNlbCBhIHByZWxvYWQuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsU291bmRzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIFVSSSB0byB1bmxvYWQuXG5cdCAqL1xuXHRwLnJlbW92ZUFsbFNvdW5kcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IodmFyIGtleSBpbiB0aGlzLl9hdWRpb1NvdXJjZXMpIHtcblx0XHRcdHRoaXMucmVtb3ZlU291bmQoa2V5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHNvdW5kIGluc3RhbmNlLiBJZiB0aGUgc291bmQgaGFzIG5vdCBiZWVuIHByZWxvYWRlZCwgaXQgaXMgaW50ZXJuYWxseSBwcmVsb2FkZWQgaGVyZS5cblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgc291cmNlIHRvIHVzZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGltZSB0aGUgY2xpcCBwbGF5cyBmb3IsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHNvdW5kIGluc3RhbmNlIGZvciBwbGF5YmFjayBhbmQgY29udHJvbC5cblx0ICovXG5cdHAuY3JlYXRlID0gZnVuY3Rpb24gKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHRcdGlmICghdGhpcy5pc1ByZWxvYWRTdGFydGVkKHNyYykpIHtcblx0XHRcdHRoaXMucHJlbG9hZCh0aGlzLnJlZ2lzdGVyKHNyYykpO1xuXHRcdH1cblx0XHR2YXIgc2kgPSBuZXcgdGhpcy5fc291bmRJbnN0YW5jZUNsYXNzKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgdGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10pO1xuXHRcdHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10ucHVzaChzaSk7XG5cdFx0cmV0dXJuIHNpO1xuXHR9O1xuXG5cdC8vIGlmIGEgcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdm9sdW1lIGFuZCBtdXRlLCBpdCBzaG91bGQgc2V0IHRoZXNlIHRvIG51bGxcblx0LyoqXG5cdCAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZSBvZiB0aGUgcGx1Z2luLCB3aGljaCBhZmZlY3RzIGFsbCBTb3VuZEluc3RhbmNlcy5cblx0ICogQG1ldGhvZCBzZXRWb2x1bWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2b2x1bWUgdG8gc2V0LCBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gcHJvY2Vzc2VzIHRoZSBzZXRWb2x1bWUgY2FsbCAodHJ1ZSkuIFRoZSBTb3VuZCBjbGFzcyB3aWxsIGFmZmVjdCBhbGwgdGhlXG5cdCAqIGluc3RhbmNlcyBtYW51YWxseSBvdGhlcndpc2UuXG5cdCAqL1xuXHRwLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG1hc3RlciB2b2x1bWUgb2YgdGhlIHBsdWdpbiwgd2hpY2ggYWZmZWN0cyBhbGwgU291bmRJbnN0YW5jZXMuXG5cdCAqIEBtZXRob2QgZ2V0Vm9sdW1lXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHZvbHVtZSBsZXZlbCwgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKi9cblx0cC5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZTtcblx0fTtcblxuXHQvKipcblx0ICogTXV0ZSBhbGwgc291bmRzIHZpYSB0aGUgcGx1Z2luLlxuXHQgKiBAbWV0aG9kIHNldE11dGVcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiBhbGwgc291bmQgc2hvdWxkIGJlIG11dGVkIG9yIG5vdC4gTm90ZSB0aGF0IHBsdWdpbi1sZXZlbCBtdXRpbmcganVzdCBsb29rcyB1cFxuXHQgKiB0aGUgbXV0ZSB2YWx1ZSBvZiBTb3VuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9nZXRNdXRlXCJ9fXt7L2Nyb3NzTGlua319LCBzbyB0aGlzIHByb3BlcnR5IGlzIG5vdCB1c2VkIGhlcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBtdXRlIGNhbGwgc3VjY2VlZHMuXG5cdCAqL1xuXHRwLnNldE11dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvLyBwbHVnaW5zIHNob3VsZCBvdmVyd3JpdGUgdGhpcyBtZXRob2Rcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWJzdHJhY3RQbHVnaW5dXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogSGFuZGxlcyBpbnRlcm5hbCBwcmVsb2FkIGNvbXBsZXRpb24uXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByZWxvYWRDb21wbGV0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVQcmVsb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgc3JjID0gZXZlbnQudGFyZ2V0LmdldEl0ZW0oKS5zcmM7XG5cdFx0dGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gPSBldmVudC5yZXN1bHQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdW2ldO1xuXHRcdFx0aXRlbS5zZXRQbGF5YmFja1Jlc291cmNlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0XHRcdC8vIFRvRG8gY29uc2lkZXIgYWRkaW5nIHBsYXkgY2FsbCBoZXJlIGlmIHBsYXlzdGF0ZSA9PSBwbGF5ZmFpbGVkXG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGludGVybmFsIHByZWxvYWQgZXJyb3Ncblx0ICogQG1ldGhvZCBfaGFuZGxlUHJlbG9hZEVycm9yXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVQcmVsb2FkRXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vZGVsZXRlKHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBnYWluIHZhbHVlIGZvciBtYXN0ZXIgYXVkaW8uIFNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVZvbHVtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gUGx1Z2luIFNwZWNpZmljIGNvZGVcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbiA9IEFic3RyYWN0UGx1Z2luO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogTG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgV2ViIEF1ZGlvIGNvbnRlbnQgdmlhIFByZWxvYWRKUyBvciBpbnRlcm5hbGx5LiBJbnN0YW5jZXMgYXJlIHJldHVybmVkIHRvXG5cdCAqIHRoZSBwcmVsb2FkZXIsIGFuZCB0aGUgbG9hZCBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGFzc2V0IG5lZWRzIHRvIGJlIHJlcXVlc3RlZC5cblx0ICpcblx0ICogQGNsYXNzIFdlYkF1ZGlvTG9hZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWRcblx0ICogQGV4dGVuZHMgWEhSUmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRmdW5jdGlvbiBMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORCk7XG5cblx0fTtcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuXHQvKipcblx0ICogd2ViIGF1ZGlvIGNvbnRleHQgcmVxdWlyZWQgZm9yIGRlY29kaW5nIGF1ZGlvXG5cdCAqIEBwcm9wZXJ0eSBjb250ZXh0XG5cdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdExvYWRlci5jb250ZXh0ID0gbnVsbDtcblxuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltXZWJBdWRpb0xvYWRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtLCBmYWxzZSk7XG5cdFx0dGhpcy5fcmVxdWVzdC5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcblx0fTtcblxuXHRwLl9zZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBPSlIgd2UgbGVhdmUgdGhpcyB3cmFwcGVkIGluIExvYWRlciBiZWNhdXNlIHdlIG5lZWQgdG8gcmVmZXJlbmNlIHNyYyBhbmQgdGhlIGhhbmRsZXIgb25seSByZWNlaXZlcyBhIHNpbmdsZSBhcmd1bWVudCwgdGhlIGRlY29kZWRBdWRpb1xuXHRcdExvYWRlci5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSh0aGlzLl9yYXdSZXN1bHQsXG5cdCAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUF1ZGlvRGVjb2RlZCwgdGhpcyksXG5cdCAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX3NlbmRFcnJvciwgdGhpcykpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCogVGhlIGF1ZGlvIGhhcyBiZWVuIGRlY29kZWQuXG5cdCogQG1ldGhvZCBoYW5kbGVBdWRpb0RlY29kZWRcblx0KiBAcGFyYW0gZGVjb2RlZFxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0cC5faGFuZGxlQXVkaW9EZWNvZGVkID0gZnVuY3Rpb24gKGRlY29kZWRBdWRpbykge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IGRlY29kZWRBdWRpbztcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX19zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5XZWJBdWRpb0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvU291bmRJbnN0YW5jZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgZXh0ZW5kcyB0aGUgYmFzZSBhcGkgb2Yge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCBpcyB1c2VkIGJ5XG4gKiB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAqXG4gKiBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgZXhwb3NlcyBhdWRpb05vZGVzIGZvciBhZHZhbmNlZCB1c2Vycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBwYXRoIHRvIGFuZCBmaWxlIG5hbWUgb2YgdGhlIHNvdW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBhcHBseSBhbiBvZmZzZXQsIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWJhY2tSZXNvdXJjZSBBbnkgcmVzb3VyY2UgbmVlZGVkIGJ5IHBsdWdpbiB0byBzdXBwb3J0IGF1ZGlvIHBsYXliYWNrLlxuICogQGNsYXNzIFdlYkF1ZGlvU291bmRJbnN0YW5jZVxuICogQGV4dGVuZHMgQWJzdHJhY3RTb3VuZEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gV2ViQXVkaW9Tb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RTb3VuZEluc3RhbmNlX2NvbnN0cnVjdG9yKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSk7XG5cblxuLy8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIDxiciAvPkdhaW5Ob2RlIGZvciBjb250cm9sbGluZyA8Y29kZT5XZWJBdWRpb1NvdW5kSW5zdGFuY2U8L2NvZGU+IHZvbHVtZS4gQ29ubmVjdGVkIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvZGVzdGluYXRpb25Ob2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBnYWluTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb0dhaW5Ob2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5nYWluTm9kZSA9IHMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIDxiciAvPkEgcGFuTm9kZSBhbGxvd2luZyBsZWZ0IGFuZCByaWdodCBhdWRpbyBjaGFubmVsIHBhbm5pbmcgb25seS4gQ29ubmVjdGVkIHRvIFdlYkF1ZGlvU291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvZ2Fpbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHBhbk5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9QYW5uZXJOb2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHRcdHRoaXMucGFuTm9kZSA9IHMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0XHR0aGlzLnBhbk5vZGUucGFubmluZ01vZGVsID0gcy5fcGFubmluZ01vZGVsO1xuXHRcdHRoaXMucGFuTm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhbigpO1xuXG5cdFx0LyoqXG5cdFx0ICogTk9URSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0XHQgKiA8YnIgLz5zb3VyY2VOb2RlIGlzIHRoZSBhdWRpbyBzb3VyY2UuIENvbm5lY3RlZCB0byBXZWJBdWRpb1NvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9Tb3VuZEluc3RhbmNlL3Bhbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHNvdXJjZU5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gbnVsbDtcblxuXG4vLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaW1lb3V0IHRoYXQgaXMgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIGhhbmRsZSBzb3VuZCBwbGF5aW5nIHRvIGNvbXBsZXRpb24uXG5cdFx0ICogU3RvcmVkIHNvIHdlIGNhbiByZW1vdmUgaXQgd2hlbiBzdG9wLCBwYXVzZSwgb3IgY2xlYW51cCBhcmUgY2FsbGVkXG5cdFx0ICogQHByb3BlcnR5IF9zb3VuZENvbXBsZXRlVGltZW91dFxuXHRcdCAqIEB0eXBlIHt0aW1lb3V0VmFyaWFibGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBOT1RFIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHZlcnkgYWR2YW5jZWQgdXNlcnMuXG5cdFx0ICogX3NvdXJjZU5vZGVOZXh0IGlzIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoZSBuZXh0IGxvb3AsIGluc2VydGVkIGluIGEgbG9vayBhaGVhZCBhcHByb2FjaCB0byBhbGxvdyBmb3Igc21vb3RoXG5cdFx0ICogbG9vcGluZy4gQ29ubmVjdGVkIHRvIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvU291bmRJbnN0YW5jZS9nYWluTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX3NvdXJjZU5vZGVOZXh0XG5cdFx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzaW5jZSAwLjQuMVxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGltZSBhdWRpbyBzdGFydGVkIHBsYXliYWNrLCBpbiBzZWNvbmRzLiBVc2VkIHRvIGhhbmRsZSBzZXQgcG9zaXRpb24sIGdldCBwb3NpdGlvbiwgYW5kIHJlc3VtaW5nIGZyb20gcGF1c2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGxheWJhY2tTdGFydFRpbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSAwO1xuXG5cdFx0Ly8gUHJveGllcywgbWFrZSByZW1vdmluZyBsaXN0ZW5lcnMgZWFzaWVyLlxuXHRcdHRoaXMuX2VuZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUsIHRoaXMpO1xuXHR9O1xuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChXZWJBdWRpb1NvdW5kSW5zdGFuY2UsIGNyZWF0ZWpzLkFic3RyYWN0U291bmRJbnN0YW5jZSk7XG5cdHZhciBzID0gV2ViQXVkaW9Tb3VuZEluc3RhbmNlO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cblx0LyoqXG5cdCAqIE5vdGUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdCAqIDxiciAvPkF1ZGlvIGNvbnRleHQgdXNlZCB0byBjcmVhdGUgbm9kZXMuICBUaGlzIGlzIGFuZCBuZWVkcyB0byBiZSB0aGUgc2FtZSBjb250ZXh0IHVzZWQgYnkge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG4gIFx0ICogQHByb3BlcnR5IGNvbnRleHRcblx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuY29udGV4dCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIE5vdGUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdCAqIDxiciAvPlRoZSBzY3JhdGNoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGJ1ZmZlciBwcm9wZXJ0eSBvZiBhIHNvdXJjZSBub2RlIG9uIGNsb3NlLiAgXG5cdCAqIFRoaXMgaXMgYW5kIHNob3VsZCBiZSB0aGUgc2FtZSBzY3JhdGNoIGJ1ZmZlciByZWZlcmVuY2VkIGJ5IHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuICBcdCAqIEBwcm9wZXJ0eSBfc2NyYXRjaEJ1ZmZlclxuXHQgKiBAdHlwZSB7QXVkaW9CdWZmZXJTb3VyY2VOb2RlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9zY3JhdGNoQnVmZmVyID0gbnVsbDtcblxuXHQvKipcblx0ICogTm90ZSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0ICogPGJyIC8+IEF1ZGlvIG5vZGUgZnJvbSBXZWJBdWRpb1BsdWdpbiB0aGF0IHNlcXVlbmNlcyB0byA8Y29kZT5jb250ZXh0LmRlc3RpbmF0aW9uPC9jb2RlPlxuXHQgKiBAcHJvcGVydHkgZGVzdGluYXRpb25Ob2RlXG5cdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLmRlc3RpbmF0aW9uTm9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFZhbHVlIHRvIHNldCBwYW5uaW5nIG1vZGVsIHRvIGVxdWFsIHBvd2VyIGZvciBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuICBDYW4gYmUgXCJlcXVhbHBvd2VyXCIgb3IgMCBkZXBlbmRpbmcgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByb3BlcnR5IF9wYW5uaW5nTW9kZWxcblx0ICogQHR5cGUge051bWJlciAvIFN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5fcGFubmluZ01vZGVsID0gXCJlcXVhbHBvd2VyXCI7XG5cblxuLy8gUHVibGljIG1ldGhvZHNcblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfZGVzdHJveSgpO1xuXG5cdFx0dGhpcy5wYW5Ob2RlLmRpc2Nvbm5lY3QoMCk7XG5cdFx0dGhpcy5wYW5Ob2RlID0gbnVsbDtcblx0XHR0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoMCk7XG5cdFx0dGhpcy5nYWluTm9kZSA9IG51bGw7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbV2ViQXVkaW9Tb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXHRwLl91cGRhdGVQYW4gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhbk5vZGUuc2V0UG9zaXRpb24odGhpcy5fcGFuLCAwLCAtMC41KTtcblx0XHQvLyB6IG5lZWQgdG8gYmUgLTAuNSBvdGhlcndpc2UgdGhlIHNvdW5kIG9ubHkgcGxheXMgaW4gbGVmdCwgcmlnaHQsIG9yIGNlbnRlclxuXHR9O1xuXG5cdHAuX3JlbW92ZUxvb3BpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdH07XG5cblx0cC5fYWRkTG9vcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMucGxheVN0YXRlICE9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSh0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSwgMCk7XG5cdH07XG5cblx0cC5fc2V0RHVyYXRpb25Gcm9tU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5wbGF5YmFja1Jlc291cmNlLmR1cmF0aW9uICogMTAwMDtcblx0fTtcblxuXHRwLl9oYW5kbGVDbGVhblVwID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNvdXJjZU5vZGUgJiYgdGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZ2Fpbk5vZGUubnVtYmVyT2ZPdXRwdXRzICE9IDApIHt0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoMCk7fVxuXHRcdC8vIE9KUiB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIHRoYXQgdGhpcyBkb2Vzbid0IGFsd2F5cyB3b3JrIGluIHdlYmtpdCAoQ2hyb21lIGFuZCBTYWZhcmkpLiBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24sIHRoaXMgc2hvdWxkIHdvcmsuXG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQpO1xuXG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSAwO1x0Ly8gVGhpcyBpcyB1c2VkIGJ5IGdldFBvc2l0aW9uXG5cdH07XG5cblx0LyoqXG5cdCAqIFR1cm4gb2ZmIGFuZCBkaXNjb25uZWN0IGFuIGF1ZGlvTm9kZSwgdGhlbiBzZXQgcmVmZXJlbmNlIHRvIG51bGwgdG8gcmVsZWFzZSBpdCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdCAqIEBtZXRob2QgX2NsZWFuVXBBdWRpb05vZGVcblx0ICogQHBhcmFtIGF1ZGlvTm9kZVxuXHQgKiBAcmV0dXJuIHthdWRpb05vZGV9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLl9jbGVhblVwQXVkaW9Ob2RlID0gZnVuY3Rpb24oYXVkaW9Ob2RlKSB7XG5cdFx0aWYoYXVkaW9Ob2RlKSB7XG5cdFx0XHRhdWRpb05vZGUuc3RvcCgwKTtcblx0XHRcdGF1ZGlvTm9kZS5kaXNjb25uZWN0KDApO1xuXHRcdFx0Ly8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgbGVhayBvbiBpT1MgU2FmYXJpIDctOS4gd2lsbCB0aHJvdyBpbiBhbG1vc3QgYWxsIG90aGVyXG5cdFx0XHQvLyBicm93c2VyIGltcGxlbWVudGF0aW9ucy5cblx0XHRcdHRyeSB7IGF1ZGlvTm9kZS5idWZmZXIgPSBzLl9zY3JhdGNoQnVmZmVyOyB9IGNhdGNoKGUpIHt9XG5cdFx0XHRhdWRpb05vZGUgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gYXVkaW9Ob2RlO1xuXHR9O1xuXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLmdhaW5Ob2RlLmNvbm5lY3Qocy5kZXN0aW5hdGlvbk5vZGUpOyAgLy8gdGhpcyBsaW5lIGNhbiBjYXVzZSBhIG1lbW9yeSBsZWFrLiAgTm9kZXMgbmVlZCB0byBiZSBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgYXVkaW9EZXN0aW5hdGlvbiBvciBhbnkgc2VxdWVuY2UgdGhhdCBsZWFkcyB0byBpdC5cblxuXHRcdHZhciBkdXIgPSB0aGlzLl9kdXJhdGlvbiAqIDAuMDAxO1xuXHRcdHZhciBwb3MgPSB0aGlzLl9wb3NpdGlvbiAqIDAuMDAxO1xuXHRcdGlmIChwb3MgPiBkdXIpIHtwb3MgPSBkdXI7fVxuXHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUoKHMuY29udGV4dC5jdXJyZW50VGltZSAtIGR1ciksIHBvcyk7XG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSB0aGlzLnNvdXJjZU5vZGUuc3RhcnRUaW1lIC0gcG9zO1xuXG5cdFx0dGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2VuZGVkSGFuZGxlciwgKGR1ciAtIHBvcykgKiAxMDAwKTtcblxuXHRcdGlmKHRoaXMuX2xvb3AgIT0gMCkge1xuXHRcdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lLCAwKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXVkaW8gbm9kZSB1c2luZyB0aGUgY3VycmVudCBzcmMgYW5kIGNvbnRleHQsIGNvbm5lY3RzIGl0IHRvIHRoZSBnYWluIG5vZGUsIGFuZCBzdGFydHMgcGxheWJhY2suXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZSBUaGUgdGltZSB0byBhZGQgdGhpcyB0byB0aGUgd2ViIGF1ZGlvIGNvbnRleHQsIGluIHNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIGFtb3VudCBvZiB0aW1lIGludG8gdGhlIHNyYyBhdWRpbyB0byBzdGFydCBwbGF5YmFjaywgaW4gc2Vjb25kcy5cblx0ICogQHJldHVybiB7YXVkaW9Ob2RlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSA9IGZ1bmN0aW9uKHN0YXJ0VGltZSwgb2Zmc2V0KSB7XG5cdFx0dmFyIGF1ZGlvTm9kZSA9IHMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRhdWRpb05vZGUuYnVmZmVyID0gdGhpcy5wbGF5YmFja1Jlc291cmNlO1xuXHRcdGF1ZGlvTm9kZS5jb25uZWN0KHRoaXMucGFuTm9kZSk7XG5cdFx0dmFyIGR1ciA9IHRoaXMuX2R1cmF0aW9uICogMC4wMDE7XG5cdFx0YXVkaW9Ob2RlLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSArIGR1cjtcblx0XHRhdWRpb05vZGUuc3RhcnQoYXVkaW9Ob2RlLnN0YXJ0VGltZSwgb2Zmc2V0Kyh0aGlzLl9zdGFydFRpbWUqMC4wMDEpLCBkdXIgLSBvZmZzZXQpO1xuXHRcdHJldHVybiBhdWRpb05vZGU7XG5cdH07XG5cblx0cC5fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSAocy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5fcGxheWJhY2tTdGFydFRpbWUpICogMTAwMDsgIC8vICogMTAwMCB0byBnaXZlIG1pbGxpc2Vjb25kcywgbGV0cyB1cyByZXN0YXJ0IGF0IHNhbWUgcG9pbnRcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuc291cmNlTm9kZSk7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuX3NvdXJjZU5vZGVOZXh0KTtcblxuXHRcdGlmICh0aGlzLmdhaW5Ob2RlLm51bWJlck9mT3V0cHV0cyAhPSAwKSB7dGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KDApO31cblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCk7XG5cdH07XG5cblx0cC5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2hhbmRsZVNvdW5kUmVhZHkoKTtcblx0fTtcblxuXHQvKlxuXHRwLl9oYW5kbGVTdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHdlYiBhdWRpbyBkb2VzIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGV4dHJhXG5cdH07XG5cdCovXG5cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuZXdWb2x1bWUgPSB0aGlzLl9tdXRlZCA/IDAgOiB0aGlzLl92b2x1bWU7XG5cdCAgXHRpZiAobmV3Vm9sdW1lICE9IHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSkge1xuXHRcdCAgdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlID0gbmV3Vm9sdW1lO1xuICBcdFx0fVxuXHR9O1xuXG5cdHAuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKChzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSkgKiAxMDAwKTsgLy8gcG9zIGluIHNlY29uZHMgKiAxMDAwIHRvIGdpdmUgbWlsbGlzZWNvbmRzXG5cdH07XG5cblx0cC5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLnNvdXJjZU5vZGUpO1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0KTtcblxuXHRcdGlmICghdGhpcy5fcGF1c2VkKSB7dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO31cblx0fTtcblxuXHQvLyBPSlIgd2UgYXJlIHVzaW5nIGEgbG9vayBhaGVhZCBhcHByb2FjaCB0byBlbnN1cmUgc21vb3RoIGxvb3BpbmcuXG5cdC8vIFdlIGFkZCBfc291cmNlTm9kZU5leHQgdG8gdGhlIGF1ZGlvIGNvbnRleHQgc28gdGhhdCBpdCBzdGFydHMgcGxheWluZyBldmVuIGlmIHRoaXMgY2FsbGJhY2sgaXMgZGVsYXllZC5cblx0Ly8gVGhpcyB0ZWNobmlxdWUgaXMgZGVzY3JpYmVkIGhlcmU6ICBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9hdWRpby9zY2hlZHVsaW5nL1xuXHQvLyBOT1RFIHRoZSBjb3N0IG9mIHRoaXMgaXMgdGhhdCBvdXIgYXVkaW8gbG9vcCBtYXkgbm90IGFsd2F5cyBtYXRjaCB0aGUgbG9vcCBldmVudCB0aW1pbmcgcHJlY2lzZWx5LlxuXHRwLl9oYW5kbGVMb29wID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9zb3VyY2VOb2RlTmV4dDtcblx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSA9IHRoaXMuc291cmNlTm9kZS5zdGFydFRpbWU7XG5cdFx0dGhpcy5fc291cmNlTm9kZU5leHQgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lLCAwKTtcblx0XHR0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fZW5kZWRIYW5kbGVyLCB0aGlzLl9kdXJhdGlvbik7XG5cdH07XG5cblx0cC5fdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3BhdXNlKCk7XG5cdFx0XHR0aGlzLl9yZXN1bWUoKTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuV2ViQXVkaW9Tb3VuZEluc3RhbmNlID0gY3JlYXRlanMucHJvbW90ZShXZWJBdWRpb1NvdW5kSW5zdGFuY2UsIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFdlYkF1ZGlvUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBQbGF5IHNvdW5kcyB1c2luZyBXZWIgQXVkaW8gaW4gdGhlIGJyb3dzZXIuIFRoZSBXZWJBdWRpb1BsdWdpbiBpcyBjdXJyZW50bHkgdGhlIGRlZmF1bHQgcGx1Z2luLCBhbmQgd2lsbCBiZSB1c2VkXG5cdCAqIGFueXdoZXJlIHRoYXQgaXQgaXMgc3VwcG9ydGVkLiBUbyBjaGFuZ2UgcGx1Z2luIHByaW9yaXR5LCBjaGVjayBvdXQgdGhlIFNvdW5kIEFQSVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXG5cdCAqIDxoND5Lbm93biBCcm93c2VyIGFuZCBPUyBpc3N1ZXMgZm9yIFdlYiBBdWRpbzwvaDQ+XG5cdCAqIDxiPkZpcmVmb3ggMjU8L2I+XG5cdCAqIDxsaT5cblx0ICogICAgIG1wMyBhdWRpbyBmaWxlcyBkbyBub3QgbG9hZCBwcm9wZXJseSBvbiBhbGwgd2luZG93cyBtYWNoaW5lcywgcmVwb3J0ZWQgPGEgaHJlZj1cImh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyOTk2OVwiIHRhcmdldD1cIl9ibGFua1wiPmhlcmU8L2E+LlxuXHQgKiAgICAgPGJyIC8+Rm9yIHRoaXMgcmVhc29uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHBhc3MgYW5vdGhlciBGaXJlRm94LXN1cHBvcnRlZCB0eXBlIChpLmUuIG9nZykgYXMgdGhlIGRlZmF1bHRcblx0ICogICAgIGV4dGVuc2lvbiwgdW50aWwgdGhpcyBidWcgaXMgcmVzb2x2ZWRcblx0ICogPC9saT5cblx0ICpcblx0ICogPGI+V2Via2l0IChDaHJvbWUgYW5kIFNhZmFyaSk8L2I+XG5cdCAqIDxsaT5cblx0ICogICAgIEF1ZGlvTm9kZS5kaXNjb25uZWN0IGRvZXMgbm90IGFsd2F5cyBzZWVtIHRvIHdvcmsuICBUaGlzIGNhbiBjYXVzZSB0aGUgZmlsZSBzaXplIHRvIGdyb3cgb3ZlciB0aW1lIGlmIHlvdVxuXHQgKiBcdCAgIGFyZSBwbGF5aW5nIGEgbG90IG9mIGF1ZGlvIGZpbGVzLlxuXHQgKiA8L2xpPlxuXHQgKlxuXHQgKiA8Yj5pT1MgNiBsaW1pdGF0aW9uczwvYj5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIFNvdW5kIGlzIGluaXRpYWxseSBtdXRlZCBhbmQgd2lsbCBvbmx5IHVubXV0ZSB0aHJvdWdoIHBsYXkgYmVpbmcgY2FsbGVkIGluc2lkZSBhIHVzZXIgaW5pdGlhdGVkIGV2ZW50XG5cdCAqICAgICAgICAgKHRvdWNoL2NsaWNrKS4gUGxlYXNlIHJlYWQgdGhlIG1vYmlsZSBwbGF5YmFjayBub3RlcyBpbiB0aGUgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICAgICAgY2xhc3MgZm9yIGEgZnVsbCBvdmVydmlldyBvZiB0aGUgbGltaXRhdGlvbnMsIGFuZCBob3cgdG8gZ2V0IGFyb3VuZCB0aGVtLlxuXHQgKiAgICAgPC9saT5cblx0ICpcdCAgIDxsaT5cblx0ICpcdCAgICAgICBBIGJ1ZyBleGlzdHMgdGhhdCB3aWxsIGRpc3RvcnQgdW4tY2FjaGVkIGF1ZGlvIHdoZW4gYSB2aWRlbyBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIERPTS4gWW91IGNhbiBhdm9pZFxuXHQgKlx0ICAgICAgIHRoaXMgYnVnIGJ5IGVuc3VyaW5nIHRoZSBhdWRpbyBhbmQgdmlkZW8gYXVkaW8gc2hhcmUgdGhlIHNhbWUgc2FtcGxlIHJhdGUuXG5cdCAqXHQgICA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAY2xhc3MgV2ViQXVkaW9QbHVnaW5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0ZnVuY3Rpb24gV2ViQXVkaW9QbHVnaW4oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9jb25zdHJ1Y3RvcigpO1xuXG5cbi8vIFByaXZhdGUgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFZhbHVlIHRvIHNldCBwYW5uaW5nIG1vZGVsIHRvIGVxdWFsIHBvd2VyIGZvciBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuICBDYW4gYmUgXCJlcXVhbHBvd2VyXCIgb3IgMCBkZXBlbmRpbmcgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3Bhbm5pbmdNb2RlbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXIgLyBTdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3Bhbm5pbmdNb2RlbCA9IHMuX3Bhbm5pbmdNb2RlbDs7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgd2ViIGF1ZGlvIGNvbnRleHQsIHdoaWNoIFdlYkF1ZGlvIHVzZXMgdG8gcGxheSBhdWRpby4gQWxsIG5vZGVzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViQXVkaW9QbHVnaW5cblx0XHQgKiBuZWVkIHRvIGJlIGNyZWF0ZWQgd2l0aGluIHRoaXMgY29udGV4dC5cblx0XHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHRcdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZXh0ID0gcy5jb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogQSBEeW5hbWljc0NvbXByZXNzb3JOb2RlLCB3aGljaCBpcyB1c2VkIHRvIGltcHJvdmUgc291bmQgcXVhbGl0eSBhbmQgcHJldmVudCBhdWRpbyBkaXN0b3J0aW9uLlxuXHRcdCAqIEl0IGlzIGNvbm5lY3RlZCB0byA8Y29kZT5jb250ZXh0LmRlc3RpbmF0aW9uPC9jb2RlPi5cblx0XHQgKlxuXHRcdCAqIENhbiBiZSBhY2Nlc3NlZCBieSBhZHZhbmNlZCB1c2VycyB0aHJvdWdoIGNyZWF0ZWpzLlNvdW5kLmFjdGl2ZVBsdWdpbi5keW5hbWljc0NvbXByZXNzb3JOb2RlLlxuXHRcdCAqIEBwcm9wZXJ0eSBkeW5hbWljc0NvbXByZXNzb3JOb2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0XHQgKi9cblx0XHR0aGlzLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG5cdFx0dGhpcy5keW5hbWljc0NvbXByZXNzb3JOb2RlLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgR2Fpbk5vZGUgZm9yIGNvbnRyb2xsaW5nIG1hc3RlciB2b2x1bWUuIEl0IGlzIGNvbm5lY3RlZCB0byB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9keW5hbWljc0NvbXByZXNzb3JOb2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqXG5cdFx0ICogQ2FuIGJlIGFjY2Vzc2VkIGJ5IGFkdmFuY2VkIHVzZXJzIHRocm91Z2ggY3JlYXRlanMuU291bmQuYWN0aXZlUGx1Z2luLmdhaW5Ob2RlLlxuXHRcdCAqIEBwcm9wZXJ0eSBnYWluTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb0dhaW5Ob2RlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmR5bmFtaWNzQ29tcHJlc3Nvck5vZGUpO1xuXHRcdGNyZWF0ZWpzLldlYkF1ZGlvU291bmRJbnN0YW5jZS5kZXN0aW5hdGlvbk5vZGUgPSB0aGlzLmdhaW5Ob2RlO1xuXG5cdFx0dGhpcy5fY2FwYWJpbGl0aWVzID0gcy5fY2FwYWJpbGl0aWVzO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MgPSBjcmVhdGVqcy5XZWJBdWRpb0xvYWRlcjtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3MgPSBjcmVhdGVqcy5XZWJBdWRpb1NvdW5kSW5zdGFuY2U7XG5cblx0XHR0aGlzLl9hZGRQcm9wc1RvQ2xhc3NlcygpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFdlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gU3RhdGljIFByb3BlcnRpZXNcblx0dmFyIHMgPSBXZWJBdWRpb1BsdWdpbjtcblx0LyoqXG5cdCAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi4gVGhpcyBpcyBnZW5lcmF0ZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpbi9fZ2VuZXJhdGVDYXBhYmlsaXRpZXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuXHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogVmFsdWUgdG8gc2V0IHBhbm5pbmcgbW9kZWwgdG8gZXF1YWwgcG93ZXIgZm9yIFdlYkF1ZGlvU291bmRJbnN0YW5jZS4gIENhbiBiZSBcImVxdWFscG93ZXJcIiBvciAwIGRlcGVuZGluZyBvbiBicm93c2VyIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcHJvcGVydHkgX3Bhbm5pbmdNb2RlbFxuXHQgKiBAdHlwZSB7TnVtYmVyIC8gU3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3Bhbm5pbmdNb2RlbCA9IFwiZXF1YWxwb3dlclwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgd2ViIGF1ZGlvIGNvbnRleHQsIHdoaWNoIFdlYkF1ZGlvIHVzZXMgdG8gcGxheSBhdWRpby4gQWxsIG5vZGVzIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViQXVkaW9QbHVnaW5cblx0ICogbmVlZCB0byBiZSBjcmVhdGVkIHdpdGhpbiB0aGlzIGNvbnRleHQuXG5cdCAqXG5cdCAqIEFkdmFuY2VkIHVzZXJzIGNhbiBzZXQgdGhpcyB0byBhbiBleGlzdGluZyBjb250ZXh0LCBidXQgPGI+bXVzdDwvYj4gZG8gc28gYmVmb3JlIHRoZXkgY2FsbFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU291bmQvaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2NyYXRjaCBidWZmZXIgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBidWZmZXIgcHJvcGVydHkgb2YgYSBzb3VyY2Ugbm9kZSBvbiBjbG9zZS5cblx0ICogV29ya3MgYXJvdW5kIGFuIGlPUyBTYWZhcmkgYnVnOiBodHRwczovL2dpdGh1Yi5jb20vQ3JlYXRlSlMvU291bmRKUy9pc3N1ZXMvMTAyXG5cdCAqXG5cdCAqIEFkdmFuY2VkIHVzZXJzIGNhbiBzZXQgdGhpcyB0byBhbiBleGlzdGluZyBzb3VyY2Ugbm9kZSwgYnV0IDxiPm11c3Q8L2I+IGRvIHNvIGJlZm9yZSB0aGV5IGNhbGxcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luaXRpYWxpemVEZWZhdWx0UGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQHByb3BlcnR5IF9zY3JhdGNoQnVmZmVyXG5cdCAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHQgcy5fc2NyYXRjaEJ1ZmZlciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEluZGljYXRlZCB3aGV0aGVyIGF1ZGlvIG9uIGlPUyBoYXMgYmVlbiB1bmxvY2tlZCwgd2hpY2ggcmVxdWlyZXMgYSB0b3VjaGVuZC9tb3VzZWRvd24gZXZlbnQgdGhhdCBwbGF5cyBhblxuXHQgKiBlbXB0eSBzb3VuZC5cblx0ICogQHByb3BlcnR5IF91bmxvY2tlZFxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDAuNi4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzLl91bmxvY2tlZCA9IGZhbHNlO1xuXG5cbi8vIFN0YXRpYyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci9PUy5cblx0ICogQG1ldGhvZCBpc1N1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgcGx1Z2luIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjaGVjayBpZiB0aGlzIGlzIHNvbWUga2luZCBvZiBtb2JpbGUgZGV2aWNlLCBXZWIgQXVkaW8gd29ya3Mgd2l0aCBsb2NhbCBwcm90b2NvbCB1bmRlciBQaG9uZUdhcCBhbmQgaXQgaXMgdW5saWtlbHkgc29tZW9uZSBpcyB0cnlpbmcgdG8gcnVuIGEgbG9jYWwgZmlsZVxuXHRcdHZhciBpc01vYmlsZVBob25lR2FwID0gY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0lPUyB8fCBjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzQW5kcm9pZCB8fCBjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzQmxhY2tiZXJyeTtcblx0XHQvLyBPSlIgaXNNb2JpbGUgbWF5IGJlIHJlZHVuZGFudCB3aXRoIF9pc0ZpbGVYSFJTdXBwb3J0ZWQgYXZhaWxhYmxlLiAgQ29uc2lkZXIgcmVtb3ZpbmcuXG5cdFx0aWYgKGxvY2F0aW9uLnByb3RvY29sID09IFwiZmlsZTpcIiAmJiAhaXNNb2JpbGVQaG9uZUdhcCAmJiAhdGhpcy5faXNGaWxlWEhSU3VwcG9ydGVkKCkpIHsgcmV0dXJuIGZhbHNlOyB9ICAvLyBXZWIgQXVkaW8gcmVxdWlyZXMgWEhSLCB3aGljaCBpcyBub3QgdXN1YWxseSBhdmFpbGFibGUgbG9jYWxseVxuXHRcdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzKCk7XG5cdFx0aWYgKHMuY29udGV4dCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUGxheXMgYW4gZW1wdHkgc291bmQgaW4gdGhlIHdlYiBhdWRpbyBjb250ZXh0LiAgVGhpcyBpcyB1c2VkIHRvIGVuYWJsZSB3ZWIgYXVkaW8gb24gaU9TIGRldmljZXMsIGFzIHRoZXlcblx0ICogcmVxdWlyZSB0aGUgZmlyc3Qgc291bmQgdG8gYmUgcGxheWVkIGluc2lkZSBvZiBhIHVzZXIgaW5pdGlhdGVkIGV2ZW50ICh0b3VjaC9jbGljaykuICBUaGlzIGlzIGNhbGxlZCB3aGVuXG5cdCAqIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGlzIGluaXRpYWxpemVkIChieSBTb3VuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9pbml0aWFsaXplRGVmYXVsdFBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGV4YW1wbGUpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCkge1xuXHQgKiAgICAgICAgIGNyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLnBsYXlFbXB0eVNvdW5kKCk7XG5cdCAqICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheUVtcHR5U291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucGxheUVtcHR5U291bmQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocy5jb250ZXh0ID09IG51bGwpIHtyZXR1cm47fVxuXHRcdHZhciBzb3VyY2UgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0c291cmNlLmJ1ZmZlciA9IHMuX3NjcmF0Y2hCdWZmZXI7XG5cdFx0c291cmNlLmNvbm5lY3Qocy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRzb3VyY2Uuc3RhcnQoMCwgMCwgMCk7XG5cdH07XG5cblxuLy8gU3RhdGljIFByaXZhdGUgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIFhIUiBpcyBzdXBwb3J0ZWQsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3Igd2ViIGF1ZGlvLlxuXHQgKiBAbWV0aG9kIF9pc0ZpbGVYSFJTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgWEhSIGlzIHN1cHBvcnRlZC5cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faXNGaWxlWEhSU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaXQncyBtdWNoIGVhc2llciB0byBkZXRlY3Qgd2hlbiBzb21ldGhpbmcgZ29lcyB3cm9uZywgc28gbGV0J3Mgc3RhcnQgb3B0aW1pc3RpY2FsbHlcblx0XHR2YXIgc3VwcG9ydGVkID0gdHJ1ZTtcblxuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oXCJHRVRcIiwgXCJXZWJBdWRpb1BsdWdpblRlc3QuZmFpbFwiLCBmYWxzZSk7IC8vIGxvYWRpbmcgbm9uLWV4aXN0YW50IGZpbGUgdHJpZ2dlcnMgNDA0IG9ubHkgaWYgaXQgY291bGQgbG9hZCAoc3luY2hyb25vdXMgY2FsbClcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Ly8gY2F0Y2ggZXJyb3JzIGluIGNhc2VzIHdoZXJlIHRoZSBvbmVycm9yIGlzIHBhc3NlZCBieVxuXHRcdFx0c3VwcG9ydGVkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gc3VwcG9ydGVkO1xuXHRcdH1cblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkgeyBzdXBwb3J0ZWQgPSBmYWxzZTsgfTsgLy8gY2F1c2UgaXJyZWxldmFudFxuXHRcdC8vIHdpdGggc2VjdXJpdHkgdHVybmVkIG9mZiwgd2UgY2FuIGdldCBlbXB0eSBzdWNjZXNzIHJlc3VsdHMsIHdoaWNoIGlzIGFjdHVhbGx5IGEgZmFpbGVkIHJlYWQgKHN0YXR1cyBjb2RlIDA/KVxuXHRcdHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgc3VwcG9ydGVkID0gdGhpcy5zdGF0dXMgPT0gNDA0IHx8ICh0aGlzLnN0YXR1cyA9PSAyMDAgfHwgKHRoaXMuc3RhdHVzID09IDAgJiYgdGhpcy5yZXNwb25zZSAhPSBcIlwiKSk7IH07XG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdC8vIGNhdGNoIGVycm9ycyBpbiBjYXNlcyB3aGVyZSB0aGUgb25lcnJvciBpcyBwYXNzZWQgYnlcblx0XHRcdHN1cHBvcnRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdXBwb3J0ZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS4gUGxlYXNlIHNlZSB0aGUgU291bmQgQVBJIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIHBsdWdpbiBjYXBhYmlsaXRpZXMuXG5cdCAqIEBtZXRob2QgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuX2NhcGFiaWxpdGllcyAhPSBudWxsKSB7cmV0dXJuO31cblx0XHQvLyBXZWIgQXVkaW8gY2FuIGJlIGluIGFueSBmb3JtYXRzIHN1cHBvcnRlZCBieSB0aGUgYXVkaW8gZWxlbWVudCwgZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jQXVkaW9Db250ZXh0LXNlY3Rpb25cblx0XHR2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHRpZiAodC5jYW5QbGF5VHlwZSA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXG5cdFx0aWYgKHMuY29udGV4dCA9PSBudWxsKSB7XG5cdFx0XHRpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuXHRcdFx0XHRzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpIHtcblx0XHRcdFx0cy5jb250ZXh0ID0gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzLl9zY3JhdGNoQnVmZmVyID09IG51bGwpIHtcblx0XHRcdHMuX3NjcmF0Y2hCdWZmZXIgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcblx0XHR9XG5cblx0XHRzLl9jb21wYXRpYmlsaXR5U2V0VXAoKTtcblxuXHRcdC8vIExpc3RlbiBmb3IgZG9jdW1lbnQgbGV2ZWwgY2xpY2tzIHRvIHVubG9jayBXZWJBdWRpbyBvbiBpT1MuIFNlZSB0aGUgX3VubG9jayBtZXRob2QuXG5cdFx0aWYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93ICYmIHMuY29udGV4dC5zdGF0ZSAhPSBcInJ1bm5pbmdcIikge1xuXHRcdFx0cy5fdW5sb2NrKCk7IC8vIFdoZW4gcGxheWVkIGluc2lkZSBvZiBhIHRvdWNoIGV2ZW50LCB0aGlzIHdpbGwgZW5hYmxlIGF1ZGlvIG9uIGlPUyBpbW1lZGlhdGVseS5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdH1cblxuXG5cdFx0cy5fY2FwYWJpbGl0aWVzID0ge1xuXHRcdFx0cGFubmluZzp0cnVlLFxuXHRcdFx0dm9sdW1lOnRydWUsXG5cdFx0XHR0cmFja3M6LTFcblx0XHR9O1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgb3VyIGJyb3dzZXIgc3VwcG9ydHMgZm9yIHRoaXMgcGx1Z2luIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIFNvdW5kLlNVUFBPUlRFRF9FWFRFTlNJT05TXG5cdFx0dmFyIHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBjcmVhdGVqcy5Tb3VuZC5TVVBQT1JURURfRVhURU5TSU9OUztcblx0XHR2YXIgZXh0ZW5zaW9uTWFwID0gY3JlYXRlanMuU291bmQuRVhURU5TSU9OX01BUDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgZXh0ID0gc3VwcG9ydGVkRXh0ZW5zaW9uc1tpXTtcblx0XHRcdHZhciBwbGF5VHlwZSA9IGV4dGVuc2lvbk1hcFtleHRdIHx8IGV4dDtcblx0XHRcdHMuX2NhcGFiaWxpdGllc1tleHRdID0gKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIGV4dCkgIT0gXCJcIikgfHwgKHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIm5vXCIgJiYgdC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgcGxheVR5cGUpICE9IFwiXCIpO1xuXHRcdH0gIC8vIE9KUiBhbm90aGVyIHdheSB0byBkbyB0aGlzIG1pZ2h0IGJlIGNhblBsYXlUeXBlOlwibTRhXCIsIGNvZGV4OiBtcDRcblxuXHRcdC8vIDA9bm8gb3V0cHV0LCAxPW1vbm8sIDI9c3RlcmVvLCA0PXN1cnJvdW5kLCA2PTUuMSBzdXJyb3VuZC5cblx0XHQvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0F1ZGlvQ2hhbm5lbFNwbGl0dGVyIGZvciBtb3JlIGRldGFpbHMgb24gY2hhbm5lbHMuXG5cdFx0aWYgKHMuY29udGV4dC5kZXN0aW5hdGlvbi5udW1iZXJPZkNoYW5uZWxzIDwgMikge1xuXHRcdFx0cy5fY2FwYWJpbGl0aWVzLnBhbm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB1cCBjb21wYXRpYmlsaXR5IGlmIG9ubHkgZGVwcmVjYXRlZCB3ZWIgYXVkaW8gY2FsbHMgYXJlIHN1cHBvcnRlZC5cblx0ICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNEZXByZWNhdGlvbk5vdGVzXG5cdCAqIE5lZWRlZCBzbyB3ZSBjYW4gc3VwcG9ydCBuZXcgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGRlcHJlY2F0ZWQgY2FsbHMgKEZpcmVmb3gpIGFzIHdlbGwgYXMgb2xkIGJyb3dzZXJzIHRoYXRcblx0ICogZG9uJ3Qgc3VwcG9ydCBuZXcgY2FsbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgX2NvbXBhdGliaWxpdHlTZXRVcFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqL1xuXHRzLl9jb21wYXRpYmlsaXR5U2V0VXAgPSBmdW5jdGlvbigpIHtcblx0XHRzLl9wYW5uaW5nTW9kZWwgPSBcImVxdWFscG93ZXJcIjtcblx0XHQvL2Fzc3VtZSB0aGF0IGlmIG9uZSBuZXcgY2FsbCBpcyBzdXBwb3J0ZWQsIHRoZXkgYWxsIGFyZVxuXHRcdGlmIChzLmNvbnRleHQuY3JlYXRlR2FpbikgeyByZXR1cm47IH1cblxuXHRcdC8vIHNpbXBsZSBuYW1lIGNoYW5nZSwgZnVuY3Rpb25hbGl0eSB0aGUgc2FtZVxuXHRcdHMuY29udGV4dC5jcmVhdGVHYWluID0gcy5jb250ZXh0LmNyZWF0ZUdhaW5Ob2RlO1xuXG5cdFx0Ly8gc291cmNlIG5vZGUsIGFkZCB0byBwcm90b3R5cGVcblx0XHR2YXIgYXVkaW9Ob2RlID0gcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdGF1ZGlvTm9kZS5fX3Byb3RvX18uc3RhcnQgPSBhdWRpb05vZGUuX19wcm90b19fLm5vdGVHcmFpbk9uO1x0Ly8gbm90ZSB0aGF0IG5vdGVHcmFpbk9uIHJlcXVpcmVzIGFsbCAzIHBhcmFtZXRlcnNcblx0XHRhdWRpb05vZGUuX19wcm90b19fLnN0b3AgPSBhdWRpb05vZGUuX19wcm90b19fLm5vdGVPZmY7XG5cblx0XHQvLyBwYW5uaW5nTW9kZWxcblx0XHRzLl9wYW5uaW5nTW9kZWwgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcnkgdG8gdW5sb2NrIGF1ZGlvIG9uIGlPUy4gVGhpcyBpcyB0cmlnZ2VyZWQgZnJvbSBlaXRoZXIgV2ViQXVkaW8gcGx1Z2luIHNldHVwICh3aGljaCB3aWxsIHdvcmsgaWYgaW5zaWRlIG9mXG5cdCAqIGEgYG1vdXNlZG93bmAgb3IgYHRvdWNoZW5kYCBldmVudCBzdGFjayksIG9yIHRoZSBmaXJzdCBkb2N1bWVudCB0b3VjaGVuZC9tb3VzZWRvd24gZXZlbnQuIElmIGl0IGZhaWxzICh0b3VjaGVuZFxuXHQgKiB3aWxsIGZhaWwgaWYgdGhlIHVzZXIgcHJlc3NlcyBmb3IgdG9vIGxvbmcsIGluZGljYXRpbmcgYSBzY3JvbGwgZXZlbnQgaW5zdGVhZCBvZiBhIGNsaWNrIGV2ZW50LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZWFybGllciB2ZXJzaW9ucyBvZiBpT1Mgc3VwcG9ydGVkIGB0b3VjaHN0YXJ0YCBmb3IgdGhpcywgYnV0IGlPUzkgcmVtb3ZlZCB0aGlzIGZ1bmN0aW9uYWxpdHkuIEFkZGluZ1xuXHQgKiBhIGB0b3VjaHN0YXJ0YCBldmVudCB0byBzdXBwb3J0IG9sZGVyIHBsYXRmb3JtcyBtYXkgcHJlY2x1ZGUgYSBgbW91c2Vkb3duYCBldmVuIGZyb20gZ2V0dGluZyBmaXJlZCBvbiBpT1M5LCBzbyB3ZVxuXHQgKiBzdGljayB3aXRoIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hlbmRgLlxuXHQgKiBAbWV0aG9kIF91bmxvY2tcblx0ICogQHNpbmNlIDAuNi4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzLl91bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocy5fdW5sb2NrZWQpIHsgcmV0dXJuOyB9XG5cdFx0cy5wbGF5RW1wdHlTb3VuZCgpO1xuXHRcdGlmIChzLmNvbnRleHQuc3RhdGUgPT0gXCJydW5uaW5nXCIpIHtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBzLl91bmxvY2ssIHRydWUpO1xuXHRcdFx0cy5fdW5sb2NrZWQgPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXG4vLyBQdWJsaWMgTWV0aG9kc1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltXZWJBdWRpb1BsdWdpbl1cIjtcblx0fTtcblxuXG4vLyBQcml2YXRlIE1ldGhvZHNcblx0LyoqXG5cdCAqIFNldCB1cCBuZWVkZWQgcHJvcGVydGllcyBvbiBzdXBwb3J0ZWQgY2xhc3NlcyBXZWJBdWRpb1NvdW5kSW5zdGFuY2UgYW5kIFdlYkF1ZGlvTG9hZGVyLlxuXHQgKiBAbWV0aG9kIF9hZGRQcm9wc1RvQ2xhc3Nlc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9hZGRQcm9wc1RvQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjID0gdGhpcy5fc291bmRJbnN0YW5jZUNsYXNzO1xuXHRcdGMuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblx0XHRjLl9zY3JhdGNoQnVmZmVyID0gcy5fc2NyYXRjaEJ1ZmZlcjtcblx0XHRjLmRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuZ2Fpbk5vZGU7XG5cdFx0Yy5fcGFubmluZ01vZGVsID0gdGhpcy5fcGFubmluZ01vZGVsO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGdhaW4gdmFsdWUgZm9yIG1hc3RlciBhdWRpby4gU2hvdWxkIG5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cblx0ICogQG1ldGhvZCBfdXBkYXRlVm9sdW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbmV3Vm9sdW1lID0gY3JlYXRlanMuU291bmQuX21hc3Rlck11dGUgPyAwIDogdGhpcy5fdm9sdW1lO1xuXHRcdGlmIChuZXdWb2x1bWUgIT0gdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlKSB7XG5cdFx0XHR0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWUgPSBuZXdWb2x1bWU7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luID0gY3JlYXRlanMucHJvbW90ZShXZWJBdWRpb1BsdWdpbiwgXCJBYnN0cmFjdFBsdWdpblwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBIVE1MQXVkaW9UYWdQb29sLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogSFRNTEF1ZGlvVGFnUG9vbCBpcyBhbiBvYmplY3QgcG9vbCBmb3IgSFRNTEF1ZGlvIHRhZyBpbnN0YW5jZXMuXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9UYWdQb29sXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gSFRNTEF1ZGlvVGFnUG9vbCgpIHtcblx0XHRcdHRocm93IFwiSFRNTEF1ZGlvVGFnUG9vbCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXHR2YXIgcyA9IEhUTUxBdWRpb1RhZ1Bvb2w7XG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBBIGhhc2ggbG9va3VwIG9mIGVhY2ggYmFzZSBhdWRpbyB0YWcsIGluZGV4ZWQgYnkgdGhlIGF1ZGlvIHNvdXJjZS5cblx0ICogQHByb3BlcnR5IF90YWdzXG5cdCAqIEB0eXBlIHt7fX1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl90YWdzID0ge307XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBwb29sIGZvciBodG1sIGF1ZGlvIHRhZ3Ncblx0ICogQHByb3BlcnR5IF90YWdQb29sXG5cdCAqIEB0eXBlIHtUYWdQb29sfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX3RhZ1Bvb2wgPSBuZXcgVGFnUG9vbCgpO1xuXG5cdC8qKlxuXHQgKiBBIGhhc2ggbG9va3VwIG9mIGlmIGEgYmFzZSBhdWRpbyB0YWcgaXMgYXZhaWxhYmxlLCBpbmRleGVkIGJ5IHRoZSBhdWRpbyBzb3VyY2Vcblx0ICogQHByb3BlcnR5IF90YWdzVXNlZFxuXHQgKiBAdHlwZSB7e319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fdGFnVXNlZCA9IHt9O1xuXG4vLyBTdGF0aWMgTWV0aG9kc1xuXHQvKipcblx0ICAqIEdldCBhbiBhdWRpbyB0YWcgd2l0aCB0aGUgZ2l2ZW4gc291cmNlLlxuXHQgICogQG1ldGhvZCBnZXRcblx0ICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmaWxlIHVzZWQgYnkgdGhlIGF1ZGlvIHRhZy5cblx0ICAqIEBzdGF0aWNcblx0ICAqL1xuXHQgcy5nZXQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHQgPSBzLl90YWdzW3NyY107XG5cdFx0aWYgKHQgPT0gbnVsbCkge1xuXHRcdFx0Ly8gY3JlYXRlIG5ldyBiYXNlIHRhZ1xuXHRcdFx0dCA9IHMuX3RhZ3Nbc3JjXSA9IHMuX3RhZ1Bvb2wuZ2V0KCk7XG5cdFx0XHR0LnNyYyA9IHNyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IGJhc2Ugb3IgcG9vbFxuXHRcdFx0aWYgKHMuX3RhZ1VzZWRbc3JjXSkge1xuXHRcdFx0XHR0ID0gcy5fdGFnUG9vbC5nZXQoKTtcblx0XHRcdFx0dC5zcmMgPSBzcmM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzLl90YWdVc2VkW3NyY10gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdDtcblx0IH07XG5cblx0IC8qKlxuXHQgICogUmV0dXJuIGFuIGF1ZGlvIHRhZyB0byB0aGUgcG9vbC5cblx0ICAqIEBtZXRob2Qgc2V0XG5cdCAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZSB1c2VkIGJ5IHRoZSBhdWRpbyB0YWcuXG5cdCAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgQXVkaW8gdGFnIHRvIHNldC5cblx0ICAqIEBzdGF0aWNcblx0ICAqL1xuXHQgcy5zZXQgPSBmdW5jdGlvbiAoc3JjLCB0YWcpIHtcblx0XHQgLy8gY2hlY2sgaWYgdGhpcyBpcyBiYXNlLCBpZiB5ZXMgc2V0IGJvb2xlYW4gaWYgbm90IHJldHVybiB0byBwb29sXG5cdFx0IGlmKHRhZyA9PSBzLl90YWdzW3NyY10pIHtcblx0XHRcdCBzLl90YWdVc2VkW3NyY10gPSBmYWxzZTtcblx0XHQgfSBlbHNlIHtcblx0XHRcdCBzLl90YWdQb29sLnNldCh0YWcpO1xuXHRcdCB9XG5cdCB9O1xuXG5cdC8qKlxuXHQgKiBEZWxldGUgc3RvcmVkIHRhZyByZWZlcmVuY2UgYW5kIHJldHVybiB0aGVtIHRvIHBvb2wuIE5vdGUgdGhhdCBpZiB0aGUgdGFnIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdCwgdGhpcyB3aWxsIGZhaWwuXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmb3IgdGhlIHRhZ1xuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgVGFnUG9vbCB3YXMgZGVsZXRlZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5yZW1vdmUgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IHMuX3RhZ3Nbc3JjXTtcblx0XHRpZiAodGFnID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHMuX3RhZ1Bvb2wuc2V0KHRhZyk7XG5cdFx0ZGVsZXRlKHMuX3RhZ3Nbc3JjXSk7XG5cdFx0ZGVsZXRlKHMuX3RhZ1VzZWRbc3JjXSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBzcmMgYXVkaW8gaW4gbWlsbGlzZWNvbmRzXG5cdCAqIEBtZXRob2QgZ2V0RHVyYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdXNlZCBieSB0aGUgYXVkaW8gdGFnLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IER1cmF0aW9uIG9mIHNyYyBpbiBtaWxsaXNlY29uZHNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXREdXJhdGlvbj0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciB0ID0gcy5fdGFnc1tzcmNdO1xuXHRcdGlmICh0ID09IG51bGwgfHwgIXQuZHVyYXRpb24pIHtyZXR1cm4gMDt9XHQvLyBPSlIgZHVyYXRpb24gaXMgTmFOIGlmIGxvYWRpbmcgaGFzIG5vdCBjb21wbGV0ZWRcblx0XHRyZXR1cm4gdC5kdXJhdGlvbiAqIDEwMDA7XG5cdH07XG5cblx0Y3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbCA9IEhUTUxBdWRpb1RhZ1Bvb2w7XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdC8qKlxuXHQgKiBUaGUgVGFnUG9vbCBpcyBhbiBvYmplY3QgcG9vbCBmb3IgSFRNTEF1ZGlvIHRhZyBpbnN0YW5jZXMuXG5cdCAqICNjbGFzcyBUYWdQb29sXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gVGFnUG9vbChzcmMpIHtcblxuLy8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0YWdzIGluIHRoZSBwb29sLlxuXHRcdCAqICNwcm9wZXJ0eSB0YWdzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdzID0gW107XG5cdH07XG5cblx0dmFyIHAgPSBUYWdQb29sLnByb3RvdHlwZTtcblx0cC5jb25zdHJ1Y3RvciA9IFRhZ1Bvb2w7XG5cblxuLy8gUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIEdldCBhbiBIVE1MQXVkaW9FbGVtZW50IGZvciBpbW1lZGlhdGUgcGxheWJhY2suIFRoaXMgdGFrZXMgaXQgb3V0IG9mIHRoZSBwb29sLlxuXHQgKiAjbWV0aG9kIGdldFxuXHQgKiBAcmV0dXJuIHtIVE1MQXVkaW9FbGVtZW50fSBBbiBIVE1MIGF1ZGlvIHRhZy5cblx0ICovXG5cdHAuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0YWc7XG5cdFx0aWYgKHRoaXMuX3RhZ3MubGVuZ3RoID09IDApIHtcblx0XHRcdHRhZyA9IHRoaXMuX2NyZWF0ZVRhZygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWcgPSB0aGlzLl90YWdzLnBvcCgpO1xuXHRcdH1cblx0XHRpZiAodGFnLnBhcmVudE5vZGUgPT0gbnVsbCkge2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGFnKTt9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHQvKipcblx0ICogUHV0IGFuIEhUTUxBdWRpb0VsZW1lbnQgYmFjayBpbiB0aGUgcG9vbCBmb3IgdXNlLlxuXHQgKiAjbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR9IHRhZyBIVE1MIGF1ZGlvIHRhZ1xuXHQgKi9cblx0cC5zZXQgPSBmdW5jdGlvbiAodGFnKSB7XG5cdFx0Ly8gT0pSIHRoaXMgZmlyc3Qgc3RlcCBzZWVtcyB1bm5lY2Vzc2FyeVxuXHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5fdGFncywgdGFnKTtcblx0XHRpZiAoaW5kZXggPT0gLTEpIHtcblx0XHRcdHRoaXMuX3RhZ3Muc3JjID0gbnVsbDtcblx0XHRcdHRoaXMuX3RhZ3MucHVzaCh0YWcpO1xuXHRcdH1cblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltUYWdQb29sXVwiO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlIGFuIEhUTUwgYXVkaW8gdGFnLlxuXHQgKiAjbWV0aG9kIF9jcmVhdGVUYWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdG8gc2V0IGZvciB0aGUgYXVkaW8gdGFnLlxuXHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gUmV0dXJucyBhbiBIVE1MIGF1ZGlvIHRhZy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XG5cdFx0dGFnLmF1dG9wbGF5ID0gZmFsc2U7XG5cdFx0dGFnLnByZWxvYWQgPSBcIm5vbmVcIjtcblx0XHQvL0xNOiBGaXJlZm94IGZhaWxzIHdoZW4gdGhpcyB0aGUgcHJlbG9hZD1cIm5vbmVcIiBmb3Igb3RoZXIgdGFncywgYnV0IGl0IG5lZWRzIHRvIGJlIFwibm9uZVwiIHRvIGVuc3VyZSBQcmVsb2FkSlMgd29ya3MuXG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlIGV4dGVuZHMgdGhlIGJhc2UgYXBpIG9mIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgaXMgdXNlZCBieVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHBhdGggdG8gYW5kIGZpbGUgbmFtZSBvZiB0aGUgc291bmQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gYXBwbHkgYW4gb2Zmc2V0LCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5YmFja1Jlc291cmNlIEFueSByZXNvdXJjZSBuZWVkZWQgYnkgcGx1Z2luIHRvIHN1cHBvcnQgYXVkaW8gcGxheWJhY2suXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0U291bmRJbnN0YW5jZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEhUTUxBdWRpb1NvdW5kSW5zdGFuY2Uoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfY29uc3RydWN0b3Ioc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKTtcblxuXG4vLyBQcml2YXRlIFByb3BlcnRpZXNcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gbnVsbDtcblx0XHR0aGlzLl9kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cblx0XHQvLyBQcm94aWVzLCBtYWtlIHJlbW92aW5nIGxpc3RlbmVycyBlYXNpZXIuXG5cdFx0dGhpcy5fZW5kZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU291bmRDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fcmVhZHlIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnUmVhZHksIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5fcGxheUZhaWxlZCwgdGhpcyk7XG5cdFx0dGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlQXVkaW9TcHJpdGVMb29wLCB0aGlzKTtcblx0XHR0aGlzLl9sb29wSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0aWYgKGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gKHN0YXJ0VGltZSArIGR1cmF0aW9uKSAqIDAuMDAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0RHVyYXRpb24odGhpcy5zcmMpO1xuXHRcdH1cblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChIVE1MQXVkaW9Tb3VuZEluc3RhbmNlLCBjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2UpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBDYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gd2hlbiBwbHVnaW4gZG9lcyBub3QgaGFuZGxlIG1hc3RlciB2b2x1bWUuXG5cdCAqIHVuZG9jJ2QgYmVjYXVzZSBpdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIFNvdW5kXG5cdCAqICNtZXRob2Qgc2V0TWFzdGVyVm9sdW1lXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKi9cblx0cC5zZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IHdoZW4gcGx1Z2luIGRvZXMgbm90IGhhbmRsZSBtYXN0ZXIgbXV0ZS5cblx0ICogdW5kb2MnZCBiZWNhdXNlIGl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgU291bmRcblx0ICogI21ldGhvZCBzZXRNYXN0ZXJNdXRlXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKi9cblx0cC5zZXRNYXN0ZXJNdXRlID0gZnVuY3Rpb24gKGlzTXV0ZWQpIHtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltIVE1MQXVkaW9Tb3VuZEluc3RhbmNlXVwiO1xuXHR9O1xuXG4vL1ByaXZhdGUgTWV0aG9kc1xuXHRwLl9yZW1vdmVMb29waW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9PSBudWxsKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSBmYWxzZTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdH07XG5cblx0cC5fYWRkTG9vcGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPT0gbnVsbCAgfHwgdGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSkge3JldHVybjt9XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UubG9vcCA9IHRydWU7XG5cdH07XG5cblx0cC5faGFuZGxlQ2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFnID0gdGhpcy5fcGxheWJhY2tSZXNvdXJjZTtcblx0XHRpZiAodGFnICE9IG51bGwpIHtcblx0XHRcdHRhZy5wYXVzZSgpO1xuXHRcdFx0dGFnLmxvb3AgPSBmYWxzZTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19SRUFEWSwgdGhpcy5fcmVhZHlIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NUQUxMRUQsIHRoaXMuX3N0YWxsZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0YWcuY3VycmVudFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9IC8vIFJlc2V0IFBvc2l0aW9uXG5cdFx0XHRjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLnNldCh0aGlzLnNyYywgdGFnKTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRwLl9iZWdpblBsYXlpbmcgPSBmdW5jdGlvbiAocGxheVByb3BzKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0KHRoaXMuc3JjKTtcblx0XHRyZXR1cm4gdGhpcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2VfX2JlZ2luUGxheWluZyhwbGF5UHJvcHMpO1xuXHR9O1xuXG5cdHAuX2hhbmRsZVNvdW5kUmVhZHkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZWFkeVN0YXRlICE9PSA0KSB7XG5cdFx0XHR2YXIgdGFnID0gdGhpcy5fcGxheWJhY2tSZXNvdXJjZTtcblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fUkVBRFksIHRoaXMuX3JlYWR5SGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TVEFMTEVELCB0aGlzLl9zdGFsbGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnByZWxvYWQgPSBcImF1dG9cIjsgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIEZpcmVmb3gsIGFzIGl0IHdvbid0IGV2ZXIgXCJsb2FkXCIgdW50aWwgdGhpcyBpcyBzZXQuXG5cdFx0XHR0YWcubG9hZCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgPSAodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fcG9zaXRpb24pICogMC4wMDE7XG5cdFx0aWYgKHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUpIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0aWYodGhpcy5fbG9vcCAhPSAwKSB7XG5cdFx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5sb29wID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBsYXkoKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBoYW5kbGUgd2hlbiBhIHRhZyBpcyBub3QgcmVhZHkgZm9yIGltbWVkaWF0ZSBwbGF5YmFjayB3aGVuIGl0IGlzIHJldHVybmVkIGZyb20gdGhlIEhUTUxBdWRpb1RhZ1Bvb2wuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRhZ1JlYWR5XG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVUYWdSZWFkeSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1JFQURZLCB0aGlzLl9yZWFkeUhhbmRsZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TVEFMTEVELCB0aGlzLl9zdGFsbGVkSGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO1xuXHR9O1xuXG5cdHAuX3BhdXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucGF1c2UoKTtcblx0fTtcblxuXHRwLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wbGF5KCk7XG5cdH07XG5cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBuZXdWb2x1bWUgPSAodGhpcy5fbXV0ZWQgfHwgY3JlYXRlanMuU291bmQuX21hc3Rlck11dGUpID8gMCA6IHRoaXMuX3ZvbHVtZSAqIGNyZWF0ZWpzLlNvdW5kLl9tYXN0ZXJWb2x1bWU7XG5cdFx0XHRpZiAobmV3Vm9sdW1lICE9IHRoaXMuX3BsYXliYWNrUmVzb3VyY2Uudm9sdW1lKSB7dGhpcy5fcGxheWJhY2tSZXNvdXJjZS52b2x1bWUgPSBuZXdWb2x1bWU7fVxuXHRcdH1cblx0fTtcblxuXHRwLl9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgKiAxMDAwKSAtIHRoaXMuX3N0YXJ0VGltZTtcblx0fTtcblxuXHRwLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2hhbmRsZVNldFBvc2l0aW9uU2VlaywgZmFsc2UpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lID0gKHRoaXMuX3Bvc2l0aW9uICsgdGhpcy5fc3RhcnRUaW1lKSAqIDAuMDAxO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7IC8vIE91dCBvZiByYW5nZVxuXHRcdFx0dGhpcy5faGFuZGxlU2V0UG9zaXRpb25TZWVrKG51bGwpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBlbmFibGUgc2V0dGluZyBwb3NpdGlvbiwgYXMgd2UgbmVlZCB0byB3YWl0IGZvciB0aGF0IHNlZWsgdG8gYmUgZG9uZSBiZWZvcmUgd2UgYWRkIGJhY2sgb3VyIGxvb3AgaGFuZGxpbmcgc2VlayBsaXN0ZW5lclxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTZXRQb3NpdGlvblNlZWtcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZVNldFBvc2l0aW9uU2VlayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2hhbmRsZVNldFBvc2l0aW9uU2VlaywgZmFsc2UpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogVGltZXIgdXNlZCB0byBsb29wIGF1ZGlvIHNwcml0ZXMuXG5cdCAqIE5PVEUgYmVjYXVzZSBvZiB0aGUgaW5hY2N1cmFjaWVzIGluIHRoZSB0aW1ldXBkYXRlIGV2ZW50ICgxNSAtIDI1MG1zKSBhbmQgaW4gc2V0dGluZyB0aGUgdGFnIHRvIHRoZSBkZXNpcmVkIHRpbWVkXG5cdCAqICh1cCB0byAzMDBtcyksIGl0IGlzIHN0cm9uZ2x5IHJlY29tbWVuZGVkIG5vdCB0byBsb29wIGF1ZGlvIHNwcml0ZXMgd2l0aCBIVE1MIEF1ZGlvIGlmIHNtb290aCBsb29waW5nIGlzIGRlc2lyZWRcblx0ICpcblx0ICogQG1ldGhvZCBfaGFuZGxlQXVkaW9TcHJpdGVMb29wXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQXVkaW9TcHJpdGVMb29wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYodGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSA8PSB0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lKSB7cmV0dXJuO31cblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBhdXNlKCk7XG5cdFx0aWYodGhpcy5fbG9vcCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVTb3VuZENvbXBsZXRlKG51bGwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0XHR0aGlzLl9sb29wLS07XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lICogMC4wMDE7XG5cdFx0XHRpZighdGhpcy5fcGF1c2VkKSB7dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wbGF5KCk7fVxuXHRcdFx0dGhpcy5fc2VuZEV2ZW50KFwibG9vcFwiKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gTk9URSB3aXRoIHRoaXMgYXBwcm9hY2ggYXVkaW8gd2lsbCBsb29wIGFzIHJlbGlhYmx5IGFzIHRoZSBicm93c2VyIGFsbG93c1xuXHQvLyBidXQgd2UgY291bGQgZW5kIHVwIHNlbmRpbmcgdGhlIGxvb3AgZXZlbnQgYWZ0ZXIgbmV4dCBsb29wIHBsYXliYWNrIGJlZ2luc1xuXHRwLl9oYW5kbGVMb29wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYodGhpcy5fbG9vcCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cblx0cC5fdXBkYXRlU3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUgPSAodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fZHVyYXRpb24pICogMC4wMDE7XG5cblx0XHRpZih0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fRU5ERUQsIHRoaXMuX2VuZGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fVElNRV9VUERBVEUsIHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciwgZmFsc2UpO1xuXHRcdH1cblx0fTtcblxuXHRwLl91cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKSAqIDAuMDAxO1xuXG5cdFx0aWYodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX0VOREVELCB0aGlzLl9lbmRlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cblx0cC5fc2V0RHVyYXRpb25Gcm9tU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gY3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5nZXREdXJhdGlvbih0aGlzLnNyYyk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IG51bGw7XG5cdH07XG5cblx0Y3JlYXRlanMuSFRNTEF1ZGlvU291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLnByb21vdGUoSFRNTEF1ZGlvU291bmRJbnN0YW5jZSwgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSFRNTEF1ZGlvUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBQbGF5IHNvdW5kcyB1c2luZyBIVE1MICZsdDthdWRpbyZndDsgdGFncyBpbiB0aGUgYnJvd3Nlci4gVGhpcyBwbHVnaW4gaXMgdGhlIHNlY29uZCBwcmlvcml0eSBwbHVnaW4gaW5zdGFsbGVkXG5cdCAqIGJ5IGRlZmF1bHQsIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS4gIEZvciBvbGRlciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGh0bWxcblx0ICogYXVkaW8sIGluY2x1ZGUgYW5kIGluc3RhbGwgdGhlIHt7I2Nyb3NzTGluayBcIkZsYXNoQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5Lbm93biBCcm93c2VyIGFuZCBPUyBpc3N1ZXMgZm9yIEhUTUwgQXVkaW88L2g0PlxuXHQgKiA8Yj5BbGwgYnJvd3NlcnM8L2I+PGJyIC8+XG5cdCAqIFRlc3RpbmcgaGFzIHNob3duIGluIGFsbCBicm93c2VycyB0aGVyZSBpcyBhIGxpbWl0IHRvIGhvdyBtYW55IGF1ZGlvIHRhZyBpbnN0YW5jZXMgeW91IGFyZSBhbGxvd2VkLiAgSWYgeW91IGV4Y2VlZFxuXHQgKiB0aGlzIGxpbWl0LCB5b3UgY2FuIGV4cGVjdCB0byBzZWUgdW5wcmVkaWN0YWJsZSByZXN1bHRzLiBQbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kLk1BWF9JTlNUQU5DRVNcIn19e3svY3Jvc3NMaW5rfX0gYXNcblx0ICogYSBndWlkZSB0byBob3cgbWFueSB0b3RhbCBhdWRpbyB0YWdzIHlvdSBjYW4gc2FmZWx5IHVzZSBpbiBhbGwgYnJvd3NlcnMuICBUaGlzIGlzc3VlIGlzIHByaW1hcmlseSBsaW1pdGVkIHRvIElFOS5cblx0ICpcbiAgICAgKiA8Yj5JRSBodG1sIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuICAgICAqIDx1bD48bGk+VGhlcmUgaXMgYSBkZWxheSBpbiBhcHBseWluZyB2b2x1bWUgY2hhbmdlcyB0byB0YWdzIHRoYXQgb2NjdXJzIG9uY2UgcGxheWJhY2sgaXMgc3RhcnRlZC4gU28gaWYgeW91IGhhdmVcbiAgICAgKiBtdXRlZCBhbGwgc291bmRzLCB0aGV5IHdpbGwgYWxsIHBsYXkgZHVyaW5nIHRoaXMgZGVsYXkgdW50aWwgdGhlIG11dGUgYXBwbGllcyBpbnRlcm5hbGx5LiBUaGlzIGhhcHBlbnMgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZW4gb3IgaG93IHlvdSBhcHBseSB0aGUgdm9sdW1lIGNoYW5nZSwgYXMgdGhlIHRhZyBzZWVtcyB0byBuZWVkIHRvIHBsYXkgdG8gYXBwbHkgaXQuPC9saT5cbiAgICAgKiA8bGk+TVAzIGVuY29kaW5nIHdpbGwgbm90IGFsd2F5cyB3b3JrIGZvciBhdWRpbyB0YWdzIGlmIGl0J3Mgbm90IGRlZmF1bHQuICBXZSd2ZSBmb3VuZCBkZWZhdWx0IGVuY29kaW5nIHdpdGhcbiAgICAgKiA2NGticHMgd29ya3MuPC9saT5cblx0ICogPGxpPk9jY2FzaW9uYWxseSB2ZXJ5IHNob3J0IHNhbXBsZXMgd2lsbCBnZXQgY3V0IG9mZi48L2xpPlxuXHQgKiA8bGk+VGhlcmUgaXMgYSBsaW1pdCB0byBob3cgbWFueSBhdWRpbyB0YWdzIHlvdSBjYW4gbG9hZCBvciBwbGF5IGF0IG9uY2UsIHdoaWNoIGFwcGVhcnMgdG8gYmUgZGV0ZXJtaW5lZCBieVxuXHQgKiBoYXJkd2FyZSBhbmQgYnJvd3NlciBzZXR0aW5ncy4gIFNlZSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW4uTUFYX0lOU1RBTkNFU1wifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBzYWZlIGVzdGltYXRlLlxuXHQgKiBOb3RlIHRoYXQgYXVkaW8gc3ByaXRlcyBjYW4gYmUgdXNlZCBhcyBhIHNvbHV0aW9uIHRvIHRoaXMgaXNzdWUuPC9saT48L3VsPlxuXHQgKlxuXHQgKiA8Yj5TYWZhcmkgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+U2FmYXJpIHJlcXVpcmVzIFF1aWNrdGltZSB0byBiZSBpbnN0YWxsZWQgZm9yIGF1ZGlvIHBsYXliYWNrLjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+aU9TIDYgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+Y2FuIG9ubHkgaGF2ZSBvbmUgJmx0O2F1ZGlvJmd0OyB0YWc8L2xpPlxuXHQgKiBcdFx0PGxpPmNhbiBub3QgcHJlbG9hZCBvciBhdXRvcGxheSB0aGUgYXVkaW88L2xpPlxuXHQgKiBcdFx0PGxpPmNhbiBub3QgY2FjaGUgdGhlIGF1ZGlvPC9saT5cblx0ICogXHRcdDxsaT5jYW4gbm90IHBsYXkgdGhlIGF1ZGlvIGV4Y2VwdCBpbnNpZGUgYSB1c2VyIGluaXRpYXRlZCBldmVudC48L2xpPlxuXHQgKlx0XHQ8bGk+Tm90ZSBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGlPUyAoNispPC9saT5cblx0ICogXHRcdDxsaT5hdWRpbyBzcHJpdGVzIGNhbiBiZSB1c2VkIHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlc2UgaXNzdWVzIGFuZCBhcmUgc3Ryb25nbHkgcmVjb21tZW5kZWQgb24gaU9TPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGI+QW5kcm9pZCBOYXRpdmUgQnJvd3NlciBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPjxsaT5XZSBoYXZlIG5vIGNvbnRyb2wgb3ZlciBhdWRpbyB2b2x1bWUuIE9ubHkgdGhlIHVzZXIgY2FuIHNldCB2b2x1bWUgb24gdGhlaXIgZGV2aWNlLjwvbGk+XG5cdCAqICAgICAgPGxpPldlIGNhbiBvbmx5IHBsYXkgYXVkaW8gaW5zaWRlIGEgdXNlciBldmVudCAodG91Y2gvY2xpY2spLiAgVGhpcyBjdXJyZW50bHkgbWVhbnMgeW91IGNhbm5vdCBsb29wIHNvdW5kIG9yIHVzZSBhIGRlbGF5LjwvbGk+PC91bD5cblx0ICogPGI+IEFuZHJvaWQgQ2hyb21lIDI2LjAuMTQxMC41OCBzcGVjaWZpYyBsaW1pdGF0aW9uczwvYj48YnIgLz5cblx0ICogPHVsPiA8bGk+Q2FuIG9ubHkgcGxheSAxIHNvdW5kIGF0IGEgdGltZS48L2xpPlxuXHQgKiAgICAgIDxsaT5Tb3VuZCBpcyBub3QgY2FjaGVkLjwvbGk+XG5cdCAqICAgICAgPGxpPlNvdW5kIGNhbiBvbmx5IGJlIGxvYWRlZCBpbiBhIHVzZXIgaW5pdGlhdGVkIHRvdWNoL2NsaWNrIGV2ZW50LjwvbGk+XG5cdCAqICAgICAgPGxpPlRoZXJlIGlzIGEgZGVsYXkgYmVmb3JlIGEgc291bmQgaXMgcGxheWVkLCBwcmVzdW1hYmx5IHdoaWxlIHRoZSBzcmMgaXMgbG9hZGVkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgZ2VuZXJhbCBub3RlcyBvbiBrbm93biBpc3N1ZXMuXG5cdCAqXG5cdCAqIEBjbGFzcyBIVE1MQXVkaW9QbHVnaW5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBIVE1MQXVkaW9QbHVnaW4oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0Ly8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgYXMgd2UgYXJlIG5vdyB1c2luZyBvYmplY3QgcG9vbGluZyBmb3IgdGFncy5cblx0XHQgKlxuXHRcdCAqIDxiPk5PVEUgdGhpcyBwcm9wZXJ0eSBvbmx5IGV4aXN0cyBhcyBhIGxpbWl0YXRpb24gb2YgSFRNTCBhdWRpby48L2I+XG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHROdW1DaGFubmVsc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kZWZhdWx0TnVtQ2hhbm5lbHMgPSAyO1xuXG5cdFx0dGhpcy5fY2FwYWJpbGl0aWVzID0gcy5fY2FwYWJpbGl0aWVzO1xuXG5cdFx0dGhpcy5fbG9hZGVyQ2xhc3MgPSBjcmVhdGVqcy5Tb3VuZExvYWRlcjtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlQ2xhc3MgPSBjcmVhdGVqcy5IVE1MQXVkaW9Tb3VuZEluc3RhbmNlO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSFRNTEF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5BYnN0cmFjdFBsdWdpbik7XG5cdHZhciBzID0gSFRNTEF1ZGlvUGx1Z2luO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIHRoYXQgY2FuIGJlIGxvYWRlZCBvciBwbGF5ZWQuIFRoaXMgaXMgYSBicm93c2VyIGxpbWl0YXRpb24sIHByaW1hcmlseSBsaW1pdGVkIHRvIElFOS5cblx0ICogVGhlIGFjdHVhbCBudW1iZXIgdmFyaWVzIGZyb20gYnJvd3NlciB0byBicm93c2VyIChhbmQgaXMgbGFyZ2VseSBoYXJkd2FyZSBkZXBlbmRhbnQpLCBidXQgdGhpcyBpcyBhIHNhZmUgZXN0aW1hdGUuXG5cdCAqIEF1ZGlvIHNwcml0ZXMgd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuXHQgKiBAcHJvcGVydHkgTUFYX0lOU1RBTkNFU1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAzMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLk1BWF9JTlNUQU5DRVMgPSAzMDtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcImNhblBsYXlUaHJvdWdoXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS5cblx0ICogQHByb3BlcnR5IF9BVURJT19SRUFEWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjYW5wbGF5dGhyb3VnaFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX1JFQURZID0gXCJjYW5wbGF5dGhyb3VnaFwiO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwiZW5kZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX0VOREVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGVuZGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fRU5ERUQgPSBcImVuZGVkXCI7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJzZWVrZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLiAgV2UgdXRpbGl6ZSB0aGlzIGV2ZW50IGZvciBtYWludGFpbmluZyBsb29wIGV2ZW50cy5cblx0ICogQHByb3BlcnR5IF9BVURJT19TRUVLRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc2Vla2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fQVVESU9fU0VFS0VEID0gXCJzZWVrZWRcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcInN0YWxsZWRcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLlxuXHQgKiBAcHJvcGVydHkgX0FVRElPX1NUQUxMRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3RhbGxlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX1NUQUxMRUQgPSBcInN0YWxsZWRcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcInRpbWV1cGRhdGVcIiBldmVudCBmb3IgY2xlYW5lciBjb2RlLiAgVXRpbGl6ZWQgZm9yIGxvb3BpbmcgYXVkaW8gc3ByaXRlcy5cblx0ICogVGhpcyBldmVudCBjYWxsc2JhY2sgZXZlciAxNSB0byAyNTBtcyBhbmQgY2FuIGJlIGRyb3BwZWQgYnkgdGhlIGJyb3dzZXIgZm9yIHBlcmZvcm1hbmNlLlxuXHQgKiBAcHJvcGVydHkgX1RJTUVfVVBEQVRFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRpbWV1cGRhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9USU1FX1VQREFURSA9IFwidGltZXVwZGF0ZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFRoaXMgaXMgZ2VuZXJhdGVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luL19nZW5lcmF0ZUNhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuIFBsZWFzZSBzZWUgdGhlIFNvdW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIGFsbFxuXHQgKiBvZiB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXMuXG5cdCAqIEBwcm9wZXJ0eSBfY2FwYWJpbGl0aWVzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXG4vLyBTdGF0aWMgTWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci9PUy4gTm90ZSB0aGF0IEhUTUwgYXVkaW8gaXMgYXZhaWxhYmxlIGluIG1vc3QgbW9kZXJuXG5cdCAqIGJyb3dzZXJzLCBidXQgaXMgZGlzYWJsZWQgaW4gaU9TIGJlY2F1c2Ugb2YgaXRzIGxpbWl0YXRpb25zLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzKCk7XG5cdFx0cmV0dXJuIChzLl9jYXBhYmlsaXRpZXMgIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS4gUGxlYXNlIHNlZSB0aGUgU291bmQgQVBJIHt7I2Nyb3NzTGluayBcIlNvdW5kL2dldENhcGFiaWxpdGllc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIGFuIG92ZXJ2aWV3IG9mIHBsdWdpbiBjYXBhYmlsaXRpZXMuXG5cdCAqIEBtZXRob2QgX2dlbmVyYXRlQ2FwYWJpbGl0aWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fZ2VuZXJhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuX2NhcGFiaWxpdGllcyAhPSBudWxsKSB7cmV0dXJuO31cblx0XHR2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHRpZiAodC5jYW5QbGF5VHlwZSA9PSBudWxsKSB7cmV0dXJuIG51bGw7fVxuXG5cdFx0cy5fY2FwYWJpbGl0aWVzID0ge1xuXHRcdFx0cGFubmluZzpmYWxzZSxcblx0XHRcdHZvbHVtZTp0cnVlLFxuXHRcdFx0dHJhY2tzOi0xXG5cdFx0fTtcblxuXHRcdC8vIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIG91ciBicm93c2VyIHN1cHBvcnRzIGZvciB0aGlzIHBsdWdpbiBieSBpdGVyYXRpbmcgdGhyb3VnaCBTb3VuZC5TVVBQT1JURURfRVhURU5TSU9OU1xuXHRcdHZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gY3JlYXRlanMuU291bmQuU1VQUE9SVEVEX0VYVEVOU0lPTlM7XG5cdFx0dmFyIGV4dGVuc2lvbk1hcCA9IGNyZWF0ZWpzLlNvdW5kLkVYVEVOU0lPTl9NQVA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdXBwb3J0ZWRFeHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGV4dCA9IHN1cHBvcnRlZEV4dGVuc2lvbnNbaV07XG5cdFx0XHR2YXIgcGxheVR5cGUgPSBleHRlbnNpb25NYXBbZXh0XSB8fCBleHQ7XG5cdFx0XHRzLl9jYXBhYmlsaXRpZXNbZXh0XSA9ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwibm9cIiAmJiB0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwiXCIpIHx8ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBwbGF5VHlwZSkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIlwiKTtcblx0XHR9ICAvLyBPSlIgYW5vdGhlciB3YXkgdG8gZG8gdGhpcyBtaWdodCBiZSBjYW5QbGF5VHlwZTpcIm00YVwiLCBjb2RleDogbXA0XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHNcblx0cC5yZWdpc3RlciA9IGZ1bmN0aW9uIChsb2FkSXRlbSkge1xuXHRcdHZhciB0YWcgPSBjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLmdldChsb2FkSXRlbS5zcmMpO1xuXHRcdHZhciBsb2FkZXIgPSB0aGlzLkFic3RyYWN0UGx1Z2luX3JlZ2lzdGVyKGxvYWRJdGVtKTtcblx0XHRsb2FkZXIuc2V0VGFnKHRhZyk7XG5cblx0XHRyZXR1cm4gbG9hZGVyO1xuXHR9O1xuXG5cdHAucmVtb3ZlU291bmQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFBsdWdpbl9yZW1vdmVTb3VuZChzcmMpO1xuXHRcdGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wucmVtb3ZlKHNyYyk7XG5cdH07XG5cblx0cC5jcmVhdGUgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdFx0dmFyIHNpID0gdGhpcy5BYnN0cmFjdFBsdWdpbl9jcmVhdGUoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKTtcblx0XHRzaS5zZXRQbGF5YmFja1Jlc291cmNlKG51bGwpO1xuXHRcdHJldHVybiBzaTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltIVE1MQXVkaW9QbHVnaW5dXCI7XG5cdH07XG5cblx0Ly8gcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdGhlc2Vcblx0cC5zZXRWb2x1bWUgPSBwLmdldFZvbHVtZSA9IHAuc2V0TXV0ZSA9IG51bGw7XG5cblxuXHRjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4gPSBjcmVhdGVqcy5wcm9tb3RlKEhUTUxBdWRpb1BsdWdpbiwgXCJBYnN0cmFjdFBsdWdpblwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUd2Vlbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLy8gVE9ETzogcG9zc2libHkgYWRkIGEgRU5EIGFjdGlvbnNNb2RlIChvbmx5IHJ1bnMgYWN0aW9ucyB0aGF0ID09IHBvc2l0aW9uKT9cbi8vIFRPRE86IGV2YWx1YXRlIGEgd2F5IHRvIGRlY291cGxlIHBhdXNlZCBmcm9tIHRpY2sgcmVnaXN0cmF0aW9uLlxuXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIFR3ZWVuIGluc3RhbmNlIHR3ZWVucyBwcm9wZXJ0aWVzIGZvciBhIHNpbmdsZSB0YXJnZXQuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlIGNoYWluZWQgZm9yIGVhc3kgY29uc3RydWN0aW9uIGFuZCBzZXF1ZW5jaW5nOlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdGFyZ2V0LmFscGhhID0gMTtcblx0ICpcdCAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KVxuXHQgKlx0ICAgICAgICAgLndhaXQoNTAwKVxuXHQgKlx0ICAgICAgICAgLnRvKHthbHBoYTowLCB2aXNpYmxlOmZhbHNlfSwgMTAwMClcblx0ICpcdCAgICAgICAgIC5jYWxsKGhhbmRsZUNvbXBsZXRlKTtcblx0ICpcdCAgICBmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZSgpIHtcblx0ICpcdCAgICBcdC8vVHdlZW4gY29tcGxldGVcblx0ICpcdCAgICB9XG5cdCAqXG5cdCAqIE11bHRpcGxlIHR3ZWVucyBjYW4gcG9pbnQgdG8gdGhlIHNhbWUgaW5zdGFuY2UsIGhvd2V2ZXIgaWYgdGhleSBhZmZlY3QgdGhlIHNhbWUgcHJvcGVydGllcyB0aGVyZSBjb3VsZCBiZSB1bmV4cGVjdGVkXG5cdCAqIGJlaGF2aW91ci4gVG8gc3RvcCBhbGwgdHdlZW5zIG9uIGFuIG9iamVjdCwgdXNlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3JlbW92ZVR3ZWVuc1wifX17ey9jcm9zc0xpbmt9fSBvciBwYXNzIGBvdmVycmlkZTp0cnVlYFxuXHQgKiBpbiB0aGUgcHJvcHMgYXJndW1lbnQuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCwge292ZXJyaWRlOnRydWV9KS50byh7eDoxMDB9KTtcblx0ICpcblx0ICogU3Vic2NyaWJlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgdG8gZ2V0IG5vdGlmaWVkIHdoZW4gYSBwcm9wZXJ0eSBvZiB0aGVcblx0ICogdGFyZ2V0IGlzIGNoYW5nZWQuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCwge292ZXJyaWRlOnRydWV9KS50byh7eDoxMDB9KS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZUNoYW5nZSk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIC8vIFRoZSB0d2VlbiBjaGFuZ2VkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9nZXRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBhZGRpdGlvbmFsIHBhcmFtIGRvY3VtZW50YXRpb24uXG5cdCAqIEBjbGFzcyBUd2VlblxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlLCBwYXVzZWQ6dHJ1ZX1gLlxuXHQgKiBBbGwgcHJvcGVydGllcyBkZWZhdWx0IHRvIGZhbHNlLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOjxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb3ZlcnJpZGU6IGlmIHRydWUsIGBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAgd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIGFueSBvdGhlciB0d2VlbnMgd2l0aCB0aGUgc2FtZSB0YXJnZXQuXG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciBmb3IgdGhlIFwiY2hhbmdlXCIgZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW5EYXRhXSBBbiBvYmplY3QgY29udGFpbmluZyBkYXRhIGZvciB1c2UgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIFNlZSBpbmRpdmlkdWFsXG5cdCAqIHBsdWdpbnMnIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFR3ZWVuKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEpIHtcblxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDYXVzZXMgdGhpcyB0d2VlbiB0byBjb250aW51ZSBwbGF5aW5nIHdoZW4gYSBnbG9iYWwgcGF1c2UgaXMgYWN0aXZlLiBGb3IgZXhhbXBsZSwgaWYgVHdlZW5KUyBpcyB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdGhlbiBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSAodGhlIGRlZmF1bHQpIHdpbGwgY2F1c2UgdGhpcyB0d2VlbiB0byBiZSBwYXVzZWQgd2hlbiA8Y29kZT5UaWNrZXIuc2V0UGF1c2VkKHRydWUpPC9jb2RlPlxuXHRcdCAqIGlzIGNhbGxlZC4gU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90aWNrXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBmb3IgbW9yZSBpbmZvLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHNcblx0XHQgKiBwYXJhbWV0ZXIuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgdHdlZW4gd2lsbCBsb29wIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHMgcGFyYW0uXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoaXMgdHdlZW4gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0XHQgKiBUaGlzIHZhbHVlIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBhcyB5b3UgbW9kaWZ5IHRoZSB0d2Vlbi4gQ2hhbmdpbmcgaXQgZGlyZWN0bHkgY291bGQgcmVzdWx0IGluIHVuZXhwZWN0ZWRcblx0XHQgKiBiZWhhdmlvdXIuXG5cdFx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyB5b3UgdG8gc3BlY2lmeSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBFYWNoIHBsdWdpbiB1c2VzIHRoaXMgZGlmZmVyZW50bHksIGJ1dCBpbiBnZW5lcmFsXG5cdFx0ICogeW91IHNwZWNpZnkgZGF0YSBieSBzZXR0aW5nIGl0IHRvIGEgcHJvcGVydHkgb2YgcGx1Z2luRGF0YSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHBsdWdpbiBjbGFzcy5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXHRteVR3ZWVuLnBsdWdpbkRhdGEuUGx1Z2luQ2xhc3NOYW1lID0gZGF0YTtcblx0XHQgKiA8YnIvPlxuXHRcdCAqIEFsc28sIG1vc3QgcGx1Z2lucyBzdXBwb3J0IGEgcHJvcGVydHkgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlbS4gVGhpcyBpcyB0eXBpY2FsbHkgdGhlIHBsdWdpbiBjbGFzcyBuYW1lIGZvbGxvd2VkIGJ5IFwiX2VuYWJsZWRcIi48YnIvPlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5QbHVnaW5DbGFzc05hbWVfZW5hYmxlZCA9IGZhbHNlOzxici8+XG5cdFx0ICogPGJyLz5cblx0XHQgKiBTb21lIHBsdWdpbnMgYWxzbyBzdG9yZSBpbnN0YW5jZSBkYXRhIGluIHRoaXMgb2JqZWN0LCB1c3VhbGx5IGluIGEgcHJvcGVydHkgbmFtZWQgX1BsdWdpbkNsYXNzTmFtZS5cblx0XHQgKiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGluZGl2aWR1YWwgcGx1Z2lucyBmb3IgbW9yZSBkZXRhaWxzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwbHVnaW5EYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbkRhdGEgPSBwbHVnaW5EYXRhIHx8IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgdHdlZW4uIFRoaXMgaXMgdGhlIG9iamVjdCBvbiB3aGljaCB0aGUgdHdlZW5lZCBwcm9wZXJ0aWVzIHdpbGwgYmUgY2hhbmdlZC4gQ2hhbmdpbmdcblx0XHQgKiB0aGlzIHByb3BlcnR5IGFmdGVyIHRoZSB0d2VlbiBpcyBjcmVhdGVkIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwb3NpdGlvbiBvZiB0aGUgdHdlZW4uIFRoaXMgd2lsbCBhbHdheXMgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIGR1cmF0aW9uLlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucG9zaXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIHR3ZWVuJ3MgY3VycmVudCBwb3NpdGlvbiBpcyB3aXRoaW4gYSBwYXNzaXZlIHdhaXQuXG5cdFx0ICogQHByb3BlcnR5IHBhc3NpdmVcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VyUXVldWVQcm9wc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1clF1ZXVlUHJvcHMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbml0UXVldWVQcm9wc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2luaXRRdWV1ZVByb3BzID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0ZXBzID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aW9uc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fYWN0aW9ucyA9IFtdO1xuXHRcblx0XHQvKipcblx0XHQgKiBSYXcgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgY3VycmVudCBzdGVwLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RlcFBvc2l0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0ZXBQb3NpdGlvbiA9IDA7IC8vIHRoaXMgaXMgbmVlZGVkIGJ5IE1vdmllQ2xpcC5cblx0XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplZCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90YXJnZXRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl91c2VUaWNrcyA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luaXRlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2luaXRlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBpcyBjdXJyZW50bHkgcmVnaXN0ZXJlZCB3aXRoIFR3ZWVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnaXN0ZXJlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHR0aGlzLl91c2VUaWNrcyA9IHByb3BzLnVzZVRpY2tzO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0dGhpcy5sb29wID0gcHJvcHMubG9vcDtcblx0XHRcdHByb3BzLm9uQ2hhbmdlICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0XHRpZiAocHJvcHMub3ZlcnJpZGUpIHsgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldCk7IH1cblx0XHR9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wYXVzZWQpIHsgdGhpcy5fcGF1c2VkPXRydWU7IH1cblx0XHRlbHNlIHsgY3JlYXRlanMuVHdlZW4uX3JlZ2lzdGVyKHRoaXMsdHJ1ZSk7IH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBvc2l0aW9uIT1udWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocHJvcHMucG9zaXRpb24sIFR3ZWVuLk5PTkUpOyB9XG5cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUd2VlbiwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgbm9uZSBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBOT05FXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLk5PTkUgPSAwO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgbG9vcCBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBMT09QXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAxXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLkxPT1AgPSAxO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCBkZWZpbmluZyB0aGUgcmV2ZXJzZSBhY3Rpb25zTW9kZSBmb3IgdXNlIHdpdGggc2V0UG9zaXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBSRVZFUlNFXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAZGVmYXVsdCAyXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLlJFVkVSU0UgPSAyO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudCByZXR1cm5lZCBieSBwbHVnaW5zIHRvIHRlbGwgdGhlIHR3ZWVuIG5vdCB0byB1c2UgZGVmYXVsdCBhc3NpZ25tZW50LlxuXHQgKiBAcHJvcGVydHkgSUdOT1JFXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5JR05PUkUgPSB7fTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcblx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3R3ZWVucyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3BsdWdpbnMgPSB7fTtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1x0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHR3ZWVuIGluc3RhbmNlLiBUaGlzIGlzIGZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gdXNpbmcgXCJuZXcgVHdlZW4oLi4uKVwiLCBidXQgbG9va3MgY2xlYW5lclxuXHQgKiB3aXRoIHRoZSBjaGFpbmVkIHN5bnRheCBvZiBUd2VlbkpTLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgd2lsbCBoYXZlIGl0cyBwcm9wZXJ0aWVzIHR3ZWVuZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlLCBwYXVzZWQ6dHJ1ZX1gKS5cblx0ICogQWxsIHByb3BlcnRpZXMgZGVmYXVsdCB0byBgZmFsc2VgLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOlxuXHQgKiA8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb25cblx0ICogICAgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG92ZXJyaWRlOiBpZiB0cnVlLCBgY3JlYXRlanMuVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSBhbnkgb3RoZXIgdHdlZW5zIHdpdGhcblx0ICogICAgdGhlIHNhbWUgdGFyZ2V0LlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW5EYXRhXSBBbiBvYmplY3QgY29udGFpbmluZyBkYXRhIGZvciB1c2UgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIFNlZSBpbmRpdmlkdWFsIHBsdWdpbnMnXG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlPWZhbHNlXSBJZiB0cnVlLCBhbnkgcHJldmlvdXMgdHdlZW5zIG9uIHRoZSBzYW1lIHRhcmdldCB3aWxsIGJlIHJlbW92ZWQuIFRoaXMgaXMgdGhlXG5cdCAqIHNhbWUgYXMgY2FsbGluZyBgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gQSByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZWQgdHdlZW4uIEFkZGl0aW9uYWwgY2hhaW5lZCB0d2VlbnMsIG1ldGhvZCBjYWxscywgb3IgY2FsbGJhY2tzIGNhbiBiZVxuXHQgKiBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCB0d2VlbiBpbnN0YW5jZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSwgb3ZlcnJpZGUpIHtcblx0XHRpZiAob3ZlcnJpZGUpIHsgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldCk7IH1cblx0XHRyZXR1cm4gbmV3IFR3ZWVuKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyBhbGwgdHdlZW5zLiBUaGlzIHR5cGljYWxseSB1c2VzIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MsIGJ1dCB5b3UgY2FuIGNhbGwgaXRcblx0ICogbWFudWFsbHkgaWYgeW91IHByZWZlciB0byB1c2UgeW91ciBvd24gXCJoZWFydGJlYXRcIiBpbXBsZW1lbnRhdGlvbi5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgY2hhbmdlIGluIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHRpY2suIFJlcXVpcmVkIHVubGVzcyBhbGwgdHdlZW5zIGhhdmVcblx0ICogYHVzZVRpY2tzYCBzZXQgdG8gdHJ1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgYSBnbG9iYWwgcGF1c2UgaXMgaW4gZWZmZWN0LiBUd2VlbnMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGlnbm9yZSB0aGlzLCBidXQgYWxsIG90aGVycyB3aWxsIHBhdXNlIGlmIHRoaXMgaXMgYHRydWVgLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi50aWNrID0gZnVuY3Rpb24oZGVsdGEsIHBhdXNlZCkge1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zLnNsaWNlKCk7IC8vIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cblx0XHRmb3IgKHZhciBpPXR3ZWVucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHRpZiAoKHBhdXNlZCAmJiAhdHdlZW4uaWdub3JlR2xvYmFsUGF1c2UpIHx8IHR3ZWVuLl9wYXVzZWQpIHsgY29udGludWU7IH1cblx0XHRcdHR3ZWVuLnRpY2sodHdlZW4uX3VzZVRpY2tzPzE6ZGVsdGEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGV2ZW50cyB0aGF0IHJlc3VsdCBmcm9tIFR3ZWVuIGJlaW5nIHVzZWQgYXMgYW4gZXZlbnQgaGFuZGxlci4gVGhpcyBpcyBpbmNsdWRlZCB0byBhbGxvdyBUd2VlbiB0byBoYW5kbGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRzIGZyb20gdGhlIGNyZWF0ZWpzIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTm8gb3RoZXIgZXZlbnRzIGFyZSBoYW5kbGVkIGluIFR3ZWVuLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3QgcGFzc2VkIGluIGJ5IHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uIFdpbGxcblx0ICogdXN1YWxseSBiZSBvZiB0eXBlIFwidGlja1wiLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKi9cblx0VHdlZW4uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC50eXBlID09IFwidGlja1wiKSB7XG5cdFx0XHR0aGlzLnRpY2soZXZlbnQuZGVsdGEsIGV2ZW50LnBhdXNlZCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBleGlzdGluZyB0d2VlbnMgZm9yIGEgdGFyZ2V0LiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IG5ldyB0d2VlbnMgaWYgdGhlIGBvdmVycmlkZWBcblx0ICogcHJvcGVydHkgaXMgYHRydWVgLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIHJlbW92ZSBleGlzdGluZyB0d2VlbnMgZnJvbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4ucmVtb3ZlVHdlZW5zID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQudHdlZW5qc19jb3VudCkgeyByZXR1cm47IH1cblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRmb3IgKHZhciBpPXR3ZWVucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHRpZiAodHdlZW4uX3RhcmdldCA9PSB0YXJnZXQpIHtcblx0XHRcdFx0dHdlZW4uX3BhdXNlZCA9IHRydWU7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRhcmdldC50d2VlbmpzX2NvdW50ID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcCBhbmQgcmVtb3ZlIGFsbCBleGlzdGluZyB0d2VlbnMuXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsVHdlZW5zXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRUd2Vlbi5yZW1vdmVBbGxUd2VlbnMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRmb3IgKHZhciBpPSAwLCBsPXR3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNbaV07XG5cdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdHR3ZWVuLnRhcmdldCYmKHR3ZWVuLnRhcmdldC50d2VlbmpzX2NvdW50ID0gMCk7XG5cdFx0fVxuXHRcdHR3ZWVucy5sZW5ndGggPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgKGFuZCBob3cgbWFueSkgb24gdGhlIHRhcmdldCBvYmplY3QgKGlmIHNwZWNpZmllZCkgb3IgaW4gZ2VuZXJhbC5cblx0ICogQG1ldGhvZCBoYXNBY3RpdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIFRoZSB0YXJnZXQgdG8gY2hlY2sgZm9yIGFjdGl2ZSB0d2VlbnMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBpbmRpY2F0ZVxuXHQgKiBpZiB0aGVyZSBhcmUgYW55IGFjdGl2ZSB0d2VlbnMgb24gYW55IHRhcmdldC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlcmUgYXJlIGFjdGl2ZSB0d2VlbnMuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLmhhc0FjdGl2ZVR3ZWVucyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldC50d2VlbmpzX2NvdW50ICE9IG51bGwgJiYgISF0YXJnZXQudHdlZW5qc19jb3VudDsgfVxuXHRcdHJldHVybiBUd2Vlbi5fdHdlZW5zICYmICEhVHdlZW4uX3R3ZWVucy5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluc3RhbGxzIGEgcGx1Z2luLCB3aGljaCBjYW4gbW9kaWZ5IGhvdyBjZXJ0YWluIHByb3BlcnRpZXMgYXJlIGhhbmRsZWQgd2hlbiB0d2VlbmVkLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkNTU1BsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gd3JpdGUgVHdlZW5KUyBwbHVnaW5zLlxuXHQgKiBAbWV0aG9kIGluc3RhbGxQbHVnaW5cblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzIEFuIGFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCB0aGUgcGx1Z2luIHdpbGwgaGFuZGxlLlxuXHQgKi9cblx0VHdlZW4uaW5zdGFsbFBsdWdpbiA9IGZ1bmN0aW9uKHBsdWdpbiwgcHJvcGVydGllcykge1xuXHRcdHZhciBwcmlvcml0eSA9IHBsdWdpbi5wcmlvcml0eTtcblx0XHRpZiAocHJpb3JpdHkgPT0gbnVsbCkgeyBwbHVnaW4ucHJpb3JpdHkgPSBwcmlvcml0eSA9IDA7IH1cblx0XHRmb3IgKHZhciBpPTAsbD1wcm9wZXJ0aWVzLmxlbmd0aCxwPVR3ZWVuLl9wbHVnaW5zO2k8bDtpKyspIHtcblx0XHRcdHZhciBuID0gcHJvcGVydGllc1tpXTtcblx0XHRcdGlmICghcFtuXSkgeyBwW25dID0gW3BsdWdpbl07IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJyID0gcFtuXTtcblx0XHRcdFx0Zm9yICh2YXIgaj0wLGpsPWFyci5sZW5ndGg7ajxqbDtqKyspIHtcblx0XHRcdFx0XHRpZiAocHJpb3JpdHkgPCBhcnJbal0ucHJpb3JpdHkpIHsgYnJlYWs7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwW25dLnNwbGljZShqLDAscGx1Z2luKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBvciB1bnJlZ2lzdGVycyBhIHR3ZWVuIHdpdGggdGhlIHRpY2tpbmcgc3lzdGVtLlxuXHQgKiBAbWV0aG9kIF9yZWdpc3RlclxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gaW5zdGFuY2UgdG8gcmVnaXN0ZXIgb3IgdW5yZWdpc3Rlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiBgdHJ1ZWAsIHRoZSB0d2VlbiBpcyByZWdpc3RlcmVkLiBJZiBgZmFsc2VgIHRoZSB0d2VlbiBpcyB1bnJlZ2lzdGVyZWQuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0VHdlZW4uX3JlZ2lzdGVyID0gZnVuY3Rpb24odHdlZW4sIHZhbHVlKSB7XG5cdFx0dmFyIHRhcmdldCA9IHR3ZWVuLl90YXJnZXQ7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0aWYgKHZhbHVlICYmICF0d2Vlbi5fcmVnaXN0ZXJlZCkge1xuXHRcdFx0Ly8gVE9ETzogdGhpcyBhcHByb2FjaCBtaWdodCBmYWlsIGlmIGEgZGV2IGlzIHVzaW5nIHNlYWxlZCBvYmplY3RzIGluIEVTNVxuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudCA9IHRhcmdldC50d2VlbmpzX2NvdW50ID8gdGFyZ2V0LnR3ZWVuanNfY291bnQrMSA6IDE7IH1cblx0XHRcdHR3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHRcdGlmICghVHdlZW4uX2luaXRlZCAmJiBjcmVhdGVqcy5UaWNrZXIpIHsgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIFR3ZWVuKTsgVHdlZW4uX2luaXRlZCA9IHRydWU7IH1cblx0XHR9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0d2Vlbi5fcmVnaXN0ZXJlZCkge1xuXHRcdFx0aWYgKHRhcmdldCkgeyB0YXJnZXQudHdlZW5qc19jb3VudC0tOyB9XG5cdFx0XHR2YXIgaSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0gPT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHR3ZWVuLl9yZWdpc3RlcmVkID0gdmFsdWU7XG5cdH07XG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0d2VlbidzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqKi9cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUXVldWVzIGEgd2FpdCAoZXNzZW50aWFsbHkgYW4gZW1wdHkgdHdlZW4pLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdC8vVGhpcyB0d2VlbiB3aWxsIHdhaXQgMXMgYmVmb3JlIGFscGhhIGlzIGZhZGVkIHRvIDAuXG5cdCAqXHRcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLndhaXQoMTAwMCkudG8oe2FscGhhOjB9LCAxMDAwKTtcblx0ICpcblx0ICogQG1ldGhvZCB3YWl0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHdhaXQgaW4gbWlsbGlzZWNvbmRzIChvciBpbiB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXNzaXZlXSBUd2VlbiBwcm9wZXJ0aWVzIHdpbGwgbm90IGJlIHVwZGF0ZWQgZHVyaW5nIGEgcGFzc2l2ZSB3YWl0LiBUaGlzXG5cdCAqIGlzIG1vc3RseSB1c2VmdWwgZm9yIHVzZSB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0aGF0IGNvbnRhaW4gbXVsdGlwbGUgdHdlZW5zXG5cdCAqIGFmZmVjdGluZyB0aGUgc2FtZSB0YXJnZXQgYXQgZGlmZmVyZW50IHRpbWVzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICoqL1xuXHRwLndhaXQgPSBmdW5jdGlvbihkdXJhdGlvbiwgcGFzc2l2ZSkge1xuXHRcdGlmIChkdXJhdGlvbiA9PSBudWxsIHx8IGR1cmF0aW9uIDw9IDApIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YXIgbyA9IHRoaXMuX2Nsb25lUHJvcHModGhpcy5fY3VyUXVldWVQcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZFN0ZXAoe2Q6ZHVyYXRpb24sIHAwOm8sIGU6dGhpcy5fbGluZWFyRWFzZSwgcDE6bywgdjpwYXNzaXZlfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhIHR3ZWVuIGZyb20gdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoZSB0YXJnZXQgcHJvcGVydGllcy4gU2V0IGR1cmF0aW9uIHRvIDAgdG8ganVtcCB0byB0aGVzZSB2YWx1ZS5cblx0ICogTnVtZXJpYyBwcm9wZXJ0aWVzIHdpbGwgYmUgdHdlZW5lZCBmcm9tIHRoZWlyIGN1cnJlbnQgdmFsdWUgaW4gdGhlIHR3ZWVuIHRvIHRoZSB0YXJnZXQgdmFsdWUuIE5vbi1udW1lcmljXG5cdCAqIHByb3BlcnRpZXMgd2lsbCBiZSBzZXQgYXQgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHthbHBoYTowfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgdG9cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHByb3BlcnR5IHRhcmdldCB2YWx1ZXMgZm9yIHRoaXMgdHdlZW4gKEV4LiBge3g6MzAwfWAgd291bGQgdHdlZW4gdGhlIHhcblx0ICogcHJvcGVydHkgb2YgdGhlIHRhcmdldCB0byAzMDApLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgd2FpdCBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtlYXNlPVwibGluZWFyXCJdIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciB0aGlzIHR3ZWVuLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIkVhc2VcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdCBvZiBidWlsdC1pbiBlYXNlIGZ1bmN0aW9ucy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnRvID0gZnVuY3Rpb24ocHJvcHMsIGR1cmF0aW9uLCBlYXNlKSB7XG5cdFx0aWYgKGlzTmFOKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA8IDApIHsgZHVyYXRpb24gPSAwOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2FkZFN0ZXAoe2Q6ZHVyYXRpb258fDAsIHAwOnRoaXMuX2Nsb25lUHJvcHModGhpcy5fY3VyUXVldWVQcm9wcyksIGU6ZWFzZSwgcDE6dGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9hcHBlbmRRdWV1ZVByb3BzKHByb3BzKSl9KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICBcdC8vd291bGQgY2FsbCBteUZ1bmN0aW9uKCkgYWZ0ZXIgMSBzZWNvbmQuXG5cdCAqICAgXHRteVR3ZWVuLndhaXQoMTAwMCkuY2FsbChteUZ1bmN0aW9uKTtcblx0ICpcblx0ICogQG1ldGhvZCBjYWxsXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcGFyYW1zXS4gVGhlIHBhcmFtZXRlcnMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aC4gSWYgdGhpcyBpcyBvbWl0dGVkLCB0aGVuIHRoZSBmdW5jdGlvblxuXHQgKiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBzaW5nbGUgcGFyYW0gcG9pbnRpbmcgdG8gdGhpcyB0d2Vlbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0uIFRoZSBzY29wZSB0byBjYWxsIHRoZSBmdW5jdGlvbiBpbi4gSWYgb21pdHRlZCwgaXQgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIHRhcmdldCdzXG5cdCAqICAgICAgc2NvcGUuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHtmOmNhbGxiYWNrLCBwOnBhcmFtcyA/IHBhcmFtcyA6IFt0aGlzXSwgbzpzY29wZSA/IHNjb3BlIDogdGhpcy5fdGFyZ2V0fSk7XG5cdH07XG5cblx0Ly8gVE9ETzogYWRkIGNsYXJpZmljYXRpb24gYmV0d2VlbiB0aGlzIGFuZCBhIDAgZHVyYXRpb24gLnRvOlxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBzZXQgdGhlIHNwZWNpZmllZCBwcm9wcyBvbiB0aGUgc3BlY2lmaWVkIHRhcmdldC4gSWYgdGFyZ2V0IGlzIG51bGwsIGl0IHdpbGwgdXNlIHRoaXMgdHdlZW4nc1xuXHQgKiB0YXJnZXQuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0bXlUd2Vlbi53YWl0KDEwMDApLnNldCh7dmlzaWJsZTpmYWxzZX0sZm9vKTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIHRvIHNldCAoZXguIGB7dmlzaWJsZTpmYWxzZX1gKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIFRoZSB0YXJnZXQgdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIG9uLiBJZiBvbWl0dGVkLCB0aGV5IHdpbGwgYmUgc2V0IG9uIHRoZSB0d2VlbidzIHRhcmdldC5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzLCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkQWN0aW9uKHtmOnRoaXMuX3NldCwgbzp0aGlzLCBwOltwcm9wcywgdGFyZ2V0ID8gdGFyZ2V0IDogdGhpcy5fdGFyZ2V0XX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHBsYXkgKHVucGF1c2UpIHRoZSBzcGVjaWZpZWQgdHdlZW4uIFRoaXMgZW5hYmxlcyB5b3UgdG8gc2VxdWVuY2UgbXVsdGlwbGUgdHdlZW5zLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdG15VHdlZW4udG8oe3g6MTAwfSw1MDApLnBsYXkob3RoZXJUd2Vlbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gdG8gcGxheS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdGlmICghdHdlZW4pIHsgdHdlZW4gPSB0aGlzOyB9XG5cdFx0cmV0dXJuIHRoaXMuY2FsbCh0d2Vlbi5zZXRQYXVzZWQsIFtmYWxzZV0sIHR3ZWVuKTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBwYXVzZSB0aGUgc3BlY2lmaWVkIHR3ZWVuLlxuXHQgKiBAbWV0aG9kIHBhdXNlXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiB0byBwYXVzZS4gSWYgbnVsbCwgaXQgcGF1c2VzIHRoaXMgdHdlZW4uXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpXG5cdCAqL1xuXHRwLnBhdXNlID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRpZiAoIXR3ZWVuKSB7IHR3ZWVuID0gdGhpczsgfVxuXHRcdHJldHVybiB0aGlzLmNhbGwodHdlZW4uc2V0UGF1c2VkLCBbdHJ1ZV0sIHR3ZWVuKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHR3ZWVuIHRvIGEgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FjdGlvbnNNb2RlPTFdIFNwZWNpZmllcyBob3cgYWN0aW9ucyBhcmUgaGFuZGxlZCAoaWUuIGNhbGwsIHNldCwgcGxheSwgcGF1c2UpOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL05PTkU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDApIC0gcnVuIG5vIGFjdGlvbnMuPC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vTE9PUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMSkgLSBpZiBuZXcgcG9zaXRpb24gaXMgbGVzcyB0aGFuIG9sZCwgdGhlbiBydW4gYWxsXG5cdCAqICAgICAgYWN0aW9ucyBiZXR3ZWVuIG9sZCBhbmQgZHVyYXRpb24sIHRoZW4gYWxsIGFjdGlvbnMgYmV0d2VlbiAwIGFuZCBuZXcuPC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vUkVWRVJTRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMikgLSBpZiBuZXcgcG9zaXRpb24gaXMgbGVzcyB0aGFuIG9sZCwgcnVuIGFsbFxuXHQgKiAgICAgIGFjdGlvbnMgYmV0d2VlbiB0aGVtIGluIHJldmVyc2UuPC9saT5cblx0ICogPC91bD5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3ZWVuIGlzIGNvbXBsZXRlIChpZS4gdGhlIGZ1bGwgdHdlZW4gaGFzIHJ1biAmIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYGZhbHNlYCkuXG5cdCAqL1xuXHRwLnNldFBvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIGFjdGlvbnNNb2RlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyB2YWx1ZSA9IDA7IH1cblx0XHRpZiAoYWN0aW9uc01vZGUgPT0gbnVsbCkgeyBhY3Rpb25zTW9kZSA9IDE7IH1cblxuXHRcdC8vIG5vcm1hbGl6ZSBwb3NpdGlvbjpcblx0XHR2YXIgdCA9IHZhbHVlO1xuXHRcdHZhciBlbmQgPSBmYWxzZTtcblx0XHRpZiAodCA+PSB0aGlzLmR1cmF0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5sb29wKSB7IHQgPSB0JXRoaXMuZHVyYXRpb247IH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0ID0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHQgPT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZW5kOyB9XG5cblxuXHRcdHZhciBwcmV2UG9zID0gdGhpcy5fcHJldlBvcztcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIHNldCB0aGlzIGluIGFkdmFuY2UgaW4gY2FzZSBhbiBhY3Rpb24gbW9kaWZpZXMgcG9zaXRpb24uXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gdmFsdWU7XG5cblx0XHQvLyBoYW5kbGUgdHdlZW5zOlxuXHRcdGlmICh0aGlzLl90YXJnZXQpIHtcblx0XHRcdGlmIChlbmQpIHtcblx0XHRcdFx0Ly8gYWRkcmVzc2VzIHByb2JsZW1zIHdpdGggYW4gZW5kaW5nIHplcm8gbGVuZ3RoIHN0ZXAuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRhcmdldFByb3BzKG51bGwsMSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3N0ZXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gZmluZCBvdXIgbmV3IHR3ZWVuIGluZGV4OlxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5fc3RlcHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGVwc1tpXS50ID4gdCkgeyBicmVhazsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGVwID0gdGhpcy5fc3RlcHNbaS0xXTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMoc3RlcCwodGhpcy5fc3RlcFBvc2l0aW9uID0gdC1zdGVwLnQpL3N0ZXAuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcnVuIGFjdGlvbnM6XG5cdFx0aWYgKGFjdGlvbnNNb2RlICE9IDAgJiYgdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAodGhpcy5fdXNlVGlja3MpIHtcblx0XHRcdFx0Ly8gb25seSBydW4gdGhlIGFjdGlvbnMgd2UgbGFuZGVkIG9uLlxuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKHQsdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGFjdGlvbnNNb2RlID09IDEgJiYgdDxwcmV2UG9zKSB7XG5cdFx0XHRcdGlmIChwcmV2UG9zICE9IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5fcnVuQWN0aW9ucyhwcmV2UG9zLCB0aGlzLmR1cmF0aW9uKTsgfVxuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKDAsIHQsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucyhwcmV2UG9zLCB0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdHdlZW4gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBUaGlzIGlzIG5vcm1hbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBUd2VlbiBlbmdpbmUgKHZpYSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90aWNrXCJ9fXt7L2Nyb3NzTGlua319KSwgYnV0IGlzXG5cdCAqIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgdG8gYWR2YW5jZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICovXG5cdHAudGljayA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHR3ZWVuLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWx1ZT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHdlZW4gc2hvdWxkIGJlIHBhdXNlZCAoYHRydWVgKSBvciBwbGF5ZWQgKGBmYWxzZWApLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKVxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9wYXVzZWQgPT09ICEhdmFsdWUpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9wYXVzZWQgPSAhIXZhbHVlO1xuXHRcdFR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vIHRpbnkgYXBpIChwcmltYXJpbHkgZm9yIHRvb2wgb3V0cHV0KTpcblx0cC53ID0gcC53YWl0O1xuXHRwLnQgPSBwLnRvO1xuXHRwLmMgPSBwLmNhbGw7XG5cdHAucyA9IHAuc2V0O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUd2Vlbl1cIjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUd2VlbiBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlVGFyZ2V0UHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0ZXBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3VwZGF0ZVRhcmdldFByb3BzID0gZnVuY3Rpb24oc3RlcCwgcmF0aW8pIHtcblx0XHR2YXIgcDAscDEsdix2MCx2MSxhcnI7XG5cdFx0aWYgKCFzdGVwICYmIHJhdGlvID09IDEpIHtcblx0XHRcdC8vIEdEUzogd2hlbiBkb2VzIHRoaXMgcnVuPyBKdXN0IGF0IHRoZSB2ZXJ5IGVuZD8gU2hvdWxkbid0LlxuXHRcdFx0dGhpcy5wYXNzaXZlID0gZmFsc2U7XG5cdFx0XHRwMCA9IHAxID0gdGhpcy5fY3VyUXVldWVQcm9wcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wYXNzaXZlID0gISFzdGVwLnY7XG5cdFx0XHRpZiAodGhpcy5wYXNzaXZlKSB7IHJldHVybjsgfSAvLyBkb24ndCB1cGRhdGUgcHJvcHMuXG5cdFx0XHQvLyBhcHBseSBlYXNlIHRvIHJhdGlvLlxuXHRcdFx0aWYgKHN0ZXAuZSkgeyByYXRpbyA9IHN0ZXAuZShyYXRpbywwLDEsMSk7IH1cblx0XHRcdHAwID0gc3RlcC5wMDtcblx0XHRcdHAxID0gc3RlcC5wMTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2luaXRRdWV1ZVByb3BzKSB7XG5cdFx0XHRpZiAoKHYwID0gcDBbbl0pID09IG51bGwpIHsgcDBbbl0gPSB2MCA9IHRoaXMuX2luaXRRdWV1ZVByb3BzW25dOyB9XG5cdFx0XHRpZiAoKHYxID0gcDFbbl0pID09IG51bGwpIHsgcDFbbl0gPSB2MSA9IHYwOyB9XG5cdFx0XHRpZiAodjAgPT0gdjEgfHwgcmF0aW8gPT0gMCB8fCByYXRpbyA9PSAxIHx8ICh0eXBlb2YodjApICE9IFwibnVtYmVyXCIpKSB7XG5cdFx0XHRcdC8vIG5vIGludGVycG9sYXRpb24gLSBlaXRoZXIgYXQgc3RhcnQsIGVuZCwgdmFsdWVzIGRvbid0IGNoYW5nZSwgb3IgdGhlIHZhbHVlIGlzIG5vbi1udW1lcmljLlxuXHRcdFx0XHR2ID0gcmF0aW8gPT0gMSA/IHYxIDogdjA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2ID0gdjArKHYxLXYwKSpyYXRpbztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlnbm9yZSA9IGZhbHNlO1xuXHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdHZhciB2MiA9IGFycltpXS50d2Vlbih0aGlzLCBuLCB2LCBwMCwgcDEsIHJhdGlvLCAhIXN0ZXAmJnAwPT1wMSwgIXN0ZXApO1xuXHRcdFx0XHRcdGlmICh2MiA9PSBUd2Vlbi5JR05PUkUpIHsgaWdub3JlID0gdHJ1ZTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB2ID0gdjI7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFpZ25vcmUpIHsgdGhpcy5fdGFyZ2V0W25dID0gdjsgfVxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9ydW5BY3Rpb25zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZVN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3J1bkFjdGlvbnMgPSBmdW5jdGlvbihzdGFydFBvcywgZW5kUG9zLCBpbmNsdWRlU3RhcnQpIHtcblx0XHR2YXIgc1BvcyA9IHN0YXJ0UG9zO1xuXHRcdHZhciBlUG9zID0gZW5kUG9zO1xuXHRcdHZhciBpID0gLTE7XG5cdFx0dmFyIGogPSB0aGlzLl9hY3Rpb25zLmxlbmd0aDtcblx0XHR2YXIgayA9IDE7XG5cdFx0aWYgKHN0YXJ0UG9zID4gZW5kUG9zKSB7XG5cdFx0XHQvLyBydW5uaW5nIGJhY2t3YXJkcywgZmxpcCBldmVyeXRoaW5nOlxuXHRcdFx0c1BvcyA9IGVuZFBvcztcblx0XHRcdGVQb3MgPSBzdGFydFBvcztcblx0XHRcdGkgPSBqO1xuXHRcdFx0aiA9IGsgPSAtMTtcblx0XHR9XG5cdFx0d2hpbGUgKChpKz1rKSAhPSBqKSB7XG5cdFx0XHR2YXIgYWN0aW9uID0gdGhpcy5fYWN0aW9uc1tpXTtcblx0XHRcdHZhciBwb3MgPSBhY3Rpb24udDtcblx0XHRcdGlmIChwb3MgPT0gZVBvcyB8fCAocG9zID4gc1BvcyAmJiBwb3MgPCBlUG9zKSB8fCAoaW5jbHVkZVN0YXJ0ICYmIHBvcyA9PSBzdGFydFBvcykgKSB7XG5cdFx0XHRcdGFjdGlvbi5mLmFwcGx5KGFjdGlvbi5vLCBhY3Rpb24ucCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBlbmRRdWV1ZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FwcGVuZFF1ZXVlUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dmFyIGFycixvbGRWYWx1ZSxpLCBsLCBpbmplY3RQcm9wcztcblx0XHRmb3IgKHZhciBuIGluIG8pIHtcblx0XHRcdGlmICh0aGlzLl9pbml0UXVldWVQcm9wc1tuXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9sZFZhbHVlID0gdGhpcy5fdGFyZ2V0W25dO1xuXG5cdFx0XHRcdC8vIGluaXQgcGx1Z2luczpcblx0XHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdFx0Zm9yIChpPTAsbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHRcdG9sZFZhbHVlID0gYXJyW2ldLmluaXQodGhpcywgbiwgb2xkVmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pbml0UXVldWVQcm9wc1tuXSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl0gPSAob2xkVmFsdWU9PT11bmRlZmluZWQpID8gbnVsbCA6IG9sZFZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkVmFsdWUgPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0b2xkVmFsdWUgPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dO1xuXHRcdFx0aWYgKGFyciA9IFR3ZWVuLl9wbHVnaW5zW25dKSB7XG5cdFx0XHRcdGluamVjdFByb3BzID0gaW5qZWN0UHJvcHN8fHt9O1xuXHRcdFx0XHRmb3IgKGk9MCwgbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHQvLyBUT0RPOiByZW1vdmUgdGhlIGNoZWNrIGZvciAuc3RlcCBpbiB0aGUgbmV4dCB2ZXJzaW9uLiBJdCdzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdGlmIChhcnJbaV0uc3RlcCkgeyBhcnJbaV0uc3RlcCh0aGlzLCBuLCBvbGRWYWx1ZSwgb1tuXSwgaW5qZWN0UHJvcHMpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2N1clF1ZXVlUHJvcHNbbl0gPSBvW25dO1xuXHRcdH1cblx0XHRpZiAoaW5qZWN0UHJvcHMpIHsgdGhpcy5fYXBwZW5kUXVldWVQcm9wcyhpbmplY3RQcm9wcyk7IH1cblx0XHRyZXR1cm4gdGhpcy5fY3VyUXVldWVQcm9wcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRvW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hZGRTdGVwXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FkZFN0ZXAgPSBmdW5jdGlvbihvKSB7XG5cdFx0aWYgKG8uZCA+IDApIHtcblx0XHRcdHRoaXMuX3N0ZXBzLnB1c2gobyk7XG5cdFx0XHRvLnQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiArPSBvLmQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hZGRBY3Rpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkQWN0aW9uID0gZnVuY3Rpb24obykge1xuXHRcdG8udCA9IHRoaXMuZHVyYXRpb247XG5cdFx0dGhpcy5fYWN0aW9ucy5wdXNoKG8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NldCA9IGZ1bmN0aW9uKHByb3BzLCBvKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0b1tuXSA9IHByb3BzW25dO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5Ud2VlbiA9IGNyZWF0ZWpzLnByb21vdGUoVHdlZW4sIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGltZWxpbmUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXG4vLyBjb25zdHJ1Y3Rvclx0XG5cdC8qKlxuXHQgKiBUaGUgVGltZWxpbmUgY2xhc3Mgc3luY2hyb25pemVzIG11bHRpcGxlIHR3ZWVucyBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgY29udHJvbGxlZCBhcyBhIGdyb3VwLiBQbGVhc2Ugbm90ZSB0aGF0IGlmIGFcblx0ICogdGltZWxpbmUgaXMgbG9vcGluZywgdGhlIHR3ZWVucyBvbiBpdCBtYXkgYXBwZWFyIHRvIGxvb3AgZXZlbiBpZiB0aGUgXCJsb29wXCIgcHJvcGVydHkgb2YgdGhlIHR3ZWVuIGlzIGZhbHNlLlxuXHQgKiBAY2xhc3MgVGltZWxpbmVcblx0ICogQHBhcmFtIHtBcnJheX0gdHdlZW5zIEFuIGFycmF5IG9mIFR3ZWVucyB0byBhZGQgdG8gdGhpcyB0aW1lbGluZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2FkZFR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9zZXRMYWJlbHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZX1gKS4gQWxsIHByb3BlcnRpZXNcblx0ICogZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUgaWdub3JlR2xvYmFsUGF1c2UgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdGltZWxpbmUuPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgdG8gYWRkIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBUaW1lbGluZSh0d2VlbnMsIGxhYmVscywgcHJvcHMpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHRpbWVsaW5lIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0aW1lbGluZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrcyBgaXMgYHRydWVgKS4gVGhpcyB2YWx1ZSBpcyB1c3VhbGx5XG5cdFx0ICogYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvdXBkYXRlRHVyYXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHRpbWVsaW5lIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHdlZW5zXG5cdFx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl90d2VlbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbHMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbExpc3Rcblx0XHQgKiBAdHlwZSBBcnJheVtPYmplY3RdXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbExpc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVsaW5lIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0fVxuXHRcdGlmICh0d2VlbnMpIHsgdGhpcy5hZGRUd2Vlbi5hcHBseSh0aGlzLCB0d2VlbnMpOyB9XG5cdFx0dGhpcy5zZXRMYWJlbHMobGFiZWxzKTtcblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgY3JlYXRlanMuVHdlZW4uTk9ORSk7IH1cblx0XHRcblx0fTtcblx0XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRpbWVsaW5lLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0aW1lbGluZSdzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNS4wXG5cdCAqKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgb25lIG9yIG1vcmUgdHdlZW5zIChvciB0aW1lbGluZXMpIHRvIHRoaXMgdGltZWxpbmUuIFRoZSB0d2VlbnMgd2lsbCBiZSBwYXVzZWQgKHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlXG5cdCAqIG5vcm1hbCB0aWNraW5nIHN5c3RlbSkgYW5kIG1hbmFnZWQgYnkgdGhpcyB0aW1lbGluZS4gQWRkaW5nIGEgdHdlZW4gdG8gbXVsdGlwbGUgdGltZWxpbmVzIHdpbGwgcmVzdWx0IGluXG5cdCAqIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKiBAbWV0aG9kIGFkZFR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byBhZGQuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhlIGZpcnN0IHR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICoqL1xuXHRwLmFkZFR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHRoaXMucmVtb3ZlVHdlZW4odHdlZW4pO1xuXHRcdHRoaXMuX3R3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHR0d2Vlbi5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0dHdlZW4uX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHR3ZWVuLl91c2VUaWNrcyA9IHRoaXMuX3VzZVRpY2tzO1xuXHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5kdXJhdGlvbiA9IHR3ZWVuLmR1cmF0aW9uOyB9XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPj0gMCkgeyB0d2Vlbi5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBvbmUgb3IgbW9yZSB0d2VlbnMgZnJvbSB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byByZW1vdmUuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIG9mIHRoZSB0d2VlbnMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fSBlbHNlIGlmIChsID09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgdHdlZW5zID0gdGhpcy5fdHdlZW5zO1xuXHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+PSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMudXBkYXRlRHVyYXRpb24oKTsgfVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGFkZExhYmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgbmFtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0aGlzIGxhYmVsIHJlcHJlc2VudHMuXG5cdCAqKi9cblx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSBwb3NpdGlvbjtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAobGlzdCkge1xuXHRcdFx0Zm9yICh2YXIgaT0gMCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykgeyBpZiAocG9zaXRpb24gPCBsaXN0W2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdGxpc3Quc3BsaWNlKGksIDAsIHtsYWJlbDpsYWJlbCwgcG9zaXRpb246cG9zaXRpb259KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmluZXMgbGFiZWxzIGZvciB1c2Ugd2l0aCBnb3RvQW5kUGxheS9TdG9wLiBPdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5IHNldCBsYWJlbHMuXG5cdCAqIEBtZXRob2Qgc2V0TGFiZWxzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvIEFuIG9iamVjdCBkZWZpbmluZyBsYWJlbHMgZm9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluIHRoZSBmb3JtIGB7bGFiZWxOYW1lOnRpbWV9YCB3aGVyZSB0aW1lIGlzIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiovXG5cdHAuc2V0TGFiZWxzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuX2xhYmVscyA9IG8gPyAgbyA6IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGxhYmVscyBkZWZpbmVkIG9uIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5W09iamVjdF19IEEgc29ydGVkIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmICghbGlzdCkge1xuXHRcdFx0bGlzdCA9IHRoaXMuX2xhYmVsTGlzdCA9IFtdO1xuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuX2xhYmVscztcblx0XHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7bGFiZWw6biwgcG9zaXRpb246bGFiZWxzW25dfSk7XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS5wb3NpdGlvbi0gYi5wb3NpdGlvbjsgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHRpbWVsaW5lIHdpdGhcblx0ICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGdldEN1cnJlbnRMYWJlbCB3b3VsZCByZXR1cm46XG5cdCAqIDxVTD5cblx0ICogXHRcdDxMST5udWxsIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDIuPC9MST5cblx0ICogXHRcdDxMST5cImZpcnN0XCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgNC48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA3LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJzZWNvbmRcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAxNS48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGxhYmVsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbGFiZWxcblx0ICoqL1xuXHRwLmdldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXHRcdHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHZhciBsID0gbGFiZWxzLmxlbmd0aDtcblx0XHRpZiAobCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGk8bDsgaSsrKSB7IGlmIChwb3MgPCBsYWJlbHNbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0cmV0dXJuIChpPT0wKSA/IG51bGwgOiBsYWJlbHNbaS0xXS5sYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVucGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApXG5cdCAqIG9yIGxhYmVsIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKSBvciBsYWJlbFxuXHQgKiB0byBqdW1wIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0aW1lbGluZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZV0gcGFyYW1ldGVyIHNwZWNpZnlpbmcgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vc2V0UG9zaXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBtb3JlIGRldGFpbHMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aW1lbGluZSBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHRpbWVsaW5lIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKiovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHR2YXIgdCA9IHRoaXMuX2NhbGNQb3NpdGlvbih2YWx1ZSk7XG5cdFx0dmFyIGVuZCA9ICF0aGlzLmxvb3AgJiYgdmFsdWUgPj0gdGhpcy5kdXJhdGlvbjtcblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIGluIGNhc2UgYW4gYWN0aW9uIGNoYW5nZXMgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLl90d2VlbnNbaV0uc2V0UG9zaXRpb24odCwgYWN0aW9uc01vZGUpO1xuXHRcdFx0aWYgKHQgIT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZmFsc2U7IH0gLy8gYW4gYWN0aW9uIGNoYW5nZWQgdGhpcyB0aW1lbGluZSdzIHBvc2l0aW9uLlxuXHRcdH1cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7IFxuXHRcdGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWNhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lbGluZS4gVGhlIGR1cmF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIHR3ZWVucyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCxcblx0ICogYnV0IHRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbW9kaWZ5IGEgdHdlZW4gYWZ0ZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS5cblx0ICogQG1ldGhvZCB1cGRhdGVEdXJhdGlvblxuXHQgKiovXG5cdHAudXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XHRmb3IgKHZhciBpPTAsbD10aGlzLl90d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdGltZWxpbmUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQpLCBidXQgaXMgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIGEgbnVtZXJpYyBwb3NpdGlvbiBpcyBwYXNzZWQsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgcG9zaXRpb24gb2YgdGhlXG5cdCAqIGNvcnJlc3BvbmRpbmcgZnJhbWUgbGFiZWwgd2lsbCBiZSByZXR1cm5lZCwgb3IgYG51bGxgIGlmIGEgbWF0Y2hpbmcgbGFiZWwgaXMgbm90IGRlZmluZWQuXG5cdCAqIEBtZXRob2QgcmVzb2x2ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBBIG51bWVyaWMgcG9zaXRpb24gdmFsdWUgb3IgbGFiZWwgc3RyaW5nLlxuXHQgKiovXG5cdHAucmVzb2x2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSBOdW1iZXIocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAoaXNOYU4ocG9zKSkgeyBwb3MgPSB0aGlzLl9sYWJlbHNbcG9zaXRpb25PckxhYmVsXTsgfVxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0KiBAbWV0aG9kIHRvU3RyaW5nXG5cdCogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RpbWVsaW5lXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUaW1lbGluZSBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcG9zaXRpb25PckxhYmVsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBvcyk7IH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjUG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGNQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyByZXR1cm4gMDsgfVxuXHRcdGlmICh2YWx1ZSA8IHRoaXMuZHVyYXRpb24pIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHRoaXMubG9vcCA/IHZhbHVlJXRoaXMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlRpbWVsaW5lID0gY3JlYXRlanMucHJvbW90ZShUaW1lbGluZSwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFYXNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgRWFzZSBjbGFzcyBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggVHdlZW5KUy4gSXQgZG9lcyBub3QgdXNlIHRoZSBzdGFuZGFyZCA0IHBhcmFtXG5cdCAqIGVhc2luZyBzaWduYXR1cmUuIEluc3RlYWQgaXQgdXNlcyBhIHNpbmdsZSBwYXJhbSB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgbGluZWFyIHJhdGlvICgwIHRvIDEpIG9mIHRoZSB0d2Vlbi5cblx0ICpcblx0ICogTW9zdCBtZXRob2RzIG9uIEVhc2UgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSBhcyBlYXNpbmcgZnVuY3Rpb25zOlxuXHQgKlxuXHQgKiAgICAgIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHt4OjEwMH0sIDUwMCwgRWFzZS5saW5lYXIpO1xuXHQgKlxuXHQgKiBIb3dldmVyLCBtZXRob2RzIGJlZ2lubmluZyB3aXRoIFwiZ2V0XCIgd2lsbCByZXR1cm4gYW4gZWFzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHBhcmFtZXRlciB2YWx1ZXM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3k6MjAwfSwgNTAwLCBFYXNlLmdldFBvd0luKDIuMikpO1xuXHQgKlxuXHQgKiBQbGVhc2Ugc2VlIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy5jcmVhdGVqcy5jb20vRGVtb3MvVHdlZW5KUy9Ud2Vlbl9TcGFya1RhYmxlXCI+c3BhcmsgdGFibGUgZGVtbzwvYT4gZm9yIGFuXG5cdCAqIG92ZXJ2aWV3IG9mIHRoZSBkaWZmZXJlbnQgZWFzZSB0eXBlcyBvbiA8YSBocmVmPVwiaHR0cDovL3R3ZWVuanMuY29tXCI+VHdlZW5KUy5jb208L2E+LlxuXHQgKlxuXHQgKiA8ZW0+RXF1YXRpb25zIGRlcml2ZWQgZnJvbSB3b3JrIGJ5IFJvYmVydCBQZW5uZXIuPC9lbT5cblx0ICogQGNsYXNzIEVhc2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIEVhc2UoKSB7XG5cdFx0dGhyb3cgXCJFYXNlIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCI7XG5cdH1cblxuXG4vLyBzdGF0aWMgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHQvKipcblx0ICogQG1ldGhvZCBsaW5lYXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5saW5lYXIgPSBmdW5jdGlvbih0KSB7IHJldHVybiB0OyB9O1xuXG5cdC8qKlxuXHQgKiBJZGVudGljYWwgdG8gbGluZWFyLlxuXHQgKiBAbWV0aG9kIG5vbmVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ub25lID0gRWFzZS5saW5lYXI7XG5cblx0LyoqXG5cdCAqIE1pbWljcyB0aGUgc2ltcGxlIC0xMDAgdG8gMTAwIGVhc2luZyBpbiBGbGFzaCBQcm8uXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQSB2YWx1ZSBmcm9tIC0xIChlYXNlIGluKSB0byAxIChlYXNlIG91dCkgaW5kaWNhdGluZyB0aGUgc3RyZW5ndGggYW5kIGRpcmVjdGlvbiBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdGlmIChhbW91bnQgPCAtMSkgeyBhbW91bnQgPSAtMTsgfVxuXHRcdGlmIChhbW91bnQgPiAxKSB7IGFtb3VudCA9IDE7IH1cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKGFtb3VudD09MCkgeyByZXR1cm4gdDsgfVxuXHRcdFx0aWYgKGFtb3VudDwwKSB7IHJldHVybiB0Kih0Ki1hbW91bnQrMSthbW91bnQpOyB9XG5cdFx0XHRyZXR1cm4gdCooKDItdCkqYW1vdW50KygxLWFtb3VudCkpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbiA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3codCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93T3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxLU1hdGgucG93KDEtdCxwb3cpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBleHBvbmVudGlhbCBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldFBvd0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dJbk91dCA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqTWF0aC5wb3codCxwb3cpO1xuXHRcdFx0cmV0dXJuIDEtMC41Kk1hdGguYWJzKE1hdGgucG93KDItdCxwb3cpKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbiA9IEVhc2UuZ2V0UG93SW4oMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkT3V0ID0gRWFzZS5nZXRQb3dPdXQoMik7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YWRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoMik7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW4gPSBFYXNlLmdldFBvd0luKDMpO1xuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljT3V0ID0gRWFzZS5nZXRQb3dPdXQoMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY0luT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgzKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbiA9IEVhc2UuZ2V0UG93SW4oNCk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRPdXQgPSBFYXNlLmdldFBvd091dCg0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0SW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDQpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluID0gRWFzZS5nZXRQb3dJbig1KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludE91dCA9IEVhc2UuZ2V0UG93T3V0KDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNSk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLU1hdGguY29zKHQqTWF0aC5QSS8yKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluXCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW4gPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja0luID0gRWFzZS5nZXRCYWNrSW4oMS43KTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBvdXRcIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAoLS10KnQqKChhbW91bnQrMSkqdCArIGFtb3VudCkgKyAxKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja091dCA9IEVhc2UuZ2V0QmFja091dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIGluIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja0luT3V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0YW1vdW50Kj0xLjUyNTtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gMC41Kih0KnQqKChhbW91bnQrMSkqdC1hbW91bnQpKTtcblx0XHRcdHJldHVybiAwLjUqKCh0LT0yKSp0KigoYW1vdW50KzEpKnQrYW1vdW50KSsyKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW5PdXQgPSBFYXNlLmdldEJhY2tJbk91dCgxLjcpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMS10KnQpLSAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY091dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEtKC0tdCkqdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCo9MikgPCAxKSByZXR1cm4gLTAuNSooTWF0aC5zcXJ0KDEtdCp0KS0xKTtcblx0XHRyZXR1cm4gMC41KihNYXRoLnNxcnQoMS0odC09MikqdCkrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMS1FYXNlLmJvdW5jZU91dCgxLXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZU91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZU91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDEvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqdCp0KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0xLjUvMi43NSkqdCswLjc1KTtcblx0XHR9IGVsc2UgaWYgKHQgPCAyLjUvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTIuMjUvMi43NSkqdCswLjkzNzUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi42MjUvMi43NSkqdCArMC45ODQzNzUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0PDAuNSkgcmV0dXJuIEVhc2UuYm91bmNlSW4gKHQqMikgKiAuNTtcblx0XHRyZXR1cm4gRWFzZS5ib3VuY2VPdXQodCoyLTEpKjAuNSswLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY0luID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0PT0wIHx8IHQ9PTEpIHJldHVybiB0O1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyKk1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gLShhbXBsaXR1ZGUqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QpKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW4gPSBFYXNlLmdldEVsYXN0aWNJbigxLDAuMyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNPdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0cmV0dXJuIChhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCApKzEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljT3V0ID0gRWFzZS5nZXRFbGFzdGljT3V0KDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW5PdXQgPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyICogTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIC0wLjUqKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oICh0LXMpKnBpMi9wZXJpb2QgKSk7XG5cdFx0XHRyZXR1cm4gYW1wbGl0dWRlKk1hdGgucG93KDIsLTEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkqMC41KzE7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY0luT3V0ID0gRWFzZS5nZXRFbGFzdGljSW5PdXQoMSwwLjMqMS41KTtcblxuXHRjcmVhdGVqcy5FYXNlID0gRWFzZTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1vdGlvbkd1aWRlUGx1Z2luLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIFR3ZWVuSlMgcGx1Z2luIGZvciB3b3JraW5nIHdpdGggbW90aW9uIGd1aWRlcy5cblx0ICpcblx0ICogVG8gdXNlLCBpbnN0YWxsIHRoZSBwbHVnaW4gYWZ0ZXIgVHdlZW5KUyBoYXMgbG9hZGVkLiBOZXh0IHR3ZWVuIHRoZSAnZ3VpZGUnIHByb3BlcnR5IHdpdGggYW4gb2JqZWN0IGFzIGRldGFpbGVkIGJlbG93LlxuXHQgKlxuXHQgKiAgICAgICBjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsKCk7XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICAvLyBVc2luZyBhIE1vdGlvbiBHdWlkZVxuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHtndWlkZTp7IHBhdGg6WzAsMCwgMCwyMDAsMjAwLDIwMCwgMjAwLDAsMCwwXSB9fSw3MDAwKTtcblx0ICpcdCAgICAvLyBWaXN1YWxpemluZyB0aGUgbGluZVxuXHQgKlx0ICAgIGdyYXBoaWNzLm1vdmVUbygwLDApLmN1cnZlVG8oMCwyMDAsMjAwLDIwMCkuY3VydmVUbygyMDAsMCwwLDApO1xuXHQgKlxuXHQgKiBFYWNoIHBhdGggbmVlZHMgcHJlLWNvbXB1dGF0aW9uIHRvIGVuc3VyZSB0aGVyZSdzIGZhc3QgcGVyZm9ybWFuY2UuIEJlY2F1c2Ugb2YgdGhlIHByZS1jb21wdXRhdGlvbiB0aGVyZSdzIG5vXG5cdCAqIGJ1aWx0IGluIHN1cHBvcnQgZm9yIHBhdGggY2hhbmdlcyBtaWQgdHdlZW4uIFRoZXNlIGFyZSB0aGUgR3VpZGUgT2JqZWN0J3MgcHJvcGVydGllczo8VUw+XG5cdCAqICAgICAgPExJPiBwYXRoOiBSZXF1aXJlZCwgQXJyYXkgOiBUaGUgeC95IHBvaW50cyB1c2VkIHRvIGRyYXcgdGhlIHBhdGggd2l0aCBhIG1vdmVUbyBhbmQgMSB0byBuIGN1cnZlVG8gY2FsbHMuPC9MST5cblx0ICogICAgICA8TEk+IHN0YXJ0OiBPcHRpb25hbCwgMC0xIDogSW5pdGlhbCBwb3NpdGlvbiwgZGVmYXVsdCAwIGV4Y2VwdCBmb3Igd2hlbiBjb250aW51aW5nIGFsb25nIHRoZSBzYW1lIHBhdGguPC9MST5cblx0ICogICAgICA8TEk+IGVuZDogT3B0aW9uYWwsIDAtMSA6IEZpbmFsIHBvc2l0aW9uLCBkZWZhdWx0IDEgaWYgbm90IHNwZWNpZmllZC48L0xJPlxuXHQgKiAgICAgIDxMST4gb3JpZW50OiBPcHRpb25hbCwgc3RyaW5nIDogXCJmaXhlZFwiL1wiYXV0b1wiL1wiY3dcIi9cImNjd1wiPFVMPlxuXHQgKlx0XHRcdFx0PExJPlwiZml4ZWRcIiBmb3JjZXMgdGhlIG9iamVjdCB0byBmYWNlIGRvd24gdGhlIHBhdGggYWxsIG1vdmVtZW50IChyZWxhdGl2ZSB0byBzdGFydCByb3RhdGlvbiksPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiYXV0b1wiIHJvdGF0ZXMgdGhlIG9iamVjdCBhbG9uZyB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgbGluZS48L0xJPlxuXHQgKiAgICAgIFx0XHQ8TEk+XCJjd1wiL1wiY2N3XCIgZm9yY2UgY2xvY2t3aXNlIG9yIGNvdW50ZXIgY2xvY2t3aXNlIHJvdGF0aW9ucyBpbmNsdWRpbmcgZmxhc2ggbGlrZSBiZWhhdmlvdXI8L0xJPlxuXHQgKiBcdFx0PC9VTD48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBHdWlkZSBvYmplY3RzIHNob3VsZCBub3QgYmUgc2hhcmVkIGJldHdlZW4gdHdlZW5zIGV2ZW4gaWYgYWxsIHByb3BlcnRpZXMgYXJlIGlkZW50aWNhbCwgdGhlIGxpYnJhcnkgc3RvcmVzXG5cdCAqIGluZm9ybWF0aW9uIG9uIHRoZXNlIG9iamVjdHMgaW4gdGhlIGJhY2tncm91bmQgYW5kIHNoYXJpbmcgdGhlbSBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuIFZhbHVlc1xuXHQgKiBvdXRzaWRlIDAtMSByYW5nZSBvZiB0d2VlbnMgd2lsbCBiZSBhIFwiYmVzdCBndWVzc1wiIGZyb20gdGhlIGFwcHJvcHJpYXRlIHBhcnQgb2YgdGhlIGRlZmluZWQgY3VydmUuXG5cdCAqXG5cdCAqIEBjbGFzcyBNb3Rpb25HdWlkZVBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3Rpb25HdWlkZVBsdWdpbigpIHtcblx0XHR0aHJvdyhcIk1vdGlvbkd1aWRlUGx1Z2luIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCIpXG5cdH07XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcHJpb3JpdHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4ucHJpb3JpdHkgPSAwOyAvLyBoaWdoIHByaW9yaXR5LCBzaG91bGQgcnVuIHNvb25lclxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZlM7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZkU7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE5vcm1TO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtRTtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogSW5zdGFsbHMgdGhpcyBwbHVnaW4gZm9yIHVzZSB3aXRoIFR3ZWVuSlMuIENhbGwgdGhpcyBvbmNlIGFmdGVyIFR3ZWVuSlMgaXMgbG9hZGVkIHRvIGVuYWJsZSB0aGlzIHBsdWdpbi5cblx0ICogQG1ldGhvZCBpbnN0YWxsXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0Y3JlYXRlanMuVHdlZW4uaW5zdGFsbFBsdWdpbihNb3Rpb25HdWlkZVBsdWdpbiwgW1wiZ3VpZGVcIiwgXCJ4XCIsIFwieVwiLCBcInJvdGF0aW9uXCJdKTtcblx0XHRyZXR1cm4gY3JlYXRlanMuVHdlZW4uSUdOT1JFO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5pdCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSkge1xuXHRcdHZhciB0YXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInhcIikpeyB0YXJnZXQueCA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwieVwiKSl7IHRhcmdldC55ID0gMDsgfVxuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJyb3RhdGlvblwiKSl7IHRhcmdldC5yb3RhdGlvbiA9IDA7IH1cblxuXHRcdGlmKHByb3A9PVwicm90YXRpb25cIil7IHR3ZWVuLl9fbmVlZHNSb3QgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHByb3A9PVwiZ3VpZGVcIj9udWxsOnZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHN0ZXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uc3RlcCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgaW5qZWN0UHJvcHMpIHtcblx0XHQvLyBvdGhlciBwcm9wc1xuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiKXtcblx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHN0YXJ0VmFsdWU7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbEUgPSBlbmRWYWx1ZTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0fVxuXHRcdGlmKHByb3AgIT0gXCJndWlkZVwiKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cblx0XHQvLyBndWlkZSBvbmx5IGluZm9ybWF0aW9uIC0gU3RhcnQgLVxuXHRcdHZhciB0ZW1wLCBkYXRhID0gZW5kVmFsdWU7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKXsgZGF0YS5wYXRoID0gW107IH1cblx0XHR2YXIgcGF0aCA9IGRhdGEucGF0aDtcblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSl7IGRhdGEuZW5kID0gMTsgfVxuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwic3RhcnRcIikpe1xuXHRcdFx0ZGF0YS5zdGFydCA9IChzdGFydFZhbHVlJiZzdGFydFZhbHVlLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiZzdGFydFZhbHVlLnBhdGg9PT1wYXRoKT9zdGFydFZhbHVlLmVuZDowO1xuXHRcdH1cblxuXHRcdC8vIEZpZ3VyZSBvdXQgc3VibGluZSBpbmZvcm1hdGlvblxuXHRcdGlmKGRhdGEuaGFzT3duUHJvcGVydHkoXCJfc2VnbWVudHNcIikgJiYgZGF0YS5fbGVuZ3RoKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dmFyIGwgPSBwYXRoLmxlbmd0aDtcblx0XHR2YXIgYWNjdXJhY3kgPSAxMDtcdFx0Ly8gQWRqdXN0IHRvIGltcHJvdmUgbGluZSBmb2xsb3dpbmcgcHJlY2lzaW9uIGJ1dCBzYWNyaWZpY2UgcGVyZm9ybWFuY2UgKCMgb2Ygc2VnKVxuXHRcdGlmKGwgPj0gNiAmJiAobC0yKSAlIDQgPT0gMCl7XHQvLyBFbm91Z2ggcG9pbnRzICYmIGNvbnRhaW5zIGNvcnJlY3QgbnVtYmVyIHBlciBlbnRyeSBpZ25vcmluZyBzdGFydFxuXHRcdFx0ZGF0YS5fc2VnbWVudHMgPSBbXTtcblx0XHRcdGRhdGEuX2xlbmd0aCA9IDA7XG5cdFx0XHRmb3IodmFyIGk9MjsgaTxsOyBpKz00KXtcblx0XHRcdFx0dmFyIHN4ID0gcGF0aFtpLTJdLCBzeSA9IHBhdGhbaS0xXTtcblx0XHRcdFx0dmFyIGN4ID0gcGF0aFtpKzBdLCBjeSA9IHBhdGhbaSsxXTtcblx0XHRcdFx0dmFyIGV4ID0gcGF0aFtpKzJdLCBleSA9IHBhdGhbaSszXTtcblx0XHRcdFx0dmFyIG9sZFggPSBzeCwgb2xkWSA9IHN5O1xuXHRcdFx0XHR2YXIgdGVtcFgsIHRlbXBZLCB0b3RhbCA9IDA7XG5cdFx0XHRcdHZhciBzdWJsaW5lcyA9IFtdO1xuXHRcdFx0XHRmb3IodmFyIGo9MTsgajw9YWNjdXJhY3k7IGorKyl7XG5cdFx0XHRcdFx0dmFyIHQgPSBqL2FjY3VyYWN5O1xuXHRcdFx0XHRcdHZhciBpbnYgPSAxIC0gdDtcblx0XHRcdFx0XHR0ZW1wWCA9IGludippbnYgKiBzeCArIDIgKiBpbnYgKiB0ICogY3ggKyB0KnQgKiBleDtcblx0XHRcdFx0XHR0ZW1wWSA9IGludippbnYgKiBzeSArIDIgKiBpbnYgKiB0ICogY3kgKyB0KnQgKiBleTtcblx0XHRcdFx0XHR0b3RhbCArPSBzdWJsaW5lc1tzdWJsaW5lcy5wdXNoKE1hdGguc3FydCgodGVtcD10ZW1wWC1vbGRYKSp0ZW1wICsgKHRlbXA9dGVtcFktb2xkWSkqdGVtcCkpLTFdO1xuXHRcdFx0XHRcdG9sZFggPSB0ZW1wWDtcblx0XHRcdFx0XHRvbGRZID0gdGVtcFk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS5fc2VnbWVudHMucHVzaCh0b3RhbCk7XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2goc3VibGluZXMpO1xuXHRcdFx0XHRkYXRhLl9sZW5ndGggKz0gdG90YWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93KFwiaW52YWxpZCAncGF0aCcgZGF0YSwgcGxlYXNlIHNlZSBkb2N1bWVudGF0aW9uIGZvciB2YWxpZCBwYXRoc1wiKTtcblx0XHR9XG5cblx0XHQvLyBTZXR1cCB4L3kgdHdlZW5zXG5cdFx0dGVtcCA9IGRhdGEub3JpZW50O1xuXHRcdGRhdGEub3JpZW50ID0gdHJ1ZTtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5zdGFydCwgbyk7XG5cdFx0dHdlZW4uX19yb3RQYXRoUyA9IE51bWJlcihvLnJvdGF0aW9uLnRvRml4ZWQoNSkpO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aEUgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRkYXRhLm9yaWVudCA9IGZhbHNlO1x0Ly9oZXJlIGFuZCBub3cgd2UgZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvXG5cdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCBkYXRhLmVuZCwgaW5qZWN0UHJvcHMpO1xuXHRcdGRhdGEub3JpZW50ID0gdGVtcDtcblxuXHRcdC8vIFNldHVwIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHRpZighZGF0YS5vcmllbnQpeyByZXR1cm4gZW5kVmFsdWU7IH1cblx0XHR0d2Vlbi5fX2d1aWRlRGF0YSA9IGRhdGE7XG5cdFx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEodHdlZW4sIGluamVjdFByb3BzKTtcblx0XHRyZXR1cm4gZW5kVmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdGVzdFJvdERhdGFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEgPSBmdW5jdGlvbih0d2VlbiwgaW5qZWN0UHJvcHMpe1xuXG5cdFx0Ly8gbm8gcm90YXRpb24gaW5mb3JtYXQ/IGlmIHdlIG5lZWQgaXQgY29tZSBiYWNrLCBpZiB3ZSBkb24ndCB1c2UgMCAmIGVuc3VyZSB3ZSBoYXZlIGd1aWRlIGRhdGFcblx0XHRpZih0d2Vlbi5fX3JvdEdsb2JhbFMgPT09IHVuZGVmaW5lZCB8fCB0d2Vlbi5fX3JvdEdsb2JhbEUgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRpZih0d2Vlbi5fX25lZWRzUm90KXsgcmV0dXJuOyB9XG5cdFx0XHRpZih0d2Vlbi5fY3VyUXVldWVQcm9wcy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gdHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSBpbmplY3RQcm9wcy5yb3RhdGlvbiA9IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0d2Vlbi5fX2d1aWRlRGF0YSA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuOyB9XG5cblx0XHQvLyBQcm9jZXNzIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHR2YXIgZGF0YSA9IHR3ZWVuLl9fZ3VpZGVEYXRhO1xuXHRcdHZhciByb3RHbG9iYWxEID0gdHdlZW4uX19yb3RHbG9iYWxFIC0gdHdlZW4uX19yb3RHbG9iYWxTO1xuXHRcdHZhciByb3RQYXRoRCA9IHR3ZWVuLl9fcm90UGF0aEUgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXHRcdHZhciByb3QgPSByb3RHbG9iYWxEIC0gcm90UGF0aEQ7XG5cblx0XHRpZihkYXRhLm9yaWVudCA9PSBcImF1dG9cIil7XG5cdFx0XHRpZihyb3QgPiAxODApe1x0XHRcdHJvdCAtPSAzNjA7IH1cblx0XHRcdGVsc2UgaWYocm90IDwgLTE4MCl7XHRyb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjd1wiKXtcblx0XHRcdHdoaWxlKHJvdCA8IDApeyByb3QgKz0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEID4gMCAmJiByb3RHbG9iYWxEICE9IDE4MCl7IHJvdCArPSAzNjA7IH1cblxuXHRcdH0gZWxzZSBpZihkYXRhLm9yaWVudCA9PSBcImNjd1wiKXtcblx0XHRcdHJvdCA9IHJvdEdsb2JhbEQgLSAoKHJvdFBhdGhEID4gMTgwKT8oMzYwLXJvdFBhdGhEKToocm90UGF0aEQpKTtcdC8vIHNpZ24gZmxpcHBpbmcgb24gcGF0aFxuXHRcdFx0d2hpbGUocm90ID4gMCl7IHJvdCAtPSAzNjA7IH1cblx0XHRcdGlmKHJvdCA9PSAwICYmIHJvdEdsb2JhbEQgPCAwICYmIHJvdEdsb2JhbEQgIT0gLTE4MCl7IHJvdCAtPSAzNjA7IH1cblx0XHR9XG5cblx0XHRkYXRhLnJvdERlbHRhID0gcm90O1xuXHRcdGRhdGEucm90T2ZmUyA9IHR3ZWVuLl9fcm90R2xvYmFsUyAtIHR3ZWVuLl9fcm90UGF0aFM7XG5cblx0XHQvLyByZXNldFxuXHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9fZ3VpZGVEYXRhID0gdHdlZW4uX19uZWVkc1JvdCA9IHVuZGVmaW5lZDtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0d2VlblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi50d2VlbiA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSwgc3RhcnRWYWx1ZXMsIGVuZFZhbHVlcywgcmF0aW8sIHdhaXQsIGVuZCkge1xuXHRcdHZhciBkYXRhID0gZW5kVmFsdWVzLmd1aWRlO1xuXHRcdGlmKGRhdGEgPT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IHN0YXJ0VmFsdWVzLmd1aWRlKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0aWYoZGF0YS5sYXN0UmF0aW8gIT0gcmF0aW8pe1xuXHRcdFx0Ly8gZmlyc3QgdGltZSB0aHJvdWdoIHNvIGNhbGN1bGF0ZSB3aGF0IEkgbmVlZCB0b1xuXHRcdFx0dmFyIHQgPSAoKGRhdGEuZW5kLWRhdGEuc3RhcnQpKih3YWl0P2RhdGEuZW5kOnJhdGlvKStkYXRhLnN0YXJ0KTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgdCwgdHdlZW4udGFyZ2V0KTtcblx0XHRcdHN3aXRjaChkYXRhLm9yaWVudCl7XG5cdFx0XHRcdGNhc2UgXCJjd1wiOlx0XHQvLyBtaXggaW4gdGhlIG9yaWdpbmFsIHJvdGF0aW9uXG5cdFx0XHRcdGNhc2UgXCJjY3dcIjpcblx0XHRcdFx0Y2FzZSBcImF1dG9cIjogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUyArIGRhdGEucm90RGVsdGEqcmF0aW87IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZml4ZWRcIjpcdC8vIGZvbGxvdyBmaXhlZCBiZWhhdmlvdXIgdG8gc29sdmUgcG90ZW50aWFsIGlzc3Vlc1xuXHRcdFx0XHRkZWZhdWx0OiB0d2Vlbi50YXJnZXQucm90YXRpb24gKz0gZGF0YS5yb3RPZmZTOyBicmVhaztcblx0XHRcdH1cblx0XHRcdGRhdGEubGFzdFJhdGlvID0gcmF0aW87XG5cdFx0fVxuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiICYmICgoIWRhdGEub3JpZW50KSB8fCBkYXRhLm9yaWVudCA9PSBcImZhbHNlXCIpKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHR3ZWVuLnRhcmdldFtwcm9wXTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSB4L3kvcm90YXRpb24gaW5mb3JtYXRpb24gYWJvdXQgYSBwYXRoIGZvciBhIGdpdmVuIHJhdGlvIGFsb25nIHRoZSBwYXRoLlxuXHQgKiBBc3N1bWVzIGEgcGF0aCBvYmplY3Qgd2l0aCBhbGwgb3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQuXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0IHlvdSB3b3VsZCBwYXNzIHRvIHRoZSBcImd1aWRlOlwiIHByb3BlcnR5IGluIGEgVHdlZW5cblx0ICogQHBhcmFtIHJhdGlvIDAtMSBEaXN0YW5jZSBhbG9uZyBwYXRoLCB2YWx1ZXMgb3V0c2lkZSAwLTEgYXJlIFwiYmVzdCBndWVzc1wiXG5cdCAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdHMgb250bywgd2lsbCB1c2UgYSBuZXcgb2JqZWN0IGlmIG5vdCBzdXBwbGllZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCBvciBhIG5ldyBvYmplY3Qgdy8gdGhlIHR3ZWVuZWQgcHJvcGVydGllc1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjID0gZnVuY3Rpb24oZGF0YSwgcmF0aW8sIHRhcmdldCkge1xuXHRcdGlmKGRhdGEuX3NlZ21lbnRzID09IHVuZGVmaW5lZCl7IHRocm93KFwiTWlzc2luZyBjcml0aWNhbCBwcmUtY2FsY3VsYXRlZCBpbmZvcm1hdGlvbiwgcGxlYXNlIGZpbGUgYSBidWdcIik7IH1cblx0XHRpZih0YXJnZXQgPT0gdW5kZWZpbmVkKXsgdGFyZ2V0ID0ge3g6MCwgeTowLCByb3RhdGlvbjowfTsgfVxuXHRcdHZhciBzZWcgPSBkYXRhLl9zZWdtZW50cztcblx0XHR2YXIgcGF0aCA9IGRhdGEucGF0aDtcblxuXHRcdC8vIGZpbmQgc2VnbWVudFxuXHRcdHZhciBwb3MgPSBkYXRhLl9sZW5ndGggKiByYXRpbztcblx0XHR2YXIgY2FwID0gc2VnLmxlbmd0aCAtIDI7XG5cdFx0dmFyIG4gPSAwO1xuXHRcdHdoaWxlKHBvcyA+IHNlZ1tuXSAmJiBuIDwgY2FwKXtcblx0XHRcdHBvcyAtPSBzZWdbbl07XG5cdFx0XHRuKz0yO1xuXHRcdH1cblxuXHRcdC8vIGZpbmQgc3VibGluZVxuXHRcdHZhciBzdWJsaW5lcyA9IHNlZ1tuKzFdO1xuXHRcdHZhciBpID0gMDtcblx0XHRjYXAgPSBzdWJsaW5lcy5sZW5ndGgtMTtcblx0XHR3aGlsZShwb3MgPiBzdWJsaW5lc1tpXSAmJiBpIDwgY2FwKXtcblx0XHRcdHBvcyAtPSBzdWJsaW5lc1tpXTtcblx0XHRcdGkrKztcblx0XHR9XG5cdFx0dmFyIHQgPSAoaS8rK2NhcCkrKHBvcy8oY2FwKnN1YmxpbmVzW2ldKSk7XG5cblx0XHQvLyBmaW5kIHgveVxuXHRcdG4gPSAobioyKSsyO1xuXHRcdHZhciBpbnYgPSAxIC0gdDtcblx0XHR0YXJnZXQueCA9IGludippbnYgKiBwYXRoW24tMl0gKyAyICogaW52ICogdCAqIHBhdGhbbiswXSArIHQqdCAqIHBhdGhbbisyXTtcblx0XHR0YXJnZXQueSA9IGludippbnYgKiBwYXRoW24tMV0gKyAyICogaW52ICogdCAqIHBhdGhbbisxXSArIHQqdCAqIHBhdGhbbiszXTtcblxuXHRcdC8vIG9yaWVudGF0aW9uXG5cdFx0aWYoZGF0YS5vcmllbnQpe1xuXHRcdFx0dGFyZ2V0LnJvdGF0aW9uID0gNTcuMjk1Nzc5NSAqIE1hdGguYXRhbjIoXG5cdFx0XHRcdChwYXRoW24rMV0tcGF0aFtuLTFdKSppbnYgKyAocGF0aFtuKzNdLXBhdGhbbisxXSkqdCxcblx0XHRcdFx0KHBhdGhbbiswXS1wYXRoW24tMl0pKmludiArIChwYXRoW24rMl0tcGF0aFtuKzBdKSp0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1vdGlvbkd1aWRlUGx1Z2luID0gTW90aW9uR3VpZGVQbHVnaW47XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFR3ZWVuSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlR3ZWVuSlMgPSBjcmVhdGVqcy5Ud2VlbkpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4yXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzEgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbmlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IHRoaXMuY3JlYXRlanM7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval('module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.20';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2), __webpack_require__(1)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcz8yZWYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxhQUFhLE9BQU87O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLEVBQUU7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSx5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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0IsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtB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QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLE1BQU0saUJBQWlCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBNEQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOO0FBQ0E7QUFDQSxPQUFPLEVBU0o7QUFDSCxDQUFDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjIwJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksIF8ubWF0Y2hlcyh7ICdhJzogNCB9KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCAxKSwgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIG1hdGNoZXNGdW5jID0gXy5vdmVyU29tZShbeyAnYSc6IDEgfSwgeyAnYSc6IDIgfV0pXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/MDA4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/createjs-module/createjs.js\nvar createjs = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/lodash/lodash.js\nvar lodash = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/MainModule/Stage.js\n\n\nclass Stage_Stage {\n  constructor() {\n    this.stage = new createjs[\"Stage\"]('myCanvas');\n    this.stage.enableMouseOver(10);\n    createjs[\"Ticker\"].addEventListener('tick', this.stage);\n  }\n\n}\n\nconst stage = new Stage_Stage();\n/* harmony default export */ var MainModule_Stage = (stage);\n// CONCATENATED MODULE: ./src/MainModule/index.js\n\n\n\nconst SHARED_DEPENDENCIES = {\n  stage: MainModule_Stage,\n  createjs: createjs,\n  _: lodash\n};\n/* harmony default export */ var MainModule = (SHARED_DEPENDENCIES);\n// CONCATENATED MODULE: ./src/ConnectorLine.js\n\nconst {\n  createjs: ConnectorLine_createjs\n} = MainModule;\nclass ConnectorLine extends ConnectorLine_createjs.Container {\n  constructor({\n    container\n  }) {\n    super();\n    this.container = container;\n    this.container.stage.addChild(this);\n  }\n\n  create({\n    x = 0,\n    y = 0\n  }) {\n    this.shape = new ConnectorLine_createjs.Shape();\n    this.shapeX = x;\n    this.shapeY = y;\n    this.shape.graphics.setStrokeStyle(1);\n    this.shape.graphics.beginStroke('black');\n    this.shape.graphics.moveTo(x, y);\n    this.shape.graphics.endStroke();\n    this.addChild(this.shape);\n  }\n\n  updateLine(x, y, shapex = this.shapeX, shapey = this.shapeY) {\n    this.shape.graphics.clear();\n    this.shape.graphics.setStrokeStyle(1);\n    this.shape.graphics.beginStroke('black');\n    this.shape.graphics.moveTo(shapex, shapey);\n    this.shape.graphics.lineTo(x, y);\n    this.shape.graphics.endStroke();\n  }\n\n}\n// CONCATENATED MODULE: ./src/DotCircles.js\n\n\nconst {\n  createjs: DotCircles_createjs,\n  _\n} = MainModule;\nclass DotCircles_DotCircles extends DotCircles_createjs.Container {\n  constructor(config = {}) {\n    super();\n\n    _.bindAll(this, 'create', 'mouseDownEventHandler', 'pressMoveEventHandler', 'mouseDownEventHandler', 'mouseOverEventHandler', 'pressUpEventHandler');\n\n    this.shapeArr = [];\n    this.config = config;\n    this.visible = false;\n    this.container = config.container;\n    this.create(config);\n    this.arrangeDots(config.container);\n  }\n\n  create({\n    x = 0,\n    y = 0,\n    radius = 7,\n    fillColor = 'yellow'\n  }) {\n    for (let i = 0; i < 4; i++) {\n      // eslint-disable-line no-plusplus\n      const dotCircleContainer = new DotCircles_createjs.Container();\n      dotCircleContainer.name = 'dotContainer';\n      dotCircleContainer.setBounds(x, y, 14, 14);\n      const shape = new DotCircles_createjs.Shape();\n      dotCircleContainer.connectedLinesData = [];\n      shape.id = i;\n      const g = shape.graphics;\n      g.setStrokeStyle(1);\n      g.beginStroke();\n      g.beginFill(fillColor);\n      g.drawCircle(0, 0, radius);\n      dotCircleContainer.addChild(shape);\n      this.container.addChild(dotCircleContainer);\n      dotCircleContainer.addEventListener('mousedown', this.mouseDownEventHandler);\n      dotCircleContainer.addEventListener('pressmove', this.pressMoveEventHandler);\n      dotCircleContainer.addEventListener('mouseover', this.mouseOverEventHandler);\n      dotCircleContainer.addEventListener('pressup', this.pressUpEventHandler);\n      this.shapeArr.push(dotCircleContainer);\n    }\n  }\n\n  arrangeDots(container) {\n    const {\n      width,\n      height\n    } = container.getBounds();\n\n    for (let i = 0; i < 4; i++) {\n      // eslint-disable-line no-plusplus\n      if (i === 0) {\n        this.shapeArr[i].name = 'topDot';\n        this.shapeArr[i].x = container.x + (width - 5) / 2;\n        this.shapeArr[i].y = 0;\n      }\n\n      if (i === 1) {\n        this.shapeArr[i].name = 'leftDot';\n        this.shapeArr[i].x = 0;\n        this.shapeArr[i].y = container.y + (height - 5) / 2;\n      }\n\n      if (i === 2) {\n        this.shapeArr[i].name = 'rightDot';\n        this.shapeArr[i].x = container.x + (width - 5);\n        this.shapeArr[i].y = container.y + (height - 5) / 2;\n      }\n\n      if (i === 3) {\n        this.shapeArr[i].name = 'bottomDot';\n        this.shapeArr[i].x = container.x + (width - 5) / 2;\n        this.shapeArr[i].y = container.y + (height - 5);\n      }\n    }\n  }\n\n  mouseDownEventHandler(event) {\n    event.stopPropagation();\n    const {\n      stageX,\n      stageY\n    } = event;\n\n    if (this.container.boundaryConditionChecker({\n      stageX,\n      stageY\n    })) {\n      this.lineDraw = new ConnectorLine({\n        container: this.container\n      });\n      const bounds = event.currentTarget.getBounds();\n      const location = event.currentTarget.localToGlobal(bounds.x, bounds.y);\n      this.lineDraw.create({\n        x: location.x,\n        y: location.y,\n        endx: location.x,\n        endy: location.y\n      });\n      this.diffX = location.x - event.stageX;\n      this.diffY = location.y - event.stageY;\n    }\n  }\n\n  pressMoveEventHandler(event) {\n    event.stopPropagation();\n    const {\n      stageX,\n      stageY\n    } = event;\n\n    if (this.container.boundaryConditionChecker({\n      stageX,\n      stageY\n    })) {\n      this.lineDraw.updateLine(event.stageX, event.stageY);\n    }\n  }\n\n  pressUpEventHandler(event) {\n    const {\n      stageX,\n      stageY\n    } = event;\n\n    if (this.container.boundaryConditionChecker({\n      stageX,\n      stageY\n    })) {\n      const startingPoint = event.currentTarget;\n      const {\n        droppableDot\n      } = event.currentTarget.stage;\n      const connectedLinesData = {\n        endTarget: droppableDot,\n        startingPoint,\n        line: this.lineDraw\n      };\n      event.currentTarget.stage.droppableDot.connectedLinesData.push(connectedLinesData);\n      startingPoint.connectedLinesData.push(connectedLinesData);\n    }\n  }\n\n  mouseOverEventHandler(event) {\n    this.container.stage.droppableDot = event.currentTarget;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Constants.js\nconst initailShapeData = {\n  initailShapeWidth: 150,\n  initailShapeHeight: 300\n};\nconst outerShapeContainerData = {\n  outerShapeWidth: 750,\n  outerShapeHeight: 650,\n  ox: 200,\n  oy: 10\n};\n// CONCATENATED MODULE: ./src/Shape.js\n\n\n\nconst {\n  createjs: Shape_createjs,\n  _: Shape_\n} = MainModule;\nclass Shape_Shape extends Shape_createjs.Container {\n  constructor() {\n    super();\n\n    Shape_.bindAll(this, 'boundaryConditionChecker', 'pressUpEventHandler', 'addDotsToShape', 'mouseDownEventHandler', 'pressMoveEventHandler', 'mouseDownEventHandler', 'mouseOutEventHandler', 'mouseOverEventHandler');\n  }\n\n  addDotsToShape() {\n    this.dotCirclesObj = new DotCircles_DotCircles({\n      x: 0,\n      y: 0,\n      container: this\n    });\n    this.addChild(this.dotCirclesObj);\n  }\n\n  addEventListeners() {\n    this.addEventListener('mousedown', this.mouseDownEventHandler);\n    this.addEventListener('pressmove', this.pressMoveEventHandler);\n    this.addEventListener('mouseout', this.mouseOverEventHandler);\n    this.addEventListener('mouseover', this.mouseOutEventHandler);\n    this.addEventListener('pressup', this.pressUpEventHandler);\n  }\n\n  pressUpEventHandler() {\n    this.a = 's';\n  }\n\n  mouseOutEventHandler() {\n    Shape_.forEach(this.dotCirclesObj.shapeArr, container => {\n      container.visible = true; // eslint-disable-line\n    });\n  }\n\n  mouseOverEventHandler() {\n    Shape_.forEach(this.dotCirclesObj.shapeArr, container => {\n      container.visible = false; // eslint-disable-line\n    });\n  }\n\n  mouseMoveEventHandler() {// eslint-disable-line class-methods-use-this\n    // for future use\n  }\n\n  mouseDownEventHandler(event) {\n    this.diffX = event.stageX - this.x;\n    this.diffY = event.stageY - this.y;\n  }\n\n  pressMoveEventHandler(event) {\n    event.stopPropagation();\n    const {\n      stageX,\n      stageY\n    } = event;\n\n    if (this.boundaryConditionChecker({\n      stageX,\n      stageY\n    })) {\n      const {\n        x,\n        y\n      } = this.parent.globalToLocal(stageX, stageY);\n      this.x = x - this.diffX;\n      this.y = y - this.diffY;\n    }\n\n    for (let i = 0; i < 4; i++) {\n      // eslint-disable-line no-plusplus\n      if (this.dotCirclesObj.shapeArr[i].connectedLinesData.length !== 0) {\n        const linesArr = this.dotCirclesObj.shapeArr[i].connectedLinesData;\n\n        Shape_.forEach(linesArr, data => {\n          data.line.shape.graphics.clear();\n          const bounds = data.endTarget.getBounds();\n          const location = data.endTarget.localToGlobal(bounds.x, bounds.y);\n          const bounds1 = data.startingPoint.getBounds();\n          const location1 = data.startingPoint.localToGlobal(bounds1.x, bounds1.y);\n          data.line.updateLine(location1.x, location1.y, location.x, location.y);\n        });\n      }\n    }\n  }\n\n  boundaryConditionChecker({\n    stageX,\n    stageY\n  }) {\n    const {\n      outerShapeWidth,\n      outerShapeHeight,\n      ox,\n      oy\n    } = outerShapeContainerData;\n    const {\n      width,\n      height\n    } = this.getBounds();\n    const topCondition = stageX > ox + this.diffX && stageY > oy + this.diffY;\n    const bottomCondition = stageX < ox + outerShapeWidth - (width - this.diffX) && stageY < oy + outerShapeHeight - (height - this.diffY);\n    const boundaryCondition = topCondition && bottomCondition;\n    return boundaryCondition;\n  }\n\n}\n// CONCATENATED MODULE: ./src/TextSetter.js\n\nconst {\n  createjs: TextSetter_createjs\n} = MainModule;\nclass TextSetter extends TextSetter_createjs.Container {\n  constructor({\n    editable = false,\n    label = 'Hello',\n    container\n  }) {\n    super();\n    this.setDefaultText({\n      editable,\n      label\n    });\n    this.setPositionOfText(container);\n  }\n\n  setDefaultText({\n    editable = false,\n    label = 'Hello'\n  }) {\n    if (!editable) {\n      this.enable = editable;\n      this.text = new TextSetter_createjs.Text(label, '15px Arial', 'black');\n      this.addChild(this.text);\n    } else {// future use case\n    }\n  }\n\n  setPositionOfText(container) {\n    // eslint-disable-line class-methods-use-this\n    const {\n      width,\n      height\n    } = container.getBounds();\n    const x = (width - this.text.getBounds().width) / 2;\n    const y = (height - this.text.getBounds().height) / 2;\n    this.set({\n      x,\n      y\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./src/StartComponent.js\n\n\n\nconst {\n  createjs: StartComponent_createjs\n} = MainModule;\nclass StartComponent_StartComponent extends Shape_Shape {\n  constructor(config = {}) {\n    super();\n    this.create(config);\n    this.name = 'StartComponent';\n    this.addDotsToShape();\n    const text = new TextSetter({\n      editable: false,\n      label: 'Start',\n      container: this\n    });\n    this.addChild(text);\n  }\n\n  create({\n    x = 0,\n    y = 0,\n    radius = 30,\n    fillColor = 'pink'\n  }) {\n    this.shape = new StartComponent_createjs.Shape();\n    this.shape.set({\n      x: 30,\n      y: 30\n    });\n    this.setBounds(0, 0, radius * 2, radius * 2);\n    const g = this.shape.graphics;\n    g.setStrokeStyle(1);\n    g.beginStroke('black');\n    g.beginFill(fillColor);\n    g.drawCircle(x, y, radius);\n    this.addChild(this.shape);\n    this.addEventListeners();\n  }\n\n}\n// CONCATENATED MODULE: ./src/NormalComponent.js\n\n\n\nconst {\n  createjs: NormalComponent_createjs\n} = MainModule;\nclass NormalComponent_NormalComponent extends Shape_Shape {\n  constructor(config = {}) {\n    super();\n    this.create(config);\n    this.name = 'NormalComponent';\n    const text = new TextSetter({\n      editable: false,\n      label: 'Normal',\n      container: this\n    });\n    this.addChild(text);\n    this.addDotsToShape();\n  }\n\n  create({\n    width = 90,\n    height = 60,\n    x = 0,\n    y = 0,\n    fillColor = 'pink'\n  }) {\n    this.shape = new NormalComponent_createjs.Shape();\n    this.setBounds(0, 0, width, height);\n    const g = this.shape.graphics;\n    g.setStrokeStyle(1);\n    g.beginStroke('black');\n    g.beginFill(fillColor);\n    g.drawRect(x, y, width, height);\n    this.addChild(this.shape);\n    this.addEventListeners();\n  }\n\n}\n// CONCATENATED MODULE: ./src/ModuleComponent.js\n\n\n\nconst {\n  createjs: ModuleComponent_createjs\n} = MainModule;\nclass ModuleComponent_ModuleComponent extends Shape_Shape {\n  constructor(config = {}) {\n    super();\n    this.create(config);\n    this.name = 'ModuleComponent';\n    const text = new TextSetter({\n      editable: false,\n      label: 'Model',\n      container: this\n    });\n    this.addChild(text);\n    this.addDotsToShape();\n  }\n\n  create({\n    width = 90,\n    height = 50,\n    x = 0,\n    y = 0,\n    fillColor = 'pink'\n  }) {\n    this.shape = new ModuleComponent_createjs.Shape();\n    this.shape.set({\n      x: 0,\n      y: 0\n    });\n    this.shape.setBounds(x, y, width, height);\n    this.setBounds(x, y, width, height);\n    const g = this.shape.graphics;\n    g.setStrokeStyle(1);\n    g.beginStroke('black');\n    g.beginFill(fillColor);\n    g.drawRoundRect(x, y, width, height, 20);\n    this.addChild(this.shape);\n    this.addEventListeners();\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\nconst {\n  createjs: src_createjs,\n  stage: src_stage,\n  _: src_\n} = MainModule;\n\nclass src_Init {\n  constructor() {\n    this.stage = src_stage.stage;\n    this.startArr = [];\n    this.normalArr = [];\n    this.moduleArr = [];\n    this.stage.droppableDot = null;\n    this.createStartComponent();\n    this.createNormalComponent();\n    this.createModelComponent();\n  }\n\n  createStartComponent() {\n    const x = 60;\n    const y = 60;\n    const shapeContainer = new src_createjs.Container();\n    shapeContainer.setBounds(0, 0, 0, 0);\n    const shape = new src_createjs.Shape();\n    shapeContainer.addChild(shape);\n    shapeContainer.set({\n      x,\n      y\n    });\n    const g = shape.graphics;\n    g.setStrokeStyle(1);\n    g.beginStroke('#000000');\n    g.beginFill('pink');\n    g.drawCircle(0, 0, 30);\n    shapeContainer.addChild(shape);\n    this.stage.addChild(shapeContainer);\n    const text = new TextSetter({\n      editable: false,\n      label: 'Start',\n      container: shapeContainer\n    });\n    shapeContainer.addChild(text);\n    shape.addEventListener('mousedown', event => {\n      const startComponentObj = new StartComponent_StartComponent();\n      startComponentObj.set({\n        x: x / 2,\n        y: y / 2\n      });\n      this.stage.addChild(startComponentObj);\n      this.startArr.push(startComponentObj);\n      startComponentObj.mouseDownEventHandler(event);\n    });\n    shape.addEventListener('pressmove', event => {\n      src_.last(this.startArr).pressMoveEventHandler(event);\n    });\n  }\n\n  createNormalComponent() {\n    const x = 30;\n    const y = 120;\n    const shapeContainer = new src_createjs.Container();\n    shapeContainer.set({\n      x,\n      y\n    });\n    const shape = new src_createjs.Shape();\n    shape.setBounds(0, 0, 90, 60);\n    const g = shape.graphics;\n    g.setStrokeStyle(1);\n    g.beginStroke('#000000');\n    g.beginFill('pink');\n    g.drawRect(0, 0, 90, 60);\n    shapeContainer.addChild(shape);\n    this.stage.addChild(shapeContainer);\n    const text = new TextSetter({\n      editable: false,\n      label: 'Normal',\n      container: shapeContainer\n    });\n    shapeContainer.addChild(text);\n    shape.addEventListener('mousedown', event => {\n      const normalComponentObj = new NormalComponent_NormalComponent();\n      normalComponentObj.set({\n        x,\n        y\n      });\n      this.stage.addChild(normalComponentObj);\n      this.normalArr.push(normalComponentObj);\n      normalComponentObj.mouseDownEventHandler(event);\n    });\n    shape.addEventListener('pressmove', event => {\n      src_.last(this.normalArr).pressMoveEventHandler(event);\n    });\n  }\n\n  createModelComponent() {\n    const x = 30;\n    const y = 220;\n    const shapeContainer = new src_createjs.Container();\n    shapeContainer.set({\n      x,\n      y\n    });\n    const shape = new src_createjs.Shape();\n    shape.setBounds(0, 0, 90, 50);\n    const g = shape.graphics;\n    g.setStrokeStyle(1).beginStroke('#000000').beginFill('pink').drawRoundRect(0, 0, 90, 50, 20);\n    shapeContainer.addChild(shape);\n    const text = new TextSetter({\n      editable: false,\n      label: 'Model',\n      container: shapeContainer\n    });\n    shapeContainer.addChild(text);\n    this.stage.addChild(shapeContainer);\n    shape.addEventListener('mousedown', event => {\n      const moduleComponentObj = new ModuleComponent_ModuleComponent();\n      this.stage.addChild(moduleComponentObj);\n      moduleComponentObj.set({\n        x,\n        y\n      });\n      this.moduleArr.push(moduleComponentObj);\n      moduleComponentObj.mouseDownEventHandler(event);\n    });\n    shape.addEventListener('pressmove', event => {\n      src_.last(this.moduleArr).pressMoveEventHandler(event);\n    });\n  }\n\n}\n\nconst init = new src_Init();\ndocument.addEventListener('DOMContentLoaded', init, false); // eslint-disable-line no-undef//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTWFpbk1vZHVsZS9TdGFnZS5qcz9mNzY1Iiwid2VicGFjazovLy8uL3NyYy9NYWluTW9kdWxlL2luZGV4LmpzP2JkNDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Nvbm5lY3RvckxpbmUuanM/YmIwNSIsIndlYnBhY2s6Ly8vLi9zcmMvRG90Q2lyY2xlcy5qcz9lMDk1Iiwid2VicGFjazovLy8uL3NyYy9Db25zdGFudHMuanM/ZTM2NyIsIndlYnBhY2s6Ly8vLi9zcmMvU2hhcGUuanM/NDliMiIsIndlYnBhY2s6Ly8vLi9zcmMvVGV4dFNldHRlci5qcz8xNDkxIiwid2VicGFjazovLy8uL3NyYy9TdGFydENvbXBvbmVudC5qcz8yODE1Iiwid2VicGFjazovLy8uL3NyYy9Ob3JtYWxDb21wb25lbnQuanM/ZjFhMCIsIndlYnBhY2s6Ly8vLi9zcmMvTW9kdWxlQ29tcG9uZW50LmpzPzZkYzQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsiU3RhZ2UiLCJjb25zdHJ1Y3RvciIsInN0YWdlIiwiY3JlYXRlanMiLCJlbmFibGVNb3VzZU92ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiU0hBUkVEX0RFUEVOREVOQ0lFUyIsIl8iLCJDb25uZWN0b3JMaW5lIiwiQ29udGFpbmVyIiwiY29udGFpbmVyIiwiYWRkQ2hpbGQiLCJjcmVhdGUiLCJ4IiwieSIsInNoYXBlIiwiU2hhcGUiLCJzaGFwZVgiLCJzaGFwZVkiLCJncmFwaGljcyIsInNldFN0cm9rZVN0eWxlIiwiYmVnaW5TdHJva2UiLCJtb3ZlVG8iLCJlbmRTdHJva2UiLCJ1cGRhdGVMaW5lIiwic2hhcGV4Iiwic2hhcGV5IiwiY2xlYXIiLCJsaW5lVG8iLCJEb3RDaXJjbGVzIiwiY29uZmlnIiwiYmluZEFsbCIsInNoYXBlQXJyIiwidmlzaWJsZSIsImFycmFuZ2VEb3RzIiwicmFkaXVzIiwiZmlsbENvbG9yIiwiaSIsImRvdENpcmNsZUNvbnRhaW5lciIsIm5hbWUiLCJzZXRCb3VuZHMiLCJjb25uZWN0ZWRMaW5lc0RhdGEiLCJpZCIsImciLCJiZWdpbkZpbGwiLCJkcmF3Q2lyY2xlIiwibW91c2VEb3duRXZlbnRIYW5kbGVyIiwicHJlc3NNb3ZlRXZlbnRIYW5kbGVyIiwibW91c2VPdmVyRXZlbnRIYW5kbGVyIiwicHJlc3NVcEV2ZW50SGFuZGxlciIsInB1c2giLCJ3aWR0aCIsImhlaWdodCIsImdldEJvdW5kcyIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwic3RhZ2VYIiwic3RhZ2VZIiwiYm91bmRhcnlDb25kaXRpb25DaGVja2VyIiwibGluZURyYXciLCJib3VuZHMiLCJjdXJyZW50VGFyZ2V0IiwibG9jYXRpb24iLCJsb2NhbFRvR2xvYmFsIiwiZW5keCIsImVuZHkiLCJkaWZmWCIsImRpZmZZIiwic3RhcnRpbmdQb2ludCIsImRyb3BwYWJsZURvdCIsImVuZFRhcmdldCIsImxpbmUiLCJpbml0YWlsU2hhcGVEYXRhIiwiaW5pdGFpbFNoYXBlV2lkdGgiLCJpbml0YWlsU2hhcGVIZWlnaHQiLCJvdXRlclNoYXBlQ29udGFpbmVyRGF0YSIsIm91dGVyU2hhcGVXaWR0aCIsIm91dGVyU2hhcGVIZWlnaHQiLCJveCIsIm95IiwiYWRkRG90c1RvU2hhcGUiLCJkb3RDaXJjbGVzT2JqIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJtb3VzZU91dEV2ZW50SGFuZGxlciIsImEiLCJmb3JFYWNoIiwibW91c2VNb3ZlRXZlbnRIYW5kbGVyIiwicGFyZW50IiwiZ2xvYmFsVG9Mb2NhbCIsImxlbmd0aCIsImxpbmVzQXJyIiwiZGF0YSIsImJvdW5kczEiLCJsb2NhdGlvbjEiLCJ0b3BDb25kaXRpb24iLCJib3R0b21Db25kaXRpb24iLCJib3VuZGFyeUNvbmRpdGlvbiIsIlRleHRTZXR0ZXIiLCJlZGl0YWJsZSIsImxhYmVsIiwic2V0RGVmYXVsdFRleHQiLCJzZXRQb3NpdGlvbk9mVGV4dCIsImVuYWJsZSIsInRleHQiLCJUZXh0Iiwic2V0IiwiU3RhcnRDb21wb25lbnQiLCJOb3JtYWxDb21wb25lbnQiLCJkcmF3UmVjdCIsIk1vZHVsZUNvbXBvbmVudCIsImRyYXdSb3VuZFJlY3QiLCJJbml0Iiwic3RhcnRBcnIiLCJub3JtYWxBcnIiLCJtb2R1bGVBcnIiLCJjcmVhdGVTdGFydENvbXBvbmVudCIsImNyZWF0ZU5vcm1hbENvbXBvbmVudCIsImNyZWF0ZU1vZGVsQ29tcG9uZW50Iiwic2hhcGVDb250YWluZXIiLCJzdGFydENvbXBvbmVudE9iaiIsImxhc3QiLCJub3JtYWxDb21wb25lbnRPYmoiLCJtb2R1bGVDb21wb25lbnRPYmoiLCJpbml0IiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxNQUFNQSxXQUFOLENBQVk7QUFDVkMsYUFBVyxHQUFHO0FBQ1osU0FBS0MsS0FBTCxHQUFhLElBQUlDLGlCQUFKLENBQW1CLFVBQW5CLENBQWI7QUFDQSxTQUFLRCxLQUFMLENBQVdFLGVBQVgsQ0FBMkIsRUFBM0I7QUFDQUQsc0JBQUEsQ0FBZ0JFLGdCQUFoQixDQUFpQyxNQUFqQyxFQUF5QyxLQUFLSCxLQUE5QztBQUNEOztBQUxTOztBQVFaLE1BQU1BLEtBQUssR0FBRyxJQUFJRixXQUFKLEVBQWQ7QUFDZUUsMERBQWYsRTs7QUNYQTtBQUNBO0FBQ0E7QUFFQSxNQUFNSSxtQkFBbUIsR0FBRztBQUMxQkoseUJBRDBCO0FBRTFCQyxvQkFGMEI7QUFHMUJJLFdBQUNBO0FBSHlCLENBQTVCO0FBTWVELGtFQUFmLEU7O0FDVkE7QUFFQSxNQUFNO0FBQUVILFVBQVFBO0FBQVYsSUFBZUcsVUFBckI7QUFFZSxNQUFNRSxhQUFOLFNBQTRCTCxzQkFBUSxDQUFDTSxTQUFyQyxDQUErQztBQUM1RFIsYUFBVyxDQUFDO0FBQUVTO0FBQUYsR0FBRCxFQUFnQjtBQUN6QjtBQUNBLFNBQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsU0FBS0EsU0FBTCxDQUFlUixLQUFmLENBQXFCUyxRQUFyQixDQUE4QixJQUE5QjtBQUNEOztBQUVEQyxRQUFN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QUFXO0FBQzdDL0MsVUFBQyxDQUFDaUgsSUFBRixDQUFPLEtBQUtOLFNBQVosRUFBdUJuRSxxQkFBdkIsQ0FBNkNPLEtBQTdDO0FBQ0QsS0FGRDtBQUdEOztBQW5HUTs7QUFxR1gsTUFBTXFFLElBQUksR0FBRyxJQUFJWixRQUFKLEVBQWI7QUFDQWEsUUFBUSxDQUFDdkgsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDc0gsSUFBOUMsRUFBb0QsS0FBcEQsRSxDQUE0RCIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3JlYXRlanMgZnJvbSAnY3JlYXRlanMtbW9kdWxlJztcblxuY2xhc3MgU3RhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKCdteUNhbnZhcycpO1xuICAgIHRoaXMuc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcbiAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcigndGljaycsIHRoaXMuc3RhZ2UpO1xuICB9XG59XG5cbmNvbnN0IHN0YWdlID0gbmV3IFN0YWdlKCk7XG5leHBvcnQgZGVmYXVsdCBzdGFnZTtcbiIsImltcG9ydCAqIGFzIGNyZWF0ZWpzIGZyb20gJ2NyZWF0ZWpzLW1vZHVsZSc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgc3RhZ2UgZnJvbSAnLi9TdGFnZSc7XG5cbmNvbnN0IFNIQVJFRF9ERVBFTkRFTkNJRVMgPSB7XG4gIHN0YWdlLFxuICBjcmVhdGVqcyxcbiAgXyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNIQVJFRF9ERVBFTkRFTkNJRVM7XG4iLCJpbXBvcnQgU0hBUkVEX0RFUEVOREVOQ0lFUyBmcm9tICcuL01haW5Nb2R1bGUnO1xuXG5jb25zdCB7IGNyZWF0ZWpzIH0gPSBTSEFSRURfREVQRU5ERU5DSUVTO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0b3JMaW5lIGV4dGVuZHMgY3JlYXRlanMuQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoeyBjb250YWluZXIgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5jb250YWluZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcyk7XG4gIH1cblxuICBjcmVhdGUoeyB4ID0gMCwgeSA9IDAgfSkge1xuICAgIHRoaXMuc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICB0aGlzLnNoYXBlWCA9IHg7XG4gICAgdGhpcy5zaGFwZVkgPSB5O1xuICAgIHRoaXMuc2hhcGUuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgdGhpcy5zaGFwZS5ncmFwaGljcy5iZWdpblN0cm9rZSgnYmxhY2snKTtcbiAgICB0aGlzLnNoYXBlLmdyYXBoaWNzLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLnNoYXBlLmdyYXBoaWNzLmVuZFN0cm9rZSgpO1xuICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5zaGFwZSk7XG4gIH1cblxuICB1cGRhdGVMaW5lKHgsIHksIHNoYXBleCA9IHRoaXMuc2hhcGVYLCBzaGFwZXkgPSB0aGlzLnNoYXBlWSkge1xuICAgIHRoaXMuc2hhcGUuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICB0aGlzLnNoYXBlLmdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEpO1xuICAgIHRoaXMuc2hhcGUuZ3JhcGhpY3MuYmVnaW5TdHJva2UoJ2JsYWNrJyk7XG4gICAgdGhpcy5zaGFwZS5ncmFwaGljcy5tb3ZlVG8oc2hhcGV4LCBzaGFwZXkpO1xuICAgIHRoaXMuc2hhcGUuZ3JhcGhpY3MubGluZVRvKHgsIHkpO1xuICAgIHRoaXMuc2hhcGUuZ3JhcGhpY3MuZW5kU3Ryb2tlKCk7XG4gIH1cbn1cbiIsImltcG9ydCBTSEFSRURfREVQRU5ERU5DSUVTIGZyb20gJy4vTWFpbk1vZHVsZS9pbmRleCc7XG5pbXBvcnQgQ29ubmVjdG9yTGluZSBmcm9tICcuL0Nvbm5lY3RvckxpbmUnO1xuXG5jb25zdCB7IGNyZWF0ZWpzLCBfIH0gPSBTSEFSRURfREVQRU5ERU5DSUVTO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3RDaXJjbGVzIGV4dGVuZHMgY3JlYXRlanMuQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIF8uYmluZEFsbCh0aGlzLCAnY3JlYXRlJywgJ21vdXNlRG93bkV2ZW50SGFuZGxlcicsICdwcmVzc01vdmVFdmVudEhhbmRsZXInLCAnbW91c2VEb3duRXZlbnRIYW5kbGVyJywgJ21vdXNlT3ZlckV2ZW50SGFuZGxlcicsICdwcmVzc1VwRXZlbnRIYW5kbGVyJyk7XG4gICAgdGhpcy5zaGFwZUFyciA9IFtdO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lcjtcbiAgICB0aGlzLmNyZWF0ZShjb25maWcpO1xuICAgIHRoaXMuYXJyYW5nZURvdHMoY29uZmlnLmNvbnRhaW5lcik7XG4gIH1cblxuICBjcmVhdGUoe1xuICAgIHggPSAwLCB5ID0gMCwgcmFkaXVzID0gNywgZmlsbENvbG9yID0gJ3llbGxvdycsXG4gIH0pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBsdXNwbHVzXG4gICAgICBjb25zdCBkb3RDaXJjbGVDb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICBkb3RDaXJjbGVDb250YWluZXIubmFtZSA9ICdkb3RDb250YWluZXInO1xuICAgICAgZG90Q2lyY2xlQ29udGFpbmVyLnNldEJvdW5kcyh4LCB5LCAxNCwgMTQpO1xuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGRvdENpcmNsZUNvbnRhaW5lci5jb25uZWN0ZWRMaW5lc0RhdGEgPSBbXTtcbiAgICAgIHNoYXBlLmlkID0gaTtcbiAgICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcbiAgICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgICBnLmJlZ2luU3Ryb2tlKCk7XG4gICAgICBnLmJlZ2luRmlsbChmaWxsQ29sb3IpO1xuICAgICAgZy5kcmF3Q2lyY2xlKDAsIDAsIHJhZGl1cyk7XG5cbiAgICAgIGRvdENpcmNsZUNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZChkb3RDaXJjbGVDb250YWluZXIpO1xuICAgICAgZG90Q2lyY2xlQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VEb3duRXZlbnRIYW5kbGVyKTtcbiAgICAgIGRvdENpcmNsZUNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdwcmVzc21vdmUnLCB0aGlzLnByZXNzTW92ZUV2ZW50SGFuZGxlcik7XG4gICAgICBkb3RDaXJjbGVDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJFdmVudEhhbmRsZXIpO1xuICAgICAgZG90Q2lyY2xlQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZXNzdXAnLCB0aGlzLnByZXNzVXBFdmVudEhhbmRsZXIpO1xuICAgICAgdGhpcy5zaGFwZUFyci5wdXNoKGRvdENpcmNsZUNvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgYXJyYW5nZURvdHMoY29udGFpbmVyKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250YWluZXIuZ2V0Qm91bmRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdGhpcy5zaGFwZUFycltpXS5uYW1lID0gJ3RvcERvdCc7XG4gICAgICAgIHRoaXMuc2hhcGVBcnJbaV0ueCA9IGNvbnRhaW5lci54ICsgKHdpZHRoIC0gNSkgLyAyO1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZUFycltpXS5uYW1lID0gJ2xlZnREb3QnO1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLnggPSAwO1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLnkgPSBjb250YWluZXIueSArIChoZWlnaHQgLSA1KSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLm5hbWUgPSAncmlnaHREb3QnO1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLnggPSBjb250YWluZXIueCArICh3aWR0aCAtIDUpO1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLnkgPSBjb250YWluZXIueSArIChoZWlnaHQgLSA1KSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gMykge1xuICAgICAgICB0aGlzLnNoYXBlQXJyW2ldLm5hbWUgPSAnYm90dG9tRG90JztcbiAgICAgICAgdGhpcy5zaGFwZUFycltpXS54ID0gY29udGFpbmVyLnggKyAod2lkdGggLSA1KSAvIDI7XG4gICAgICAgIHRoaXMuc2hhcGVBcnJbaV0ueSA9IGNvbnRhaW5lci55ICsgKGhlaWdodCAtIDUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG1vdXNlRG93bkV2ZW50SGFuZGxlcihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IHsgc3RhZ2VYLCBzdGFnZVkgfSA9IGV2ZW50O1xuICAgIGlmICh0aGlzLmNvbnRhaW5lci5ib3VuZGFyeUNvbmRpdGlvbkNoZWNrZXIoeyBzdGFnZVgsIHN0YWdlWSB9KSkge1xuICAgICAgdGhpcy5saW5lRHJhdyA9IG5ldyBDb25uZWN0b3JMaW5lKHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciB9KTtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRzKCk7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQubG9jYWxUb0dsb2JhbChib3VuZHMueCwgYm91bmRzLnkpO1xuICAgICAgdGhpcy5saW5lRHJhdy5jcmVhdGUoe1xuICAgICAgICB4OiBsb2NhdGlvbi54LCB5OiBsb2NhdGlvbi55LCBlbmR4OiBsb2NhdGlvbi54LCBlbmR5OiBsb2NhdGlvbi55LFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpZmZYID0gbG9jYXRpb24ueCAtIGV2ZW50LnN0YWdlWDtcbiAgICAgIHRoaXMuZGlmZlkgPSBsb2NhdGlvbi55IC0gZXZlbnQuc3RhZ2VZO1xuICAgIH1cbiAgfVxuXG4gIHByZXNzTW92ZUV2ZW50SGFuZGxlcihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IHsgc3RhZ2VYLCBzdGFnZVkgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLmJvdW5kYXJ5Q29uZGl0aW9uQ2hlY2tlcih7IHN0YWdlWCwgc3RhZ2VZIH0pKSB7XG4gICAgICB0aGlzLmxpbmVEcmF3LnVwZGF0ZUxpbmUoZXZlbnQuc3RhZ2VYLCBldmVudC5zdGFnZVkpO1xuICAgIH1cbiAgfVxuXG4gIHByZXNzVXBFdmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7IHN0YWdlWCwgc3RhZ2VZIH0gPSBldmVudDtcblxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5ib3VuZGFyeUNvbmRpdGlvbkNoZWNrZXIoeyBzdGFnZVgsIHN0YWdlWSB9KSkge1xuICAgICAgY29uc3Qgc3RhcnRpbmdQb2ludCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCB7IGRyb3BwYWJsZURvdCB9ID0gZXZlbnQuY3VycmVudFRhcmdldC5zdGFnZTtcbiAgICAgIGNvbnN0IGNvbm5lY3RlZExpbmVzRGF0YSA9IHsgZW5kVGFyZ2V0OiBkcm9wcGFibGVEb3QsIHN0YXJ0aW5nUG9pbnQsIGxpbmU6IHRoaXMubGluZURyYXcgfTtcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuc3RhZ2UuZHJvcHBhYmxlRG90LmNvbm5lY3RlZExpbmVzRGF0YS5wdXNoKGNvbm5lY3RlZExpbmVzRGF0YSk7XG4gICAgICBzdGFydGluZ1BvaW50LmNvbm5lY3RlZExpbmVzRGF0YS5wdXNoKGNvbm5lY3RlZExpbmVzRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgbW91c2VPdmVyRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5jb250YWluZXIuc3RhZ2UuZHJvcHBhYmxlRG90ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IGluaXRhaWxTaGFwZURhdGEgPSB7IGluaXRhaWxTaGFwZVdpZHRoOiAxNTAsIGluaXRhaWxTaGFwZUhlaWdodDogMzAwIH07XG5leHBvcnQgY29uc3Qgb3V0ZXJTaGFwZUNvbnRhaW5lckRhdGEgPSB7XG4gIG91dGVyU2hhcGVXaWR0aDogNzUwLCBvdXRlclNoYXBlSGVpZ2h0OiA2NTAsIG94OiAyMDAsIG95OiAxMCxcbn07XG4iLCJpbXBvcnQgU0hBUkVEX0RFUEVOREVOQ0lFUyBmcm9tICcuL01haW5Nb2R1bGUvaW5kZXgnO1xuaW1wb3J0IERvdENpcmNsZXMgZnJvbSAnLi9Eb3RDaXJjbGVzJztcbmltcG9ydCB7IG91dGVyU2hhcGVDb250YWluZXJEYXRhIH0gZnJvbSAnLi9Db25zdGFudHMnO1xuXG5jb25zdCB7IGNyZWF0ZWpzLCBfIH0gPSBTSEFSRURfREVQRU5ERU5DSUVTO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFwZSBleHRlbmRzIGNyZWF0ZWpzLkNvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdib3VuZGFyeUNvbmRpdGlvbkNoZWNrZXInLCAncHJlc3NVcEV2ZW50SGFuZGxlcicsICdhZGREb3RzVG9TaGFwZScsICdtb3VzZURvd25FdmVudEhhbmRsZXInLCAncHJlc3NNb3ZlRXZlbnRIYW5kbGVyJywgJ21vdXNlRG93bkV2ZW50SGFuZGxlcicsICdtb3VzZU91dEV2ZW50SGFuZGxlcicsICdtb3VzZU92ZXJFdmVudEhhbmRsZXInKTtcbiAgfVxuXG4gIGFkZERvdHNUb1NoYXBlKCkge1xuICAgIHRoaXMuZG90Q2lyY2xlc09iaiA9IG5ldyBEb3RDaXJjbGVzKHsgeDogMCwgeTogMCwgY29udGFpbmVyOiB0aGlzIH0pO1xuICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5kb3RDaXJjbGVzT2JqKTtcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd25FdmVudEhhbmRsZXIpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJlc3Ntb3ZlJywgdGhpcy5wcmVzc01vdmVFdmVudEhhbmRsZXIpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1vdXNlT3ZlckV2ZW50SGFuZGxlcik7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm1vdXNlT3V0RXZlbnRIYW5kbGVyKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZXNzdXAnLCB0aGlzLnByZXNzVXBFdmVudEhhbmRsZXIpO1xuICB9XG5cbiAgcHJlc3NVcEV2ZW50SGFuZGxlcigpIHtcbiAgICB0aGlzLmEgPSAncyc7XG4gIH1cblxuICBtb3VzZU91dEV2ZW50SGFuZGxlcigpIHtcbiAgICBfLmZvckVhY2godGhpcy5kb3RDaXJjbGVzT2JqLnNoYXBlQXJyLCAoY29udGFpbmVyKSA9PiB7XG4gICAgICAgIGNvbnRhaW5lci52aXNpYmxlID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH0pO1xuICB9XG5cbiAgbW91c2VPdmVyRXZlbnRIYW5kbGVyKCkge1xuICAgIF8uZm9yRWFjaCh0aGlzLmRvdENpcmNsZXNPYmouc2hhcGVBcnIsIChjb250YWluZXIpID0+IHtcbiAgICAgICAgY29udGFpbmVyLnZpc2libGUgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH0pO1xuICB9XG5cbiAgbW91c2VNb3ZlRXZlbnRIYW5kbGVyKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICAvLyBmb3IgZnV0dXJlIHVzZVxuICB9XG5cbiAgbW91c2VEb3duRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5kaWZmWCA9IGV2ZW50LnN0YWdlWCAtIHRoaXMueDtcbiAgICB0aGlzLmRpZmZZID0gZXZlbnQuc3RhZ2VZIC0gdGhpcy55O1xuICB9XG5cbiAgcHJlc3NNb3ZlRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgeyBzdGFnZVgsIHN0YWdlWSB9ID0gZXZlbnQ7XG4gICAgaWYgKHRoaXMuYm91bmRhcnlDb25kaXRpb25DaGVja2VyKHsgc3RhZ2VYLCBzdGFnZVkgfSkpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wYXJlbnQuZ2xvYmFsVG9Mb2NhbChzdGFnZVgsIHN0YWdlWSk7XG4gICAgICB0aGlzLnggPSB4IC0gdGhpcy5kaWZmWDtcbiAgICAgIHRoaXMueSA9IHkgLSB0aGlzLmRpZmZZO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgIGlmICh0aGlzLmRvdENpcmNsZXNPYmouc2hhcGVBcnJbaV0uY29ubmVjdGVkTGluZXNEYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBsaW5lc0FyciA9IHRoaXMuZG90Q2lyY2xlc09iai5zaGFwZUFycltpXS5jb25uZWN0ZWRMaW5lc0RhdGE7XG4gICAgICAgIF8uZm9yRWFjaChsaW5lc0FyciwgKGRhdGEpID0+IHtcbiAgICAgICAgICBkYXRhLmxpbmUuc2hhcGUuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICAgICAgICBjb25zdCBib3VuZHMgPSBkYXRhLmVuZFRhcmdldC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGRhdGEuZW5kVGFyZ2V0LmxvY2FsVG9HbG9iYWwoYm91bmRzLngsIGJvdW5kcy55KTtcbiAgICAgICAgICBjb25zdCBib3VuZHMxID0gZGF0YS5zdGFydGluZ1BvaW50LmdldEJvdW5kcygpO1xuICAgICAgICAgIGNvbnN0IGxvY2F0aW9uMSA9IGRhdGEuc3RhcnRpbmdQb2ludC5sb2NhbFRvR2xvYmFsKGJvdW5kczEueCwgYm91bmRzMS55KTtcbiAgICAgICAgICBkYXRhLmxpbmUudXBkYXRlTGluZShsb2NhdGlvbjEueCwgbG9jYXRpb24xLnksIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBib3VuZGFyeUNvbmRpdGlvbkNoZWNrZXIoeyBzdGFnZVgsIHN0YWdlWSB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgb3V0ZXJTaGFwZVdpZHRoLCBvdXRlclNoYXBlSGVpZ2h0LCBveCwgb3ksXG4gICAgfSA9IG91dGVyU2hhcGVDb250YWluZXJEYXRhO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICBjb25zdCB0b3BDb25kaXRpb24gPSBzdGFnZVggPiAob3ggKyB0aGlzLmRpZmZYKSAmJiBzdGFnZVkgPiAob3kgKyB0aGlzLmRpZmZZKTtcbiAgICBjb25zdCBib3R0b21Db25kaXRpb24gPSBzdGFnZVggPCAob3ggKyBvdXRlclNoYXBlV2lkdGggLSAod2lkdGggLSB0aGlzLmRpZmZYKSlcbiAgICAmJiBzdGFnZVkgPCAob3kgKyBvdXRlclNoYXBlSGVpZ2h0IC0gKGhlaWdodCAtIHRoaXMuZGlmZlkpKTtcbiAgICBjb25zdCBib3VuZGFyeUNvbmRpdGlvbiA9IHRvcENvbmRpdGlvbiAmJiBib3R0b21Db25kaXRpb247XG4gICAgcmV0dXJuIGJvdW5kYXJ5Q29uZGl0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQgU0hBUkVEX0RFUEVOREVOQ0lFUyBmcm9tICcuL01haW5Nb2R1bGUvaW5kZXgnO1xuXG5jb25zdCB7IGNyZWF0ZWpzIH0gPSBTSEFSRURfREVQRU5ERU5DSUVTO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0U2V0dGVyIGV4dGVuZHMgY3JlYXRlanMuQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoeyBlZGl0YWJsZSA9IGZhbHNlLCBsYWJlbCA9ICdIZWxsbycsIGNvbnRhaW5lciB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldERlZmF1bHRUZXh0KHsgZWRpdGFibGUsIGxhYmVsIH0pO1xuICAgIHRoaXMuc2V0UG9zaXRpb25PZlRleHQoY29udGFpbmVyKTtcbiAgfVxuXG4gIHNldERlZmF1bHRUZXh0KHsgZWRpdGFibGUgPSBmYWxzZSwgbGFiZWwgPSAnSGVsbG8nIH0pIHtcbiAgICBpZiAoIWVkaXRhYmxlKSB7XG4gICAgICB0aGlzLmVuYWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdGhpcy50ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQobGFiZWwsICcxNXB4IEFyaWFsJywgJ2JsYWNrJyk7XG4gICAgICB0aGlzLmFkZENoaWxkKHRoaXMudGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAvLyBmdXR1cmUgdXNlIGNhc2VcbiAgICB9XG4gIH1cblxuICBzZXRQb3NpdGlvbk9mVGV4dChjb250YWluZXIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250YWluZXIuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgeCA9ICh3aWR0aCAtIHRoaXMudGV4dC5nZXRCb3VuZHMoKS53aWR0aCkgLyAyO1xuICAgIGNvbnN0IHkgPSAoaGVpZ2h0IC0gdGhpcy50ZXh0LmdldEJvdW5kcygpLmhlaWdodCkgLyAyO1xuICAgIHRoaXMuc2V0KHsgeCwgeSB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IFNIQVJFRF9ERVBFTkRFTkNJRVMgZnJvbSAnLi9NYWluTW9kdWxlL2luZGV4JztcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlJztcbmltcG9ydCBUZXh0U2V0dGVyIGZyb20gJy4vVGV4dFNldHRlcic7XG5cbmNvbnN0IHsgY3JlYXRlanMgfSA9IFNIQVJFRF9ERVBFTkRFTkNJRVM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0Q29tcG9uZW50IGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jcmVhdGUoY29uZmlnKTtcbiAgICB0aGlzLm5hbWUgPSAnU3RhcnRDb21wb25lbnQnO1xuICAgIHRoaXMuYWRkRG90c1RvU2hhcGUoKTtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRTZXR0ZXIoeyBlZGl0YWJsZTogZmFsc2UsIGxhYmVsOiAnU3RhcnQnLCBjb250YWluZXI6IHRoaXMgfSk7XG4gICAgdGhpcy5hZGRDaGlsZCh0ZXh0KTtcbiAgfVxuXG4gIGNyZWF0ZSh7XG4gICAgeCA9IDAsIHkgPSAwLCByYWRpdXMgPSAzMCwgZmlsbENvbG9yID0gJ3BpbmsnLFxuICB9KSB7XG4gICAgdGhpcy5zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHRoaXMuc2hhcGUuc2V0KHsgeDogMzAsIHk6IDMwIH0pO1xuICAgIHRoaXMuc2V0Qm91bmRzKDAsIDAsIHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIpO1xuICAgIGNvbnN0IGcgPSB0aGlzLnNoYXBlLmdyYXBoaWNzO1xuICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgZy5iZWdpblN0cm9rZSgnYmxhY2snKTtcbiAgICBnLmJlZ2luRmlsbChmaWxsQ29sb3IpO1xuICAgIGcuZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpO1xuICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5zaGFwZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG59XG4iLCJpbXBvcnQgU0hBUkVEX0RFUEVOREVOQ0lFUyBmcm9tICcuL01haW5Nb2R1bGUvaW5kZXgnO1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUnO1xuaW1wb3J0IFRleHRTZXR0ZXIgZnJvbSAnLi9UZXh0U2V0dGVyJztcblxuY29uc3QgeyBjcmVhdGVqcyB9ID0gU0hBUkVEX0RFUEVOREVOQ0lFUztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vcm1hbENvbXBvbmVudCBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3JlYXRlKGNvbmZpZyk7XG4gICAgdGhpcy5uYW1lID0gJ05vcm1hbENvbXBvbmVudCc7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0U2V0dGVyKHsgZWRpdGFibGU6IGZhbHNlLCBsYWJlbDogJ05vcm1hbCcsIGNvbnRhaW5lcjogdGhpcyB9KTtcbiAgICB0aGlzLmFkZENoaWxkKHRleHQpO1xuICAgIHRoaXMuYWRkRG90c1RvU2hhcGUoKTtcbiAgfVxuXG4gIGNyZWF0ZSh7XG4gICAgd2lkdGggPSA5MCwgaGVpZ2h0ID0gNjAsIHggPSAwLCB5ID0gMCwgZmlsbENvbG9yID0gJ3BpbmsnLFxuICB9KSB7XG4gICAgdGhpcy5zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHRoaXMuc2V0Qm91bmRzKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGcgPSB0aGlzLnNoYXBlLmdyYXBoaWNzO1xuICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgZy5iZWdpblN0cm9rZSgnYmxhY2snKTtcbiAgICBnLmJlZ2luRmlsbChmaWxsQ29sb3IpO1xuICAgIGcuZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5hZGRDaGlsZCh0aGlzLnNoYXBlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbn1cbiIsImltcG9ydCBTSEFSRURfREVQRU5ERU5DSUVTIGZyb20gJy4vTWFpbk1vZHVsZS9pbmRleCc7XG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZSc7XG5pbXBvcnQgVGV4dFNldHRlciBmcm9tICcuL1RleHRTZXR0ZXInO1xuXG5jb25zdCB7IGNyZWF0ZWpzIH0gPSBTSEFSRURfREVQRU5ERU5DSUVTO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2R1bGVDb21wb25lbnQgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNyZWF0ZShjb25maWcpO1xuICAgIHRoaXMubmFtZSA9ICdNb2R1bGVDb21wb25lbnQnO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dFNldHRlcih7IGVkaXRhYmxlOiBmYWxzZSwgbGFiZWw6ICdNb2RlbCcsIGNvbnRhaW5lcjogdGhpcyB9KTtcbiAgICB0aGlzLmFkZENoaWxkKHRleHQpO1xuICAgIHRoaXMuYWRkRG90c1RvU2hhcGUoKTtcbiAgfVxuXG4gIGNyZWF0ZSh7XG4gICAgd2lkdGggPSA5MCwgaGVpZ2h0ID0gNTAsIHggPSAwLCB5ID0gMCwgZmlsbENvbG9yID0gJ3BpbmsnLFxuICB9KSB7XG4gICAgdGhpcy5zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHRoaXMuc2hhcGUuc2V0KHsgeDogMCwgeTogMCB9KTtcblxuICAgIHRoaXMuc2hhcGUuc2V0Qm91bmRzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuc2V0Qm91bmRzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGcgPSB0aGlzLnNoYXBlLmdyYXBoaWNzO1xuICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgZy5iZWdpblN0cm9rZSgnYmxhY2snKTtcbiAgICBnLmJlZ2luRmlsbChmaWxsQ29sb3IpO1xuICAgIGcuZHJhd1JvdW5kUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyMCk7XG4gICAgdGhpcy5hZGRDaGlsZCh0aGlzLnNoYXBlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbn1cbiIsImltcG9ydCBTSEFSRURfREVQRU5ERU5DSUVTIGZyb20gJy4vTWFpbk1vZHVsZSc7XG5cbmltcG9ydCBTdGFydENvbXBvbmVudCBmcm9tICcuL1N0YXJ0Q29tcG9uZW50JztcbmltcG9ydCBOb3JtYWxDb21wb25lbnQgZnJvbSAnLi9Ob3JtYWxDb21wb25lbnQnO1xuaW1wb3J0IE1vZHVsZUNvbXBvbmVudCBmcm9tICcuL01vZHVsZUNvbXBvbmVudCc7XG5pbXBvcnQgVGV4dFNldHRlciBmcm9tICcuL1RleHRTZXR0ZXInO1xuXG5jb25zdCB7IGNyZWF0ZWpzLCBzdGFnZSwgXyB9ID0gU0hBUkVEX0RFUEVOREVOQ0lFUztcblxuY2xhc3MgSW5pdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhZ2UgPSBzdGFnZS5zdGFnZTtcbiAgICB0aGlzLnN0YXJ0QXJyID0gW107XG4gICAgdGhpcy5ub3JtYWxBcnIgPSBbXTtcbiAgICB0aGlzLm1vZHVsZUFyciA9IFtdO1xuICAgIHRoaXMuc3RhZ2UuZHJvcHBhYmxlRG90ID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0ZVN0YXJ0Q29tcG9uZW50KCk7XG4gICAgdGhpcy5jcmVhdGVOb3JtYWxDb21wb25lbnQoKTtcbiAgICB0aGlzLmNyZWF0ZU1vZGVsQ29tcG9uZW50KCk7XG4gIH1cblxuICBjcmVhdGVTdGFydENvbXBvbmVudCgpIHtcbiAgICBjb25zdCB4ID0gNjA7XG4gICAgY29uc3QgeSA9IDYwO1xuICAgIGNvbnN0IHNoYXBlQ29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgIHNoYXBlQ29udGFpbmVyLnNldEJvdW5kcygwLCAwLCAwLCAwKTtcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHNoYXBlQ29udGFpbmVyLmFkZENoaWxkKHNoYXBlKTtcbiAgICBzaGFwZUNvbnRhaW5lci5zZXQoeyB4LCB5IH0pO1xuICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcbiAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuICAgIGcuYmVnaW5TdHJva2UoJyMwMDAwMDAnKTtcbiAgICBnLmJlZ2luRmlsbCgncGluaycpO1xuICAgIGcuZHJhd0NpcmNsZSgwLCAwLCAzMCk7XG4gICAgc2hhcGVDb250YWluZXIuYWRkQ2hpbGQoc2hhcGUpO1xuICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc2hhcGVDb250YWluZXIpO1xuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dFNldHRlcih7IGVkaXRhYmxlOiBmYWxzZSwgbGFiZWw6ICdTdGFydCcsIGNvbnRhaW5lcjogc2hhcGVDb250YWluZXIgfSk7XG4gICAgc2hhcGVDb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICAgc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdGFydENvbXBvbmVudE9iaiA9IG5ldyBTdGFydENvbXBvbmVudCgpO1xuICAgICAgc3RhcnRDb21wb25lbnRPYmouc2V0KHsgeDogeCAvIDIsIHk6IHkgLyAyIH0pO1xuICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChzdGFydENvbXBvbmVudE9iaik7XG4gICAgICB0aGlzLnN0YXJ0QXJyLnB1c2goc3RhcnRDb21wb25lbnRPYmopO1xuICAgICAgc3RhcnRDb21wb25lbnRPYmoubW91c2VEb3duRXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZXNzbW92ZScsIChldmVudCkgPT4ge1xuICAgICAgXy5sYXN0KHRoaXMuc3RhcnRBcnIpLnByZXNzTW92ZUV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVOb3JtYWxDb21wb25lbnQoKSB7XG4gICAgY29uc3QgeCA9IDMwO1xuICAgIGNvbnN0IHkgPSAxMjA7XG4gICAgY29uc3Qgc2hhcGVDb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgc2hhcGVDb250YWluZXIuc2V0KHsgeCwgeSB9KTtcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHNoYXBlLnNldEJvdW5kcygwLCAwLCA5MCwgNjApO1xuICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcbiAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuICAgIGcuYmVnaW5TdHJva2UoJyMwMDAwMDAnKTtcbiAgICBnLmJlZ2luRmlsbCgncGluaycpO1xuICAgIGcuZHJhd1JlY3QoMCwgMCwgOTAsIDYwKTtcbiAgICBzaGFwZUNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG4gICAgdGhpcy5zdGFnZS5hZGRDaGlsZChzaGFwZUNvbnRhaW5lcik7XG5cbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRTZXR0ZXIoeyBlZGl0YWJsZTogZmFsc2UsIGxhYmVsOiAnTm9ybWFsJywgY29udGFpbmVyOiBzaGFwZUNvbnRhaW5lciB9KTtcbiAgICBzaGFwZUNvbnRhaW5lci5hZGRDaGlsZCh0ZXh0KTtcblxuICAgIHNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsQ29tcG9uZW50T2JqID0gbmV3IE5vcm1hbENvbXBvbmVudCgpO1xuICAgICAgbm9ybWFsQ29tcG9uZW50T2JqLnNldCh7IHgsIHkgfSk7XG4gICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKG5vcm1hbENvbXBvbmVudE9iaik7XG4gICAgICB0aGlzLm5vcm1hbEFyci5wdXNoKG5vcm1hbENvbXBvbmVudE9iaik7XG4gICAgICBub3JtYWxDb21wb25lbnRPYmoubW91c2VEb3duRXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZXNzbW92ZScsIChldmVudCkgPT4ge1xuICAgICAgXy5sYXN0KHRoaXMubm9ybWFsQXJyKS5wcmVzc01vdmVFdmVudEhhbmRsZXIoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlTW9kZWxDb21wb25lbnQoKSB7XG4gICAgY29uc3QgeCA9IDMwO1xuICAgIGNvbnN0IHkgPSAyMjA7XG4gICAgY29uc3Qgc2hhcGVDb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgc2hhcGVDb250YWluZXIuc2V0KHsgeCwgeSB9KTtcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgIHNoYXBlLnNldEJvdW5kcygwLCAwLCA5MCwgNTApO1xuICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcbiAgICBnLnNldFN0cm9rZVN0eWxlKDEpLmJlZ2luU3Ryb2tlKCcjMDAwMDAwJykuYmVnaW5GaWxsKCdwaW5rJykuZHJhd1JvdW5kUmVjdCgwLCAwLCA5MCwgNTAsIDIwKTtcbiAgICBzaGFwZUNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG5cbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRTZXR0ZXIoeyBlZGl0YWJsZTogZmFsc2UsIGxhYmVsOiAnTW9kZWwnLCBjb250YWluZXI6IHNoYXBlQ29udGFpbmVyIH0pO1xuICAgIHNoYXBlQ29udGFpbmVyLmFkZENoaWxkKHRleHQpO1xuICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc2hhcGVDb250YWluZXIpO1xuXG4gICAgc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGVDb21wb25lbnRPYmogPSBuZXcgTW9kdWxlQ29tcG9uZW50KCk7XG4gICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKG1vZHVsZUNvbXBvbmVudE9iaik7XG4gICAgICBtb2R1bGVDb21wb25lbnRPYmouc2V0KHsgeCwgeSB9KTtcbiAgICAgIHRoaXMubW9kdWxlQXJyLnB1c2gobW9kdWxlQ29tcG9uZW50T2JqKTtcbiAgICAgIG1vZHVsZUNvbXBvbmVudE9iai5tb3VzZURvd25FdmVudEhhbmRsZXIoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcigncHJlc3Ntb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICBfLmxhc3QodGhpcy5tb2R1bGVBcnIpLnByZXNzTW92ZUV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGluaXQgPSBuZXcgSW5pdCgpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXQsIGZhbHNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")}]);